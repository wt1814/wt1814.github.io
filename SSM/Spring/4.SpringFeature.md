---
title: Spring容器特性
date: 2020-04-08 00:00:00
tags:
    - Spring
---

<!-- TOC -->

- [1. FactoryBean](#1-factorybean)
- [2. lazy-init属性和预实例化](#2-lazy-init属性和预实例化)
- [3. 循环依赖](#3-循环依赖)
    - [3.1. 什么是循环依赖？](#31-什么是循环依赖)
    - [3.2. 如何检测是否存在循环依赖？](#32-如何检测是否存在循环依赖)
    - [3.3. Spring如何解决循环依赖的问题?](#33-spring如何解决循环依赖的问题)
        - [3.3.1. 构造器循环依赖](#331-构造器循环依赖)
        - [3.3.2. setter循环依赖，单例](#332-setter循环依赖单例)
        - [3.3.3. setter循环依赖，非单例](#333-setter循环依赖非单例)
- [4. BeanFactoryPostProcessor和BeanPostProcessor](#4-beanfactorypostprocessor和beanpostprocessor)
    - [](#)
    - [4.1. 示例](#41-示例)

<!-- /TOC -->

# 1. FactoryBean  

&emsp; FactoryBean是一个接口。生产一些特殊的bean，如ProxyFactoryBean。源码如下：  

```
public interface FactoryBean<T> {
    @Nullable
    T getObject() throws Exception;
    @Nullable
    Class<?> getObjectType();

    default boolean isSingleton() {
        return true;
    }
}
```  
&emsp; 接口很简单，只有三个方法。  
* getObject: 返回一个工厂生产出来的对象，这个对象将要使用在Spring IOC 容器中  
* getObjectType : 返回工厂生产出来对象的类型  
* isSingleton: 表示生产出来的对象是否是单例的  


&emsp; FactoryBean的生产特性是在getBean中起作用的，看下面的调用：  

    bean = getObjectForBeanlnstance(sharedlnstance, name, beanName, mbd);  
&emsp; FactoryBean的机制可以为提供一个很好的封装机制，比如封装Proxy、RMI、JNDI等。  

# 2. lazy-init属性和预实例化  
&emsp; 在IOC容器的初始化过程中，主要的工作是对BeanDefinition的定位、载入、解析和注册。此时依赖注入并没有发生，依赖注入发生在应用第一次向容器索要Bean时。 向容器索要Bean是通过getBean的调用来完成的，该getBean是容器提供Bean服务的最基本的接口。  
&emsp; 对于容器的初始化，也有一种例外情况，就是用户可以通过设置Bean的lazy-init属性来控制预实例化的过程。这个预实例化在初始化容器时完成Bean的 依赖注入。毫无疑问，这种容器的使用方式会对容器初始化的性能有一些影响，但却能够提 高应用第一次取得Bean的性能。因为应用在第一次取得Bean时，依赖注入已经结束了，应用 可以取得已有的Bean。  

```
public void refresh() throws BeansException, IllegalStateException {
    synchronized(this.startupShutdownMonitor) {
        this.prepareRefresh();
        ConfigurableListableBeanFactory beanFactory = this.obtainFreshBeanFactory();
        this.prepareBeanFactory(beanFactory);

        try {
            this.postProcessBeanFactory(beanFactory);
            this.invokeBeanFactoryPostProcessors(beanFactory);
            this.registerBeanPostProcessors(beanFactory);
            this.initMessageSource();
            this.initApplicationEventMulticaster();
            this.onRefresh();
            this.registerListeners();
            //这里是对lazy-init属性进行处理的地方
            this.finishBeanFactoryInitialization(beanFactory);
            this.finishRefresh();
        } catch (BeansException var9) {
            if (this.logger.isWarnEnabled()) {
                this.logger.warn("Exception encountered during context initialization - cancelling refresh attempt: " + var9);
            }

            this.destroyBeans();
            this.cancelRefresh(var9);
            throw var9;
        } finally {
            this.resetCommonCaches();
        }

    }
}

//在finishBeanFactoryInitialization中进行具体的处理过程
protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) {
    if (beanFactory.containsBean("conversionService") && beanFactory.isTypeMatch("conversionService", ConversionService.class)) {
        beanFactory.setConversionService((ConversionService)beanFactory.getBean("conversionService", ConversionService.class));
    }

    if (!beanFactory.hasEmbeddedValueResolver()) {
        beanFactory.addEmbeddedValueResolver((strVal) -> {
            return this.getEnvironment().resolvePlaceholders(strVal);
        });
    }

    String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, false, false);
    String[] var3 = weaverAwareNames;
    int var4 = weaverAwareNames.length;

    for(int var5 = 0; var5 < var4; ++var5) {
        String weaverAwareName = var3[var5];
        this.getBean(weaverAwareName);
    }

    beanFactory.setTempClassLoader((ClassLoader)null);
    beanFactory.freezeConfiguration();
    //这里週用的是BeanFactory的 prelnstantiateSingletons, 这个方法是由DefaultListableBeanFactory实现的
    beanFactory.preInstantiateSingletons();
}

//在DefaultListableBeanFactory中的preInstantiateSingletons是这样的
public void preInstantiateSingletons() throws BeansException {
    if (this.logger.isDebugEnabled()) {
        this.logger.debug("Pre-instantiating singletons in " + this);
    }

    List<String> beanNames = new ArrayList(this.beanDefinitionNames);
    Iterator var2 = beanNames.iterator();

    //在这里就开始getBean，也就是触发Bean的依赖注入
    /*这个getBean和前面分析的触发依賴注入的过程是一样的,只是发生的地方不同.
    如果不设置 lazy-init属性，那么这个依赖注入是发生在容器初始化结束以后。第一次向容器发出getBean时，
    如果设置了lazy-init属性，那么依赖注入发生在容器初始化的过程中,会对 beanDefinitionMap中所有的Bean进行依赖注入，
    这样在初始化过程结束以后.容器执行 getBean得到的就是已经准备好的Bean，不需要进行依赖注入*/
    while(true) {
        String beanName;
        Object bean;
        do {
            while(true) {
                RootBeanDefinition bd;
                do {
                    do {
                        do {
                            if (!var2.hasNext()) {
                                var2 = beanNames.iterator();

                                while(var2.hasNext()) {
                                    beanName = (String)var2.next();
                                    Object singletonInstance = this.getSingleton(beanName);
                                    if (singletonInstance instanceof SmartInitializingSingleton) {
                                        SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton)singletonInstance;
                                        if (System.getSecurityManager() != null) {
                                            AccessController.doPrivileged(() -> {
                                                smartSingleton.afterSingletonsInstantiated();
                                                return null;
                                            }, this.getAccessControlContext());
                                        } else {
                                            smartSingleton.afterSingletonsInstantiated();
                                        }
                                    }
                                }

                                return;
                            }

                            beanName = (String)var2.next();
                            bd = this.getMergedLocalBeanDefinition(beanName);
                        } while(bd.isAbstract());
                    } while(!bd.isSingleton());
                } while(bd.isLazyInit());

                if (this.isFactoryBean(beanName)) {
                    bean = this.getBean("&" + beanName);
                    break;
                }

                this.getBean(beanName);
            }
        } while(!(bean instanceof FactoryBean));

        FactoryBean<?> factory = (FactoryBean)bean;
        boolean isEagerInit;
        if (System.getSecurityManager() != null && factory instanceof SmartFactoryBean) {
            SmartFactoryBean var10000 = (SmartFactoryBean)factory;
            ((SmartFactoryBean)factory).getClass();
            isEagerInit = (Boolean)AccessController.doPrivileged(var10000::isEagerInit, this.getAccessControlContext());
        } else {
            isEagerInit = factory instanceof SmartFactoryBean && ((SmartFactoryBean)factory).isEagerInit();
        }

        if (isEagerInit) {
            this.getBean(beanName);
        }
    }
}
```


# 3. 循环依赖  

## 3.1. 什么是循环依赖？  
&emsp; 多个bean之间相互依赖，形成了一个闭环。比如：A依赖于B、B依赖于C、C依赖于A。  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/SSM/Spring/spring-5.png)  

&emsp; 代码中表示：  

```
public class A{
    B b;
}
public class B{
    C c;
}
public class C{
    A a;
}
```

&emsp; Spring循环依赖会抛出异常。  

## 3.2. 如何检测是否存在循环依赖？  
&emsp; 检测循环依赖比较简单，使用一个列表来记录正在创建中的bean，bean创建之前，先去记录中看一下自己是否已经在列表中了，如果在，说明存在循环依赖，如果不在，则将其加入到这个列表，bean创建完毕之后，将其再从这个列表中移除。  
&emsp; 源码示例：Spring创建单例bean时候，会调用下面方法  

```
protected void beforeSingletonCreation(String beanName) {
    if (!this.inCreationCheckExclusions.contains(beanName) && !this.singletonsCurrentlyInCreation.add(beanName)) {
        throw new BeanCurrentlyInCreationException(beanName);
    }
}
```
&emsp; singletonsCurrentlyInCreation就是用来记录目前正在创建中的bean名称列表，this.singletonsCurrentlyInCreation.add(beanName)返回false，说明beanName已经在当前列表中了，此时会抛循环依赖的异常BeanCurrentlyInCreationException，这个异常对应的源码：  

```
public BeanCurrentlyInCreationException(String beanName) {
    super(beanName,
            "Requested bean is currently in creation: Is there an unresolvable circular reference?");
}
```
&emsp; 上面是单例bean检测循环依赖的源码，再来看看非单例bean的情况。  
&emsp; 以prototype情况为例，源码位于org.springframework.beans.factory.support.AbstractBeanFactory#doGetBean方法中，将主要代码列出来看一下：  

```
//检查正在创建的bean列表中是否存在beanName，如果存在，说明存在循环依赖，抛出循环依赖的异常
if (isPrototypeCurrentlyInCreation(beanName)) {
    throw new BeanCurrentlyInCreationException(beanName);
}

//判断scope是否是prototype
if (mbd.isPrototype()) {
    Object prototypeInstance = null;
    try {
        //将beanName放入正在创建的列表中
        beforePrototypeCreation(beanName);
        prototypeInstance = createBean(beanName, mbd, args);
    }
    finally {
        //将beanName从正在创建的列表中移除
        afterPrototypeCreation(beanName);
    }
}
```  

## 3.3. Spring如何解决循环依赖的问题?  

&emsp; 参考SpringBean生命周期。  
&emsp; Spring创建bean主要的几个步骤：  
* 步骤1：实例化bean，即调用构造器创建bean实例  
* 步骤2：填充属性，注入依赖的bean，比如通过set方式、@Autowired注解的方式注入依赖的bean  
* 步骤3：bean的初始化，比如调用init方法等。    

&emsp; 从上面3个步骤中可以看出，注入依赖的对象，有2种情况：  
1. 通过步骤1中构造器的方式注入依赖  
2. 通过步骤2注入依赖  

### 3.3.1. 构造器循环依赖  
&emsp; Spring实例化bean是通过ApplicationContext.getBean()方法来进行的。如果要获取的对象依赖了另一个对象，那么其首先会创建当前对象，然后通过递归的调用ApplicationContext.getBean()方法来获取所依赖的对象，最后将获取到的对象注入到当前对象中。  
&emsp; 如果构造器循环依赖，形成了闭环，Spring容器无法解决，会抛出BeanCurrentlyInCreationException异常。  

    Caused by: org.springframework.beans.factory.BeanCurrentlyInCreationException:
    Error creating bean with name 'a': Requested bean is currently in creation: Is there an unresolvable circular reference?

### 3.3.2. setter循环依赖，单例  
&emsp; setter循环依赖，Spring通过3级缓存解决。  
* 第一级缓存singletonObjects里面放置的是实例化好的单例对象。  
* 第二级earlySingletonObjects里面存放的是提前曝光的单例对象（没有完全装配好）。  
* 第三级singletonFactories里面存放的是要被实例化的对象的对象工厂。  

### 3.3.3. setter循环依赖，非单例  
&emsp; 只有单例的bean会通过三级缓存提前暴露来解决循环依赖的问题，而非单例的bean，每次从容器中获取都是一个新的对象，都会重新创建，所以非单例的bean是没有缓存的，不会将其放到三级缓存中。这种循环依赖也会抛异常：  

    Caused by: org.springframework.beans.factory.BeanCurrentlyInCreationException:
        Error creating bean with name 'a': Requested bean is currently in creation: Is there an unresolvable circular reference?

# 4. BeanFactoryPostProcessor和BeanPostProcessor  

## 


## 4.1. 示例  
1. bean的定义

```
public class CustomBean implements InitializingBean {
    private String desc;
    private String remark;

    public CustomBean() {
        System.out.println("第二步：执行CustomBean类的无参构造函数");
    }
    public String getDesc() {
        return desc;
    }
    public void setDesc(String desc) {
        System.out.println("第三步：调用setDesc方法");
        this.desc = desc;
    }
    public String getRemark() {
        return remark;
    }
    public void setRemark(String remark) {
        System.out.println("第四步：调用setRemark方法");
        this.remark = remark;
    }
    public void afterPropertiesSet() throws Exception {
        System.out.println("第六步：调用afterPropertiesSet方法");
        this.desc = "在初始化方法中修改之后的描述信息";
    }
    public void initMethod() {
        System.out.println("第七步：调用initMethod方法");
    }
    public String toString() {
        StringBuilder builder = new StringBuilder();
        builder.append("[描述：").append(desc);
        builder.append("， 备注：").append(remark).append("]");
        return builder.toString();
    }
}
```

2. 定义BeanFactoryPostProcessor  

```
public class MyBeanFactoryPostProcessor implements BeanFactoryPostProcessor {

    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {
        System.out.println("第一步：调用MyBeanFactoryPostProcessor的postProcessBeanFactory");
        BeanDefinition bd = beanFactory.getBeanDefinition("customBean");
        MutablePropertyValues pv =  bd.getPropertyValues();
        if (pv.contains("remark")) {
            pv.addPropertyValue("remark", "在BeanFactoryPostProcessor中修改之后的备忘信息");
        }
    }

}
```

3. 定义BeanPostProcessor  

```
public class MyBeanPostProcessor implements BeanPostProcessor {

    @Override
    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
        System.out.println("第五步：BeanPostProcessor，对象" + beanName + "调用初始化方法之前的数据： " + bean.toString());
        return bean;
    }

    @Override
    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
        System.out.println("第八步：BeanPostProcessor，对象" + beanName + "调用初始化方法之后的数据：" + bean.toString());
        return bean;
    }
}
```

4. 定义测试类  

```
public class PostProcessorTest {
        public static void main(String[] args) {
            ApplicationContext context = new ClassPathXmlApplicationContext("spring/postprocessor.xml");
            CustomBean bean = (CustomBean) context.getBean("customBean");
            System.out.println("################ 实例化、初始化bean完成");
            System.out.println("****************下面输出结果");
            System.out.println("描述：" + bean.getDesc());
            System.out.println("备注：" + bean.getRemark());

        }
}
```

&emsp; 运行结果如下：  

    第一步：调用MyBeanFactoryPostProcessor的postProcessBeanFactory
    第二步：执行CustomBean类的无参构造函数
    第三步：调用setDesc方法
    第四步：调用setRemark方法
    第五步：BeanPostProcessor，对象customBean调用初始化方法之前的数据： [描述：原始的描述信息， 备注：在BeanFactoryPostProcessor中修改之后的备忘信息]
    第六步：调用afterPropertiesSet方法
    第七步：调用initMethod方法
    第八步：BeanPostProcessor，对象customBean调用初始化方法之后的数据：[描述：在初始化方法中修改之后的描述信息， 备注：在BeanFactoryPostProcessor中修改之后的备忘信息]
    ################ 实例化、初始化bean完成
    ****************下面输出结果
    描述：在初始化方法中修改之后的描述信息
    备注：在BeanFactoryPostProcessor中修改之后的备忘信息

*************************************************************************
&emsp; 分析以上结果：在bean实例化之前，首先执行BeanFactoryPostProcessor实现类的方法，然后通过调用bean的无参构造函数实例化bean，并调用set方法注入属性值。bean实例化后，执行初始化操作，调用两个初始化方法（两个初始化方法的顺序：先执行afterPropertiesSet，再执行init-method）前后，执行了BeanPostProcessor实现类的两个方法。  




