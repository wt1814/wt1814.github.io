---
title: Spring容器特性
date: 2020-04-08 00:00:00
tags:
    - Spring
---
<!-- TOC -->

- [1. FactoryBean](#1-factorybean)
    - [1.1. FactoryBean的作用](#11-factorybean的作用)
    - [1.2. Spring中有关FactoryBean的源码](#12-spring中有关factorybean的源码)
- [2. 循环依赖](#2-循环依赖)
    - [2.1. 什么是循环依赖？](#21-什么是循环依赖)
    - [2.2. 如何检测是否存在循环依赖？](#22-如何检测是否存在循环依赖)
    - [2.3. Spring如何解决循环依赖的问题?](#23-spring如何解决循环依赖的问题)
        - [2.3.1. 构造器循环依赖](#231-构造器循环依赖)
        - [2.3.2. setter循环依赖，单例](#232-setter循环依赖单例)
        - [2.3.3. setter循环依赖，非单例](#233-setter循环依赖非单例)
- [3. Spring可二次开发常用接口](#3-spring可二次开发常用接口)
    - [3.1. BeanFactoryPostProcessor和BeanPostProcessor](#31-beanfactorypostprocessor和beanpostprocessor)
        - [3.1.1. BeanFactoryPostProcessor接口](#311-beanfactorypostprocessor接口)
        - [3.1.2. BeanPostProcessor接口](#312-beanpostprocessor接口)
            - [3.1.2.1. InstantiationAwareBeanPostProcessor](#3121-instantiationawarebeanpostprocessor)
        - [3.1.3. BeanFactoryPostProcessor和BeanPostProcessor的示例](#313-beanfactorypostprocessor和beanpostprocessor的示例)
    - [3.2. ApplicationEvent抽象类、ApplicationListener接口](#32-applicationevent抽象类applicationlistener接口)
        - [3.2.1. Spring事件机制解析](#321-spring事件机制解析)
            - [3.2.1.1. ApplicationEvent，事件](#3211-applicationevent事件)
            - [3.2.1.2. ApplicationListener，事件监听器](#3212-applicationlistener事件监听器)
            - [3.2.1.3. ApplicationEventMulticaster，事件管理者](#3213-applicationeventmulticaster事件管理者)
            - [3.2.1.4. ApplicationEventPublisher，事件发布者](#3214-applicationeventpublisher事件发布者)
    - [3.3. Aware接口，Bean对容器对感知](#33-aware接口bean对容器对感知)
        - [3.3.1. ApplicationContextAware接口](#331-applicationcontextaware接口)
            - [3.3.1.1. ApplicationContextAware接口解析](#3311-applicationcontextaware接口解析)
        - [3.3.2. BeanNameAware接口](#332-beannameaware接口)
    - [3.4. InitializingBean接口、DisposableBean接口](#34-initializingbean接口disposablebean接口)
        - [3.4.1. InitializingBean接口](#341-initializingbean接口)
        - [3.4.2. DisposableBean接口](#342-disposablebean接口)
- [4. lazy-init属性和预实例化](#4-lazy-init属性和预实例化)
- [5. autowiring(自动依赖装配)的实现](#5-autowiring自动依赖装配的实现)

<!-- /TOC -->


# 1. FactoryBean  
## 1.1. FactoryBean的作用   

&emsp; FactoryBean接口源码：  

```
package org.springframework.beans.factory;

public interface FactoryBean<T> {
    T getObject() throws Exception;
    Class<?> getObjectType();
    boolean isSingleton();
}
```

&emsp; 在该接口中还定义了以下3个方法：  
* getObject()：返回由FactoryBean创建的Bean实例，如果isSingleton()返回true，则该实例会放到Spring容器中单实例缓存池中；  
* Singleton()：返回由FactoryBean创建的Bean实例的作用域是singleton还是prototype；  
* getObjectType()：返回FactoryBean创建的Bean类型。  

&emsp; 如果一个IOC容器中的Bean实现了FacgoryBean接口，通过getBean(String BeanName)获取到的Bean对象并不是FactoryBean的实现类对象，而是这个实现类中的getObject()方法返回的对象。如果要想获取FactoryBean的实现类，就要getBean(&BeanName)，在BeanName之前加上&。  

&emsp; 作用：FactoryBean接口生产一些工厂bean（工厂模式中的工厂类），如Spring自身提供的ProxyFactoryBean、JndiObjectFactoryBean还有Mybatis中的SqlSessionFactory。这些Bean实例过程比较复杂。  
&emsp; SqlSessionFactory部分源码：  

```
public class SqlSessionFactoryBean implements FactoryBean<SqlSessionFactory>, InitializingBean, ApplicationListener<ApplicationEvent> {
    private static final Log LOGGER = LogFactory.getLog(SqlSessionFactoryBean.class);
    //...
    public SqlSessionFactory getObject() throws Exception {
        if (this.sqlSessionFactory == null) {
            this.afterPropertiesSet();
        }

        return this.sqlSessionFactory;
    }
    //...
}
```

## 1.2. Spring中有关FactoryBean的源码  
&emsp; FactoryBean的生产特性是在getBean中起作用的。  

    bean = getObjectForBeanlnstance(sharedlnstance, name, beanName, mbd);  


# 2. 循环依赖  

## 2.1. 什么是循环依赖？  
&emsp; 多个bean之间相互依赖，形成了一个闭环。比如：A依赖于B、B依赖于C、C依赖于A。  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/SSM/Spring/spring-5.png)  

&emsp; 代码中表示：  

```
public class A{
    B b;
}
public class B{
    C c;
}
public class C{
    A a;
}
```

&emsp; Spring循环依赖会抛出异常。  

## 2.2. 如何检测是否存在循环依赖？  
&emsp; 检测循环依赖比较简单，使用一个列表来记录正在创建中的bean，bean创建之前，先去记录中看一下自己是否已经在列表中了，如果在，说明存在循环依赖，如果不在，则将其加入到这个列表，bean创建完毕之后，将其再从这个列表中移除。  
&emsp; 源码示例：Spring创建单例bean时候，会调用下面方法  

```
protected void beforeSingletonCreation(String beanName) {
    if (!this.inCreationCheckExclusions.contains(beanName) && !this.singletonsCurrentlyInCreation.add(beanName)) {
        throw new BeanCurrentlyInCreationException(beanName);
    }
}
```
&emsp; singletonsCurrentlyInCreation就是用来记录目前正在创建中的bean名称列表，this.singletonsCurrentlyInCreation.add(beanName)返回false，说明beanName已经在当前列表中了，此时会抛循环依赖的异常BeanCurrentlyInCreationException，这个异常对应的源码：  

```
public BeanCurrentlyInCreationException(String beanName) {
    super(beanName,
            "Requested bean is currently in creation: Is there an unresolvable circular reference?");
}
```
&emsp; 上面是单例bean检测循环依赖的源码，再来看看非单例bean的情况。  
&emsp; 以prototype情况为例，源码位于org.springframework.beans.factory.support.AbstractBeanFactory#doGetBean方法中，将主要代码列出来看一下：  

```
//检查正在创建的bean列表中是否存在beanName，如果存在，说明存在循环依赖，抛出循环依赖的异常
if (isPrototypeCurrentlyInCreation(beanName)) {
    throw new BeanCurrentlyInCreationException(beanName);
}

//判断scope是否是prototype
if (mbd.isPrototype()) {
    Object prototypeInstance = null;
    try {
        //将beanName放入正在创建的列表中
        beforePrototypeCreation(beanName);
        prototypeInstance = createBean(beanName, mbd, args);
    }
    finally {
        //将beanName从正在创建的列表中移除
        afterPrototypeCreation(beanName);
    }
}
```  

## 2.3. Spring如何解决循环依赖的问题?  

&emsp; 参考SpringBean生命周期。  
&emsp; Spring创建bean主要的几个步骤：  
* 步骤1：实例化bean，即调用构造器创建bean实例  
* 步骤2：填充属性，注入依赖的bean，比如通过set方式、@Autowired注解的方式注入依赖的bean  
* 步骤3：bean的初始化，比如调用init方法等。    

&emsp; 从上面3个步骤中可以看出，注入依赖的对象，有2种情况：  
1. 通过步骤1中构造器的方式注入依赖  
2. 通过步骤2注入依赖  

### 2.3.1. 构造器循环依赖  
&emsp; Spring实例化bean是通过ApplicationContext.getBean()方法来进行的。如果要获取的对象依赖了另一个对象，那么其首先会创建当前对象，然后通过递归的调用ApplicationContext.getBean()方法来获取所依赖的对象，最后将获取到的对象注入到当前对象中。  
&emsp; 如果构造器循环依赖，形成了闭环，Spring容器无法解决，会抛出BeanCurrentlyInCreationException异常。  

    Caused by: org.springframework.beans.factory.BeanCurrentlyInCreationException:
    Error creating bean with name 'a': Requested bean is currently in creation: Is there an unresolvable circular reference?

### 2.3.2. setter循环依赖，单例  
&emsp; setter循环依赖，Spring通过3级缓存解决。  
* 第一级缓存singletonObjects里面放置的是实例化好的单例对象。  
* 第二级earlySingletonObjects里面存放的是提前曝光的单例对象（没有完全装配好）。  
* 第三级singletonFactories里面存放的是要被实例化的对象的对象工厂。  

### 2.3.3. setter循环依赖，非单例  
&emsp; 只有单例的bean会通过三级缓存提前暴露来解决循环依赖的问题，而非单例的bean，每次从容器中获取都是一个新的对象，都会重新创建，所以非单例的bean是没有缓存的，不会将其放到三级缓存中。这种循环依赖也会抛异常：  

    Caused by: org.springframework.beans.factory.BeanCurrentlyInCreationException:
        Error creating bean with name 'a': Requested bean is currently in creation: Is there an unresolvable circular reference?

# 3. Spring可二次开发常用接口  
&emsp; Spring为了用户的开发方便和特性支持，开放了一些特殊接口和类，用户可进行实现或者继承，常见的如这些： ApplicationContextAware接口、ApplicationEvent抽象类、ApplicationListener接口、BeanNameAware接口、BeanFactoryAware接口、InitializingBean接口、DisposableBean接口、BeanPostProcessor接口。  

## 3.1. BeanFactoryPostProcessor和BeanPostProcessor  
### 3.1.1. BeanFactoryPostProcessor接口  
&emsp; 该接口的定义如下：  

```
public interface BeanFactoryPostProcessor {

    //可以通过beanFactory获取bean定义信息
    void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException;

}
```
&emsp; 实现该接口，可以在spring的bean创建之前，修改bean的定义属性。也就是说，Spring允许BeanFactoryPostProcessor在容器实例化任何其它bean之前读取配置元数据，并可以根据需要进行修改，例如可以把bean的scope从singleton改为prototype，也可以把property的值给修改掉。可以同时配置多个BeanFactoryPostProcessor，并通过设置'order'属性来控制各个BeanFactoryPostProcessor的执行次序。  
&emsp; 注意：BeanFactoryPostProcessor是在spring容器加载了bean的定义文件之后，在bean实例化之前执行的。接口方法的入参是ConfigurrableListableBeanFactory，使用该参数，可以获取到相关bean的定义信息。  

&emsp; Spring中，有内置的一些BeanFactoryPostProcessor实现类，常用的有：  
* org.springframework.beans.factory.config.PropertyPlaceholderConfigurer  
* org.springframework.beans.factory.config.PropertyOverrideConfigurer  
* org.springframework.beans.factory.config.CustomEditorConfigurer：用来注册自定义的属性编辑器  

![image](https://gitee.com/wt1814/pic-host/raw/master/images/SSM/Spring/spring-6.png)  

### 3.1.2. BeanPostProcessor接口  
&emsp; 该接口的定义如下：  

```
public interface BeanPostProcessor {

    //bean初始化之前调用
    @Nullable
    default Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
        return bean;
    }
    //bean初始化之后调用
    @Nullable
    default Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
        return bean;
    }
}
```
&emsp; BeanPostProcessor，可以在spring容器实例化bean之后，在执行bean的初始化方法前后，添加一些自己的处理逻辑。这里说的初始化方法，指的是下面两种：  
* bean实现了InitializingBean接口，对应的方法为afterPropertiesSet
* 在bean定义的时候，通过init-method设置的方法

    实例化和初始化的区别
    1. 实例化----实例化的过程是一个创建Bean的过程，即调用Bean的构造函数，单例的Bean放入单例池中。
    2. 初始化----初始化的过程是一个赋值的过程，即调用Bean的setter，设置Bean的属性。
    BeanPostProcessor作用于过程(1)前后

&emsp; Spring中Bean的实例化过程图示：  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/SSM/Spring/spring-7.png)  

&emsp; 注意：BeanPostProcessor是在spring容器加载了bean的定义文件并且实例化bean之后执行的。BeanPostProcessor的执行顺序是在BeanFactoryPostProcessor之后。  

&emsp; ***BeanFactory和ApplicationContext加载BeanPostProcessor：***  
&emsp; BeanFactory和ApplicationContext对待bean后置处理器稍有不同。ApplicationContext会自动检测在配置文件中实现了BeanPostProcessor接口的所有bean，并把它们注册为后置处理器，然后在容器创建bean的适当时候调用它，因此部署一个后置处理器同部署其他的bean并没有什么区别。而使用BeanFactory实现的时候，bean 后置处理器必须通过代码显式地去注册，在IoC容器继承体系中的ConfigurableBeanFactory接口中定义了注册方法  

    void addBeanPostProcessor(BeanPostProcessor beanPostProcessor);
&emsp; 另外，不要将BeanPostProcessor标记为延迟初始化。因为如果这样做，Spring容器将不会注册它们，自定义逻辑也就无法得到应用。假如在<beans />元素的定义中使用了'default-lazy-init'属性，请确信各个BeanPostProcessor标记为'lazy-init="false"'。  

&emsp; Spring中有内置的一些BeanPostProcessor实现类，例如：  
* org.springframework.context.annotation.CommonAnnotationBeanPostProcessor：支持@Resource注解的注入  
* org.springframework.beans.factory.annotation.RequiredAnnotationBeanPostProcessor：支持@Required注解的注入  
* org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor：支持@Autowired注解的注入  
* org.springframework.orm.jpa.support.PersistenceAnnotationBeanPostProcessor：支持@PersistenceUnit和@PersistenceContext注解的注入  
* org.springframework.context.support.ApplicationContextAwareProcessor：用来为bean注入ApplicationContext等容器对象  

&emsp; 这些注解类的BeanPostProcessor，在spring配置文件中，可以通过这样的配置 <context:component-scan base-package="*.*" /> ，自动进行注册。（spring通过ComponentScanBeanDefinitionParser类来解析该标签）  

&emsp; 如果自定义了多个的BeanPostProcessor的实现类，通过实现Ordered接口，设置order属性，可以按照顺序执行实现类的方法。  

#### 3.1.2.1. InstantiationAwareBeanPostProcessor  
&emsp; InstantiationAwareBeanPostProcessor是BeanPostProcessor的子接口，可以在Bean生命周期的另外两个时期提供扩展的回调接口，即实例化Bean之前（调用postProcessBeforeInstantiation方法）和实例化Bean之后（调用postProcessAfterInstantiation方法）。  


### 3.1.3. BeanFactoryPostProcessor和BeanPostProcessor的示例  
1. bean的定义

```
public class CustomBean implements InitializingBean {
    private String desc;
    private String remark;

    public CustomBean() {
        System.out.println("第二步：执行CustomBean类的无参构造函数");
    }
    public String getDesc() {
        return desc;
    }
    public void setDesc(String desc) {
        System.out.println("第三步：调用setDesc方法");
        this.desc = desc;
    }
    public String getRemark() {
        return remark;
    }
    public void setRemark(String remark) {
        System.out.println("第四步：调用setRemark方法");
        this.remark = remark;
    }
    public void afterPropertiesSet() throws Exception {
        System.out.println("第六步：调用afterPropertiesSet方法");
        this.desc = "在初始化方法中修改之后的描述信息";
    }
    public void initMethod() {
        System.out.println("第七步：调用initMethod方法");
    }
    public String toString() {
        StringBuilder builder = new StringBuilder();
        builder.append("[描述：").append(desc);
        builder.append("， 备注：").append(remark).append("]");
        return builder.toString();
    }
}
```

2. 定义BeanFactoryPostProcessor  

```
public class MyBeanFactoryPostProcessor implements BeanFactoryPostProcessor {

    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {
        System.out.println("第一步：调用MyBeanFactoryPostProcessor的postProcessBeanFactory");
        BeanDefinition bd = beanFactory.getBeanDefinition("customBean");
        MutablePropertyValues pv =  bd.getPropertyValues();
        if (pv.contains("remark")) {
            pv.addPropertyValue("remark", "在BeanFactoryPostProcessor中修改之后的备忘信息");
        }
    }

}
```

3. 定义BeanPostProcessor  

```
public class MyBeanPostProcessor implements BeanPostProcessor {

    @Override
    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
        System.out.println("第五步：BeanPostProcessor，对象" + beanName + "调用初始化方法之前的数据： " + bean.toString());
        return bean;
    }

    @Override
    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
        System.out.println("第八步：BeanPostProcessor，对象" + beanName + "调用初始化方法之后的数据：" + bean.toString());
        return bean;
    }
}
```

4. 定义测试类  

```
public class PostProcessorTest {
        public static void main(String[] args) {
            ApplicationContext context = new ClassPathXmlApplicationContext("spring/postprocessor.xml");
            CustomBean bean = (CustomBean) context.getBean("customBean");
            System.out.println("################ 实例化、初始化bean完成");
            System.out.println("****************下面输出结果");
            System.out.println("描述：" + bean.getDesc());
            System.out.println("备注：" + bean.getRemark());

        }
}
```

&emsp; 运行结果如下：  

    第一步：调用MyBeanFactoryPostProcessor的postProcessBeanFactory
    第二步：执行CustomBean类的无参构造函数
    第三步：调用setDesc方法
    第四步：调用setRemark方法
    第五步：BeanPostProcessor，对象customBean调用初始化方法之前的数据： [描述：原始的描述信息， 备注：在BeanFactoryPostProcessor中修改之后的备忘信息]
    第六步：调用afterPropertiesSet方法
    第七步：调用initMethod方法
    第八步：BeanPostProcessor，对象customBean调用初始化方法之后的数据：[描述：在初始化方法中修改之后的描述信息， 备注：在BeanFactoryPostProcessor中修改之后的备忘信息]
    ################ 实例化、初始化bean完成
    ****************下面输出结果
    描述：在初始化方法中修改之后的描述信息
    备注：在BeanFactoryPostProcessor中修改之后的备忘信息

*************************************************************************
&emsp; 分析以上结果：在bean实例化之前，首先执行BeanFactoryPostProcessor实现类的方法，然后通过调用bean的无参构造函数实例化bean，并调用set方法注入属性值。bean实例化后，执行初始化操作，调用两个初始化方法（两个初始化方法的顺序：先执行afterPropertiesSet，再执行init-method）前后，执行了BeanPostProcessor实现类的两个方法。  

## 3.2. ApplicationEvent抽象类、ApplicationListener接口  

&emsp; 使用测试  

&emsp; ApplicationEvent抽象类、ApplicationListener接口是常常搭配使用的：  
* ApplicationEvent：是个抽象类，里面只有一个构造函数和一个长整型的timestamp。  
* ApplicationListener：是一个接口，里面只有一个onApplicationEvent方法。所以自己的类在实现该接口的时候，要实装该方法。  
* ApplicationContext：如果在上下文中部署一个实现了ApplicationListener接口的bean，那么每当在一个ApplicationEvent发布到 ApplicationContext时，这个bean得到通知。  

```
public class EmailEvent extends ApplicationEvent {

    private static final long serialVersionUID = 1L;
    public String address;
    public String text;

    public EmailEvent(Object source) {
        super(source);
    }

    public EmailEvent(Object source, String address, String text) {
        super(source);
        this.address = address;
        this.text = text;
    }

    public void print(){
        System.out.println("hello spring event!");
    }
}

public class EmailListener implements ApplicationListener {

    public void onApplicationEvent(ApplicationEvent  event) {
        if(event instanceof EmailEvent){
            EmailEvent emailEvent = (EmailEvent)event;
            emailEvent.print();
            System.out.println("the source is:"+emailEvent.getSource());
            System.out.println("the address is:"+emailEvent.address);
            System.out.println("the email's context is:"+emailEvent.text);
        }
    }
}

public class Test {
    public static void main(String[] args) {
        ApplicationContext context = new ClassPathXmlApplicationContext("classpath:applicationContext.xml");
        EmailEvent event = new EmailEvent("hello","boylmx@163.com","this is a email text!");
        context.publishEvent(event);
    }
}
```
&emsp; 测试结果如下：  

    hello spring event!  
    the source is:hello  
    the address is:boylmx@163.com  
    the email's context is:this is a email text! 

### 3.2.1. Spring事件机制解析  
&emsp; ***实现Spring事件机制主要有4个类***：  
* ApplicationEvent：事件，每个实现类表示一类事件，可携带数据。
* ApplicationListener：事件监听器，用于接收事件处理时间。
* ApplicationEventMulticaster：事件管理者，用于事件监听器的注册和事件的广播。
* ApplicationEventPublisher：事件发布者，委托ApplicationEventMulticaster完成事件发布。

#### 3.2.1.1. ApplicationEvent，事件  
&emsp; ApplicationEvent表示事件，每个实现类表示一类事件，可携带数据。下面以一些Spring提供的标准事件，都继承了ApplicationEvent。  

|事件	|描述|
|---|---|
|ContextRefreshedEvent	|事件发布在ApplicationContext初始化或刷新时(例如,通过在ConfigurableApplicationContext接口使用refresh()方法)。这里,“初始化”意味着所有bean加载,post-processor bean被检测到并且激活,单例预先实例化,ApplicationContext对象可以使用了。只要上下文没有关闭,可以触发多次刷新,ApplicationContext提供了一种可选择的支持这种“热”刷新。例如XmlWebApplicationContext支持热刷新,但GenericApplicationContext并非如此。具体是在AbstractApplicationContext的finishRefresh()方法中。|
|ContextRefreshedEvent	|事件发布在ApplicationContext初始化或刷新时(例如,通过在ConfigurableApplicationContext接口使用refresh()方法)。这里,“初始化”意味着所有bean加载,post-processor bean被检测到并且激活,单例预先实例化,ApplicationContext对象可以使用了。只要上下文没有关闭,可以触发多次刷新,ApplicationContext提供了一种可选择的支持这种“热”刷新。例如,XmlWebApplicationContext支持热刷新,但GenericApplicationContext并非如此。具体是在AbstractApplicationContext的finishRefresh()方法中。|
|ContextStartedEvent	|事件发布在ApplicationContext开始使用ConfigurableApplicationContext接口start()方法。这里,“开始”意味着所有生命周期bean接收到一个明确的起始信号。通常,这个信号用于明确停止后重新启动,但它也可以用于启动组件没有被配置为自动运行(例如,组件还没有开始初始化)。|
|ContextStoppedEvent	|事件发布在ApplicationContext停止时通过使用ConfigurableApplicationContext接口上的stop()方法。在这里,“停止”意味着所有生命周期bean接收一个显式的停止信号。停止上下文可以通过重新调用start()方法。|
|ContextClosedEvent	|事件发布在ApplicationContext关闭时通过关闭ConfigurableApplicationContext接口方法。这里,“封闭”意味着所有单例bean被摧毁。一个封闭的环境达到生命的终结。它不能刷新或重启。|
|RequestHandledEvent	|一个特定的web事件告诉所有能处理HTTP请求的bean 。这个事件是在请求完成后发布的。这个事件只适用于使用Spring的DispatcherServlet的web应用程序。|

&emsp; ApplicationEvent代码如下：  

```
public abstract class ApplicationEvent extends EventObject {
    private static final long serialVersionUID = 7099057708183571937L;
    private final long timestamp = System.currentTimeMillis();

    public ApplicationEvent(Object source) {
        super(source);
    }

    public final long getTimestamp() {
        return this.timestamp;
    }
}
```
#### 3.2.1.2. ApplicationListener，事件监听器  

```
@FunctionalInterface
public interface ApplicationListener<E extends ApplicationEvent> extends EventListener {
    void onApplicationEvent(E event);
}
```
&emsp; 当事件监听器接收到它可以处理的事件，会调用onApplicationEvent()方法。注意到ApplicationListener是泛型参数，这样可以实现所有继承了ApplicationEvent的监听。我们可以尽可能多的注册想要的事件侦听器,但是默认情况下事件监听器同步接收事件。这意味着publishEvent()方法会阻塞直到所有的事件监听器成处理完事件。这种单线程同步方法的一个特点是,当一个监听器接收到一个事件时,它运行在事务上下文的发布者线程上(如果事务上下文可用)。如果事件的发布需要另一种策略（譬如多线程）需要实现ApplicationEventMulticaster接口类。  

#### 3.2.1.3. ApplicationEventMulticaster，事件管理者  
&emsp; ApplicationEventMulticaster接口方法分为三类，注册事件监听器、移除事件监听器、发布事件。  

```
public interface ApplicationEventMulticaster {
   void addApplicationListener(ApplicationListener<?> listener);
   void addApplicationListenerBean(String listenerBeanName);
   void removeApplicationListener(ApplicationListener<?> listener);
   void removeApplicationListenerBean(String listenerBeanName);
   void removeAllListeners();
   void multicastEvent(ApplicationEvent event);
   void multicastEvent(ApplicationEvent event, @Nullable ResolvableType eventType);
}
```

&emsp; 执行AbstractApplicationContext.initApplicationEventMulticaster() 方法时会实例化一个bean name为applicationEventMulticaster的SimpleApplicationEventMulticaster，它的父类实现了前5个方法依靠一个内部类ListenerRetriever维护了一个Set<ApplicationListener<?>>，本质事件监听器的注册或移除就是对这个Set的添加和移除操作。  

```
public abstract class AbstractApplicationEventMulticaster
      implements ApplicationEventMulticaster, BeanClassLoaderAware, BeanFactoryAware {
   private final ListenerRetriever defaultRetriever = new ListenerRetriever(false);
   
   @Override
   public void addApplicationListener(ApplicationListener<?> listener) {
      synchronized (this.retrievalMutex) {
         // 如果已经注册，则显式删除代理的目标，以避免对同一个侦听器进行双重调用。
         Object singletonTarget = AopProxyUtils.getSingletonTarget(listener);
         if (singletonTarget instanceof ApplicationListener) {
            this.defaultRetriever.applicationListeners.remove(singletonTarget);
         }
         this.defaultRetriever.applicationListeners.add(listener);
         this.retrieverCache.clear();
      }
   }
 
   @Override
   public void removeApplicationListener(ApplicationListener<?> listener) {
      synchronized (this.retrievalMutex) {
         this.defaultRetriever.applicationListeners.remove(listener);
         this.retrieverCache.clear();
      }
   }
 
   private class ListenerRetriever {
      public final Set<ApplicationListener<?>> applicationListeners = new LinkedHashSet<>();
      public final Set<String> applicationListenerBeans = new LinkedHashSet<>();
      private final boolean preFiltered;
      public ListenerRetriever(boolean preFiltered) {
         this.preFiltered = preFiltered;
      }
      public Collection<ApplicationListener<?>> getApplicationListeners() {
         List<ApplicationListener<?>> allListeners = new ArrayList<>(
               this.applicationListeners.size() + this.applicationListenerBeans.size());
         allListeners.addAll(this.applicationListeners);
         if (!this.applicationListenerBeans.isEmpty()) {
            BeanFactory beanFactory = getBeanFactory();
            for (String listenerBeanName : this.applicationListenerBeans) {
               try {
                  ApplicationListener<?> listener = beanFactory.getBean(listenerBeanName, ApplicationListener.class);
                  if (this.preFiltered || !allListeners.contains(listener)) {
                     allListeners.add(listener);
                  }
               }
               catch (NoSuchBeanDefinitionException ex) {
                  // Singleton listener instance (without backing bean definition) disappeared -
                  // probably in the middle of the destruction phase
               }
            }
         }
         if (!this.preFiltered || !this.applicationListenerBeans.isEmpty()) {
            AnnotationAwareOrderComparator.sort(allListeners);
         }
         return allListeners;
      }
   }
}
```

&emsp; 接口后两个方法由子类实现，可以看到SimpleApplicationEventMulticaster拥有一个Executor和ErrorHandler，分表表示监听器的调用线程池（如果不想使用单线程同步处理则可以设置一个线程池）和监听器处理事件失败的处理者(如果设置了的话)否则抛异常。  

```
public class SimpleApplicationEventMulticaster extends AbstractApplicationEventMulticaster {
   @Nullable
   private Executor taskExecutor;
   @Nullable
   private ErrorHandler errorHandler;
   public SimpleApplicationEventMulticaster() {
   }
   public SimpleApplicationEventMulticaster(BeanFactory beanFactory) {
      setBeanFactory(beanFactory);
   }
   public void setTaskExecutor(@Nullable Executor taskExecutor) {
      this.taskExecutor = taskExecutor;
   }
   public void setErrorHandler(@Nullable ErrorHandler errorHandler) {
      this.errorHandler = errorHandler;
   }
   @Override
   public void multicastEvent(ApplicationEvent event) {
      //广播事件，可以自动分析出ApplicationEvent是那种事件类型
      multicastEvent(event, resolveDefaultEventType(event));
   }
   @Override
   public void multicastEvent(final ApplicationEvent event, @Nullable ResolvableType eventType) {
      ResolvableType type = (eventType != null ? eventType : resolveDefaultEventType(event));
      //调用父类方法getApplicationListeners只取得能处理此类事件的时间监听器，依次处理
      for (final ApplicationListener<?> listener : getApplicationListeners(event, type)) {
         Executor executor = getTaskExecutor();
         if (executor != null) {
            executor.execute(() -> invokeListener(listener, event));
         }
         else {
            invokeListener(listener, event);
         }
      }
   }
 
   private ResolvableType resolveDefaultEventType(ApplicationEvent event) {
      return ResolvableType.forInstance(event);
   }
 
   protected void invokeListener(ApplicationListener<?> listener, ApplicationEvent event) {
      ErrorHandler errorHandler = getErrorHandler();
      if (errorHandler != null) {
         try {
            doInvokeListener(listener, event);
         }
         catch (Throwable err) {
            errorHandler.handleError(err);
         }
      }
      else {
         doInvokeListener(listener, event);
      }
   }
 
   @SuppressWarnings({"unchecked", "rawtypes"})
   private void doInvokeListener(ApplicationListener listener, ApplicationEvent event) {
      try {
         listener.onApplicationEvent(event);
      }
      catch (ClassCastException ex) {　　// 省略}
   }
 
   private boolean matchesClassCastMessage(String classCastMessage, Class<?> eventClass) {// 省略}
}
```

#### 3.2.1.4. ApplicationEventPublisher，事件发布者  

```
@FunctionalInterface
public interface ApplicationEventPublisher {
   default void publishEvent(ApplicationEvent event) {
      publishEvent((Object) event);
   }
   void publishEvent(Object event);
}
```

&emsp; ApplicationEventPublisher很简单只有两个发布事件的方法，AbstractApplicationContext是它的默认实现类，下面是具体实现。  

```
@Override
public void publishEvent(ApplicationEvent event) {
   publishEvent(event, null);
}
@Override
public void publishEvent(Object event) {
   publishEvent(event, null);
}
protected void publishEvent(Object event, @Nullable ResolvableType eventType) {
   Assert.notNull(event, "Event must not be null");
 
   ApplicationEvent applicationEvent;
   if (event instanceof ApplicationEvent) {
      applicationEvent = (ApplicationEvent) event;
   }
   else {
      applicationEvent = new PayloadApplicationEvent<>(this, event);
      if (eventType == null) {
         eventType = ((PayloadApplicationEvent) applicationEvent).getResolvableType();
      }
   }
 
   // Multicast right now if possible - or lazily once the multicaster is initialized
   if (this.earlyApplicationEvents != null) {
      this.earlyApplicationEvents.add(applicationEvent);
   }
   else {
      getApplicationEventMulticaster().multicastEvent(applicationEvent, eventType);
   }
 
   // Publish event via parent context as well...
   if (this.parent != null) {
      if (this.parent instanceof AbstractApplicationContext) {
         ((AbstractApplicationContext) this.parent).publishEvent(event, eventType);
      }
      else {
         this.parent.publishEvent(event);
      }
   }
}
```
&emsp; 可以看到事件的发布依赖于前面提到的bean name是applicationEventMulticaster的SimpleApplicationEventMulticaster。关于监听器注册有两种方法：接口实现、注解，代码如下：  

```
//使用接口实现方式
public class RegisterListener implements ApplicationListener<UserRegisterEvent> {
    @Override
    public void onApplicationEvent(UserRegisterEvent userRegisterEvent) {
        //../省略逻辑
    }
}

//使用@EventListener注解方式
@Component
public class AnnotationRegisterListener {
    @EventListener
    public void register(UserRegisterEvent userRegisterEvent)
    {
　　　　//../省略逻辑
    }
}
```

## 3.3. Aware接口，Bean对容器对感知  
&emsp; 容器管理的Bean一般不需要了解容器的状态和直接使用容器，但在某些情况下，是需要在Bean中直接对IOC容器进行操作的，这时候，就需要在Bean中设定对容器的感知。Spring IOC容器也提供了该功能，它是通过特定的aware接口来完成的。aware接口有以下这些：  
* BeanNameAware ，可以在Bean中得到它在IOC容器中的Bean实例名称。  
* BeanFactoryAware，可以在Bean中得到Bean所在的IOC容器，从而直接在Bean中使用IOC容器的服务。  
* ApplicationContextAware，可以在Bean中得到Bean所在的应用上下文，从而直接在 Bean中使用应用上下文的服务。  
* MessageSourceAware，在Bean中可以得到消息源。  
* ApplicationEventPublisherAware，在Bean中可以得到应用上下文的事件发布器，从而可以在Bean中发布应用上下文的事件。  
* ResourceLoaderAware，在Bean中可以得到ResourceLoader，从而在Bean中使用 ResourceLoader加载外部对应的Resource资源。  

&emsp; 在设置Bean的属性之后，调用初始化回调方法之前，Spring会调用aware接口中的setter方法。  

### 3.3.1. ApplicationContextAware接口  

&emsp; AbstractApplicationContext类是Spring容器应用上下文的一个抽象父类，ApplicationContextAware是用来获取spring的上下文。当一个类需要获取ApplicationContext实例时，可以通过工具类直接实现ApplicationContextAware接口，返回ApplicationContext对象。如下代码所示：  

```
@Component
public class BeansUtils implements ApplicationContextAware {

    private static ApplicationContext context;

    public static <T> T getBean(Class<T> bean) {
        return context.getBean(bean);
    }
    public static <T> T getBean(String var1, @Nullable Class<T> var2){
        return context.getBean(var1, var2);
    }

    public static ApplicationContext getContext() {
        return context;
    }

    @Override
    public void setApplicationContext(ApplicationContext context) throws BeansException {
        BeansUtils.context = context;
    }
}
```

#### 3.3.1.1. ApplicationContextAware接口解析
&emsp; ApplicationContextAware接口源码：   

```
public interface ApplicationContextAware {
    void setApplicationContext(ApplicationContext applicationcontext) throws BeansException;
}
```
&emsp; 这里只有一个方法setApplicationContext(ApplicationContext applicationcontext),它是一 个回调函数，在Bean中通过实现这个函数，可以在容器回调该aware接口方法时使注入的 applicationcontext引用在Bean中保存下来，供Bean需要使用Applicationcontext的基本服务时 使用。这个对setApplicationContext方法的回调是由容器自动完成的。  

&emsp; 在初始化的时候，从入口类ClassPathXmlApplicationContext->AbstractApplicationContext类的的refresh方法 ->prepareBeanFactory方法：  

```
protected void prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) {
    // 设置 BeanFactory 的类加载器，我们知道 BeanFactory 需要加载类，也就需要类加载器，这里设置为当前 ApplicationContext 的类加载器
    beanFactory.setBeanClassLoader(getClassLoader());
    // 设置 BeanExpressionResolver
    beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver());
    beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment()));
    // 添加一个 BeanPostProcessor，这个 processor 比较简单，实现了 Aware 接口的几个特殊的 beans 在初始化的时候，这个 processor 负责回调
    beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));
    // 下面几行的意思就是，如果某个 bean 依赖于以下几个接口的实现类，在自动装配的时候忽略它们，Spring 会通过其他方式来处理这些依赖。
    beanFactory.ignoreDependencyInterface(EnvironmentAware.class);
    beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);
    beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);
    beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);
    beanFactory.ignoreDependencyInterface(MessageSourceAware.class);
    beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);
    beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);
    beanFactory.registerResolvableDependency(ResourceLoader.class, this);
    beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this);
    beanFactory.registerResolvableDependency(ApplicationContext.class, this);

    if (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {
        beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));
        beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));
    }// 如果没有定义 "environment" 这个 bean，那么 Spring 会 "手动" 注册一个
    if (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) {
        beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());
    }
    // 如果没有定义 "systemProperties" 这个 bean，那么 Spring 会 "手动" 注册一个
    if (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) {
        beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());
    }
    // 如果没有定义 "systemEnvironment" 这个 bean，那么 Spring 会 "手动" 注册一个
    if (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) {
        beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());
    }
}
```

&emsp; beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this)); spring源码里面将ApplicationContextAwareProcessor加入到BeanPostProcessor处理器里面了，并且传的是一个ApplicationContext类型参数进去。  
```
class ApplicationContextAwareProcessor implements BeanPostProcessor {

    private final ConfigurableApplicationContext applicationContext;
    //beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));调用此构造方法把ApplicationContext传过来
    public ApplicationContextAwareProcessor(ConfigurableApplicationContext applicationContext) {
        this.applicationContext = applicationContext;
    }

    //实例化之前进行的处理
    public Object postProcessBeforeInitialization(final Object bean, String beanName) throws BeansException {
        AccessControlContext acc = null;

        if (System.getSecurityManager() != null &&
                (bean instanceof EnvironmentAware || bean instanceof EmbeddedValueResolverAware ||
                        bean instanceof ResourceLoaderAware || bean instanceof ApplicationEventPublisherAware ||
                        bean instanceof MessageSourceAware || bean instanceof ApplicationContextAware)) {
            acc = this.applicationContext.getBeanFactory().getAccessControlContext();
        }

        if (acc != null) {
            AccessController.doPrivileged(new PrivilegedAction<Object>() {
                public Object run() {
                    //给Aware的实现类set值进去
                    invokeAwareInterfaces(bean);
                    return null;
                }
            }, acc);
        }
        else {
            //给Aware的实现类set值进去
            invokeAwareInterfaces(bean);
        }

        return bean;
    }

    private void invokeAwareInterfaces(Object bean) {
        if (bean instanceof Aware) {
            if (bean instanceof EnvironmentAware) {
                ((EnvironmentAware) bean).setEnvironment(this.applicationContext.getEnvironment());
            }
            if (bean instanceof EmbeddedValueResolverAware) {
                ((EmbeddedValueResolverAware) bean).setEmbeddedValueResolver(
                        new EmbeddedValueResolver(this.applicationContext.getBeanFactory()));
            }
            if (bean instanceof ResourceLoaderAware) {
                ((ResourceLoaderAware) bean).setResourceLoader(this.applicationContext);
            }
            if (bean instanceof ApplicationEventPublisherAware) {
                ((ApplicationEventPublisherAware) bean).setApplicationEventPublisher(this.applicationContext);
            }
            if (bean instanceof MessageSourceAware) {
                ((MessageSourceAware) bean).setMessageSource(this.applicationContext);
            }
            //判读是否是属于ApplicationContextAware接口的类
            if (bean instanceof ApplicationContextAware) {
                //调用实现类的setApplicationContext方法把applicationContext set进去
                ((ApplicationContextAware) bean).setApplicationContext(this.applicationContext);
            }
        }
    }
　　// ... ... 
}
```

&emsp; 作为依赖注入的一部分，postProcessBeforelnitialization会在initializeBean的实现过程 中被调用，从而实现对aware接口的相关注入。  

### 3.3.2. BeanNameAware接口  
&emsp; BeanNameAware接口可以在Bean中得到它在IOC容器中的Bean实例名称。  
&emsp; BeanNameAware接口源码：  

```
public interface BeanNameAware extends Aware {
    void setBeanName(String var1);
}
```
```
public class BeanTest implements BeanNameAware{

    private String beanName;

    @Override
    public void setBeanName(String beanName) {
        // 让Bean获取自己在BeanFactory配置中的名字（根据情况是id或者name）
        this.beanName=beanName;     
    }
}
```
&emsp; setBeanName()方法Spring会自动调用。setBeanName()会在Spring自身完成Bean配置之后，且在调用任何Bean生命周期回调（初始化或者销毁）方法之前就调用这个方法。换言之，在程序中使用BeanFactory.getBean(String beanName)之前，Bean的名字就已经设定好了。所以，程序中可以使用BeanName而不用担心它没有被初始化。  

## 3.4. InitializingBean接口、DisposableBean接口  
### 3.4.1. InitializingBean接口  
&emsp; 当需要在bean的全部属性设置成功后做些特殊的处理，可以让该bean实现InitializingBean接口。效果等同于bean的init-method属性的使用或者@PostContsuct注解的使用，它只包括afterPropertiesSet方法，凡是继承该接口的类，在初始化bean的时候都会执行该方法。  

### 3.4.2. DisposableBean接口  
&emsp; 当需要在bean销毁之前做些特殊的处理，可以让该bean实现DisposableBean接口，该接口也只定义了一个destory方法。效果等同于bean的destroy-method属性的使用或者@PreDestory注解的使用。  
&emsp; 注解、DisposableBean、destroy-method三种方式的执行顺序：先注解，然后执行DisposableBean接口中定义的方法，最后执行destroy-method属性指定的方法。  

# 4. lazy-init属性和预实例化  
&emsp; 在IOC容器的初始化过程中，主要的工作是对BeanDefinition的定位、载入、解析和注册。此时依赖注入并没有发生，依赖注入发生在应用第一次向容器索要Bean时。 向容器索要Bean是通过getBean的调用来完成的，该getBean是容器提供Bean服务的最基本的接口。  
&emsp; 对于容器的初始化，也有一种例外情况，就是用户可以通过设置Bean的lazy-init属性来控制预实例化的过程。这个预实例化在初始化容器时完成Bean的 依赖注入。毫无疑问，这种容器的使用方式会对容器初始化的性能有一些影响，但却能够提 高应用第一次取得Bean的性能。因为应用在第一次取得Bean时，依赖注入已经结束了，应用 可以取得已有的Bean。  

```
public void refresh() throws BeansException, IllegalStateException {
    synchronized(this.startupShutdownMonitor) {
        this.prepareRefresh();
        ConfigurableListableBeanFactory beanFactory = this.obtainFreshBeanFactory();
        this.prepareBeanFactory(beanFactory);

        try {
            this.postProcessBeanFactory(beanFactory);
            this.invokeBeanFactoryPostProcessors(beanFactory);
            this.registerBeanPostProcessors(beanFactory);
            this.initMessageSource();
            this.initApplicationEventMulticaster();
            this.onRefresh();
            this.registerListeners();
            //这里是对lazy-init属性进行处理的地方
            this.finishBeanFactoryInitialization(beanFactory);
            this.finishRefresh();
        } catch (BeansException var9) {
            if (this.logger.isWarnEnabled()) {
                this.logger.warn("Exception encountered during context initialization - cancelling refresh attempt: " + var9);
            }

            this.destroyBeans();
            this.cancelRefresh(var9);
            throw var9;
        } finally {
            this.resetCommonCaches();
        }

    }
}

//在finishBeanFactoryInitialization中进行具体的处理过程
protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) {
    if (beanFactory.containsBean("conversionService") && beanFactory.isTypeMatch("conversionService", ConversionService.class)) {
        beanFactory.setConversionService((ConversionService)beanFactory.getBean("conversionService", ConversionService.class));
    }

    if (!beanFactory.hasEmbeddedValueResolver()) {
        beanFactory.addEmbeddedValueResolver((strVal) -> {
            return this.getEnvironment().resolvePlaceholders(strVal);
        });
    }

    String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, false, false);
    String[] var3 = weaverAwareNames;
    int var4 = weaverAwareNames.length;

    for(int var5 = 0; var5 < var4; ++var5) {
        String weaverAwareName = var3[var5];
        this.getBean(weaverAwareName);
    }

    beanFactory.setTempClassLoader((ClassLoader)null);
    beanFactory.freezeConfiguration();
    //这里週用的是BeanFactory的 prelnstantiateSingletons, 这个方法是由DefaultListableBeanFactory实现的
    beanFactory.preInstantiateSingletons();
}

//在DefaultListableBeanFactory中的preInstantiateSingletons是这样的
public void preInstantiateSingletons() throws BeansException {
    if (this.logger.isDebugEnabled()) {
        this.logger.debug("Pre-instantiating singletons in " + this);
    }

    List<String> beanNames = new ArrayList(this.beanDefinitionNames);
    Iterator var2 = beanNames.iterator();

    //在这里就开始getBean，也就是触发Bean的依赖注入
    /*这个getBean和前面分析的触发依賴注入的过程是一样的,只是发生的地方不同.
    如果不设置 lazy-init属性，那么这个依赖注入是发生在容器初始化结束以后。第一次向容器发出getBean时，
    如果设置了lazy-init属性，那么依赖注入发生在容器初始化的过程中,会对 beanDefinitionMap中所有的Bean进行依赖注入，
    这样在初始化过程结束以后.容器执行 getBean得到的就是已经准备好的Bean，不需要进行依赖注入*/
    while(true) {
        String beanName;
        Object bean;
        do {
            while(true) {
                RootBeanDefinition bd;
                do {
                    do {
                        do {
                            if (!var2.hasNext()) {
                                var2 = beanNames.iterator();

                                while(var2.hasNext()) {
                                    beanName = (String)var2.next();
                                    Object singletonInstance = this.getSingleton(beanName);
                                    if (singletonInstance instanceof SmartInitializingSingleton) {
                                        SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton)singletonInstance;
                                        if (System.getSecurityManager() != null) {
                                            AccessController.doPrivileged(() -> {
                                                smartSingleton.afterSingletonsInstantiated();
                                                return null;
                                            }, this.getAccessControlContext());
                                        } else {
                                            smartSingleton.afterSingletonsInstantiated();
                                        }
                                    }
                                }

                                return;
                            }

                            beanName = (String)var2.next();
                            bd = this.getMergedLocalBeanDefinition(beanName);
                        } while(bd.isAbstract());
                    } while(!bd.isSingleton());
                } while(bd.isLazyInit());

                if (this.isFactoryBean(beanName)) {
                    bean = this.getBean("&" + beanName);
                    break;
                }

                this.getBean(beanName);
            }
        } while(!(bean instanceof FactoryBean));

        FactoryBean<?> factory = (FactoryBean)bean;
        boolean isEagerInit;
        if (System.getSecurityManager() != null && factory instanceof SmartFactoryBean) {
            SmartFactoryBean var10000 = (SmartFactoryBean)factory;
            ((SmartFactoryBean)factory).getClass();
            isEagerInit = (Boolean)AccessController.doPrivileged(var10000::isEagerInit, this.getAccessControlContext());
        } else {
            isEagerInit = factory instanceof SmartFactoryBean && ((SmartFactoryBean)factory).isEagerInit();
        }

        if (isEagerInit) {
            this.getBean(beanName);
        }
    }
}
```

# 5. autowiring(自动依赖装配)的实现  
......


