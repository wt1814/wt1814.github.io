---
title: Spring容器特性
date: 2020-04-08 00:00:00
tags:
    - Spring
---
<!-- TOC -->

- [FactoryBean](#factorybean)
    - [FactoryBean的作用](#factorybean的作用)
    - [Spring中有关FactoryBean的源码](#spring中有关factorybean的源码)
- [循环依赖](#循环依赖)
    - [什么是循环依赖？](#什么是循环依赖)
    - [如何检测是否存在循环依赖？](#如何检测是否存在循环依赖)
    - [Spring如何解决循环依赖的问题?](#spring如何解决循环依赖的问题)
        - [构造器循环依赖](#构造器循环依赖)
        - [setter循环依赖，单例](#setter循环依赖单例)
        - [setter循环依赖，非单例](#setter循环依赖非单例)
- [Spring可二次开发常用接口](#spring可二次开发常用接口)
- [BeanFactoryPostProcessor和BeanPostProcessor](#beanfactorypostprocessor和beanpostprocessor)
    - [BeanFactoryPostProcessor接口](#beanfactorypostprocessor接口)
    - [BeanPostProcessor接口](#beanpostprocessor接口)
        - [InstantiationAwareBeanPostProcessor](#instantiationawarebeanpostprocessor)
    - [BeanFactoryPostProcessor和BeanPostProcessor的示例](#beanfactorypostprocessor和beanpostprocessor的示例)
- [aware接口，Bean对容器对感知](#aware接口bean对容器对感知)
- [lazy-init属性和预实例化](#lazy-init属性和预实例化)
- [autowiring(自动依赖装配)的实现](#autowiring自动依赖装配的实现)

<!-- /TOC -->


# FactoryBean  
## FactoryBean的作用   

&emsp; FactoryBean接口源码：  

```
package org.springframework.beans.factory;

public interface FactoryBean<T> {
    T getObject() throws Exception;
    Class<?> getObjectType();
    boolean isSingleton();
}
```

&emsp; 在该接口中还定义了以下3个方法：  
* getObject()：返回由FactoryBean创建的Bean实例，如果isSingleton()返回true，则该实例会放到Spring容器中单实例缓存池中；  
* Singleton()：返回由FactoryBean创建的Bean实例的作用域是singleton还是prototype；  
* getObjectType()：返回FactoryBean创建的Bean类型。  

&emsp; 如果一个IOC容器中的Bean实现了FacgoryBean接口，通过getBean(String BeanName)获取到的Bean对象并不是FactoryBean的实现类对象，而是这个实现类中的getObject()方法返回的对象。如果要想获取FactoryBean的实现类，就要getBean(&BeanName)，在BeanName之前加上&。  

&emsp; 作用：FactoryBean接口生产一些工厂bean（工厂模式中的工厂类），如Spring自身提供的ProxyFactoryBean、JndiObjectFactoryBean还有Mybatis中的SqlSessionFactory。这些Bean实例过程比较复杂。  
&emsp; SqlSessionFactory部分源码：  

```
public class SqlSessionFactoryBean implements FactoryBean<SqlSessionFactory>, InitializingBean, ApplicationListener<ApplicationEvent> {
    private static final Log LOGGER = LogFactory.getLog(SqlSessionFactoryBean.class);
    //...
    public SqlSessionFactory getObject() throws Exception {
        if (this.sqlSessionFactory == null) {
            this.afterPropertiesSet();
        }

        return this.sqlSessionFactory;
    }
    //...
}
```

## Spring中有关FactoryBean的源码  
&emsp; FactoryBean的生产特性是在getBean中起作用的。  

    bean = getObjectForBeanlnstance(sharedlnstance, name, beanName, mbd);  


# 循环依赖  

## 什么是循环依赖？  
&emsp; 多个bean之间相互依赖，形成了一个闭环。比如：A依赖于B、B依赖于C、C依赖于A。  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/SSM/Spring/spring-5.png)  

&emsp; 代码中表示：  

```
public class A{
    B b;
}
public class B{
    C c;
}
public class C{
    A a;
}
```

&emsp; Spring循环依赖会抛出异常。  

## 如何检测是否存在循环依赖？  
&emsp; 检测循环依赖比较简单，使用一个列表来记录正在创建中的bean，bean创建之前，先去记录中看一下自己是否已经在列表中了，如果在，说明存在循环依赖，如果不在，则将其加入到这个列表，bean创建完毕之后，将其再从这个列表中移除。  
&emsp; 源码示例：Spring创建单例bean时候，会调用下面方法  

```
protected void beforeSingletonCreation(String beanName) {
    if (!this.inCreationCheckExclusions.contains(beanName) && !this.singletonsCurrentlyInCreation.add(beanName)) {
        throw new BeanCurrentlyInCreationException(beanName);
    }
}
```
&emsp; singletonsCurrentlyInCreation就是用来记录目前正在创建中的bean名称列表，this.singletonsCurrentlyInCreation.add(beanName)返回false，说明beanName已经在当前列表中了，此时会抛循环依赖的异常BeanCurrentlyInCreationException，这个异常对应的源码：  

```
public BeanCurrentlyInCreationException(String beanName) {
    super(beanName,
            "Requested bean is currently in creation: Is there an unresolvable circular reference?");
}
```
&emsp; 上面是单例bean检测循环依赖的源码，再来看看非单例bean的情况。  
&emsp; 以prototype情况为例，源码位于org.springframework.beans.factory.support.AbstractBeanFactory#doGetBean方法中，将主要代码列出来看一下：  

```
//检查正在创建的bean列表中是否存在beanName，如果存在，说明存在循环依赖，抛出循环依赖的异常
if (isPrototypeCurrentlyInCreation(beanName)) {
    throw new BeanCurrentlyInCreationException(beanName);
}

//判断scope是否是prototype
if (mbd.isPrototype()) {
    Object prototypeInstance = null;
    try {
        //将beanName放入正在创建的列表中
        beforePrototypeCreation(beanName);
        prototypeInstance = createBean(beanName, mbd, args);
    }
    finally {
        //将beanName从正在创建的列表中移除
        afterPrototypeCreation(beanName);
    }
}
```  

## Spring如何解决循环依赖的问题?  

&emsp; 参考SpringBean生命周期。  
&emsp; Spring创建bean主要的几个步骤：  
* 步骤1：实例化bean，即调用构造器创建bean实例  
* 步骤2：填充属性，注入依赖的bean，比如通过set方式、@Autowired注解的方式注入依赖的bean  
* 步骤3：bean的初始化，比如调用init方法等。    

&emsp; 从上面3个步骤中可以看出，注入依赖的对象，有2种情况：  
1. 通过步骤1中构造器的方式注入依赖  
2. 通过步骤2注入依赖  

### 构造器循环依赖  
&emsp; Spring实例化bean是通过ApplicationContext.getBean()方法来进行的。如果要获取的对象依赖了另一个对象，那么其首先会创建当前对象，然后通过递归的调用ApplicationContext.getBean()方法来获取所依赖的对象，最后将获取到的对象注入到当前对象中。  
&emsp; 如果构造器循环依赖，形成了闭环，Spring容器无法解决，会抛出BeanCurrentlyInCreationException异常。  

    Caused by: org.springframework.beans.factory.BeanCurrentlyInCreationException:
    Error creating bean with name 'a': Requested bean is currently in creation: Is there an unresolvable circular reference?

### setter循环依赖，单例  
&emsp; setter循环依赖，Spring通过3级缓存解决。  
* 第一级缓存singletonObjects里面放置的是实例化好的单例对象。  
* 第二级earlySingletonObjects里面存放的是提前曝光的单例对象（没有完全装配好）。  
* 第三级singletonFactories里面存放的是要被实例化的对象的对象工厂。  

### setter循环依赖，非单例  
&emsp; 只有单例的bean会通过三级缓存提前暴露来解决循环依赖的问题，而非单例的bean，每次从容器中获取都是一个新的对象，都会重新创建，所以非单例的bean是没有缓存的，不会将其放到三级缓存中。这种循环依赖也会抛异常：  

    Caused by: org.springframework.beans.factory.BeanCurrentlyInCreationException:
        Error creating bean with name 'a': Requested bean is currently in creation: Is there an unresolvable circular reference?

# Spring可二次开发常用接口  
&emsp; Spring为了用户的开发方便和特性支持，开放了一些特殊接口和类，用户可进行实现或者继承，常见的如这些： ApplicationContextAware接口、ApplicationEvent抽象类、ApplicationListener接口、BeanNameAware接口、BeanFactoryAware接口、InitializingBean接口、DisposableBean接口、BeanPostProcessor接口。  

# BeanFactoryPostProcessor和BeanPostProcessor  
## BeanFactoryPostProcessor接口  
&emsp; 该接口的定义如下：  

```
public interface BeanFactoryPostProcessor {

    //可以通过beanFactory获取bean定义信息
    void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException;

}
```
&emsp; 实现该接口，可以在spring的bean创建之前，修改bean的定义属性。也就是说，Spring允许BeanFactoryPostProcessor在容器实例化任何其它bean之前读取配置元数据，并可以根据需要进行修改，例如可以把bean的scope从singleton改为prototype，也可以把property的值给修改掉。可以同时配置多个BeanFactoryPostProcessor，并通过设置'order'属性来控制各个BeanFactoryPostProcessor的执行次序。  
&emsp; 注意：BeanFactoryPostProcessor是在spring容器加载了bean的定义文件之后，在bean实例化之前执行的。接口方法的入参是ConfigurrableListableBeanFactory，使用该参数，可以获取到相关bean的定义信息。  

&emsp; Spring中，有内置的一些BeanFactoryPostProcessor实现类，常用的有：  
* org.springframework.beans.factory.config.PropertyPlaceholderConfigurer  
* org.springframework.beans.factory.config.PropertyOverrideConfigurer  
* org.springframework.beans.factory.config.CustomEditorConfigurer：用来注册自定义的属性编辑器  

![image](https://gitee.com/wt1814/pic-host/raw/master/images/SSM/Spring/spring-6.png)  

## BeanPostProcessor接口  
&emsp; 该接口的定义如下：  

```
public interface BeanPostProcessor {

    //bean初始化之前调用
    @Nullable
    default Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
        return bean;
    }
    //bean初始化之后调用
    @Nullable
    default Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
        return bean;
    }
}
```
&emsp; BeanPostProcessor，可以在spring容器实例化bean之后，在执行bean的初始化方法前后，添加一些自己的处理逻辑。这里说的初始化方法，指的是下面两种：  
* bean实现了InitializingBean接口，对应的方法为afterPropertiesSet
* 在bean定义的时候，通过init-method设置的方法

    实例化和初始化的区别
    1. 实例化----实例化的过程是一个创建Bean的过程，即调用Bean的构造函数，单例的Bean放入单例池中。
    2. 初始化----初始化的过程是一个赋值的过程，即调用Bean的setter，设置Bean的属性。
    BeanPostProcessor作用于过程(1)前后

&emsp; Spring中Bean的实例化过程图示：  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/SSM/Spring/spring-7.png)  

&emsp; 注意：BeanPostProcessor是在spring容器加载了bean的定义文件并且实例化bean之后执行的。BeanPostProcessor的执行顺序是在BeanFactoryPostProcessor之后。  

&emsp; ***BeanFactory和ApplicationContext加载BeanPostProcessor：***  
&emsp; BeanFactory和ApplicationContext对待bean后置处理器稍有不同。ApplicationContext会自动检测在配置文件中实现了BeanPostProcessor接口的所有bean，并把它们注册为后置处理器，然后在容器创建bean的适当时候调用它，因此部署一个后置处理器同部署其他的bean并没有什么区别。而使用BeanFactory实现的时候，bean 后置处理器必须通过代码显式地去注册，在IoC容器继承体系中的ConfigurableBeanFactory接口中定义了注册方法  

    void addBeanPostProcessor(BeanPostProcessor beanPostProcessor);
&emsp; 另外，不要将BeanPostProcessor标记为延迟初始化。因为如果这样做，Spring容器将不会注册它们，自定义逻辑也就无法得到应用。假如在<beans />元素的定义中使用了'default-lazy-init'属性，请确信各个BeanPostProcessor标记为'lazy-init="false"'。  

&emsp; Spring中有内置的一些BeanPostProcessor实现类，例如：  
* org.springframework.context.annotation.CommonAnnotationBeanPostProcessor：支持@Resource注解的注入  
* org.springframework.beans.factory.annotation.RequiredAnnotationBeanPostProcessor：支持@Required注解的注入  
* org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor：支持@Autowired注解的注入  
* org.springframework.orm.jpa.support.PersistenceAnnotationBeanPostProcessor：支持@PersistenceUnit和@PersistenceContext注解的注入  
* org.springframework.context.support.ApplicationContextAwareProcessor：用来为bean注入ApplicationContext等容器对象  

&emsp; 这些注解类的BeanPostProcessor，在spring配置文件中，可以通过这样的配置 <context:component-scan base-package="*.*" /> ，自动进行注册。（spring通过ComponentScanBeanDefinitionParser类来解析该标签）  

&emsp; 如果自定义了多个的BeanPostProcessor的实现类，通过实现Ordered接口，设置order属性，可以按照顺序执行实现类的方法。  

### InstantiationAwareBeanPostProcessor  
&emsp; InstantiationAwareBeanPostProcessor是BeanPostProcessor的子接口，可以在Bean生命周期的另外两个时期提供扩展的回调接口，即实例化Bean之前（调用postProcessBeforeInstantiation方法）和实例化Bean之后（调用postProcessAfterInstantiation方法）。  


## BeanFactoryPostProcessor和BeanPostProcessor的示例  
1. bean的定义

```
public class CustomBean implements InitializingBean {
    private String desc;
    private String remark;

    public CustomBean() {
        System.out.println("第二步：执行CustomBean类的无参构造函数");
    }
    public String getDesc() {
        return desc;
    }
    public void setDesc(String desc) {
        System.out.println("第三步：调用setDesc方法");
        this.desc = desc;
    }
    public String getRemark() {
        return remark;
    }
    public void setRemark(String remark) {
        System.out.println("第四步：调用setRemark方法");
        this.remark = remark;
    }
    public void afterPropertiesSet() throws Exception {
        System.out.println("第六步：调用afterPropertiesSet方法");
        this.desc = "在初始化方法中修改之后的描述信息";
    }
    public void initMethod() {
        System.out.println("第七步：调用initMethod方法");
    }
    public String toString() {
        StringBuilder builder = new StringBuilder();
        builder.append("[描述：").append(desc);
        builder.append("， 备注：").append(remark).append("]");
        return builder.toString();
    }
}
```

2. 定义BeanFactoryPostProcessor  

```
public class MyBeanFactoryPostProcessor implements BeanFactoryPostProcessor {

    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {
        System.out.println("第一步：调用MyBeanFactoryPostProcessor的postProcessBeanFactory");
        BeanDefinition bd = beanFactory.getBeanDefinition("customBean");
        MutablePropertyValues pv =  bd.getPropertyValues();
        if (pv.contains("remark")) {
            pv.addPropertyValue("remark", "在BeanFactoryPostProcessor中修改之后的备忘信息");
        }
    }

}
```

3. 定义BeanPostProcessor  

```
public class MyBeanPostProcessor implements BeanPostProcessor {

    @Override
    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
        System.out.println("第五步：BeanPostProcessor，对象" + beanName + "调用初始化方法之前的数据： " + bean.toString());
        return bean;
    }

    @Override
    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
        System.out.println("第八步：BeanPostProcessor，对象" + beanName + "调用初始化方法之后的数据：" + bean.toString());
        return bean;
    }
}
```

4. 定义测试类  

```
public class PostProcessorTest {
        public static void main(String[] args) {
            ApplicationContext context = new ClassPathXmlApplicationContext("spring/postprocessor.xml");
            CustomBean bean = (CustomBean) context.getBean("customBean");
            System.out.println("################ 实例化、初始化bean完成");
            System.out.println("****************下面输出结果");
            System.out.println("描述：" + bean.getDesc());
            System.out.println("备注：" + bean.getRemark());

        }
}
```

&emsp; 运行结果如下：  

    第一步：调用MyBeanFactoryPostProcessor的postProcessBeanFactory
    第二步：执行CustomBean类的无参构造函数
    第三步：调用setDesc方法
    第四步：调用setRemark方法
    第五步：BeanPostProcessor，对象customBean调用初始化方法之前的数据： [描述：原始的描述信息， 备注：在BeanFactoryPostProcessor中修改之后的备忘信息]
    第六步：调用afterPropertiesSet方法
    第七步：调用initMethod方法
    第八步：BeanPostProcessor，对象customBean调用初始化方法之后的数据：[描述：在初始化方法中修改之后的描述信息， 备注：在BeanFactoryPostProcessor中修改之后的备忘信息]
    ################ 实例化、初始化bean完成
    ****************下面输出结果
    描述：在初始化方法中修改之后的描述信息
    备注：在BeanFactoryPostProcessor中修改之后的备忘信息

*************************************************************************
&emsp; 分析以上结果：在bean实例化之前，首先执行BeanFactoryPostProcessor实现类的方法，然后通过调用bean的无参构造函数实例化bean，并调用set方法注入属性值。bean实例化后，执行初始化操作，调用两个初始化方法（两个初始化方法的顺序：先执行afterPropertiesSet，再执行init-method）前后，执行了BeanPostProcessor实现类的两个方法。  


# aware接口，Bean对容器对感知  


ApplicationEvent抽象类、ApplicationListener接口  


# lazy-init属性和预实例化  
&emsp; 在IOC容器的初始化过程中，主要的工作是对BeanDefinition的定位、载入、解析和注册。此时依赖注入并没有发生，依赖注入发生在应用第一次向容器索要Bean时。 向容器索要Bean是通过getBean的调用来完成的，该getBean是容器提供Bean服务的最基本的接口。  
&emsp; 对于容器的初始化，也有一种例外情况，就是用户可以通过设置Bean的lazy-init属性来控制预实例化的过程。这个预实例化在初始化容器时完成Bean的 依赖注入。毫无疑问，这种容器的使用方式会对容器初始化的性能有一些影响，但却能够提 高应用第一次取得Bean的性能。因为应用在第一次取得Bean时，依赖注入已经结束了，应用 可以取得已有的Bean。  

```
public void refresh() throws BeansException, IllegalStateException {
    synchronized(this.startupShutdownMonitor) {
        this.prepareRefresh();
        ConfigurableListableBeanFactory beanFactory = this.obtainFreshBeanFactory();
        this.prepareBeanFactory(beanFactory);

        try {
            this.postProcessBeanFactory(beanFactory);
            this.invokeBeanFactoryPostProcessors(beanFactory);
            this.registerBeanPostProcessors(beanFactory);
            this.initMessageSource();
            this.initApplicationEventMulticaster();
            this.onRefresh();
            this.registerListeners();
            //这里是对lazy-init属性进行处理的地方
            this.finishBeanFactoryInitialization(beanFactory);
            this.finishRefresh();
        } catch (BeansException var9) {
            if (this.logger.isWarnEnabled()) {
                this.logger.warn("Exception encountered during context initialization - cancelling refresh attempt: " + var9);
            }

            this.destroyBeans();
            this.cancelRefresh(var9);
            throw var9;
        } finally {
            this.resetCommonCaches();
        }

    }
}

//在finishBeanFactoryInitialization中进行具体的处理过程
protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) {
    if (beanFactory.containsBean("conversionService") && beanFactory.isTypeMatch("conversionService", ConversionService.class)) {
        beanFactory.setConversionService((ConversionService)beanFactory.getBean("conversionService", ConversionService.class));
    }

    if (!beanFactory.hasEmbeddedValueResolver()) {
        beanFactory.addEmbeddedValueResolver((strVal) -> {
            return this.getEnvironment().resolvePlaceholders(strVal);
        });
    }

    String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, false, false);
    String[] var3 = weaverAwareNames;
    int var4 = weaverAwareNames.length;

    for(int var5 = 0; var5 < var4; ++var5) {
        String weaverAwareName = var3[var5];
        this.getBean(weaverAwareName);
    }

    beanFactory.setTempClassLoader((ClassLoader)null);
    beanFactory.freezeConfiguration();
    //这里週用的是BeanFactory的 prelnstantiateSingletons, 这个方法是由DefaultListableBeanFactory实现的
    beanFactory.preInstantiateSingletons();
}

//在DefaultListableBeanFactory中的preInstantiateSingletons是这样的
public void preInstantiateSingletons() throws BeansException {
    if (this.logger.isDebugEnabled()) {
        this.logger.debug("Pre-instantiating singletons in " + this);
    }

    List<String> beanNames = new ArrayList(this.beanDefinitionNames);
    Iterator var2 = beanNames.iterator();

    //在这里就开始getBean，也就是触发Bean的依赖注入
    /*这个getBean和前面分析的触发依賴注入的过程是一样的,只是发生的地方不同.
    如果不设置 lazy-init属性，那么这个依赖注入是发生在容器初始化结束以后。第一次向容器发出getBean时，
    如果设置了lazy-init属性，那么依赖注入发生在容器初始化的过程中,会对 beanDefinitionMap中所有的Bean进行依赖注入，
    这样在初始化过程结束以后.容器执行 getBean得到的就是已经准备好的Bean，不需要进行依赖注入*/
    while(true) {
        String beanName;
        Object bean;
        do {
            while(true) {
                RootBeanDefinition bd;
                do {
                    do {
                        do {
                            if (!var2.hasNext()) {
                                var2 = beanNames.iterator();

                                while(var2.hasNext()) {
                                    beanName = (String)var2.next();
                                    Object singletonInstance = this.getSingleton(beanName);
                                    if (singletonInstance instanceof SmartInitializingSingleton) {
                                        SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton)singletonInstance;
                                        if (System.getSecurityManager() != null) {
                                            AccessController.doPrivileged(() -> {
                                                smartSingleton.afterSingletonsInstantiated();
                                                return null;
                                            }, this.getAccessControlContext());
                                        } else {
                                            smartSingleton.afterSingletonsInstantiated();
                                        }
                                    }
                                }

                                return;
                            }

                            beanName = (String)var2.next();
                            bd = this.getMergedLocalBeanDefinition(beanName);
                        } while(bd.isAbstract());
                    } while(!bd.isSingleton());
                } while(bd.isLazyInit());

                if (this.isFactoryBean(beanName)) {
                    bean = this.getBean("&" + beanName);
                    break;
                }

                this.getBean(beanName);
            }
        } while(!(bean instanceof FactoryBean));

        FactoryBean<?> factory = (FactoryBean)bean;
        boolean isEagerInit;
        if (System.getSecurityManager() != null && factory instanceof SmartFactoryBean) {
            SmartFactoryBean var10000 = (SmartFactoryBean)factory;
            ((SmartFactoryBean)factory).getClass();
            isEagerInit = (Boolean)AccessController.doPrivileged(var10000::isEagerInit, this.getAccessControlContext());
        } else {
            isEagerInit = factory instanceof SmartFactoryBean && ((SmartFactoryBean)factory).isEagerInit();
        }

        if (isEagerInit) {
            this.getBean(beanName);
        }
    }
}
```

# autowiring(自动依赖装配)的实现  
......


