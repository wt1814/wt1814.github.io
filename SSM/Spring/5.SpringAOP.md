---
title: SpringAOP教程  
date: 2020-04-09 00:00:00
tags:
    - Spring
---

# 代理  
&emsp; 代理设计模式，提供了对目标对象另外的访问方式；即通过代理访问目标对象。代理好处：可以在目标对象实现的基础上，增强额外的功能操作(扩展目标对象的功能)。  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/SSM/AOP/AOP-1.png)  
&emsp; 动态代理技术：  
&emsp; 代理类在程序运行时创建的代理方式被认为动态代理。在了解动态代理之前, 先回顾一下JVM的类加载机制中的加载阶段要做的三件事情  
1. 通过一个类的全名或其它途径来获取这个类的二进制字节流；  
2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构；  
3. 在内存中生成一个代表这个类的Class对象, 作为方法区中对这个类访问的入口。  
&emsp; 而动态代理，主要就发生在第一个阶段, 这个阶段类的二进制字节流的来源可以有很多, 比如zip包、网络、运行时计算生成、其它文件生成 (JSP)、数据库获取。其中运行时计算生成就是所说的动态代理技术，在Proxy类中, 就是运用了ProxyGenerator.generateProxyClass来为特定接口生成形式为 *$Proxy 的代理类的二进制字节流。所谓的动态代理就是想办法根据接口或者目标对象计算出代理类的字节码然后加载进JVM 中。实际计算的情况会很复杂，可以借助一些诸如JDK动态代理实现、CGLIB第三方库来完成的。  
&emsp; 另一方面为了让生成的代理类与目标对象 (就是委托类) 保持一致, 有2种做法：通过接口的JDK动态代理和通过继承类的CGLIB动态代理。  

## JDK动态代理和CGLIB动态代理  
  
1. JDK动态代理  
利用拦截器(拦截器必须实现InvocationHanlder)加上反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理。  

2. CGLIB动态代理  
利用ASM开源包，对代理对象类的class文件加载进来，通过修改其字节码生成子类来处理。  

3. 何时使用JDK还是CGLIB？  
1）如果目标对象实现了接口，默认情况下会采用JDK的动态代理实现AOP。  
2）如果目标对象实现了接口，可以强制使用CGLIB实现AOP。  
3）如果目标对象没有实现了接口，必须采用CGLIB库，Spring会自动在JDK动态代理和CGLIB之间转换。  

4. 如何强制使用CGLIB实现AOP？  
1）添加CGLIB库(aspectjrt-xxx.jar、aspectjweaver-xxx.jar、cglib-nodep-xxx.jar)  
2）在Spring配置文件中加入<aop:aspectj-autoproxy proxy-target-class="true"/>  

5. JDK动态代理和CGLIB字节码生成的区别？   
1）JDK动态代理只能对实现了接口的类生成代理，而不能针对类。  
2）CGLIB是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法，并覆盖其中方法实现增强，但是因为采用的是继承，所以该类或方法最好不要声明成final，对于final类或方法，是无法继承的。  

6. CGlib比JDK快？  
1）使用CGLib实现动态代理，CGLib底层采用ASM字节码生成框架，使用字节码技术生成代理类，在jdk6之前比使用Java反射效率要高。唯一需要注意的是，CGLib不能对声明为final的方法进行代理，因为CGLib原理是动态生成被代理类的子类。  
2）在jdk6、jdk7、jdk8逐步对JDK动态代理优化之后，在调用次数较少的情况下，JDK代理效率高于CGLIB代理效率，只有当进行大量调用的时候，jdk6和jdk7比CGLIB代理效率低一点，但是到jdk8的时候，jdk代理效率高于CGLIB代理，总之，每一次jdk版本升级，jdk代理效率都得到提升，而CGLIB代理消息确有点跟不上步伐。  

7. Spring如何选择用JDK还是CGLIB？  
1）当Bean实现接口时，Spring就会用JDK的动态代理。  
2）当Bean没有实现接口时，Spring使用CGlib是实现。  
3）可以强制使用CGlib（在spring配置中加入<aop:aspectj-autoproxy proxy-target-class="true"/>）。   

----




