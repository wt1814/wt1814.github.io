---
title: SpringIOC 
date: 2020-04-06 00:00:00
tags:
    - Spring
---

<!-- TOC -->

- [1. IOC容器的设计与实现](#1-ioc容器的设计与实现)
    - [1.1. BeanFactory](#11-beanfactory)
    - [1.2. ApplicationContext](#12-applicationcontext)
        - [1.2.1. BeanFactory和ApplicationContext的区别：](#121-beanfactory和applicationcontext的区别)
    - [1.3. BeanDefinition](#13-beandefinition)
    - [1.4. BeanDefinitionReader](#14-beandefinitionreader)
- [2. Spring容器初始化的入口](#2-spring容器初始化的入口)
- [3. 基于Xml的IOC容器ClassPathXmlApplicationContext 的初始化](#3-基于xml的ioc容器classpathxmlapplicationcontext-的初始化)
    - [3.1. ClassPathXmlApplicationContext构造函数](#31-classpathxmlapplicationcontext构造函数)
    - [3.2. refresh()方法](#32-refresh方法)
    - [3.3. 容器初始化详解（obtainFreshBeanFactory()方法）：](#33-容器初始化详解obtainfreshbeanfactory方法)
- [4. 基于Annotation的IOC初始化](#4-基于annotation的ioc初始化)
    - [4.1. 定位Bean扫描路径](#41-定位bean扫描路径)
        - [4.1.1. 读取Annotation元数据](#411-读取annotation元数据)
            - [4.1.1.1. AnnotationConfigApplicationContext通过调用注解Bean定义读取器](#4111-annotationconfigapplicationcontext通过调用注解bean定义读取器)
            - [4.1.1.2. AnnotationScopeMetadataResolver 解析作用域元数据](#4112-annotationscopemetadataresolver-解析作用域元数据)
            - [4.1.1.3. AnnotationConfigUtils 处理注解 Bean 定义类中的通用注解](#4113-annotationconfigutils-处理注解-bean-定义类中的通用注解)
            - [4.1.1.4. AnnotationConfigUtils 根据注解 Bean 定义类中配置的作用域为其应用相应的代理策略](#4114-annotationconfigutils-根据注解-bean-定义类中配置的作用域为其应用相应的代理策略)
            - [4.1.1.5. BeanDefinitionReaderUtils 向容器注册 Bean](#4115-beandefinitionreaderutils-向容器注册-bean)
        - [4.1.2. 扫描指定包并解析为 BeanDefinition](#412-扫描指定包并解析为-beandefinition)
            - [4.1.2.1. ClassPathBeanDefinitionScanner 扫描给定的包及其子包](#4121-classpathbeandefinitionscanner-扫描给定的包及其子包)
            - [4.1.2.2. ClassPathScanningCandidateComponentProvider 扫描给定包及其子包的类](#4122-classpathscanningcandidatecomponentprovider-扫描给定包及其子包的类)
        - [4.1.3. 注册注解 BeanDefinition](#413-注册注解-beandefinition)

<!-- /TOC -->

# 1. IOC容器的设计与实现  
&emsp; 在Spring IOC容器的设计当中，可以看到两个主要的容器系列（根据命名）。  
* 实现了BeanFactory接口的简单容器系列，只实现了容器的最基本功能；  
* ApplicationContext应用上下文，容器的高级形态，增加了许多面向框架的特性和对应用环境的适配；  

## 1.1. BeanFactory  
&emsp; Spring Bean的创建是典型的工厂模式，这一系列的Bean工厂，也即IOC容器为开发者管理对象间的依赖关系提供了很多便利和基础服务，在Spring中有许多的 IOC 容器的实现供用户选择和使用，其相互关系如下：  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/SSM/Spring/spring-3.png)  

&emsp; 其中BeanFactory 作为最顶层的一个接口类，它定义了 IOC 容器的基本功能规范。
&emsp; BeanFactory 有三个重要的子类：ListableBeanFactory、HierarchicalBeanFactory 和 AutowireCapableBeanFactory。但是从类图中可以发现最终的默认实现类是DefaultListableBeanFactory，它实现了所有的接口。那为何要定义这么多层次的接口呢？查阅这些接口的源码和说明发现，每个接口都有它使用的场合，它主要是为了区分在 Spring 内部在操作过程中对象的传递和转化过程时，对对象的数据访问所做的限制。例如 ListableBeanFactory 接口表示这些 Bean 是可列表化的，而 HierarchicalBeanFactory 表示的是这些 Bean 是有继承关系的，也就是每个 Bean 有可能有父 Bean。AutowireCapableBeanFactory 接口定义 Bean 的自动装配规则。这三个接口共同定义了 Bean 的集合、Bean 之间的关系、以及 Bean 行为。  
&emsp; 最基本的 IOC 容器接口 BeanFactory，来看一下它的源码：  

```
public interface BeanFactory {
    //对 FactoryBean 的转义定义，因为如果使用bean 的名字检索 FactoryBean 得到的对象是工厂生成的对象，
    //如果需要得到工厂本身，需要转义String FACTORY_BEAN_PREFIX = "&";
    //根据 bean 的名字，获取在 IOC 容器中得到 bean 实例
    Object getBean(String name) throws BeansException;


    //根据 bean 的名字和 Class 类型来得到 bean 实例，增加了类型安全验证机制。
    <T> T getBean(String name, @Nullable Class<T> requiredType) throws BeansException;

    Object getBean(String name, Object... args) throws BeansException;
    <T> T getBean(Class<T> requiredType) throws BeansException;
    <T> T getBean(Class<T> requiredType, Object... args) throws BeansException;


    //提供对 bean 的检索，看看是否在 IOC 容器有这个名字的
    bean boolean containsBean(String name);

    //根据 bean 名字得到 bean 实例，并同时判断这个 bean 是不是单例
    boolean isSingleton(String name) throws NoSuchBeanDefinitionException; boolean isPrototype(String name) throws NoSuchBeanDefinitionException; boolean isTypeMatch(String name, ResolvableType typeToMatch) throws
            NoSuchBeanDefinitionException;
    boolean isTypeMatch(String name, @Nullable Class<?> typeToMatch) throws NoSuchBeanDefinitionException;
    //得到 bean 实例的 Class 类型
    @Nullable
    Class<?> getType(String name) throws NoSuchBeanDefinitionException;

    //得到 bean 的别名，如果根据别名检索，那么其原名也会被检索出来
    String[] getAliases(String name);

}
```  
&emsp; 在 BeanFactory 里只对 IOC 容器的基本行为作了定义，根本不关心Bean是如何定义怎样加载的。正如只关心工厂里得到什么的产品对象，至于工厂是怎么生产这些对象的，这个基本的接口不关心。  
&emsp; 而要知道工厂是如何产生对象的，需要看具体的 IOC 容器实现，Spring 提供了许多 IOC 容器的实现   。 比  如GenericApplicationContext  ，  ClasspathXmlApplicationContext等 。   

## 1.2. ApplicationContext  
&emsp; ApplicationContext接口是BeanFactory的扩展，它除了具备 BeanFactory 接口所拥有的全部功能外，还有应用程序上下文的一层含义，主要包括：  
1. 继承自ListableBeanFactory接口，可以访问Bean工厂上下文的组件；  
2. 继承自ResourceLoader接口，以通用的方式加载文件资源；  
3. 继承自ApplicationContextPublisher接口，拥有发布事件注册监听的能力；  
4. 继承自 MessageSource 接口，解析消息支持国际化。  

&emsp; 它最主要的实现是ClassPathXmlApplicationContext，用来读取XML配置文件，现在使用更多的是ClassPathXmlApplicationContext而不是 XMLBeanFactory。  
&emsp; Spring也为提供了多种类型的容器实现，在不同的应用场景选择：  
1. AnnotationConfigApplicationContext:从一个或多个基于java的配置类中加载上下文定义，适用于java注解的方式；  
2. ClassPathXmlApplicationContext:从类路径下的一个或多个xml配置文件中加载上下文定义，适用于xml配置的方式；  
3. FileSystemXmlApplicationContext:从文件系统下的一个或多个xml配置文件中加载上下文定义，也就是说系统盘符中加载xml配置文件；  
4. AnnotationConfigWebApplicationContext:专门为web应用准备的，适用于注解方式；  
5. XmlWebApplicationContext:从web应用下的一个或多个xml配置文件加载上下文定义，适用于xml配置方式。  

### 1.2.1. BeanFactory和ApplicationContext的区别：  

|BeanFactory	|ApplicationContext|
|---|---|
|它使用懒加载	|它使用即时加载|
|它使用语法显式提供资源对象	|它自己创建和管理资源对象|
|不支持国际化	|支持国际化|
|不支持基于依赖的注解	|支持基于依赖的注解|  

&emsp; 选用哪个？  
&emsp; BeanFactory是延迟加载，如果Bean的某一个属性没有注入，BeanFactory加载后，直至第一次使用调用getBean方法才会抛出异常。  
&emsp; ApplicationContext则在初始化自身时校验，这样有利于检查所依赖属性是否注入；所以通常情况下选择使用ApplicationContext。  


## 1.3. BeanDefinition  
&emsp; 在这些Spring提供的基本IoC容器的接口定义和实现的基础上，Spring通过定义BeanDefinition来管理基于Spring的应用中的各种对象以及它们之间的相互依赖关系。  
&emsp; BeanDefinition 中保存了Bean信息，比如这个 Bean 指向的是哪个类、是否是单例的、是否懒加载、这个Bean依赖了哪些Bean等等。  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/SSM/Spring/spring-4.png)  
&emsp; BeanDefinition抽象了Bean的定义，是让容器起作用的主要数据类型。对IoC容器来说，BeanDefinition就是对依赖反转模式中管理的对象依赖关系的数据抽象，也是容器实现依赖反转功能的核心数据结构，依赖反转功能都是围绕对这个BeanDefinition的处理来完成的。  

## 1.4. BeanDefinitionReader  
&emsp; Bean 的解析过程非常复杂，功能被分的很细，因为这里需要被扩展的地方很多，必须保证有足够的灵活性，以应对可能的变化。Bean 的解析主要就是对 Spring 配置文件的解析。这个解析过程主要通过BeanDefintionReader 来完成。  

----
# 2. Spring容器初始化的入口  
&emsp; 启动容器，实际上指实例化ApplicationContext。只是在不同情况下可能有不同的表现形式。  
&emsp; 1. ClassPathXmlApplicationContext 通过XML配置  

```java
public static void main(String[] args) {
    ApplicationContext context = new ClassPathXmlApplicationContext("classpath:applicationfile.xml");
}
```
&emsp; 2. AnnotationConfigApplicationContext通过java config类配置  

```java
@Configuration
@ComponentScan("ric.study.demo.ioc")
public class BeanDemoConfig {
    public static void main(String... strings) {
        AnnotationConfigApplicationContext context =
                new AnnotationConfigApplicationContext(BeanDemoConfig.class);
        System.out.println("Spring container started and is ready");
    }
}
```

----
# 3. 基于Xml的IOC容器ClassPathXmlApplicationContext 的初始化  
 

## 3.1. ClassPathXmlApplicationContext构造函数
&emsp; 启动 IoC 容器，即实例化ClassPathXmlApplicationContext 上下文，首先查看其构造函数：  

```java
public class ClassPathXmlApplicationContext extends AbstractXmlApplicationContext {
    private Resource[] configResources;

    // 如果已经有 ApplicationContext 并需要配置成父子关系，那么调用这个构造方法
    public ClassPathXmlApplicationContext(ApplicationContext parent) {
        super(parent);
    }
    ...
    public ClassPathXmlApplicationContext(String[] configLocations, boolean refresh, ApplicationContext parent)
            throws BeansException {

        super(parent);
        // 根据提供的路径，处理成配置文件数组(以分号、逗号、空格、tab、换行符分割)
        setConfigLocations(configLocations);
        if (refresh) {
            refresh(); // 核心方法
        }
    }
    ...
}
```
&emsp; 入参中的configLocations在这里就是XML配置文件的classpath。  
&emsp; ***super(parent);完成了BeanDefinition的resource的定位。***  
&emsp; setConfigLocations(configLocations);把一些带有占位符的地址解析成实际的地址。  

## 3.2. refresh()方法  
&emsp; SpringIOC容器对 Bean 配置资源的载入是从 refresh()函数开始的，refresh()是一个模板方法，规定了IOC容器的启动流程，有些逻辑要交给其子类去实现。Spring bean容器的刷新的核心 13个步骤完成IoC容器的创建及初始化工作：  
1. 刷新前的准备工作。  
2. ***创建IoC容器（DefaultListableBeanFactory）,加载和注册BeanDefinition对象。***  
3. 对IoC容器进行一些预处理。  
4. 允许在上下文子类中对bean工厂进行后处理。  
5. 调用BeanFactoryPostProcessor后置处理器对BeanDefinition处理。  
6. 注册BeanPostProcessor后置处理器。  
7. 初始化一些消息源（比如处理国际化的i18n等消息源）。  
8. 初始化应用事件多播器。  
9. 初始化一些特殊的bean。  
10. 注册一些监听器。  
11. 实例化剩余的单例bean（非懒加载方式）。  
12. 完成刷新时，发布对应的事件。  
13. 重置公共的一些缓存数据。  

&emsp; 注：***ClassPathXmlApplicationContext容器的初始化包括BeanDefinition的resource定位、载入和注册这三个基本的过程***。  
1. BeanDefinition的resource的定位过程，就是找到定义bean的相关的xml文件，是通过继承ResourceLoader 获得的，ResourceLoader代表了加载资源的一种方式，正是策略模式的实现。  
2. BeanDifinition的载入，就是把用户在xml中定义好的bean解析成为IoC的内部数据结构，也就是BeanDifinition。  
3. BeanDifinition的注册，向IoC容器注册这些BeanDifinition，把BeanDifinition注册到一个Map中保存。 

```java
// 完成IoC容器的创建及初始化工作
@Override
public void refresh() throws BeansException, IllegalStateException {
    //加锁
    synchronized (this.startupShutdownMonitor) {

        // 1： 刷新前的准备工作。
        // 记录下容器的启动时间、给容器设置同步标识（标记“已启动”状态）、处理配置文件中的占位符
        prepareRefresh();

        //  2：告诉子类刷新内部bean 工厂。子类启动 refreshBeanFactory()方法，Bean 定义资源文件的载入从子类的 refreshBeanFactory()方法启动
        //  内部创建了IoC容器（DefaultListableBeanFactory）,加载解析XML文件，存储到Document对象中。读取Document对象，并完成BeanDefinition对象的加载和注册工作
        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();

        //  3： 对IoC容器进行一些预处理
        // 为 BeanFactory 配置容器特性，例如设置 BeanFactory 的类加载器，配置了BeanPostProcessor，注册了三个默认bean实例，分别是 “environment”、“systemProperties”、“systemEnvironment”
        prepareBeanFactory(beanFactory);

        try {

            //  4:  允许在上下文子类中对bean工厂进行后置处理。
            // 【这里需要知道 BeanFactoryPostProcessor 这个知识点，Bean 如果实现了此接口，那么在容器初始化以后，Spring 会负责调用里面的 postProcessBeanFactory 方法。】
            // 本方法没有具体实现，是一个扩展点，开发人员可以根据自己的情况做具体的实现。到这里的时候，所有的 Bean 都加载、注册完成了，但是都还没有初始化
            postProcessBeanFactory(beanFactory);

            //  5： 调用BeanFactoryPostProcessor后置处理器postProcessBeanFactory(factory) 方法对BeanDefinition处理
            invokeBeanFactoryPostProcessors(beanFactory);

            //  6： 注册BeanPostProcessor后置处理器
            // 注意看和 BeanFactoryPostProcessor 的区别
            // 此接口两个方法: postProcessBeforeInitialization 和 postProcessAfterInitialization
            // 两个方法分别在 Bean 初始化之前和初始化之后得到执行。注意，到这里 Bean 还没初始化
            registerBeanPostProcessors(beanFactory);

            //  7： 初始化一些消息源（比如处理国际化的i18n等消息源）， 不详述
            initMessageSource();

            //  8： 初始化容器事件传播器， 不详述
            initApplicationEventMulticaster();

            //  9： 具体的子类初始化一些特殊的bean在初始化 singleton beans 之前）
            //  从方法名就可以知道，典型的模板方法(钩子方法)
            onRefresh();

            //  10： 为事件传播器注册事件监听器
            registerListeners();

            //  11： 实例化剩余的单例bean（非懒加载方式）
            //      注意事项：Bean的IoC、DI和AOP都是发生在此步骤
            finishBeanFactoryInitialization(beanFactory);

            //  12： 完成刷新时，广播事件，发布ApplicationContext 初始化完成
            finishRefresh();
        }

        catch (BeansException ex) {
            if (logger.isWarnEnabled()) {
                logger.warn("Exception encountered during context initialization - " +
                        "cancelling refresh attempt: " + ex);
            }

            // 销毁已经创建的单例，避免占用资源
            destroyBeans();

            // 取消 refresh 操作，重置容器的同步标识（'active' 标签）.
            cancelRefresh(ex);

            // 传播异常给调用者
            throw ex;
        }

        finally {

            // 13： 重置Spring核心中的常见内省缓存，因为可能不再需要单例bean的元数据了...
            resetCommonCaches();
        }
    }
}
```
&emsp; ***refresh()方法主要为IOC容器Bean的生命周期管理提供条件。***  
&emsp; Spring 容器初始化，共经历了 13 步；其中尤其需要重点关注的是：  
&emsp; 步骤2，初始化 Spring 容器，并构建了BeanDefinition定义  
&emsp; 步骤5，BeanFactoryPostProcessor，对BeanFactory做一些后置操作  
&emsp; 步骤6，BeanPostProcessor，对 bean 实例在初始化前后做一些增强工作  
&emsp; 步骤11，对剩余所有的非懒加载的BeanDefinition(bean 定义)执行 bean 实例化操作  

## 3.3. 容器初始化详解（obtainFreshBeanFactory()方法）：  
&emsp; 容器初始化时序图:  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/sourceCode/Spring/Spring-1.png)  
&emsp; 时序图在 github.com/wt1814/diagrams/tree/master/SSM/ 中，使用工具 draw.io。  

&emsp; ......

---

# 4. 基于Annotation的IOC初始化  
&emsp; Spring IOC容器对于类级别的注解和类内部的注解分以下两种处理策略：  
1. 类级别的注解：如@Component、@Repository、@Controller、@Service 以及 JavaEE6 的 @ManagedBean 和@Named 注解，都是添加在类上面的类级别注解，Spring 容器根据注解的过滤规 则扫描读取注解 Bean 定义类，并将其注册到Spring IOC容器中。  
2. 类内部的注解：如@Autowire、@Value、@Resource以及EJB和WebService 相关的注解等， 都是添加在类内部的字段或者方法上的类内部注解，SpringIOC 容器通过 Bean 后置注解处理器解析Bean内部的注解。下面将根据这两种处理策略，分别分析Spring处理注解相关的源码。  

## 4.1. 定位Bean扫描路径  
&emsp; 在 Spring 中 管 理 注 解 Bean 定 义 的 容 器 有 两 个 ： AnnotationConfigApplicationContext 和 AnnotationConfigWebApplicationContex。这两个类是专门处理 Spring 注解方式配置的容器，直接 依赖于注解作为容器配置信息来源的 IOC 容器。AnnotationConfigWebApplicationContext 是 AnnotationConfigApplicationContext 的 Web 版本，两者的用法以及对注解的处理方式几乎没有差别。  

&emsp; 示例，AnnotationConfigApplicationContext源码：  

```
public class AnnotationConfigApplicationContext extends GenericApplicationContext implements AnnotationConfigRegistry {
    //保存一个读取注解的 Bean 定义读取器，并将其设置到容器中
    private final AnnotatedBeanDefinitionReader reader;
    //保存一个扫描指定类路径中注解 Bean 定义的扫描器，并将其设置到容器中
    private final ClassPathBeanDefinitionScanner scanner;

    //默认构造函数，初始化一个空容器，容器不包含任何 Bean 信息，需要在稍后通过调用其 register()
    //方法注册配置类，并调用 refresh()方法刷新容器，触发容器对注解 Bean 的载入、解析和注册过程
    public AnnotationConfigApplicationContext() {
        this.reader = new AnnotatedBeanDefinitionReader(this);
        this.scanner = new ClassPathBeanDefinitionScanner(this);
    }

    public AnnotationConfigApplicationContext(DefaultListableBeanFactory beanFactory) {
        super(beanFactory);
        this.reader = new AnnotatedBeanDefinitionReader(this);
        this.scanner = new ClassPathBeanDefinitionScanner(this);
    }

    //最常用的构造函数，通过将涉及到的配置类传递给该构造函数，以实现将相应配置类中的 Bean 自动注册到容器中
    public AnnotationConfigApplicationContext(Class<?>... annotatedClasses) {
        this();
        register(annotatedClasses);
        refresh();
    }


    //该构造函数会自动扫描以给定的包及其子包下的所有类，并自动识别所有的 Spring Bean，将其注册到容器中
    public AnnotationConfigApplicationContext(String... basePackages) {
        this();
        scan(basePackages);
        refresh();
    }

    @Override
    public void setEnvironment(ConfigurableEnvironment environment) {
        super.setEnvironment(environment);
        this.reader.setEnvironment(environment);
        this.scanner.setEnvironment(environment);
    }

    //为容器的注解 Bean 读取器和注解 Bean 扫描器设置 Bean 名称产生器
    public void setBeanNameGenerator(BeanNameGenerator beanNameGenerator) {
        this.reader.setBeanNameGenerator(beanNameGenerator);
        this.scanner.setBeanNameGenerator(beanNameGenerator);
        getBeanFactory().registerSingleton(AnnotationConfigUtils.CONFIGURATION_BEAN_NAME_GENERATOR, beanNameGenerator);
    }

    //为容器的注解 Bean 读取器和注解 Bean 扫描器设置作用范围元信息解析器
    public void setScopeMetadataResolver(ScopeMetadataResolver scopeMetadataResolver) {
        this.reader.setScopeMetadataResolver(scopeMetadataResolver);
        this.scanner.setScopeMetadataResolver(scopeMetadataResolver);
    }

    //为容器注册一个要被处理的注解 Bean，新注册的 Bean，必须手动调用容器的
    //refresh()方法刷新容器，触发容器对新注册的 Bean 的处理
    public void register(Class<?>... annotatedClasses) {
        Assert.notEmpty(annotatedClasses, "At least one annotated class must be specified");
        this.reader.register(annotatedClasses);
    }

    //扫描指定包路径及其子包下的注解类，为了使新添加的类被处理，必须手动调用
    //refresh()方法刷新容器
    public void scan(String... basePackages) {
        Assert.notEmpty(basePackages, "At least one base package must be specified");
        this.scanner.scan(basePackages);
    }
}
```

&emsp; Spring对注解的处理分为两种方式：  
1. 直接将注解 Bean 注册到容器中 可以在初始化容器时注册；也可以在容器创建之后手动调用注册方法向容器注册，然后通过手动刷新容 器，使得容器对注册的注解 Bean 进行处理。  
2. 通过扫描指定的包及其子包下的所有类 在初始化注解容器时指定要自动扫描的路径，如果容器创建以后向给定路径动态添加了注解 Bean，则 需要手动调用容器扫描的方法，然后手动刷新容器，使得容器对所注册的 Bean 进行处理。  

&emsp; 下面将会对两种处理方式详细分析其实现过程。  

### 4.1.1. 读取Annotation元数据  
&emsp; 当创建注解处理容器时，如果传入的初始参数是具体的注解 Bean 定义类时，注解容器读取并注册。  

#### 4.1.1.1. AnnotationConfigApplicationContext通过调用注解Bean定义读取器  
&emsp; AnnotatedBeanDefinitionReader 的 register()方法向容器注册指定的注解 Bean，注解 Bean 定义读 取器向容器注册注解 Bean 的源码如下：  

```
//注册多个注解 Bean 定义类
public void register(Class<?>... annotatedClasses) {
    for (Class<?> annotatedClass : annotatedClasses) {
        registerBean(annotatedClass);
    }
}

//注册一个注解 Bean 定义类
public void registerBean(Class<?> annotatedClass) {
    doRegisterBean(annotatedClass, null, null, null);
}
public <T> void registerBean(Class<T> annotatedClass, @Nullable Supplier<T> instanceSupplier) {
    doRegisterBean(annotatedClass, instanceSupplier, null, null);
}

public <T> void registerBean(Class<T> annotatedClass, String name, @Nullable Supplier<T> instanceSupplier) {
    doRegisterBean(annotatedClass, instanceSupplier, name, null);
}

//Bean 定义读取器注册注解 Bean 定义的入口方法
@SuppressWarnings("unchecked")
public void registerBean(Class<?> annotatedClass, Class<? extends Annotation>... qualifiers) {
    doRegisterBean(annotatedClass, null, null, qualifiers);
}

//Bean 定义读取器向容器注册注解 Bean 定义类
@SuppressWarnings("unchecked")
public void registerBean(Class<?> annotatedClass, String name, Class<? extends Annotation>... qualifiers) {
    doRegisterBean(annotatedClass, null, name, qualifiers);
}

//Bean 定义读取器向容器注册注解 Bean 定义类
<T> void doRegisterBean(Class<T> annotatedClass, @Nullable Supplier<T> instanceSupplier, @Nullable String name,
                        @Nullable Class<? extends Annotation>[] qualifiers, BeanDefinitionCustomizer... definitionCustomizers) {
    //根据指定的注解 Bean 定义类，创建 Spring 容器中对注解 Bean 的封装的数据结构
    AnnotatedGenericBeanDefinition abd = new AnnotatedGenericBeanDefinition(annotatedClass);
    if (this.conditionEvaluator.shouldSkip(abd.getMetadata())) {
        return;
    }
    abd.setInstanceSupplier(instanceSupplier);
    //解析注解 Bean 定义的作用域，若@Scope("prototype")，则 Bean 为原型类型；
    //若@Scope("singleton")，则 Bean 为单态类型
    ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(abd);
    //为注解 Bean 定义设置作用域
    abd.setScope(scopeMetadata.getScopeName());
    //为注解 Bean 定义生成 Bean 名称
    String beanName = (name != null ? name : this.beanNameGenerator.generateBeanName(abd, this.registry));

    //处理注解 Bean 定义中的通用注解
    AnnotationConfigUtils.processCommonDefinitionAnnotations(abd);
    //如果在向容器注册注解 Bean 定义时，使用了额外的限定符注解，则解析限定符注解。
    //主要是配置的关于 autowiring 自动依赖注入装配的限定条件，即@Qualifier 注解
    //Spring 自动依赖注入装配默认是按类型装配，如果使用@Qualifier 则按名称
    if (qualifiers != null) {
        for (Class<? extends Annotation> qualifier : qualifiers) {
            //如果配置了@Primary 注解，设置该 Bean 为 autowiring 自动依赖注入装//配时的首选
            if (Primary.class == qualifier) {
                abd.setPrimary(true);
            }

            //如果配置了@Lazy 注解，则设置该 Bean 为非延迟初始化，如果没有配置，
            //则该 Bean 为预实例化
            else if (Lazy.class == qualifier) {
                abd.setLazyInit(true);
            }
            //如果使用了除@Primary 和@Lazy 以外的其他注解，则为该 Bean 添加一个 autowiring 自动依赖注入装配限定符，该 Bean 在进 autowiring
            // 自动依赖注入装配时，根据名称装配限定符指定的 Bean
            else {
                abd.addQualifier(new AutowireCandidateQualifier(qualifier));
            }
        }
    }
    for (BeanDefinitionCustomizer customizer : definitionCustomizers) {
        customizer.customize(abd);
    }

    //创建一个指定 Bean 名称的 Bean 定义对象，封装注解 Bean 定义类数据
    BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(abd, beanName);
    //根据注解 Bean 定义类中配置的作用域，创建相应的代理对象
    definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder,
            this.registry);
    //向 IOC 容器注册注解 Bean 类定义对象
    BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, this.registry);
}
```

&emsp; 从上面的源码可以看出，注册注解 Bean 定义类的基本步骤：  
1. 需要使用注解元数据解析器解析注解 Bean 中关于作用域的配置。  
2. 使用 AnnotationConfigUtils 的 processCommonDefinitionAnnotations()方法处理注解 Bean 定 义类中通用的注解。    
3. 使用 AnnotationConfigUtils 的 applyScopedProxyMode()方法创建对于作用域的代理对象。   
4. 通过 BeanDefinitionReaderUtils  

&emsp; 这4步的具体实现过程如下。  

#### 4.1.1.2. AnnotationScopeMetadataResolver 解析作用域元数据  
&emsp; AnnotationScopeMetadataResolver 通过 resolveScopeMetadata()方法解析注解 Bean 定义类的作用域元信息，即判断注册的 Bean 是原生类型(prototype)还是单态(singleton)类型，其源码如下：  

```
//解析注解 Bean 定义类中的作用域元信息
@Override
public ScopeMetadata resolveScopeMetadata(BeanDefinition definition) {
    ScopeMetadata metadata = new ScopeMetadata();
    if (definition instanceof AnnotatedBeanDefinition) {
        AnnotatedBeanDefinition annDef = (AnnotatedBeanDefinition) definition;
        //从注解 Bean 定义类的属性中查找属性为”Scope”的值，即@Scope 注解的值
        //annDef.getMetadata().getAnnotationAttributes 方法将 Bean
        //中所有的注解和注解的值存放在一个 map 集合中
        AnnotationAttributes attributes = AnnotationConfigUtils.attributesFor( annDef.getMetadata(), this.scopeAnnotationType);
        //将获取到的@Scope 注解的值设置到要返回的对象中
        if (attributes != null) {
            metadata.setScopeName(attributes.getString("value"));
            //获取@Scope 注解中的 proxyMode 属性值，在创建代理对象时会用到
            ScopedProxyMode proxyMode = attributes.getEnum("proxyMode");
            //如果@Scope 的 proxyMode 属性为 DEFAULT 或者 NO
            if (proxyMode == ScopedProxyMode.DEFAULT) {
                //设置 proxyMode 为 NO
                proxyMode = this.defaultProxyMode;
            }
            //为返回的元数据设置 proxyMode
            metadata.setScopedProxyMode(proxyMode);
        }
    }
    //返回解析的作用域元信息对象
    return metadata;
}
```
&emsp; 上述代码中的 annDef.getMetadata().getAnnotationAttributes()方法就是获取对象中指定类型的注解的值。  

#### 4.1.1.3. AnnotationConfigUtils 处理注解 Bean 定义类中的通用注解  
&emsp; AnnotationConfigUtils类的processCommonDefinitionAnnotations()在向容器注册 Bean 之前，首先对注解 Bean 定义类中的通用 Spring 注解进行处理，源码如下：  

```
//处理 Bean 定义中通用注解
static void processCommonDefinitionAnnotations(AnnotatedBeanDefinition abd, AnnotatedTypeMetadata metadata) {
    AnnotationAttributes lazy = attributesFor(metadata, Lazy.class);
    //如果 Bean 定义中有@Lazy 注解，则将该 Bean 预实例化属性设置为@lazy 注解的值
    if (lazy != null) {
        abd.setLazyInit(lazy.getBoolean("value"));
    }
    else if (abd.getMetadata() != metadata) {
        lazy = attributesFor(abd.getMetadata(), Lazy.class);
        if (lazy != null) {
            abd.setLazyInit(lazy.getBoolean("value"));
        }
    }
    //如果 Bean 定义中有@Primary 注解，则为该 Bean 设置为 autowiring 自动依赖注入装配的首选对象
    if (metadata.isAnnotated(Primary.class.getName())) {
        abd.setPrimary(true);
    }
    //如果 Bean 定义中有@ DependsOn 注解，则为该 Bean 设置所依赖的 Bean 名称，
    //容器将确保在实例化该 Bean 之前首先实例化所依赖的 Bean
    AnnotationAttributes dependsOn = attributesFor(metadata, DependsOn.class);
    if (dependsOn != null) {
        abd.setDependsOn(dependsOn.getStringArray("value"));
    }
    if (abd instanceof AbstractBeanDefinition) {
        AbstractBeanDefinition absBd = (AbstractBeanDefinition) abd;
        AnnotationAttributes role = attributesFor(metadata, Role.class);
        if (role != null) {
            absBd.setRole(role.getNumber("value").intValue());
        }
        AnnotationAttributes description = attributesFor(metadata, Description.class);
        if (description != null) {
            absBd.setDescription(description.getString("value"));
        }
    }
}
```

#### 4.1.1.4. AnnotationConfigUtils 根据注解 Bean 定义类中配置的作用域为其应用相应的代理策略  
&emsp; AnnotationConfigUtils类的applyScopedProxyMode()方法根据注解Bean定义类中配置的作用域 @Scope 注解的值，为 Bean 定义应用相应的代理模式，主要是在 Spring 面向切面编程(AOP)中使用。源码如下：  

```
//根据作用域为 Bean 应用引用的代码模式
static BeanDefinitionHolder applyScopedProxyMode(ScopeMetadata metadata, BeanDefinitionHolder definition, BeanDefinitionRegistry registry) {

    //获取注解 Bean 定义类中@Scope 注解的 proxyMode 属性值
    ScopedProxyMode scopedProxyMode = metadata.getScopedProxyMode();
    //如果配置的@Scope 注解的 proxyMode 属性值为 NO，则不应用代理模式
    if (scopedProxyMode.equals(ScopedProxyMode.NO)) {
        return definition;
    }
    //获取配置的@Scope 注解的 proxyMode 属性值，如果为 TARGET_CLASS
    //则返回 true，如果为 INTERFACES，则返回 false
    boolean proxyTargetClass = scopedProxyMode.equals(ScopedProxyMode.TARGET_CLASS);
    //为注册的 Bean 创建相应模式的代理对象
    return ScopedProxyCreator.createScopedProxy(definition, registry, proxyTargetClass);
}
```

&emsp; 这段为 Bean 引用创建相应模式的代理，这里不做深入的分析。   

#### 4.1.1.5. BeanDefinitionReaderUtils 向容器注册 Bean  
&emsp; BeanDefinitionReaderUtils 主要是校验 BeanDefinition 信息，然后将 Bean 添加到容器中一个管理 BeanDefinition 的 HashMap 中。  

### 4.1.2. 扫描指定包并解析为 BeanDefinition  
&emsp; 当创建注解处理容器时，如果传入的初始参数是注解 Bean 定义类所在的包时，注解容器将扫描给定的 包及其子包，将扫描到的注解 Bean 定义载入并注册。  

#### 4.1.2.1. ClassPathBeanDefinitionScanner 扫描给定的包及其子包  
&emsp; AnnotationConfigApplicationContext 通 过 调 用 类 路 径 Bean 定 义 扫 描 器 ClassPathBeanDefinitionScanner 扫描给定包及其子包下的所有类，主要源码如下：  

```
public class ClassPathBeanDefinitionScanner extends ClassPathScanningCandidateComponentProvider {
    //创建一个类路径 Bean 定义扫描器
    public ClassPathBeanDefinitionScanner(BeanDefinitionRegistry registry) {
        this(registry, true);
    }
    //为容器创建一个类路径 Bean 定义扫描器，并指定是否使用默认的扫描过滤规则。
    //即 Spring 默认扫描配置：@Component、@Repository、@Service、@Controller
    //注解的 Bean，同时也支持 JavaEE6 的@ManagedBean 和 JSR-330 的@Named 注解
    public ClassPathBeanDefinitionScanner(BeanDefinitionRegistry registry, boolean useDefaultFilters) {
        this(registry, useDefaultFilters, getOrCreateEnvironment(registry));
    }
    public ClassPathBeanDefinitionScanner(BeanDefinitionRegistry registry, boolean useDefaultFilters,Environment environment) {
        this(registry, useDefaultFilters, environment,(registry instanceof ResourceLoader ? (ResourceLoader) registry : null));
    }

    public ClassPathBeanDefinitionScanner(BeanDefinitionRegistry registry, boolean useDefaultFilters,Environment environment, @Nullable ResourceLoader resourceLoader) {
        Assert.notNull(registry, "BeanDefinitionRegistry must not be null");
        //为容器设置加载 Bean 定义的注册器
        this.registry = registry;
        if (useDefaultFilters) {
            registerDefaultFilters();
        }
        setEnvironment(environment);
        //为容器设置资源加载器
        setResourceLoader(resourceLoader);
    }
    //调用类路径 Bean 定义扫描器入口方法
    public int scan(String... basePackages) {
        //获取容器中已经注册的 Bean 个数
        int beanCountAtScanStart = this.registry.getBeanDefinitionCount();
        //启动扫描器扫描给定包
        doScan(basePackages);


        // Register annotation config processors, if necessary.
        //注册注解配置(Annotation config)处理器
        if (this.includeAnnotationConfig) {
            AnnotationConfigUtils.registerAnnotationConfigProcessors(this.registry);
        }

        //返回注册的 Bean 个数
        return (this.registry.getBeanDefinitionCount() - beanCountAtScanStart);
    }

    //类路径 Bean 定义扫描器扫描给定包及其子包
    protected Set<BeanDefinitionHolder> doScan(String... basePackages) {
        Assert.notEmpty(basePackages, "At least one base package must be specified");
        //创建一个集合，存放扫描到 Bean 定义的封装类
        Set<BeanDefinitionHolder> beanDefinitions = new LinkedHashSet<>();
        //遍历扫描所有给定的包
        for (String basePackage : basePackages) {
            //调用父类 ClassPathScanningCandidateComponentProvider 的方法
            //扫描给定类路径，获取符合条件的 Bean 定义
            Set<BeanDefinition> candidates = findCandidateComponents(basePackage);
            //遍历扫描到的 Bean
            for (BeanDefinition candidate : candidates) {
                //获取 Bean 定义类中@Scope 注解的值，即获取 Bean 的作用域
                ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(candidate);
                //为 Bean 设置注解配置的作用域
                candidate.setScope(scopeMetadata.getScopeName());
                //为 Bean 生成名称
                String beanName = this.beanNameGenerator.generateBeanName(candidate, this.registry);
                //如果扫描到的 Bean 不是 Spring 的注解 Bean，则为 Bean 设置默认值，
                //设置 Bean 的自动依赖注入装配属性等
                if (candidate instanceof AbstractBeanDefinition) {
                    postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);
                }
                //如果扫描到的 Bean 是 Spring 的注解 Bean，则处理其通用的 Spring 注解
                if (candidate instanceof AnnotatedBeanDefinition) {
                    //处理注解 Bean 中通用的注解，在分析注解 Bean 定义类读取器时已经分析过
                    AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);
                }
                //根据 Bean 名称检查指定的 Bean 是否需要在容器中注册，或者在容器中冲突
                if (checkCandidate(beanName, candidate)) {
                    BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(candidate, beanName);
                    //根据注解中配置的作用域，为 Bean 应用相应的代理模式
                    definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);
                    beanDefinitions.add(definitionHolder);
                    //向容器注册扫描到的 Bean
                    registerBeanDefinition(definitionHolder, this.registry);
                }
            }
        }
        return beanDefinitions;
    }
    //...
}
```

&emsp; 类路径Bean定义扫描器ClassPathBeanDefinitionScanner主要通过 findCandidateComponents()方法调用其父类 ClassPathScanningCandidateComponentProvider 类来扫描获取给定包及其子包下 的类。  

#### 4.1.2.2. ClassPathScanningCandidateComponentProvider 扫描给定包及其子包的类  
&emsp; ClassPathScanningCandidateComponentProvider 类的 findCandidateComponents()方法具体实 现扫描给定类路径包的功能，主要源码如下：  

```
public class ClassPathScanningCandidateComponentProvider implements EnvironmentCapable, ResourceLoaderAware {

    //保存过滤规则要包含的注解，即 Spring 默认的@Component、@Repository、@Service、
    //@Controller 注解的 Bean，以及 JavaEE6 的@ManagedBean 和 JSR-330 的@Named 注解
    private final List<TypeFilter> includeFilters = new LinkedList<>();

    //保存过滤规则要排除的注解
    private final List<TypeFilter> excludeFilters = new LinkedList<>();

    //构造方法，该方法在子类 ClassPathBeanDefinitionScanner 的构造方法中被调用
    public ClassPathScanningCandidateComponentProvider(boolean useDefaultFilters) {
        this(useDefaultFilters, new StandardEnvironment());
    }

    public ClassPathScanningCandidateComponentProvider(boolean useDefaultFilters, Environment environment) {
        //如果使用 Spring 默认的过滤规则，则向容器注册过滤规则
        if (useDefaultFilters) {
            registerDefaultFilters();
        }
        setEnvironment(environment);
        setResourceLoader(null);
    }

    //向容器注册过滤规则
    @SuppressWarnings("unchecked")
    protected void registerDefaultFilters() {
        //向要包含的过滤规则中添加@Component 注解类，注意 Spring 中@Repository
        //@Service 和@Controller 都是 Component，因为这些注解都添加了@Component 注解
        this.includeFilters.add(new AnnotationTypeFilter(Component.class));
        //获取当前类的类加载器
        ClassLoader cl = ClassPathScanningCandidateComponentProvider.class.getClassLoader();
        try {
            //向要包含的过滤规则添加 JavaEE6 的@ManagedBean 注解
            this.includeFilters.add(new AnnotationTypeFilter(
                    ((Class<? extends Annotation>) ClassUtils.forName("javax.annotation.ManagedBean", cl)), false));
            logger.debug("JSR-250 'javax.annotation.ManagedBean' found and supported for component scanning");
        } catch (ClassNotFoundException ex) {
            // JSR-250 1.1 API (as included in Java EE 6) not available - simply skip.
        }
        try {
            //向要包含的过滤规则添加@Named 注解
            this.includeFilters.add(new AnnotationTypeFilter(
                    ((Class<? extends Annotation>) ClassUtils.forName("javax.inject.Named", cl)), false));
            logger.debug("JSR-330 'javax.inject.Named' annotation found and supported for component scanning");
        } catch (ClassNotFoundException ex) {
            // JSR-330 API not available - simply skip.
        }
    }

    //扫描给定类路径的包
    public Set<BeanDefinition> findCandidateComponents(String basePackage) {
        if (this.componentsIndex != null && indexSupportsIncludeFilters()) {
            return addCandidateComponentsFromIndex(this.componentsIndex, basePackage);
        } else {
            return scanCandidateComponents(basePackage);
        }
    }

    private Set<BeanDefinition> addCandidateComponentsFromIndex(CandidateComponentsIndex index, String basePackage) {
        //创建存储扫描到的类的集合
        Set<BeanDefinition> candidates = new LinkedHashSet<>();
        try {
            Set<String> types = new HashSet<>();
            for (TypeFilter filter : this.includeFilters) {
                String stereotype = extractStereotype(filter);
                if (stereotype == null) {
                    throw new IllegalArgumentException("Failed to extract stereotype from " + filter);
                }
                types.addAll(index.getCandidateTypes(basePackage, stereotype));
            }
            boolean traceEnabled = logger.isTraceEnabled();
            boolean debugEnabled = logger.isDebugEnabled();
            for (String type : types) {
                //为指定资源获取元数据读取器，元信息读取器通过汇编(ASM)读//取资源元信息
                MetadataReader metadataReader = getMetadataReaderFactory().getMetadataReader(type);
                //如果扫描到的类符合容器配置的过滤规则
                if (isCandidateComponent(metadataReader)) {
                    //通过汇编(ASM)读取资源字节码中的 Bean 定义元信息
                    AnnotatedGenericBeanDefinition sbd = new AnnotatedGenericBeanDefinition(
                            metadataReader.getAnnotationMetadata());
                    if (isCandidateComponent(sbd)) {
                        if (debugEnabled) {
                            logger.debug("Using candidate component class from index: " + type)
                        }
                        candidates.add(sbd);
                    } else {
                        if (debugEnabled) {
                            logger.debug("Ignored because not a concrete top-level class: " + type);
                        }
                    }
                } else {
                    if (traceEnabled) {
                        logger.trace("Ignored because matching an exclude filter: " + type);
                    }
                }
            }
        }catch(IOException ex){
            throw new BeanDefinitionStoreException("I/O failure during classpath scanning", ex);
        }
        return candidates;
    }

    //判断元信息读取器读取的类是否符合容器定义的注解过滤规则
    protected boolean isCandidateComponent(MetadataReader metadataReader) throws IOException {
        //如果读取的类的注解在排除注解过滤规则中，返回 false
        for (TypeFilter tf : this.excludeFilters) {
            if (tf.match(metadataReader, getMetadataReaderFactory())){
                return false;
            }
        }
        //如果读取的类的注解在包含的注解的过滤规则中，则返回 ture
        for (TypeFilter tf : this.includeFilters) {
            if (tf.match(metadataReader, getMetadataReaderFactory())){
                return isConditionMatch(metadataReader);
            }
        }
        //如果读取的类的注解既不在排除规则，也不在包含规则中，则返回 false
        return false;
    }

}
```

### 4.1.3. 注册注解 BeanDefinition
&emsp; AnnotationConfigWebApplicationContext 是 AnnotationConfigApplicationContext 的 Web 版， 它们对于注解 Bean 的注册和扫描是基本相同的，但是 AnnotationConfigWebApplicationContext 对注解 Bean 定义的载入稍有不同，AnnotationConfigWebApplicationContext 注入注解 Bean定义源码如下：  

```
//载入注解 Bean 定义资源
@Override
protected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) {
    //为容器设置注解 Bean 定义读取器
    AnnotatedBeanDefinitionReader reader = getAnnotatedBeanDefinitionReader(beanFactory);
    //为容器设置类路径 Bean 定义扫描器
    ClassPathBeanDefinitionScanner scanner = getClassPathBeanDefinitionScanner(beanFactory);
    //获取容器的 Bean 名称生成器
    BeanNameGenerator beanNameGenerator = getBeanNameGenerator();
    //为注解 Bean 定义读取器和类路径扫描器设置 Bean 名称生成器
    if (beanNameGenerator != null) {
        reader.setBeanNameGenerator(beanNameGenerator);
        scanner.setBeanNameGenerator(beanNameGenerator);
        beanFactory.registerSingleton(AnnotationConfigUtils.CONFIGURATION_BEAN_NAME_GENERATOR, beanNameGenerator);
    }

    //获取容器的作用域元信息解析器
    ScopeMetadataResolver scopeMetadataResolver = getScopeMetadataResolver();
    //为注解 Bean 定义读取器和类路径扫描器设置作用域元信息解析器
    if (scopeMetadataResolver != null) {
        reader.setScopeMetadataResolver(scopeMetadataResolver);
        scanner.setScopeMetadataResolver(scopeMetadataResolver);
    }
    if (!this.annotatedClasses.isEmpty()) {
        if (logger.isInfoEnabled()) {
            logger.info("Registering annotated classes: [" +
                    StringUtils.collectionToCommaDelimitedString(this.annotatedClasses) + "]");
        }
        reader.register(this.annotatedClasses.toArray(new Class<?>[this.annotatedClasses.size()]));
    }
    if (!this.basePackages.isEmpty()) {
        if (logger.isInfoEnabled()) {
            logger.info("Scanning base packages: [" +
                    StringUtils.collectionToCommaDelimitedString(this.basePackages) + "]");
        }
        scanner.scan(this.basePackages.toArray(new String[this.basePackages.size()]));
    }
    //获取容器定义的 Bean 定义资源路径
    String[] configLocations = getConfigLocations();
    //如果定位的 Bean 定义资源路径不为空
    if (configLocations != null) {
        for (String configLocation : configLocations) {
            try {
                //使用当前容器的类加载器加载定位路径的字节码类文件
                Class<?> clazz = ClassUtils.forName(configLocation, getClassLoader());
                if (logger.isInfoEnabled()) {
                    logger.info("Successfully resolved class for [" + configLocation + "]");
                }
                reader.register(clazz);
            }catch (ClassNotFoundException ex){
                if (logger.isDebugEnabled()){
                    logger.debug("Could not load class for config location [" + configLocation +
                            "] - trying package scan. " + ex);
                }
                //如果容器类加载器加载定义路径的 Bean 定义资源失败
                //则启用容器类路径扫描器扫描给定路径包及其子包中的类
                int count = scanner.scan(configLocation);
                if (logger.isInfoEnabled()) {
                    if (count == 0) {
                        logger.info("No annotated classes found for specified class/package [" + configLocation + "]");
                    }
                }else {
                    logger.info("Found " + count + " annotated classes in package [" + configLocation + "]");
                }
            }

        }
    }

}
```
&emsp; 以上就是解析和注入注解配置资源的全过程分析。  










