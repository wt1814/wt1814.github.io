

<!-- TOC -->

- [1. 循环依赖](#1-循环依赖)
    - [1.1. 什么是循环依赖？](#11-什么是循环依赖)
    - [1.2. 如何检测是否存在循环依赖？](#12-如何检测是否存在循环依赖)
    - [1.3. Spring如何解决循环依赖的问题?](#13-spring如何解决循环依赖的问题)
        - [1.3.1. 构造器循环依赖](#131-构造器循环依赖)
        - [1.3.2. setter循环依赖，非单例](#132-setter循环依赖非单例)
        - [1.3.3. setter循环依赖，单例](#133-setter循环依赖单例)

<!-- /TOC -->

<!-- 
https://mp.weixin.qq.com/s/fAb9bp4BIZ6FS6J3vRLq1w
-->


# 1. 循环依赖  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/SSM/Spring/spring-8.png)  
## 1.1. 什么是循环依赖？  
&emsp; 多个bean之间相互依赖，形成了一个闭环。比如：A依赖于B、B依赖于C、C依赖于A。  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/SSM/Spring/spring-5.png)  

&emsp; 代码中表示：  

```java
public class A{
    B b;
}
public class B{
    C c;
}
public class C{
    A a;
}
```

## 1.2. 如何检测是否存在循环依赖？  
&emsp; <font color = "red">检测循环依赖比较简单，使用一个列表来记录正在创建中的bean，bean创建之前，先去记录中看一下自己是否已经在列表中了，如果在，说明存在循环依赖，如果不在，则将其加入到这个列表，bean创建完毕之后，将其再从这个列表中移除。</font>  
&emsp; 源码示例：Spring创建单例bean时，会调用以下方法  

```java
protected void beforeSingletonCreation(String beanName) {
    if (!this.inCreationCheckExclusions.contains(beanName) && !this.singletonsCurrentlyInCreation.add(beanName)) {
        throw new BeanCurrentlyInCreationException(beanName);
    }
}
```
&emsp; singletonsCurrentlyInCreation就是用来记录目前正在创建中的bean名称列表，this.singletonsCurrentlyInCreation.add(beanName)返回false，说明beanName已经在当前列表中了，此时会抛循环依赖的异常BeanCurrentlyInCreationException，这个异常对应的源码：  

```java
public BeanCurrentlyInCreationException(String beanName) {
    super(beanName,
            "Requested bean is currently in creation: Is there an unresolvable circular reference?");
}
```

----
&emsp; 上面是单例bean检测循环依赖的源码，再来看看非单例bean的情况。例如prototype原型，源码位于org.springframework.beans.factory.support.AbstractBeanFactory#doGetBean方法中，主要源码如下：  

```java
//检查正在创建的bean列表中是否存在beanName，如果存在，说明存在循环依赖，抛出循环依赖的异常
if (isPrototypeCurrentlyInCreation(beanName)) {
    throw new BeanCurrentlyInCreationException(beanName);
}

//判断scope是否是prototype
if (mbd.isPrototype()) {
    Object prototypeInstance = null;
    try {
        //将beanName放入正在创建的列表中
        beforePrototypeCreation(beanName);
        prototypeInstance = createBean(beanName, mbd, args);
    }
    finally {
        //将beanName从正在创建的列表中移除
        afterPrototypeCreation(beanName);
    }
}
```  

## 1.3. Spring如何解决循环依赖的问题?  
&emsp; Spring创建bean主要的几个步骤(参考SpringBean生命周期)：  

* 步骤1：实例化bean，即调用构造器创建bean实例  
* 步骤2：填充属性，注入依赖的bean，比如通过set方式、@Autowired注解的方式注入依赖的bean  
* 步骤3：bean的初始化，比如调用init方法等。    

&emsp; 从上面3个步骤中可以看出，<font color = "lime">注入依赖的对象，有2种情况：</font>  
1. **<font color = "red">通过步骤1中构造器的方式注入依赖</font>**  
2. **<font color = "red">通过步骤2填充属性注入依赖</font>**  

### 1.3.1. 构造器循环依赖  
&emsp; Spring实例化bean是通过ApplicationContext.getBean()方法来进行的。如果要获取的对象依赖了另一个对象，那么其首先会创建当前对象，然后通过递归的调用ApplicationContext.getBean()方法来获取所依赖的对象，最后将获取到的对象注入到当前对象中。  
&emsp; <font color = "red">如果构造器循环依赖，形成了闭环，Spring容器无法解决，会抛出BeanCurrentlyInCreationException异常。</font>  

    Caused by: org.springframework.beans.factory.BeanCurrentlyInCreationException:
    Error creating bean with name 'a': Requested bean is currently in creation: Is there an unresolvable circular reference?



### 1.3.2. setter循环依赖，非单例  
&emsp; <font color = "red">只有单例的bean会通过三级缓存提前暴露来解决循环依赖的问题，而非单例的bean，每次从容器中获取都是一个新的对象，都会重新创建，所以非单例的bean是没有缓存的，不会将其放到三级缓存中。这种循环依赖也会抛异常：</font>  

    Caused by: org.springframework.beans.factory.BeanCurrentlyInCreationException:
        Error creating bean with name 'a': Requested bean is currently in creation: Is there an unresolvable circular reference?

### 1.3.3. setter循环依赖，单例  
<!-- 
https://blog.csdn.net/lkforce/article/details/97183065
-->

&emsp; **<font color = "red">单例Bean setter循环依赖，Spring通过3级缓存解决。</font>** ：  

&emsp; 在Spring Bean的生命周期中，创建单例bean时首先会从缓存中获取这个单例的bean。  

```java
protected <T> T doGetBean(final String name, @Nullable final Class<T> requiredType, @Nullable final Object[] args, boolean typeCheckOnly) throws BeansException {
    //...
    Object sharedInstance = getSingleton(beanName);
    //...
}
```

```java
protected Object getSingleton(String beanName, boolean allowEarlyReference) {
    Object singletonObject = this.singletonObjects.get(beanName);
    if (singletonObject == null && isSingletonCurrentlyInCreation(beanName)) {
        synchronized (this.singletonObjects) {
            singletonObject = this.earlySingletonObjects.get(beanName);
            if (singletonObject == null && allowEarlyReference) {
                ObjectFactory<?> singletonFactory = this.singletonFactories.get(beanName);
                if (singletonFactory != null) {
                    singletonObject = singletonFactory.getObject();
                    this.earlySingletonObjects.put(beanName, singletonObject);
                    this.singletonFactories.remove(beanName);
                }
            }
        }
    }
    return (singletonObject != NULL_OBJECT ? singletonObject : null);
}
```
&emsp; 这个方法是Spring解决循环依赖的关键方法，在这个方法中，使用了三级缓存来查询的方式：  

* 第一级缓存singletonObjects里面放置的是实例化好的单例对象。  
* 第二级earlySingletonObjects里面存放的是提前曝光的单例对象（没有完全装配好）。  
* 第三级singletonFactories里面存放的是要被实例化的对象的对象工厂。  

&emsp; 这个方法中用到的几个判断逻辑，体现了Spring解决循环依赖的思路，不过实际上对象被放入这三层的顺序是和方法查询的循序相反的，也就是说，在循环依赖出现时，对象往往会先进入singletonFactories，然后earlySingletonObjects，然后singletonObjects。  

<!-- 
&emsp; 代码解析：    
......
-->
&emsp; 综上，Spring处理循环依赖的流程大概就是以下这样，假设对象A和对象B循环依赖：  

|步骤	|操作|	三层列表中的内容|
|---|---|---|
|1|	开始初始化对象A	|singletonFactories：<br/>earlySingletonObjects：<br/>singletonObjects：|
|2|	调用A的构造，把A放入singletonFactories|	singletonFactories：A<br/>earlySingletonObjects：<br/>singletonObjects：|
|3|	开始注入A的依赖，发现A依赖对象B|singletonFactories：A<br/>earlySingletonObjects：<br/>singletonObjects：|
|4|	开始初始化对象B|singletonFactories：A,B<br/>earlySingletonObjects：<br/>singletonObjects：|
|5|	调用B的构造，把B放入singletonFactories|	singletonFactories：A,B<br/>earlySingletonObjects：<br/>singletonObjects：|
|6|	开始注入B的依赖，发现B依赖对象A	|singletonFactories：A,B<br/>earlySingletonObjects：<br/>singletonObjects：|
|7|开始初始化对象A，发现A在singletonFactories里有，则直接获取A，把A放入earlySingletonObjects，把A从singletonFactories删除|singletonFactories：B<br/>earlySingletonObjects：A<br/>singletonObjects：|
|8|	对象B的依赖注入完成|singletonFactories：B<br/>earlySingletonObjects：A<br/>singletonObjects：|
|9|对象B创建完成，把B放入singletonObjects，把B从earlySingletonObjects和singletonFactories中删除|singletonFactories：<br/>earlySingletonObjects：A<br/>singletonObjects：B|
|10|对象B注入给A，继续注入A的其他依赖，直到A注入完成|singletonFactories：<br/>earlySingletonObjects：A<br/>singletonObjects：B|
|11|对象A创建完成，把A放入singletonObjects，把A从earlySingletonObjects和singletonFactories中删除|singletonFactories：<br/>earlySingletonObjects：<br/>singletonObjects：A,B|
|12|循环依赖处理结束，A和B都初始化和注入完成|singletonFactories：<br/>earlySingletonObjects：<br/>singletonObjects：A,B|



