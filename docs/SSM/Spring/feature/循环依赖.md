---
title: 循环依赖
date: 2020-04-08 00:00:00
tags:
    - Spring
---


<!-- TOC -->

- [1. 循环依赖](#1-循环依赖)
    - [1.1. 什么是循环依赖？](#11-什么是循环依赖)
    - [1.2. 如何检测是否存在循环依赖？](#12-如何检测是否存在循环依赖)
    - [1.3. Spring如何解决循环依赖的问题?](#13-spring如何解决循环依赖的问题)
        - [1.3.1. 构造器循环依赖](#131-构造器循环依赖)
        - [1.3.2. setter循环依赖，非单例](#132-setter循环依赖非单例)
        - [1.3.3. setter循环依赖，单例](#133-setter循环依赖单例)

<!-- /TOC -->

<!-- 
https://mp.weixin.qq.com/s/fAb9bp4BIZ6FS6J3vRLq1w
-->


# 1. 循环依赖  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/SSM/Spring/spring-8.png)  
## 1.1. 什么是循环依赖？  
&emsp; 多个bean之间相互依赖，形成了一个闭环。比如：A依赖于B、B依赖于C、C依赖于A。  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/SSM/Spring/spring-5.png)  

&emsp; 代码中表示：  

```java
public class A{
    B b;
}
public class B{
    C c;
}
public class C{
    A a;
}
```

## 1.2. 如何检测是否存在循环依赖？  
&emsp; <font color = "red">检测循环依赖比较简单，使用一个列表来记录正在创建中的bean，bean创建之前，先去记录中看一下自己是否已经在列表中了，如果在，说明存在循环依赖，如果不在，则将其加入到这个列表，bean创建完毕之后，将其再从这个列表中移除。</font>  
&emsp; 源码示例：Spring创建单例bean时，会调用以下方法  

```java
protected void beforeSingletonCreation(String beanName) {
    if (!this.inCreationCheckExclusions.contains(beanName) && !this.singletonsCurrentlyInCreation.add(beanName)) {
        throw new BeanCurrentlyInCreationException(beanName);
    }
}
```
&emsp; singletonsCurrentlyInCreation就是用来记录目前正在创建中的bean名称列表，this.singletonsCurrentlyInCreation.add(beanName)返回false，说明beanName已经在当前列表中了，此时会抛循环依赖的异常BeanCurrentlyInCreationException，这个异常对应的源码：  

```java
public BeanCurrentlyInCreationException(String beanName) {
    super(beanName,
            "Requested bean is currently in creation: Is there an unresolvable circular reference?");
}
```

----
&emsp; 上面是单例bean检测循环依赖的源码，再来看看非单例bean的情况。例如prototype原型，源码位于org.springframework.beans.factory.support.AbstractBeanFactory#doGetBean方法中，主要源码如下：  

```java
//检查正在创建的bean列表中是否存在beanName，如果存在，说明存在循环依赖，抛出循环依赖的异常
if (isPrototypeCurrentlyInCreation(beanName)) {
    throw new BeanCurrentlyInCreationException(beanName);
}

//判断scope是否是prototype
if (mbd.isPrototype()) {
    Object prototypeInstance = null;
    try {
        //将beanName放入正在创建的列表中
        beforePrototypeCreation(beanName);
        prototypeInstance = createBean(beanName, mbd, args);
    }
    finally {
        //将beanName从正在创建的列表中移除
        afterPrototypeCreation(beanName);
    }
}
```  

## 1.3. Spring如何解决循环依赖的问题?  
&emsp; Spring创建bean主要的几个步骤(参考SpringBean生命周期)：  

* 步骤1：实例化bean，即调用构造器创建bean实例  
* 步骤2：填充属性，注入依赖的bean，比如通过set方式、@Autowired注解的方式注入依赖的bean  
* 步骤3：bean的初始化，比如调用init方法等。    

&emsp; 从上面3个步骤中可以看出，<font color = "red">注入依赖的对象，有2种情况：</font>  
1. 通过步骤1中构造器的方式注入依赖  
2. 通过步骤2注入依赖  

### 1.3.1. 构造器循环依赖  
&emsp; Spring实例化bean是通过ApplicationContext.getBean()方法来进行的。如果要获取的对象依赖了另一个对象，那么其首先会创建当前对象，然后通过递归的调用ApplicationContext.getBean()方法来获取所依赖的对象，最后将获取到的对象注入到当前对象中。  
&emsp; <font color = "red">如果构造器循环依赖，形成了闭环，Spring容器无法解决，会抛出BeanCurrentlyInCreationException异常。</font>  

    Caused by: org.springframework.beans.factory.BeanCurrentlyInCreationException:
    Error creating bean with name 'a': Requested bean is currently in creation: Is there an unresolvable circular reference?



### 1.3.2. setter循环依赖，非单例  
&emsp; <font color = "red">只有单例的bean会通过三级缓存提前暴露来解决循环依赖的问题，而非单例的bean，每次从容器中获取都是一个新的对象，都会重新创建，所以非单例的bean是没有缓存的，不会将其放到三级缓存中。这种循环依赖也会抛异常：</font>  

    Caused by: org.springframework.beans.factory.BeanCurrentlyInCreationException:
        Error creating bean with name 'a': Requested bean is currently in creation: Is there an unresolvable circular reference?

### 1.3.3. setter循环依赖，单例  
&emsp; **<font color = "red">单例Bean setter循环依赖，Spring通过3级缓存解决。</font>**  

* 第一级缓存singletonObjects里面放置的是实例化好的单例对象。  
* 第二级earlySingletonObjects里面存放的是提前曝光的单例对象（没有完全装配好）。  
* 第三级singletonFactories里面存放的是要被实例化的对象的对象工厂。  
