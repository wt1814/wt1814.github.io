

<!-- TOC -->

- [1. 循环依赖-1](#1-循环依赖-1)
    - [1.1. 什么是循环依赖？](#11-什么是循环依赖)
    - [1.2. 如何检测是否存在循环依赖？](#12-如何检测是否存在循环依赖)
    - [1.3. Spring如何解决循环依赖的问题?](#13-spring如何解决循环依赖的问题)

<!-- /TOC -->

<!-- 
https://mp.weixin.qq.com/s/fAb9bp4BIZ6FS6J3vRLq1w
https://mp.weixin.qq.com/s/0EwkxNTFs6oW3Sl0P9sFXg
-->


# 1. 循环依赖-1  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/SSM/Spring/spring-8.png)  
## 1.1. 什么是循环依赖？  
&emsp; 多个bean之间相互依赖，形成了一个闭环。比如：A依赖于B、B依赖于C、C依赖于A。  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/SSM/Spring/spring-5.png)  

&emsp; 代码中表示：  

```java
public class A{
    B b;
}
public class B{
    C c;
}
public class C{
    A a;
}
```

## 1.2. 如何检测是否存在循环依赖？  
&emsp; Spring创建bean主要的几个步骤(参考SpringBean生命周期)：  

* 步骤1：实例化bean，即调用构造器创建bean实例  
* 步骤2：填充属性，注入依赖的bean，比如通过set方式、@Autowired注解的方式注入依赖的bean  
* 步骤3：bean的初始化，比如调用init方法等。    

&emsp; 从上面3个步骤中可以看出，<font color = "lime">注入依赖的对象，有2种情况：</font>  
1. **<font color = "red">通过步骤1中构造器的方式注入依赖</font>**  
2. **<font color = "red">通过步骤2填充属性注入依赖</font>**  


&emsp; <font color = "red">检测循环依赖比较简单，使用一个列表来记录正在创建中的bean，bean创建之前，先去记录中看一下自己是否已经在列表中了，如果在，说明存在循环依赖，如果不在，则将其加入到这个列表，bean创建完毕之后，将其再从这个列表中移除。</font>  
&emsp; 源码示例：Spring创建单例bean时，会调用以下方法  

```java
protected void beforeSingletonCreation(String beanName) {
    if (!this.inCreationCheckExclusions.contains(beanName) && !this.singletonsCurrentlyInCreation.add(beanName)) {
        throw new BeanCurrentlyInCreationException(beanName);
    }
}
```
&emsp; singletonsCurrentlyInCreation就是用来记录目前正在创建中的bean名称列表，this.singletonsCurrentlyInCreation.add(beanName)返回false，说明beanName已经在当前列表中了，此时会抛循环依赖的异常BeanCurrentlyInCreationException，这个异常对应的源码：  

```java
public BeanCurrentlyInCreationException(String beanName) {
    super(beanName,
            "Requested bean is currently in creation: Is there an unresolvable circular reference?");
}
```

----
&emsp; 上面是单例bean检测循环依赖的源码，再来看看非单例bean的情况。例如prototype原型，源码位于org.springframework.beans.factory.support.AbstractBeanFactory#doGetBean方法中，主要源码如下：  

```java
//检查正在创建的bean列表中是否存在beanName，如果存在，说明存在循环依赖，抛出循环依赖的异常
if (isPrototypeCurrentlyInCreation(beanName)) {
    throw new BeanCurrentlyInCreationException(beanName);
}

//判断scope是否是prototype
if (mbd.isPrototype()) {
    Object prototypeInstance = null;
    try {
        //将beanName放入正在创建的列表中
        beforePrototypeCreation(beanName);
        prototypeInstance = createBean(beanName, mbd, args);
    }
    finally {
        //将beanName从正在创建的列表中移除
        afterPrototypeCreation(beanName);
    }
}
```
&emsp; field属性注入的原型Bean发生循环依赖，会抛出异常BeanCurrentlyInCreationException。  
&emsp; 同样，构造器注入的Bean循环依赖，也会抛出异常BeanCurrentlyInCreationException。  
&emsp; 只有含有field属性注入的单例Bean，通过3级缓存解决循环依赖。  


## 1.3. Spring如何解决循环依赖的问题?  
&emsp; Spring解决循环依赖是有前置条件的  
1. 出现循环依赖的Bean必须要是单例  
2. 依赖注入的方式不能全是构造器注入的方式（很多博客上说，只能解决setter方法的循环依赖，这是错误的）  
<!-- 
https://mp.weixin.qq.com/s/0EwkxNTFs6oW3Sl0P9sFXg
-->
<!-- 
https://blog.csdn.net/lkforce/article/details/97183065
https://www.cnblogs.com/leeego-123/p/12165278.html
-->

&emsp; **<font color = "red">field属性注入的单例Bean循环依赖，Spring通过3级缓存解决。</font>** ：  

&emsp; 在Spring Bean的生命周期中，创建单例bean时首先会从缓存中获取这个单例的bean。  

```java
protected <T> T doGetBean(final String name, @Nullable final Class<T> requiredType,
                          @Nullable final Object[] args, boolean typeCheckOnly) throws BeansException {

    final String beanName = transformedBeanName(name);
    Object bean;

    // 方法1）从三个map中获取单例类
    Object sharedInstance = getSingleton(beanName);
    // ......
}
    else {
    // 如果是多例的循环引用，则直接报错
    if (isPrototypeCurrentlyInCreation(beanName)) {
        throw new BeanCurrentlyInCreationException(beanName);
    }
    // ......
    try {
        // Create bean instance.
        if (mbd.isSingleton()) {
            // 方法2) 获取单例对象
            sharedInstance = getSingleton(beanName, () -> {
                try { //方法3) 创建ObjectFactory中getObject方法的返回值
                    return createBean(beanName, mbd, args);
                }
                catch (BeansException ex) {
                    // Explicitly remove instance from singleton cache: It might have been put there
                    // eagerly by the creation process, to allow for circular reference resolution.
                    // Also remove any beans that received a temporary reference to the bean.
                    destroySingleton(beanName);
                    throw ex;
                }
            });
            bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
        }
    }
    // ......
    return (T) bean;
}

```

```java
protected Object getSingleton(String beanName, boolean allowEarlyReference) {
    Object singletonObject = this.singletonObjects.get(beanName);
    if (singletonObject == null && isSingletonCurrentlyInCreation(beanName)) {
        synchronized (this.singletonObjects) {
            singletonObject = this.earlySingletonObjects.get(beanName);
            if (singletonObject == null && allowEarlyReference) {
                ObjectFactory<?> singletonFactory = this.singletonFactories.get(beanName);
                if (singletonFactory != null) {
                    singletonObject = singletonFactory.getObject();
                    this.earlySingletonObjects.put(beanName, singletonObject);
                    this.singletonFactories.remove(beanName);
                }
            }
        }
    }
    return (singletonObject != NULL_OBJECT ? singletonObject : null);
}
```
&emsp; 这个方法是Spring解决循环依赖的关键方法，在这个方法中，使用了三级缓存来查询的方式：  

* 第一级缓存singletonObjects里面放置的是实例化好的单例对象。  
* 第二级earlySingletonObjects里面存放的是提前曝光的单例对象，尚未属性装配的Bean 。  
* 第三级singletonFactories里面存放的是要被实例化的对象的对象工厂。  

&emsp; 这个方法中用到的几个判断逻辑，体现了Spring解决循环依赖的思路，不过实际上对象被放入这三层的顺序是和方法查询的循序相反的，也就是说，在循环依赖出现时，对象往往会先进入singletonFactories，然后earlySingletonObjects，然后singletonObjects。  

<!-- 
&emsp; 代码解析：    
......
-->
&emsp; Spring处理循环依赖的流程（假设对象A和对象B循环依赖）：  

|步骤	|操作|	三级缓存中的内容|
|---|---|---|
|1|	开始初始化对象A	|singletonFactories：<br/>earlySingletonObjects：<br/>singletonObjects：|
|2|	调用A的构造，把A放入singletonFactories|	singletonFactories：A<br/>earlySingletonObjects：<br/>singletonObjects：|
|3|	开始注入A的依赖，发现A依赖对象B|singletonFactories：A<br/>earlySingletonObjects：<br/>singletonObjects：|
|4|	开始初始化对象B|singletonFactories：A,B<br/>earlySingletonObjects：<br/>singletonObjects：|
|5|	调用B的构造，把B放入singletonFactories|	singletonFactories：A,B<br/>earlySingletonObjects：<br/>singletonObjects：|
|6|	开始注入B的依赖，发现B依赖对象A	|singletonFactories：A,B<br/>earlySingletonObjects：<br/>singletonObjects：|
|7|开始初始化对象A，发现A在singletonFactories里有，则直接获取A，把A放入earlySingletonObjects，把A从singletonFactories删除|singletonFactories：B<br/>earlySingletonObjects：A<br/>singletonObjects：|
|8|	对象B的依赖注入完成|singletonFactories：B<br/>earlySingletonObjects：A<br/>singletonObjects：|
|9|对象B创建完成，把B放入singletonObjects，把B从earlySingletonObjects和singletonFactories中删除|singletonFactories：<br/>earlySingletonObjects：A<br/>singletonObjects：B|
|10|对象B注入给A，继续注入A的其他依赖，直到A注入完成|singletonFactories：<br/>earlySingletonObjects：A<br/>singletonObjects：B|
|11|对象A创建完成，把A放入singletonObjects，把A从earlySingletonObjects和singletonFactories中删除|singletonFactories：<br/>earlySingletonObjects：<br/>singletonObjects：A,B|
|12|循环依赖处理结束，A和B都初始化和注入完成|singletonFactories：<br/>earlySingletonObjects：<br/>singletonObjects：A,B|



