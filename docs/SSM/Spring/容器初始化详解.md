

<!-- TOC -->

- [1. 容器初始化详解](#1-容器初始化详解)
    - [1.1. 容器初始化时序图](#11-容器初始化时序图)
    - [1.2. 创建容器](#12-创建容器)
    - [1.3. 载入配置路径](#13-载入配置路径)
    - [1.4. 分配路径处理策略](#14-分配路径处理策略)

<!-- /TOC -->

# 1. 容器初始化详解  
## 1.1. 容器初始化时序图  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/sourceCode/Spring/Spring-1.png)  

## 1.2. 创建容器  
&emsp; obtainFreshBeanFactory()方法调用子类容器的 refreshBeanFactory()方法，启动容器载入 Bean 配置 信息的过程，代码如下：  

```java
protected ConfigurableListableBeanFactory obtainFreshBeanFactory() {
    //这里使用了委派设计模式，父类定义了抽象的refreshBeanFactory()方法，具体实现调用子类容器的refreshBeanFactory()方法
    this.refreshBeanFactory();
    ConfigurableListableBeanFactory beanFactory = this.getBeanFactory();
    if (this.logger.isDebugEnabled()) {
        this.logger.debug("Bean factory for " + this.getDisplayName() + ": " + beanFactory);
    }
    return beanFactory;
}
```
&emsp; AbstractApplicationContext类中只抽象定义了refreshBeanFactory()方法，容器真正调用的是其子类AbstractRefreshableApplicationContext实现的refreshBeanFactory()方法，方法的源码如下：  

```java
protected final void refreshBeanFactory() throws BeansException {
    //如果已经有容器，销毁容器中的 bean，关闭容器
    if (hasBeanFactory()) {
        destroyBeans(); closeBeanFactory();
    }
    try {
        //创建 IOC 容器
        DefaultListableBeanFactory beanFactory = createBeanFactory();
        beanFactory.setSerializationId(getId());
        //对 IOC 容器进行定制化，如设置启动参数，开启注解的自动装配等
        customizeBeanFactory(beanFactory);
        //调用载入 Bean 定义的方法，主要这里又使用了一个委派模式，在当前类中只定义了抽象的 loadBeanDefinitions 方法，具体 的实现调用子类容器
        loadBeanDefinitions(beanFactory);
        synchronized (this.beanFactoryMonitor) {
            this.beanFactory = beanFactory;
        } 
    }catch (IOException ex) { 
        throw new ApplicationContextException("I/O error parsing bean definition source for " + getDisplayName(), ex);
    } 
}
```
&emsp; 在这个方法中，先判断BeanFactory是否存在，如果存在则先销毁beans并关闭 beanFactory，接着创建 DefaultListableBeanFactory，并调用loadBeanDefinitions(beanFactory)装载bean定义。  

## 1.3. 载入配置路径  
&emsp; AbstractRefreshableApplicationContext 中只定义了抽象的 loadBeanDefinitions 方法，容器真正调用的是其子类 AbstractXmlApplicationContext 对该方法的实现，AbstractXmlApplicationContext 的主要源码如下：  
&emsp; loadBeanDefinitions() 方 法 同 样 是 抽 象 方 法 ， 是 由 其 子 类 实 现 的 ， 也 即 在 AbstractXmlApplicationContext 中。  

```java
public abstract class AbstractXmlApplicationContext extends AbstractRefreshableConfigApplicationContext {
    //...
    // 实现父类抽象的载入 Bean 定义方法
    @Override
    protected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException {
        //创建 XmlBeanDefinitionReader，即创建 Bean 读取器，并通过回调设置到容器中去，容器使用该读取器读取 Bean 配置资源
        XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory);
        //为 Bean 读取器设置 Spring 资源加载器，AbstractXmlApplicationContext 的
        //祖先父类 AbstractApplicationContext 继承 DefaultResourceLoader，因此，容器本身也是一个资源加载器
        beanDefinitionReader.setEnvironment(this.getEnvironment());
        beanDefinitionReader.setResourceLoader(this);
        //为 Bean 读取器设置 SAX xml 解析器
        beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this));
        //当 Bean 读取器读取 Bean 定义的 Xml 资源文件时，启用 Xml 的校验机制
        initBeanDefinitionReader(beanDefinitionReader);
        //Bean 读取器真正实现加载的方法

        loadBeanDefinitions(beanDefinitionReader);
    }

    protected void initBeanDefinitionReader(XmlBeanDefinitionReader reader) {
        reader.setValidating(this.validating);
    }

    //Xml Bean 读取器加载 Bean 配置资源
    protected void loadBeanDefinitions(XmlBeanDefinitionReader reader) throws BeansException, IOException {
        //获取 Bean 配置资源的定位
        Resource[] configResources = getConfigResources();
        if (configResources != null) {
            //Xml Bean 读取器调用其父类 AbstractBeanDefinitionReader 读取定位的 Bean 配置资源
            reader.loadBeanDefinitions(configResources);
        }
        // 如果子类中获取的 Bean 配置资源定位为空，则获取 ClassPathXmlApplicationContext
        // 构造方法中 setConfigLocations 方法设置的资源
        String[] configLocations = getConfigLocations();
        if (configLocations != null) {
            //Xml Bean 读取器调用其父类 AbstractBeanDefinitionReader 读取定位的 Bean 配置资源
            reader.loadBeanDefinitions(configLocations);
        }
    }

    //这里又使用了一个委托模式，调用子类的获取 Bean 配置资源定位的方法
    // 该方法在 ClassPathXmlApplicationContext 中进行实现，对于我们
    // 举例分析源码的 ClassPathXmlApplicationContext 没有使用该方法 
    @Nullable
    protected Resource[] getConfigResources() {
        return null;
    }
}
```
&emsp; 以 XmlBean 读取器的其中一种策略 XmlBeanDefinitionReader 为例。XmlBeanDefinitionReader 调 用其父类AbstractBeanDefinitionReader的 reader.loadBeanDefinitions()方法读取Bean配置资源。 由于我们使用 ClassPathXmlApplicationContext 作为例子分析，因此 getConfigResources 的返回值 为 null，因此程序执行 reader.loadBeanDefinitions(configLocations)分支。  

## 1.4. 分配路径处理策略  
&emsp; 在 XmlBeanDefinitionReader 的抽象父类 AbstractBeanDefinitionReader 中定义了载入过程。  
&emsp; AbstractBeanDefinitionReader 的 loadBeanDefinitions()方法源码如下：  

```java
//重载方法，调用下面的 loadBeanDefinitions(String, Set<Resource>);方法
@Override
public int loadBeanDefinitions(String location) throws BeanDefinitionStoreException {
    return loadBeanDefinitions(location, null);
}

public int loadBeanDefinitions(String location, @Nullable Set<Resource> actualResources) throws BeanDefinitionStoreException {
    //获取在 IOC 容器初始化过程中设置的资源加载器
    ResourceLoader resourceLoader = getResourceLoader();
    if (resourceLoader == null) {
        throw new BeanDefinitionStoreException( "Cannot import bean definitions from location [" + location + "]: no ResourceLoader available");
    }
    if (resourceLoader instanceof ResourcePatternResolver) {
        // Resource pattern matching available.
        try {
            //将指定位置的 Bean 配置信息解析为 Spring IOC 容器封装的资源
            // 加载多个指定位置的 Bean 配置信息
            Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location);
            //委派调用其子类 XmlBeanDefinitionReader 的方法，实现加载功能
            int loadCount = loadBeanDefinitions(resources);
            if (actualResources != null) {
                for (Resource resource : resources) {
                    actualResources.add(resource);
                }
            }
            if (logger.isDebugEnabled()) {
                logger.debug("Loaded " + loadCount + " bean definitions from location pattern [" + location + "]");
            }
            return loadCount;
        }catch (IOException ex) {
            throw new BeanDefinitionStoreException( "Could not resolve bean definition resource pattern [" + location + "]", ex);
        }
    }else {
        // Can only load single resources by absolute URL.
        // 将指定位置的 Bean 配置信息解析为 Spring IOC 容器封装的资源
        // 加载单个指定位置的 Bean 配置信息
        Resource resource = resourceLoader.getResource(location);
        //委派调用其子类 XmlBeanDefinitionReader 的方法，实现加载功能
        int loadCount = loadBeanDefinitions(resource);
        if (actualResources != null) {
            actualResources.add(resource);
        }
        if (logger.isDebugEnabled()) {
            logger.debug("Loaded " + loadCount + " bean definitions from location [" + location + "]");
        }return loadCount;
    }
}

//重载方法，调用 loadBeanDefinitions(String);
@Override
public int loadBeanDefinitions(String... locations) throws BeanDefinitionStoreException {
    Assert.notNull(locations, "Location array must not be null");
    int counter = 0;
    for (String location : locations) {
        counter += loadBeanDefinitions(location);
    }
    return counter;
}
```
&emsp; AbstractRefreshableConfigApplicationContext 的 loadBeanDefinitions(Resource...resources) 方 法实际上是调用 AbstractBeanDefinitionReader 的 loadBeanDefinitions()方法。  
&emsp; 从对 AbstractBeanDefinitionReader 的 loadBeanDefinitions()方法源码分析可以看出该方法就做了 两件事：   
&emsp; 首先，调用资源加载器的获取资源方法 resourceLoader.getResource(location)，获取到要加载的资源。 其次，真正执行加载功能是其子类 XmlBeanDefinitionReader 的 loadBeanDefinitions()方法。在 loadBeanDefinitions()方法中调用了 AbstractApplicationContext 的 getResources()方法，跟进去之 后发现 getResources()方法其实定义在 ResourcePatternResolver 中，此时，我们有必要来看一下 ResourcePatternResolver 的全类图：  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/SSM/Spring/spring-12.png)  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/SSM/Spring/spring-13.png)  
&emsp; 从上面可以看到 ResourceLoader 与 ApplicationContext 的继承关系，可以看出其实际调用的是 DefaultResourceLoader 中 的 getSource() 方 法 定 位 Resource ， 因 为ClassPathXmlApplicationContext 本身就是 DefaultResourceLoader 的实现类，所以此时又回到了 ClassPathXmlApplicationContext 中来。  

