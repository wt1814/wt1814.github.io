
<!-- TOC -->

- [1. 六合数字化心理平台](#1-六合数字化心理平台)
    - [1.1. 项目介绍（简历上写的）](#11-项目介绍简历上写的)
    - [1.2. 项目流程](#12-项目流程)
    - [1.3. 项目难点](#13-项目难点)
        - [1.3.1. 数据量大，分库分表和ES](#131-数据量大分库分表和es)
        - [1.3.2. 高并发](#132-高并发)
            - [1.3.2.1. QPS](#1321-qps)
            - [1.3.2.2. 缓存](#1322-缓存)
                - [1.3.2.2.1. CDN](#13221-cdn)
                - [1.3.2.2.2. Redis](#13222-redis)
                - [1.3.2.2.3. 数据库MySql](#13223-数据库mysql)
                - [1.3.2.2.4. 二级缓存](#13224-二级缓存)
                    - [为什么引入二级缓存？](#为什么引入二级缓存)
                    - [数据一致性](#数据一致性)
            - [1.3.2.3. 其他中间件](#1323-其他中间件)
                - [1.3.2.3.1. MQ](#13231-mq)
        - [1.3.3. 网络、内存、磁盘、CPU](#133-网络内存磁盘cpu)
        - [1.3.4. 其他难点](#134-其他难点)
            - [1.3.4.1. 分布式锁使用](#1341-分布式锁使用)
            - [1.3.4.2. 多线程的使用](#1342-多线程的使用)

<!-- /TOC -->


# 1. 六合数字化心理平台  

## 1.1. 项目介绍（简历上写的）

* 2022.04---至今 &emsp; &emsp; 六合熙诚信息科技有限公司 &emsp; &emsp; 六合数字化心理平台    
    * 核心技术：SpringCloud+MySql+MyBatis+ES+kafka+redis  
    * 项目描述：六合数字化心理平台，提供心理咨询和测评，系统支持5W人同时在线测试。  
    * 项目职责：答题系统、咨询系统、大屏系统的开发维护。  
        1. 答题流程及答题结果的处理。答题结果采用库内水平分表处理。    
        2. 用户咨询预约、咨询结果记录。  
        3. 大屏使用ES展示各机构的完成情况。  
    * 项目业绩：  
        1. 协助从0到1搭建起 Maven+Git+Jenkins+Docker敏捷流程，大幅缩短项目落地工期。搭建Sql审核平台Archery
        2. 获取试题接口优化。响应时间从5S优化到200ms左右。采用缓存预热和引入二级缓存处理。  

* 2022.04---至今 &emsp; &emsp; 六合熙诚信息科技有限公司 &emsp; &emsp; 六合数字化心理平台    
    * 核心技术：SpringCloud+MySql+MyBatis+ES+kafka+redis  
    * 项目描述：六合数字化心理平台，提供心理咨询和测评，系统支持5W人同时在线测试。  
    * 项目职责：用户系统、支付系统、工具类的开发维护。  
        1. 手机验证码、短信验证码登录，后台功能权限、数据权限验证。  
        2. 支付系统的搭建，集成阿里App、微信JSAPI方式。  
        3. 建立数据字典表，用于输入框级联展示、集成阿里OSS上传下载。



## 1.2. 项目流程   
1. 获取试题：1拼接量表 ---> 放入缓存 
2. 做题：将结果放到redis和mq  
    1. 将结果放到redis里，最后一题查询  
    2. 使用mq，削锋  


## 1.3. 项目难点  

### 1.3.1. 数据量大，分库分表和ES
1. 分库分表：  
    1. 分库数量  
    &emsp; 一个实例建议最多8个物理分库数  
    &emsp; 单个物理分表的容量不超过500万行  
    &emsp; 单一数据库实例的数据的阈值在 1TB 之内  
    &emsp; 预估1~2年内的数据增长量，得到总数据量  
    2. 主键设计：用户id，项目id，量表id，测评结果表（分8个库，主键id后3位使用用户id），采用hash分片  
        1. 根据主键查，
        2. 根据用户id查询，
        3. 根据量表id查？？？？
        4. 全表查，使用ES查。  

        &emsp; 分表id基因法： userId --> 换算二进制---> 抽取3位  --->  生成分表id前60+刚刚的30  

2. ES使用：  
    1. 采用定时同步到ES。[★★★同步数据到ES](/docs/ES/synES.md)    
        1. 多种同步方案  
            1. 定时任务：可以避免主库的写入延迟，但是可能会存在备库中数据的滞后问题。
            2. 数据订阅：使用cancel等中间件。会增加主库的读取压力，并且可能存在网络延迟等问题。
        2. 数据一致性保证
        &emsp;  1. 根据更新时间，增量更新 2. 隔天全量更新 
    2. ES分页模糊：（深度分页问题大致可以分为两类：随机深度分页：随机跳转页面；滚动深度分页：只能一页一页往下查询）  
        * from/size方案的优点是简单，缺点是在`深度分页的场景下系统开销比较大，占用较多内存。``  
        &emsp; 这种方式请求深度分页是有问题的：  
        &emsp; 我们可以假设在一个有 5 个主分片的索引中搜索。当我们请求结果的第一页（结果从 1 到 10 ），每一个分片产生前 10 的结果，并且返回给 协调节点 ，协调节点对 50 个结果排序得到全部结果的前 10 个。  
        &emsp; 现在假设我们请求第 1000 页—结果从 10001 到 10010 。所有都以相同的方式工作除了每个分片不得不产生前10010个结果以外。然后协调节点对全部 50050 个结果排序最后丢弃掉这些结果中的 50040 个结果。
        &emsp; 对结果排序的成本随分页的深度成指数上升。
        * scroll方案也很高效，但是它`基于快照，不能用在实时性高的业务场景`，建议用在类似报表导出，或者ES内部的reindex等场景。  
        &emsp; 这个分页的用法，不是为了实时查询数据，而是为了一次性查询大量的数据（甚至是全部的数据）。  
        &emsp; 因为这个scroll相当于维护了一份当前索引段的快照信息，这个快照信息是你执行这个scroll查询时的快照。在这个查询后的任何新索引进来的数据，都不会在这个快照中查询到。  
        &emsp; 但是它相对于from和size，不是查询所有数据然后剔除不要的部分，而是记录一个读取的位置，保证下一次快速继续读取。  
        &emsp; 不考虑排序的时候，可以结合SearchType.SCAN使用。  
        * search after基于ES内部排序好的游标，可以实时高效的进行分页查询，但是它`只能做下一页`这样的查询场景，不能随机的指定页数查询。  
    3. 聚合数据结果不精确 [★★★聚合查询](/docs/ES/togetherSearch.md)  

### 1.3.2. 高并发
#### 1.3.2.1. QPS  
1. 支持5W人同时在线测。5题一提交，最后一题提交时，查询所有题是否做完。  
2. 性能：单台4c8G的QPS 4000/5000，5W人总QPS8W，需要15台服务器左右。  

--------

CPU利用率：CPU利用率在过去常常被我们这些外行认为是判断机器是否已经到了满负荷的一个标准。看到70%-80%的使用率就认为机器就已经压到了临界了。  

https://www.cnblogs.com/capacity-yang/p/13064775.html 

　　假设服务并发度为1500，RT为150ms，那么该服务的QPS 为10000 = 1500（并发数） /  0.15 （RT响应时间） ，假如通过压测一台机器的QPS为500，那么该服务需要20台这样的机器。


一直再说高并发，多少QPS才算高并发？  
比如微博每天1亿多pv的系统一般也就1500QPS，5000QPS峰值。

比如有人说：

2C4G机器单机一般1000QPS。
8C8G机器单机可承受7000QPS。  

-------------------------**------------------------
机器配置 
gc设置  



#### 1.3.2.2. 缓存  

##### 1.3.2.2.1. CDN  



##### 1.3.2.2.2. Redis  
&emsp; 单机的redis一般是支持上万甚至几万。  
&emsp; 使用redis集群，通过集群，Redis解决了写操作无法负载均衡，以及存储能力受到单机限制的问题，实现了较为完善的高可用方案。

##### 1.3.2.2.3. 数据库MySql  



##### 1.3.2.2.4. 二级缓存  
###### 为什么引入二级缓存？  
&emsp; 最先搭建的redis哨兵，获取不到连接。先使用二级缓存解决，再把redis改集群方式安装。    

2. 二级缓存J2Cache
&emsp; J2Cache是开源的两级缓存框架（要求至少 Java 8）。第一级缓存使用内存(同时支持 Ehcache 2.x、Ehcache 3.x 和 Caffeine)，第二级缓存使用 Redis(推荐)/Memcached。由于大量的缓存读取会导致 L2 的网络成为整个系统的瓶颈，因此 L1 的目标是降低对 L2 的读取次数。  

1. J2Cache是一个两级缓存框架，第1级为JVM堆内缓存（通常选用caffeine），第2级为堆外缓存（Redis）。   

###### 数据一致性
2. 缓存更新：  
&emsp; active:主动清除，二级缓存过期主动通知各节点清除，优点在于所有节点可以同时收到缓存清除  
&emsp; passive:被动清除，一级缓存过期进行通知各节点清除一二级缓存  

j2cache还提供了缓存过期、广播等机制，能实现数据过期、本地缓存数据同步等功能。  
&emsp; J2Cache 从 1.3.0 版本开始支持 JGroups 和 `【Redis Pub/Sub】` 两种方式进行缓存事件的通知。在某些云平台上可能无法使用 JGroups 组播方式，可以采用 Redis 发布订阅的方式。详情请看 j2cache.properties 配置文件的说明。  


#### 1.3.2.3. 其他中间件  
##### 1.3.2.3.1. MQ  


### 1.3.3. 网络、内存、磁盘、CPU  


### 1.3.4. 其他难点
#### 1.3.4.1. 分布式锁使用  
抢库存  

#### 1.3.4.2. 多线程的使用  
答题结果的计算和大屏使用多线程处理，减少响应时间。  
  
