

<!-- TOC -->

- [1. 排序算法](#1-排序算法)
    - [1.1. 排序算法分类](#11-排序算法分类)
    - [1.2. 排序算法总结](#12-排序算法总结)

<!-- /TOC -->

# 1. 排序算法

<!-- 
~~
10 大经典排序算法
https://mp.weixin.qq.com/s/02fgxkMYZl7jdg9NGAP5YA
-->

## 1.1. 排序算法分类  
&emsp; 排序算法分类：  
* 根据待排序的数据量规模分类：  
    * 内部排序：在排序过程中，待排序的数据能够被全部加载进内存中。常见的内部排序算法有：冒泡排序、快速排序；选择排序、堆排序；插入排序、希尔排序；归并排序；基数排序等。
    * [外部排序](/docs/function/externalSort.md)：待排序的数据太大，不能全部同时放入内存，排序过程中需要内存与外部存储交换数据。  

    &emsp; 内部排序是数据记录在内存中进行排序。而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。  

* <font color = "red">是否采用比较思想</font>：  
    * [比较排序](/docs/function/compare.md)：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序。    
    * [非比较排序](/docs/function/noCompare.md)：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。   

* <font color = "red">基于算法思想分类</font>：
    * 基于交换：冒泡排序、快速排序  
    * 基于选择：选择排序、堆排序  
    * 基于插入：插入排序、希尔排序  
    * 基于分治：快速排序、归并排序  

* 根据排序时间复杂度分类：  
    * O(N)：桶排序、计数排序、基数排序  
    * O(NlogN)：快速排序、希尔排序、归并排序、堆排序  
    * O(N*N)：冒泡排序、插入排序、选择排序  

* 根据排序的稳定性进行分类：  

        稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。
        不稳定：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。
    
    * 稳定性排序：冒泡排序、插入排序、归并排序  
    * 不稳定排序：快速排序、选择排序、希尔排序、堆排序  


## 1.2. 排序算法总结  

|排序算法|	平均时间复杂度|	最好|	最坏|	空间复杂度|	稳定性|
|---|---|---|---|---|---|
|冒泡排序|	|O(n^2)	|O(n)|	|O(n^2)	|O(1)	|稳定|
|快速排序|	O(nlogn)|	O(nlogn)|	O(n^2)	|O(logn)|	不稳定|
|插入排序|	O(n^2)|	O(n)|	O(n^2)	|O(1)	|稳定|
|希尔排序|	O(n^1.3)|	O(n)|	O(nlog2n)	|O(1)	|不稳定|
|选择排序|	O(n^2)|	O(n^2)	|O(n^2)	|O(1)	|不稳定|
|堆排序	|O(nlogn)|	O(nlogn)	|O(nlogn)|	O(1)|	不稳定|
|归并排序|	O(nlogn)|	O(nlogn)|	O(nlogn)	|O(n)	|稳定|
|桶排序	|O(n+k)	|O(n+k)	|O(n+k)	|O(n+k)	|稳定|
|计数排序|	O(n+k)|	O(n+k)|	O(n+k)	|O(k)	|稳定|
|基数排序|	O(n*k)|	O(n*k)|	O(n*k)	|O(n+k)|	稳定|


&emsp; **<font color = "clime">排序算法的优先选择方式：</font>**  
1. 若n较小(如n≤50)，可采用直接插入或直接选择排序。  
&emsp; 当记录规模较小时，直接插入排序较好；否则因为直接选择移动的记录数少于直接插人，应选直接选择排序为宜。  
2. 若文件初始状态基本有序(指正序)，则应选用直接插人、冒泡或随机的快速排序为宜；  
3. 若n较大，则应采用时间复杂度为O(nlgn)的排序方法：快速排序、堆排序或归并排序。  
    * 快速排序是目前基于比较的内部排序中被认为是最好的方法，当待排序的关键字是随机分布时，快速排序的平均时间最短；  
    * 堆排序所需的辅助空间少于快速排序，并且不会出现快速排序可能出现的最坏情况。这两种排序都是不稳定的。  
    * 若要求排序稳定，则可选用归并排序。先利用直接插入排序求得较长的有序子文件，然后再两两归并之。因为直接插入排序是稳定的，所以改进后的归并排序仍是稳定的。  