
<!-- TOC -->

- [1. 动态规划解题](#1-动态规划解题)
    - [1.1. 动态规划解题](#11-动态规划解题)
        - [1.1.1. 能用动态规划解决的问题的特点](#111-能用动态规划解决的问题的特点)
        - [1.1.2. 动态规划术语](#112-动态规划术语)
        - [1.1.3. 动态规划解题步骤](#113-动态规划解题步骤)
        - [1.1.4. 动态规划解题步骤二](#114-动态规划解题步骤二)
    - [1.2. 题目实战](#12-题目实战)
        - [1.2.1. 爬楼梯](#121-爬楼梯)

<!-- /TOC -->

# 1. 动态规划解题  
<!-- 


备忘录方法
https://baike.baidu.com/item/%E5%A4%87%E5%BF%98%E5%BD%95%E6%96%B9%E6%B3%95/6756819?appJump=1&ivk_sa=1022817p

细谈递归，备忘录递归，动态规划，三种算法思想和运行原理
https://blog.csdn.net/qq_39046727/article/details/78966105

备忘录方法与动态规划比较

https://blog.csdn.net/annmi26002/article/details/101975994
动态规划题解（转）
https://www.cnblogs.com/wsw-seu/p/13381312.html


https://blog.csdn.net/zw6161080123/article/details/80639932

这才是真正的状态压缩动态规划好不好！！！ 
https://mp.weixin.qq.com/s/H2V3D0DMPbT8hQW9Cq6LjQ

https://mp.weixin.qq.com/s/MJD9t_y26lAT2ffXT3qGGg
https://mp.weixin.qq.com/s/CXLM0KC3eYYl6u2NsCpW4g

https://mp.weixin.qq.com/s?__biz=MzI5MTU1MzM3MQ==&mid=2247483932&idx=1&sn=d9cd9d5a5ebf5f31e23f11c82b6465f1&scene=21#wechat_redirect

-->

## 1.1. 动态规划解题
<!-- 

-->

### 1.1.1. 能用动态规划解决的问题的特点
&emsp; 能用动规解决的问题的特点  
&emsp; 能采用动态规划求解的问题的一般要具有3个性质：  
&emsp; (1) 最优化原理：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。  
&emsp; (2) 无后效性：即某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关。  
&emsp; (3) 有重叠子问题：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势）  


### 1.1.2. 动态规划术语
&emsp; **<font color = "red">动态规划中包含三个重要的概念：</font>** 最优子结构( f(10) =f(9)+f(8) )、边界( f(1) 与 f(2) )、状态转移公式( f(n) =f(n-1)+f(n-2) )。  

&emsp; 动态规划算法是通过拆分问题，定义问题状态和状态之间的关系，使得问题能够以递推（或者说分治）的方式去解决。它的几个重要概念如下所述。  
1. 阶段：对于一个完整的问题过程，适当的切分为若干个相互联系的子问题，每次在求解一个子问题，则对应一个阶段，整个问题的求解转化为按照阶段次序去求解。  
2. 状态：状态表示每个阶段开始时所处的客观条件，即在求解子问题时的已知条件。状态描述了研究的问题过程中的状况。  
3. 决策：决策表示当求解过程处于某一阶段的某一状态时，可以根据当前条件作出不同的选择，从而确定下一个阶段的状态，这种选择称为决策。  
4. 策略：由所有阶段的决策组成的决策序列称为全过程策略，简称策略。  
5. 最优策略：在所有的策略中，找到代价最小，性能最优的策略，此策略称为最优策略。  
6. 状态转移方程：状态转移方程是确定两个相邻阶段状态的演变过程，描述了状态之间是如何演变的。  



-----

&emsp; 综合了动态规划的特点给出的动态规划的定义： 动态规划是一种多阶段决策最优解模型，一般用来求最值问题，多数情况下它可以采用自下而上的递推方式来得出每个子问题的最优解（即最优子结构），进而自然而然地得出依赖子问题的原问题的最优解。  

1. 多阶段决策，意味着问题可以分解成子问题，子子问题，。。。，也就是说问题可以拆分成多个子问题进行求解
2. 最优子结构，在自下而上的递推过程中，我们求得的每个子问题一定是全局最优解，既然它分解的子问题是全局最优解，那么依赖于它们解的原问题自然也是全局最优解。
3. 自下而上，怎样才能自下而上的求出每个子问题的最优解呢，可以肯定子问题之间是有一定联系的，即迭代递推公式，也叫「状态转移方程」，要定义好这个状态转移方程， 我们就需要定义好每个子问题的状态（DP 状态），那为啥要自下而上地求解呢，因为如果采用像递归这样自顶向下的求解方式，子问题之间可能存在大量的重叠，大量地重叠子问题意味着大量地重复计算，这样时间复杂度很可能呈指数级上升（在下文中我们会看到多个这样重复的计算导致的指数级的时间复杂度），所以自下而上的求解方式可以消除重叠子问题。

&emsp; 简单总结一下，最优子结构，状态转移方程，重叠子问题就是动态规划的三要素，这其中定义子问题的状态与写出状态转移方程是解决动态规划最为关键的步骤，状态转移方程如果定义好了，解决动态规划就基本不是问题了。  


### 1.1.3. 动态规划解题步骤
&emsp; 动态规划所处理的问题是一个多阶段决策问题，一般由初始状态开始，通过对中间阶段决策的选择，达到结束状态。这些决策形成了一个决策序列，同时确定了完成整个过程的一条活动路线(通常是求最优的活动路线)。如图所示。动态规划的设计都有着一定的模式，一般要经历以下几个步骤。  
&emsp; 初始状态→│决策１│→│决策２│→…→│决策ｎ│→结束状态  

&emsp; (1)划分阶段：按照问题的时间或空间特征，把问题分为若干个阶段。在划分阶段时，注意划分后的阶段一定要是有序的或者是可排序的，否则问题就无法求解。  

&emsp; (2)确定状态和状态变量：将问题发展到各个阶段时所处于的各种客观情况用不同的状态表示出来。当然，状态的选择要满足无后效性。  

&emsp; (3)确定决策并写出状态转移方程：因为决策和状态转移有着天然的联系，状态转移就是根据上一阶段的状态和决策来导出本阶段的状态。所以如果确定了决策，状态转移方程也就可写出。但事实上常常是反过来做，根据相邻两个阶段的状态之间的关系来确定决策方法和状态转移方程。  

&emsp; (4)寻找边界条件：给出的状态转移方程是一个递推式，需要一个递推的终止条件或边界条件。  

&emsp; 一般，只要解决问题的阶段、状态和状态转移决策确定了，就可以写出状态转移方程（包括边界条件）。  

&emsp; 实际应用中可以按以下几个简化的步骤进行设计：  

&emsp; （1）分析最优解的性质，并刻画其结构特征。  
&emsp; （2）递归的定义最优解。  
&emsp; （3）以自底向上或自顶向下的记忆化方式（备忘录法）计算出最优值  
&emsp; （4）根据计算最优值时得到的信息，构造问题的最优解  

&emsp; 算法实现的说明  

&emsp; 动态规划的主要难点在于理论上的设计，也就是上面4个步骤的确定，一旦设计完成，实现部分就会非常简单。  

&emsp; 使用动态规划求解问题，最重要的就是确定动态规划三要素：  

&emsp; （1）问题的阶段 （2）每个阶段的状态 （3）从前一个阶段转化到后一个阶段之间的递推关系。  

&emsp; 递推关系必须是从次小的问题开始到较大的问题之间的转化，从这个角度来说，动态规划往往可以用递归程序来实现，不过因为递推可以充分利用前面保存的子问题的解来减少重复计算，所以对于大规模问题来说，有递归不可比拟的优势，这也是动态规划算法的核心之处。  

&emsp; 确定了动态规划的这三要素，整个求解过程就可以用一个最优决策表来描述，最优决策表是一个二维表，其中行表示决策的阶段，列表示问题状态，表格需要填写的数据一般对应此问题的在某个阶段某个状态下的最优值（如最短路径，最长公共子序列，最大价值等），填表的过程就是根据递推关系，从1行1列开始，以行或者列优先的顺序，依次填写表格，最后根据整个表格的数据通过简单的取舍或者运算求得问题的最优解。   

    f(n,m)=max{f(n-1,m), f(n-1,m-w[n])+P(n,m)}  

&emsp; 算法实现的步骤    
&emsp; 1、创建一个一维数组或者二维数组，保存每一个子问题的结果，具体创建一维数组还是二维数组看题目而定，基本上如果题目中给出的是一个一维数组进行操作，就可以只创建一个一维数组，如果题目中给出了两个一维数组进行操作或者两种不同类型的变量值，比如背包问题中的不同物体的体积与总体积，找零钱问题中的不同面值零钱与总钱数，这样就需要创建一个二维数组。  
&emsp; 注：需要创建二维数组的解法，都可以创建一个一维数组运用滚动数组的方式来解决，即一位数组中的值不停的变化，后面会详细徐叙述  
&emsp; 2、设置数组边界值，一维数组就是设置第一个数字，二维数组就是设置第一行跟第一列的值，特别的滚动一维数组是要设置整个数组的值，然后根据后面不同的数据加进来变幻成不同的值。  
&emsp; 3、找出状态转换方程，也就是说找到每个状态跟他上一个状态的关系，根据状态转化方程写出代码。  
&emsp; 4、返回需要的值，一般是数组的最后一个或者二维数组的最右下角。  

&emsp; 代码基本框架：  

```java
for(j=1; j<=m; j=j+1) // 第一个阶段
    xn[j] = 初始值;
 
  for(i=n-1; i>=1; i=i-1)// 其他n-1个阶段
    for(j=1; j>=f(i); j=j+1)//f(i)与i有关的表达式
      xi[j]=j=max（或min）{g(xi-[j1:j2]), ......, g(xi-1[jk:jk+1])};
 
 t = g(x1[j1:j2]); // 由子问题的最优解求解整个问题的最优解的方案
 
 print(x1[j1]);
 
 for(i=2; i<=n-1; i=i+1）
 {  
      t = t-xi-1[ji];
 
      for(j=1; j>=f(i); j=j+1)
         if(t=xi[ji])
              break;}
```

### 1.1.4. 动态规划解题步骤二
<!--

https://mp.weixin.qq.com/s/CXLM0KC3eYYl6u2NsCpW4g
-->

<!--
https://mp.weixin.qq.com/s/CXLM0KC3eYYl6u2NsCpW4g
-->

<!--
https://www.cnblogs.com/fivestudy/p/11855853.html
-->

<!--
https://mp.weixin.qq.com/s/Cw39C9MY9Wr2JlcvBQZMcA
-->

## 1.2. 题目实战  
<!-- 
最长公共子串
https://mp.weixin.qq.com/s/0Mhe1NAZJIewbVy6A0HE4Q

回文子序列
https://mp.weixin.qq.com/s/2SWKifZJ3Gf1s5L2xBDJtg

KMP算法，字符串匹配：
动态规划之 KMP 算法详解(配代码版) 
https://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&mid=2247486490&idx=3&sn=35ba410818207a1bef83d6578f4b332c&chksm=fa0e639bcd79ea8dff1141a8729cf4b1243d23ac276652a58fc23d7b6b2ce01ca2666feab293&mpshare=1&scene=1&srcid=&sharer_sharetime=1569055567478&sharer_shareid=b256218ead787d58e0b58614a973d00d&key=20f7b87cb3d4d9a8e94f75ad1bbd1fe8ed4af91513a424bebd0c4df328ea367a462e742f0885a4dbf9693a65560f764378ab2da5e0d620daa8cd627756a8d79b7b364eb9ccf4a8629e46dad4de38545d&ascene=1&uin=MTE1MTYxNzY2MQ%3D%3D&devicetype=Windows+10&version=62060844&lang=zh_CN&pass_ticket=l152qY7UDy13%2FQ8lMQftZpzwON66UoS8zNnRNqU0gQ1B38kfpkeCoh6I%2F0Cu%2FOwX

字符串匹配的KMP算法 
https://mp.weixin.qq.com/s?__biz=MzIwNTc4NTEwOQ==&mid=2247486950&idx=1&sn=61185c72b270891a0e1aa0db1f9a627f&chksm=972adc9ca05d558a3d5e8a505b29937768e6f47b6c318bc6cc478803d9634e2f4555c26179f9&mpshare=1&scene=1&srcid=&key=00a8e91eefd868fc0218770ad47efc19a0eb1837e26a2fde21a4e6ae367993f51dcfd216c2397954d6a4de33fa5f65dd63b8b620d6e981902b0f9ace3bbbf335784449a15c08450df602e9229d6857de&ascene=1&uin=MTE1MTYxNzY2MQ%3D%3D&devicetype=Windows+10&version=62060833&lang=zh_CN&pass_ticket=eg5OolRG8y0%2Bw9bavl09Uyc6GPxVmhjvDrWe622XQSg9XG10VZWa9GR31nV6T9cV
-->

### 1.2.1. 爬楼梯

