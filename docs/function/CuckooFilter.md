
<!-- TOC -->

- [1. 布谷鸟过滤器](#1-布谷鸟过滤器)
    - [1.1. 布隆过滤器和变体](#11-布隆过滤器和变体)
    - [1.2. 布隆过滤器和布谷鸟过滤器](#12-布隆过滤器和布谷鸟过滤器)
    - [1.3. 布谷鸟哈希](#13-布谷鸟哈希)
    - [1.4. 布谷鸟过滤器算法](#14-布谷鸟过滤器算法)
        - [1.4.1. 插入](#141-插入)
        - [1.4.2. 查找](#142-查找)
        - [1.4.3. 删除](#143-删除)
    - [1.5. 布谷鸟过滤器不足以及性能、参数分析](#15-布谷鸟过滤器不足以及性能参数分析)
        - [1.5.1. 缺点](#151-缺点)

<!-- /TOC -->

# 1. 布谷鸟过滤器  
<!--

*** https://www.cnblogs.com/Courage129/p/14337466.html
*** http://www.linvon.cn/posts/cuckoo/
布谷鸟过滤器
https://www.cnblogs.com/zhaodongge/p/15067657.html
https://blog.csdn.net/qq_17305249/article/details/94996252

https://www.cnblogs.com/wlxj/p/15492608.html

https://juejin.cn/post/6844903861749055502
谈谈布隆过滤器和布谷鸟过滤器的相同点和不同点？
https://cloud.tencent.com/developer/article/1745350

https://blog.csdn.net/feiying0canglang/article/details/121279365
http://www.linvon.cn/posts/cuckoo/
https://www.cnblogs.com/Courage129/p/14337466.html
https://github.com/kristoff-it/redis-cuckoofilter

Redis--布谷鸟过滤器
https://blog.csdn.net/feiying0canglang/article/details/121279365

-->


## 1.1. 布隆过滤器和变体
&emsp; 我们比较了标准的布隆过滤器和支持删除或拥有更好查找性能的部分变体，如表1中所总结的。这些数据结构在章节7中进行了实验性评估。布谷鸟过滤器比这些数据结构拥有更高的空间效率和性能。  
&emsp; 标准布隆过滤器[3]是一个项集合的紧凑表示，其支持两个操作：插入和查找。一个布隆过滤器允许一个可调节的假阳性率ϵ，因此查询会返回“绝对不存在”（没有错误)或“可能存在”(有错误的概率）两种结果。ϵ越低，过滤器所需的空间越大。  
&emsp; 一个布隆过滤器由k个哈希函数和一个位数组组成，所有位最初设置为“0”。若要插入某个项，它将此项用k个哈希函数哈希到位数组中的k个位置，然后将所有k位设置为“1”。查找处理类似，读取数组中的k个对应位：如果所有位都被设置了，查询返回true；否则返回false。  

&emsp; 布隆过滤器不支持删除。  
&emsp; 布隆过滤器可以非常节省空间，但并不是最优的[20]。 对于假阳性率ϵ，空间优化的布隆过滤器需使用 k = log2 (1/ϵ) 个哈希函数。这样的布隆过滤器可以使用1.44 log2 (1/ϵ) 个bit存储每个项，它只取决于ϵ，而不是项大小或项总数。按照信息论最小值需要每项log2 (1/ϵ)位，因此空间优化的布隆过滤器会使用高于信息论下限44%的空间开销。  

&emsp; 通过使用长度为1/ϵ位指纹和一个完美的哈希表[6]基本上可以实现信息论中的优化。为了有效地处理删除，我们用设计良好的布谷鸟哈希表来替换一个完美的哈希函数。  

&emsp; 计数布隆过滤器[12]扩展了布隆过滤器来实现删除。计数布隆过滤器使用计数器数组代替位数组。插入增加k个计数器的值，而不是简单地设置k位，查找时检查每个所需计数器是否为非零。删除操作则减少这些k个计数器的值。为了防止算术溢出（即增加具有最大可能值的计数器），数组中的每个计数器必须足够大，才能保留布隆过滤器的特性。在实践中计数器由四个或更多位组成，因此计数布隆过滤器比标准布隆过滤器需要4倍多空间。(可以通过引入二次哈希表结构来管理溢出计数器来构造计数布隆过滤器，以减少使用空间，但代价是额外的复杂性。)  

&emsp; 块布隆过滤器[22]不支持删除，但在查找时提供更好的位置定位。块布隆过滤器由一个小布隆过滤器的阵列组成，每个过滤器放置在一个CPU缓存行中。每个项只存储在这些由哈希区分的小布隆过滤器中的一个。因此每个查询加载布隆过滤器最多只会导致一次缓存缺失，这大大提高了性能。一个缺点是由于小布隆过滤器阵列的负载不平衡，假阳性率会变得更高。  

&emsp; d-left计数布隆过滤器[5]与我们在这里使用的方法相似。使用d-left哈希[19]的哈希表储存项的指纹。过滤器通过删除它们的指纹来删除项。与计数布隆过滤器相比，它降低了50%的空间成本，与空间优化的不可删除的布隆过滤器相比，通常需要1.5-2倍的空间。如我们所表明的，布谷鸟过滤器比d-left计数布隆过滤器拥有更好的空间效率，并且具有其他优点，包括简单性。  

&emsp; 商过滤器[2]也是存储指纹以支持删除的紧凑哈希表。商过滤器使用类似于线性探测的技术来定位指纹，从而提供更好的位置定位。然而它们需要额外的元数据来编码每个条目，这需要比同等的标准布隆过滤器多10∼25%的空间。此外它的所有操作都必须在获取目标项之前解码一个表中条目的序列，哈希表填充得越多这些序列就越长。 因此当哈希表的占用率超过75%时，其性能显著下降。  

&emsp; 其他变体：无论是在空间上还是在性能上，都有很多其他变体被提出来改进布隆过滤器。排名索引哈希[14]通过构建线性链式哈希表来存储压缩指纹。虽然与d-left计数布隆过滤器相似，而且空间效率更高，但更新内部索引以降低链的成本消耗是非常耗时的，因此在动态处理中不那么吸引人。Putze等人提出了布隆过滤器的两种变体[22]。一个是前面讨论过的块布隆过滤器；另一个称为Golomb压缩序列的过滤器将所有项的指纹存储在一个排序列表中。它的空间是接近最优值的，但数据结构是静态的，需要非恒定的查找时间来解码被编码的序列。因此本文没有拿它与其他过滤器比较。Pagh等人基于Cleary[8]提出了一种渐近空间最优数据结构[20]。 然而这种数据结构比其替代方案要复杂得多，似乎不适合高性能的实现。而相反布谷鸟过滤器更易于实现。  

## 1.2. 布隆过滤器和布谷鸟过滤器  
&emsp; 为了解决布隆过滤器不能删除元素的问题，布谷鸟过滤器横空出世。论文《Cuckoo Filter：Better Than Bloom》作者将布谷鸟过滤器和布隆过滤器进行了深入的对比。相比布谷鸟过滤器而言布隆过滤器有以下不足：查询性能弱、空间利用效率低、不支持反向操作（删除）以及不支持计数。  

* 查询性能弱是因为布隆过滤器需要使用多个 hash 函数探测位图中多个不同的位点，这些位点在内存上跨度很大，会导致 CPU 缓存行命中率低。
* 空间效率低是因为在相同的误判率下，布谷鸟过滤器的空间利用率要明显高于布隆，空间上大概能节省 40% 多。不过布隆过滤器并没有要求位图的长度必须是 2 的指数，而布谷鸟过滤器必须有这个要求。从这一点出发，似乎布隆过滤器的空间伸缩性更强一些。
* 不支持反向删除操作这个问题着实是击中了布隆过滤器的软肋。在一个动态的系统里面元素总是不断的来也是不断的走。布隆过滤器就好比是印迹，来过来就会有痕迹，就算走了也无法清理干净。比如你的系统里本来只留下 1kw 个元素，但是整体上来过了上亿的流水元素，布隆过滤器很无奈，它会将这些流失的元素的印迹也会永远存放在那里。随着时间的流失，这个过滤器会越来越拥挤，直到有一天你发现它的误判率太高了，不得不进行重建。  

&emsp; 布谷鸟过滤器在论文里声称自己解决了这个问题，它可以有效支持反向删除操作。而且将它作为一个重要的卖点，诱惑你们放弃布隆过滤器改用布谷鸟过滤器。  


## 1.3. 布谷鸟哈希  
&emsp; 布谷鸟过滤器源于布谷鸟哈希算法，布谷鸟哈希算法源于生活 —— 那个热爱「鸠占鹊巢」的布谷鸟。布谷鸟喜欢滥交（自由），从来不自己筑巢。它将自己的蛋产在别人的巢里，让别人来帮忙孵化。待小布谷鸟破壳而出之后，因为布谷鸟的体型相对较大，它又将养母的其它孩子（还是蛋）从巢里挤走 —— 从高空摔下夭折了。  
&emsp; 最简单的布谷鸟哈希结构是一维数组结构，会有两个 hash 算法将新来的元素映射到数组的两个位置。如果两个位置中有一个位置为空，那么就可以将元素直接放进去。但是如果这两个位置都满了，它就不得不「鸠占鹊巢」，随机踢走一个，然后自己霸占了这个位置。  

    p1 = hash1(x) % l
    p2 = hash2(x) % l

&emsp; 不同于布谷鸟的是，布谷鸟哈希算法会帮这些受害者（被挤走的蛋）寻找其它的窝。因为每一个元素都可以放在两个位置，只要任意一个有空位置，就可以塞进去。所以这个伤心的被挤走的蛋会看看自己的另一个位置有没有空，如果空了，自己挪过去也就皆大欢喜了。但是如果这个位置也被别人占了呢？好，那么它会再来一次「鸠占鹊巢」，将受害者的角色转嫁给别人。然后这个新的受害者还会重复这个过程直到所有的蛋都找到了自己的巢为止。  

    正如鲁迅的那句名言「占自己的巢，让别人滚蛋去吧！」  

&emsp; 但是会遇到一个问题，那就是如果数组太拥挤了，连续踢来踢去几百次还没有停下来，这时候会严重影响插入效率。这时候布谷鸟哈希会设置一个阈值，当连续占巢行为超出了某个阈值，就认为这个数组已经几乎满了。这时候就需要对它进行扩容，重新放置所有元素。  
&emsp; 还会有另一个问题，那就是可能会存在挤兑循环。比如两个不同的元素，hash 之后的两个位置正好相同，这时候它们一人一个位置没有问题。但是这时候来了第三个元素，它 hash 之后的位置也和它们一样，很明显，这时候会出现挤兑的循环。不过让三个不同的元素经过两次 hash 后位置还一样，这样的概率并不是很高，除非你的 hash 算法太挫了。  
&emsp; 布谷鸟哈希算法对待这种挤兑循环的态度就是认为数组太拥挤了，需要扩容（实际上并不是这样）。  

## 1.4. 布谷鸟过滤器算法  
![image](http://182.92.69.8:8081/img/structure/structure-1.png)  

&emsp; 上图（a）(b)展示了一个基本的布谷鸟哈希表的插入操作，是由一个桶数组组成，每个插入项都有由散列函数h1(x)和h2(x)确定的两个候选桶，具体操作上文中已经描述，此处不再赘述。  

&emsp; 而基本的布谷鸟过滤器也是由两个或者多个哈希函数构成，布谷鸟过滤器的布谷鸟哈希表的基本单位称为条目（entry）。 每个条目存储一个指纹（fingerprint），指纹指的是使用一个哈希函数生成的n位比特位，n的具体大小由所能接受的误判率来设置，论文中的例子使用的是8bits的指纹大小。  

&emsp; 哈希表由一个桶数组组成，其中一个桶可以有多个条目（比如上述图c中有四个条目）。而每个桶中有四个指纹位置，意味着一次哈希计算后布谷鸟有四个“巢“可用，而且四个巢是连续位置，可以更好的利用cpu高速缓存。也就是说每个桶的大小是4*8bits。  

### 1.4.1. 插入
&emsp; 布谷鸟过滤器的插入是重点，与朴素的布谷鸟哈希不同，布谷鸟过滤器采取了两个并不独立的哈希函数，具体的  

    𝑖1=ℎ𝑎𝑠ℎ(𝑥)i1=hash(x)
    𝑖2=𝑖1⊕ℎ𝑎𝑠ℎ(𝑓)i2=i1⊕hash(f)

&emsp; 𝑖1𝑖2i1i2即计算出来两个桶的索引，其中第一个桶的索引是通过某个哈希函数计算出来，第二个是使用第一个索引和指纹的哈希做了一个异或操作，进行异或操作的好处是，因为异或操作的特性：同为0不同为1，且0和任何数异或是这个数的本身。那么𝑖1i1也可以通过𝑖2i2和指纹异或来计算。 换句话说，在桶中迁走一个键，我们直接用当前桶的索引𝑖i和存储在桶中的指纹计算它的备用桶。  

&emsp; 具体的指纹是通过哈希函数取一定量的比特位  

    𝑓=𝑓𝑖𝑛𝑔𝑒𝑟𝑝𝑟𝑖𝑛𝑡(𝑥)f=fingerprint(x)

&emsp; 为什么不直接用索引1和指纹做异或操作，关于这个问题文中给了解释，因为指纹一般只是key映射出来的少量bit位置，那么假如不进行哈希操作，当指纹的比特位与整个桶数组相比很小时，那么备用位置使用“i⊕指纹”，将被放置到离桶𝑖1i1很近的位置，比如使用八位的指纹大小，最多只能改变𝑖1i1的低八位，所以也就是两个候选通的位置最多相差256，不利于均匀分配。  

### 1.4.2. 查找
&emsp; 布谷鸟过滤器的查找过程很简单，给定一个项x，算法首先根据上述插入公式，计算x的指纹和两个候选桶。然后读取这两个桶：如果两个桶中的任何现有指纹匹配，则布谷鸟过滤器返回true，否则过滤器返回false。此时，只要不发生桶溢出，就可以确保没有假阴性。  

### 1.4.3. 删除
&emsp; 标准布隆过滤器不能删除，因此删除单个项需要重建整个过滤器，而计数布隆过滤器需要更多的空间。布谷鸟过滤器就像计数布隆过滤器，可以通过从哈希表删除相应的指纹删除插入的项，其他具有类似删除过程的过滤器比布谷鸟过滤器更复杂。  

&emsp; 具体删除的过程也很简单，检查给定项的两个候选桶；如果任何桶中的指纹匹配，则从该桶中删除匹配指纹的一份副本。  

-------------

标准布隆过滤器不能删除，因此删除单个项需要重建整个过滤器，而计数布隆过滤器需要更多的空间。布谷鸟过滤器就像计数布隆过滤器，可以通过从哈希表删除相应的指纹删除插入的项。其他具有类似删除过程的过滤器比布谷鸟过滤器更复杂。例如，d-left计数布隆过滤器必须使用额外的计数器，以防止指纹碰撞1的“假删除”问题，商过滤器必须移动指纹序列去填补删除之后的“空”条目并维持其“桶结构”2。  

## 1.5. 布谷鸟过滤器不足以及性能、参数分析
### 1.5.1. 缺点

&emsp; 删除不完美，存在误删的概率。删除的时候只是删除了一份指纹副本，并不能确定此指纹副本是要删除的key的指纹。同时这个问题也导致了假阳性的情况。
插入复杂度比较高。随着插入元素的增多，复杂度会越来越高，因为存在桶满，踢出的操作，所以需要重新计算，但综合来讲复杂度还是常数级别。
&emsp; 存储空间的大小必须为2的指数的限制让空间效率打了折扣。  
&emsp; 同一个元素最多插入kb次，（k指哈希函数的个数，b指的桶中能装指纹的个数也可以说是桶的尺寸大小）如果布谷鸟过滤器支持删除，则必须存储同一项的多个副本。 插入同一项kb+1次将导致插入失败。 这类似于计数布隆过滤器，其中重复插入会导致计数器溢出。  
