
<!-- TOC -->

- [1. 红黑树](#1-红黑树)
    - [1.1. 红黑树介绍](#11-红黑树介绍)
    - [1.2. 红黑树操作](#12-红黑树操作)
        - [1.2.1. 变色](#121-变色)
        - [1.2.2. 左旋](#122-左旋)
        - [1.2.3. 右旋](#123-右旋)
    - [1.3. 红黑树的应用](#13-红黑树的应用)

<!-- /TOC -->

&emsp; **<font color = "red">总结：</font>**  
1. 红黑树，近似平衡的二叉查找树。从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点，红黑树这种平衡为黑色完美平衡。  


# 1. 红黑树  
<!-- 
***30张图带你彻底理解红黑树
https://www.jianshu.com/p/e136ec79235c
** https://www.jianshu.com/p/778ca9a176b5
https://blog.csdn.net/qq_38685503/article/details/103425572
-->

## 1.1. 红黑树介绍
&emsp; <font color = "red">红黑树本质上是一棵二叉查找树，近似平衡。在每个节点增加一个存储位表示节点的颜色，可以是红或黑(非红即黑)。其主要的优点就是“平衡”，</font>即左右子树高度几乎一致，以此来防止树退化为链表，通过这种方式来保障查找的时间复杂度为 log(n)。  


&emsp; **<font color = "red">红黑树主要有以下几个特性：</font>**   
1. 节点是红色或黑色。   
2. 根节点是黑色。  
3. <font color = "red">所有叶子都是黑色。(叶子是NUIL节点)</font>  
4. 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)  
5. **<font color = "clime">从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。</font>**  

&emsp; **<font color = "blue">黑根黑叶红不邻，同祖等高只数黑</font>**    

&emsp; **是性质4导致路径上不能有两个连续的红色节点确保了这个结果。**最短的可能路径都是黑色节点，最长的可能路径有交替的红色和黑色节点。 **因为根据性质5所有最长的路径都有相同数目的黑色节点，这就表明了没有路径能多于任何其他路径的两倍长。** 结果是这个树大致上是平衡的。  
&emsp; 因为操作比如插入、删除和查找某个值的最坏情况时间都要求与树的高度成比例，这个在高度上的理论上限允许红黑树在最坏情况下都是高效的，而不同于普通的二叉查找树。     

![image](https://gitee.com/wt1814/pic-host/raw/master/algorithm/function-6.png)  
&emsp; 红黑树并不是一个完美平衡二叉查找树，从上图可以看到，根结点P的左子树显然比右子树高，但左子树和右子树的黑结点的层数是相等的，也即任意一个结点到到每个叶子结点的路径都包含数量相同的黑结点(性质5)。所以叫 **<font color = "clime">红黑树这种平衡为黑色完美平衡。</font>**  


&emsp; **红黑树与平衡二叉树的区别：**
1. 红黑树放弃了追求完全平衡，<font color = "red">追求大致平衡</font>，在与平衡二叉树的时间复杂度相差不大的情况下，<font color = "clime">保证每次插入最多只需要三次旋转就能达到平衡</font>，实现起来也更为简单。  
2. 平衡二叉树追求绝对平衡，条件比较苛刻，实现起来比较麻烦，每次插入新节点之后需要旋转的次数不能预知。  
3. 红黑树和AVL树的区别在于它使用颜色来标识结点的高度，它所追求的是局部平衡而不是AVL树中的非常严格的平衡。  
4. 红黑树是牺牲了严格的高度平衡的优越条件为代价，红黑树能够以O(log2 n)的时间复杂度进行搜索、插入、删除操作。  
5. 红黑树的算法时间复杂度和AVL相同，但统计性能比AVL树更高。  

## 1.2. 红黑树操作  
<!-- 
在一棵AVL树中，我们通过左旋和右旋来调整由于插入和删除所造成的不平衡问题。在红黑树中，可以使用两种方式进行平衡操作：

    重新着色
    旋转

当红黑树中出现不平衡的状态，我们首先会考虑重新着色，如果重新着色依旧不能使红黑树平衡，那么就考虑旋转。

调整可以分为两类：一类是颜色调整，即改变某个节点的颜色，这种比较简单，直接将节点颜色进行转换即可；另一类是结构调整，改变检索树的结构关系。结构调整主要包含两个基本操作：左旋（Rotate Left），右旋（RotateRight）。  

红黑树操作
https://mp.weixin.qq.com/s/7qlH3OSyAs4HbDRrYmd9Qw
https://mp.weixin.qq.com/s/2_G9dKF033_suehS0Fer1w


什么是红黑树？
https://mp.weixin.qq.com/s/tnbbvgPyqz0pEpA76rn_1g
什么是红黑树？
https://mp.weixin.qq.com/s/oAyiRC_O-N5CHqAjt2va9w

-->
&emsp; 在树的结构发生改变时(插入或者删除操作)，往往会破坏上述条件4或条件5，需要通过调整使得查找树重新满足红黑树的条件。  
&emsp; 已知插入根节点涂为黑色， **<font color = "clime">其他节点都是涂红色；如果插入结点的父节点为黑色，就不需要进行旋转变色调整，</font>** 其他情况都需要根据实际选择合适的处理策略进行调整，使其符合红黑树性质。最开始调整的时候是将插入结点作为当前节点。 

### 1.2.1. 变色  
&emsp; 如果当前节点的父亲节点和叔叔节点均是红色，那么执行以下变色操作：父 --> 黑 、 叔 --> 黑 、 爷 --> 红。    

&emsp; 开始分析爷爷是否满足红黑树特性  
![image](https://gitee.com/wt1814/pic-host/raw/master/algorithm/function-45.png)  

### 1.2.2. 左旋  
&emsp; 条件：父亲是红色 、 叔叔是黑色 、 当前是右子树。  
&emsp; 执行：以父亲进行旋转  
![image](https://gitee.com/wt1814/pic-host/raw/master/algorithm/function-46.png)  

### 1.2.3. 右旋  
&emsp; 条件：父亲是红色、叔叔是黑色、当前是左子树。  
&emsp; 执行：

* 父亲节点 变为 黑色
* 爷爷节点变为红色
* 再已爷爷节点进行旋转

![image](https://gitee.com/wt1814/pic-host/raw/master/algorithm/function-47.png)  


## 1.3. 红黑树的应用  
&emsp; 红黑树的应用比较广泛，主要是用它来存储有序的数据，它的时间复杂度是O(lgn)，效率非常之高。  
&emsp; 例如，Java集合中的TreeSet和TreeMap，C++ STL中的set、map，以及Linux虚拟内存的管理，都是通过红黑树去实现的。  

