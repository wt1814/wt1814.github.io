<!-- TOC -->

- [1. 秒杀系统设计](#1-秒杀系统设计)
    - [1.1. 什么是秒杀？](#11-什么是秒杀)
    - [1.2. 秒杀应该考虑哪些问题？](#12-秒杀应该考虑哪些问题)
    - [1.3. 科普：常见的互联网分层架构](#13-科普常见的互联网分层架构)
    - [1.4. 秒杀架构思考](#14-秒杀架构思考)
        - [1.4.1. 高性能](#141-高性能)
            - [1.4.1.1. 动静分离](#1411-动静分离)
                - [1.4.1.1.1. 数据拆分](#14111-数据拆分)
                - [1.4.1.1.2. 静态缓存](#14112-静态缓存)
                    - [1.4.1.1.2.1. 怎么缓存](#141121-怎么缓存)
                    - [1.4.1.1.2.2. 哪里缓存](#141122-哪里缓存)
                - [1.4.1.1.3. 数据整合](#14113-数据整合)
                - [1.4.1.1.4. 小结](#14114-小结)
            - [1.4.1.2. 热点优化](#1412-热点优化)
                - [1.4.1.2.1. 热点操作](#14121-热点操作)
                - [1.4.1.2.2. 热点数据](#14122-热点数据)
                    - [1.4.1.2.2.1. 热点隔离](#141221-热点隔离)
                    - [1.4.1.2.2.2. 热点优化](#141222-热点优化)
            - [1.4.1.3. 系统优化](#1413-系统优化)
        - [1.4.2. 一致性](#142-一致性)
            - [1.4.2.1. 减库存的方式](#1421-减库存的方式)
            - [1.4.2.2. 减库存的问题](#1422-减库存的问题)
                - [1.4.2.2.1. 下单减库存](#14221-下单减库存)
                - [1.4.2.2.2. 付款减库存](#14222-付款减库存)
                - [1.4.2.2.3. 预扣库存](#14223-预扣库存)
                - [1.4.2.2.4. 小结](#14224-小结)
            - [1.4.2.3. ★★★实际如何减库存](#1423-★★★实际如何减库存)
            - [1.4.2.4. 一致性性能的优化](#1424-一致性性能的优化)
                - [1.4.2.4.1. 高并发读](#14241-高并发读)
                - [1.4.2.4.2. 高并发写](#14242-高并发写)
                    - [1.4.2.4.2.1. 更换DB选型](#142421-更换db选型)
                    - [1.4.2.4.2.2. 优化DB性能](#142422-优化db性能)
                - [1.4.2.4.3. 小结](#14243-小结)
            - [1.4.2.5. 总结一下](#1425-总结一下)
        - [1.4.3. 高可用](#143-高可用)
            - [1.4.3.1. 流量削峰](#1431-流量削峰)
                - [1.4.3.1.1. 答题](#14311-答题)
                - [1.4.3.1.2. 排队](#14312-排队)
                - [1.4.3.1.3. 过滤](#14313-过滤)
                - [1.4.3.1.4. 小结](#14314-小结)
            - [1.4.3.2. 高可用建设](#1432-高可用建设)
    - [1.5. 秒杀业务完整流程梳理](#15-秒杀业务完整流程梳理)

<!-- /TOC -->

&emsp; **<font color = "red">总结：</font>**  
1. 什么是秒杀系统？定时开始、库存有限...  
2. 秒杀应该考虑哪些问题？  
&emsp; 链接暴露、恶意请求（接口防刷）、突然增加的网络及服务器带宽、超卖问题、数据库设计...  
3. 秒杀系统设计思考：  
&emsp; 从架构视角来看，<font color = "red">秒杀系统本质是一个高性能、高一致、高可用的三高系统。</font>  
	* 高性能。动静分离、热点优化以及服务端性能优化。  
        * **<font color = "clime">热点数据的处理三步走，一是热点识别，二是热点隔离，三是热点优化。</font>**   
            1. 热点隔离：1. 业务隔离；2. 部署隔离；3. 数据隔离。  
            2. 热点优化：缓存和限流。  
	* 高一致。从业界通用的几种减库存方案切入。减库存一般有以下几个方式：下单减库存、付款减库存、<font color = "clime">预扣库存（买家下单后，库存为其保留一定的时间（如15 分钟），超过这段时间，库存自动释放，释放后其他买家可以购买）。业界最为常见的是预扣库存。</font>    
	* 高可用。流量削峰(答题、mq)、高可用建设。  
4. 秒杀业务完整流程梳理。  
    * 后端service服务层。  
        1. 使用缓存(Redis、Memchched)；  
        2. 使用队列处理：将请求放入队列排队处理，以可控的速度来访问底层DB；  
        3. 异步处理：如将秒杀成功的订单通知信息通过消息队列(RabbitMQ、Kafka)来异步处理。  

# 1. 秒杀系统设计  

<!-- 
万字好文，电商秒杀系统架构分析与实战！ 
https://mp.weixin.qq.com/s/Nbm1vQvPXVY_-VFesC5yvw
如何设计一个秒杀系统呢
https://mp.weixin.qq.com/s/-m-BSW6ggngdK9lRpKNTcA
-->

## 1.1. 什么是秒杀？ 
&emsp; 秒杀场景一般会在电商网站举行一些活动时遇到。  
&emsp; 对于电商网站中一些<font color = "red">稀缺或者特价商品</font>，电商网站一般会在约定时间点对其进行限量销售，因为这些商品的特殊性，会吸引大量用户前来抢购，并且会在约定的时间点同时在秒杀页面进行抢购。  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/web/web-3.png)  

&emsp; **<font color = "red">秒杀活动可以分为3个阶段：</font>**  

* 秒杀前：用户不断刷新商品详情页，页面请求达到瞬时峰值。  
* 秒杀开始：用户点击秒杀按钮，下单请求达到瞬时峰值。  
* 秒杀后：一部分成功下单的用户不断刷新订单或者产生退单操作，大部分用户继续刷新商品详情页等待退单机会。  

&emsp; **<font color = "red">秒杀系统特点：</font>**  

* 定时开始，秒杀时大量用户会在同一时间，抢购同一商品，网站瞬时流量激增。  
* 库存有限，秒杀下单数量远远大于库存数量，只有少部分用户能够秒杀成功。  
* 秒杀业务流程比较简单，一般就是下订单减库存。  

<!-- 
* 定时开始，秒杀时大量用户会在同一时间，抢购同一商品，网站瞬时流量激增。  
* 库存有限，秒杀下单数量远远大于库存数量，只有少部分用户能够秒杀成功。  
* 操作可靠，秒杀业务流程比较简单，一般就是下订单减库存。库存就是用户争夺的“资源”，实际被消费的“资源”不能超过计划要售出的“资源”，也就是不能被“超卖”。  

* 秒杀一般是访问请求数量远远大于库存数量，只有少部分用户能够秒杀成功  
* 秒杀时大量用户会在同一时间同时进行抢购，网站瞬时访问流量激增  
* 秒杀业务流程比较简单，一般就是下订单减库存  
-->

## 1.2. 秒杀应该考虑哪些问题？  

<!-- 
如何避免超卖？如果在redis中扣减库存，可以利用decr命令扣减库存，decr是原子操作，在分布式环境下也不会有并发问题，decr扣减库存后，判断返回值，如果返回值小于0，扣减库存失败，秒杀也就失败了；如果在数据库中扣减库存可以在where后面加上库存大于0的条件，来避免库存被减成负值。这样就可以避免超卖情况发生了。
接口防刷，前面已经提到过，在网关层对下单等接口按userID限流。
网关层除了对userID做限流外，还要做整体限流。在实际访问量超过预估访问量时，整体限流可以起到保护作用，避免系统被压垮。
防止重复下单，按userID限流已经起到了防止重复下单的作用。假如限制同一个用户10分钟能下一次单，一般情况下10分钟内，商品早已经被抢光了，用户也就没有再次下单的机会了。
可以结合风控系统，在网关层把羊毛党等有问题的用户请求直接拒掉。
可以在网关层上面再加一层防火墙或者高防服务，来防御DDos等分布式网络攻击。
-->

<!-- 
 还不知道【秒杀系统】如何设计？ 
https://mp.weixin.qq.com/s/CYa_YGVGCnozus2K9UTfNA
秒杀系统的架构分析与实战
https://mp.weixin.qq.com/s/CUTG32SaLST9nmhBP1PgkA

-->

* 链接暴露  
&emsp; 对于普通用户来讲，看到的只是一个比较简单的秒杀页面，在未达到规定时间，秒杀按钮是灰色的，一旦到达规定时间，灰色按钮变成可点击状态。这部分是针对小白用户的，如果是稍微有点电脑功底的用户，会通过F12看浏览器的network看到秒杀的url，通过特定软件去请求也可以实现秒杀。或者提前知道秒杀url的人，一请求就直接实现秒杀了。
* 恶意请求(接口防刷)  
&emsp; 现在的秒杀大多都会出来针对秒杀对应的软件，这类软件会模拟不断向后台服务器发起请求，一秒几百次都是很常见的，如何防止这类软件的重复无效请求，防止不断发起的请求。 
* **<font color = "red">突然增加的网络及服务器带宽</font>**  
&emsp; 假设商品页面大小200K(主要是商品图片大小)，那么需要的网络和服务器带宽是2G(200K×10000)，这些网络带宽是因为秒杀活动新增的，超过网站平时使用的带宽。  
&emsp; 解决方案：因为秒杀新增的网络带宽，必须和运营商重新购买或者租借。为了减轻网站服务器的压力，需要将秒杀商品页面缓存在CDN，同样需要和CDN服务商临时租借新增的出口带宽。  
* 超卖问题  
&emsp; 分析秒杀的业务场景，最重要的有一点就是超卖问题，假如备货只有100个，但是最终超卖了200，一般来讲秒杀系统的价格都比较低，如果超卖将严重影响公司的财产利益，因此首当其冲的就是解决商品的超卖问题。  
&emsp; 如何避免超卖？  
&emsp; 如果在redis中扣减库存，可以利用decr命令扣减库存，decr是原子操作，在分布式环境下也不会有并发问题，decr扣减库存后，判断返回值，如果返回值小于0，扣减库存失败，秒杀也就失败了；如果在数据库中扣减库存可以在where后面加上库存大于0的条件，来避免库存被减成负值。这样就可以避免超卖情况发生了。  
* 高并发  
&emsp; <font color = "red">秒杀具有时间短、并发量大的特点，</font>秒杀持续时间只有几分钟，而一般公司都为了制造轰动效应，会以极低的价格来吸引用户，因此参与抢购的用户会非常的多。短时间内会有大量请求涌进来。后端如何防止并发过高造成缓存击穿或者失效，击垮数据库都是需要考虑的问题。  
* 数据库设计  
&emsp; 秒杀有把服务器击垮的风险，如果让它与其他业务使用在同一个数据库中，耦合在一起，就很有可能牵连和影响其他的业务。如何防止这类问题发生，就算秒杀发生了宕机、服务器卡死问题，也应该尽量不影响线上正常进行的业务。  


<!-- 
* 大量请求问题  
按照1.2的考虑，就算使用缓存还是不足以应对短时间的高并发的流量的冲击。如何承载这样巨大的访问量，同时提供稳定低时延的服务保证，是需要面对的一大挑战。我们来算一笔账，假如使用的是redis缓存，单台redis服务器可承受的QPS大概是4W左右，如果一个秒杀吸引的用户量足够多的话，单QPS可能达到几十万，单体redis还是不足以支撑如此巨大的请求量。缓存会被击穿，直接渗透到DB，从而击垮mysql。后台会将会大量报错
-->

## 1.3. 科普：常见的互联网分层架构  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/web/seckill/sec-1.png)  

1. 客户端层：手机或PC端操作的客户端页面，域名通过DNS解析路由到NG。  
2. 反向代理层：一般通过NG作为反向代理，将客户端请求均衡路由到后端站点服务，NG也可以水平扩展为多实例，且每个实例可单独部署为主从的高可用方案。  
3. 站点层：站点层可以水平扩展为多个实例部署，以此来均衡来自客户端请求产生的高并发负载，多个web server之间的session信息可以集中存储于分布式缓存服务(Redis，MemCache)中。  
4. 服务层：服务层也可水平扩展为多个实例部署，即时下最火的微服务方式。  
5. 数据库层：数据库层的常见部署方式，如读写分离，分库分表等。  

## 1.4. 秒杀架构思考  

<!-- 
经验：一个秒杀系统的设计思考
https://mp.weixin.qq.com/s/cyR59SLxOqpC5my8vl8VnQ
-->

&emsp; <font color = "clime">从架构视角来看，秒杀系统本质是一个高性能、高一致、高可用的三高系统。</font>打造并维护一个超大流量的秒杀系统需要关注哪些？  
&emsp; 首先从高维度出发，整体思考问题。秒杀无外乎解决两个核心问题，一是并发读，一是并发写，对应到架构设计，就是高可用、一致性和高性能的要求。  

* 高性能。秒杀涉及高读和高写的支持，如何支撑高并发，如何抵抗高IOPS？核心优化理念其实是类似的：高读就尽量"少读"或"读少"，高写就数据拆分。可以从动静分离、热点优化以及服务端性能优化3个方面展开。  
* 一致性。秒杀的核心关注是商品库存，有限的商品在同一时间被多个请求同时扣减，而且要保证准确性，显而易见是一个难题。如何做到既不多又不少？本文将从业界通用的几种减库存方案切入，讨论一致性设计的核心逻辑。  
* 高可用。大型分布式系统在实际运行过程中面对的工况是非常复杂的，业务流量的突增、依赖服务的不稳定、应用自身的瓶颈、物理资源的损坏等方方面面都会对系统的运行带来大大小小的的冲击。如何保障应用在复杂工况环境下还能高效稳定运行，如何预防和面对突发问题，系统设计时应该从哪些方面着手？  

### 1.4.1. 高性能  
#### 1.4.1.1. 动静分离  
&emsp; 大家可能会注意到，秒杀过程中是不需要刷新整个页面的，只有时间在不停跳动。这是因为一般都会对大流量的秒杀系统做系统的静态化改造，即数据意义上的动静分离。动静分离三步走：1、数据拆分；2、静态缓存；3、数据整合。  

<!-- 
页面静态化  

“秒杀开始前几分钟，大量用户开始进入秒杀商品详情页面，很多人开始频繁刷新秒杀商品详情页，这时秒杀商品详情页访问量会猛增”。如果请求全部打到后端服务，那后端服务的压力会非常大(后端服务要处理业务逻辑，而且还要访问数据库，吞吐量比较低)。


考虑到秒杀是运营同学提前安排的活动，要秒杀哪些商品、商品价格等信息在秒杀活动开始前已经确定下来，所以我们可以把秒杀商品详情页做成静态页面，把商品详情、商品价格等参数、评论评价等信息全部放在这个静态页面里，然后把这个静态页面上传到CDN上预热(CDN是内容分发网络，可以简单理解成互联网上的巨大的缓存，用于存放静态页面、图片、视频等，可以显著提高访问速度)，用CDN扛流量，这样大量的商品详情页的访问请求就不用访问自己的网站(源站)。这样既可以提高访问速度，也没有给网站增加压力，同时也减少了网站带宽压力。

![image](https://gitee.com/wt1814/pic-host/raw/master/images/web/seckill/sec-7.png)  

-->
##### 1.4.1.1.1. 数据拆分  
&emsp; 动静分离的首要目的是将动态页面改造成适合缓存的静态页面。因此第一步就是分离出动态数据，主要从以下2个方面进行：  

* 用户。用户身份信息包括登录状态以及登录画像等，相关要素可以单独拆分出来，通过动态请求进行获取；与之相关的广平推荐，如用户偏好、地域偏好等，同样可以通过异步方式进行加载。  
* 时间。秒杀时间是由服务端统一管控的，可以通过动态请求进行获取。 

##### 1.4.1.1.2. 静态缓存
&emsp; 分离出动静态数据之后，第二步就是将静态数据进行合理的缓存，由此衍生出两个问题：1、怎么缓存；2、哪里缓存

###### 1.4.1.1.2.1. 怎么缓存
&emsp; 静态化改造的一个特点是直接缓存整个HTTP连接而不是仅仅缓存静态数据，如此一来，Web代理服务器根据请求URL，可以直接取出对应的响应体然后直接返回，响应过程无需重组HTTP协议，也无需解析HTTP请求头。  
&emsp; 而作为缓存键，URL唯一化是必不可少的，只是对于商品系统，URL天然是可以基于商品ID来进行唯一标识的，比如淘宝的 https://item.taobao.com/item.htm?id=xxxx

###### 1.4.1.1.2.2. 哪里缓存
&emsp; 静态数据缓存到哪里呢？可以有三种方式：1、浏览器；2、CDN；3、服务端。  
&emsp; 浏览器当然是第一选择，但用户的浏览器是不可控的，主要体现在如果用户不主动刷新，系统很难主动地把消息推送给用户（注意，当讨论静态数据时，潜台词是“相对不变”，言外之意是“可能会变”），如此可能会导致用户端在很长一段时间内看到的信息都是错误的。对于秒杀系统，保证缓存可以在秒级时间内失效是不可或缺的。  
&emsp; 服务端主要进行动态逻辑计算及加载，本身并不擅长处理大量连接，每个连接消耗内存较多，同时Servlet容器解析HTTP较慢，容易侵占逻辑计算资源；另外，静态数据下沉至此也会拉长请求路径。  
&emsp; 因此通常将静态数据缓存在CDN，其本身更擅长处理大并发的静态文件请求，既可以做到主动失效，又离用户尽可能近，同时规避Java语言层面的弱点。需要注意的是，CDN有以下几个问题需要解决：

* 失效问题。任何一个缓存都应该是有时效的，尤其对于一个秒杀场景。所以，系统需要保证全国各地的CDN在秒级时间内失效掉缓存信息，这实际对CDN的失效系统要求是很高的。
* 命中率问题。高命中是缓存系统最为核心的性能要求，不然缓存就失去了意义。如果将数据放到全国各地的CDN，势必会导致请求命中同一个缓存的可能性降低，那么命中率就成为一个问题。

&emsp; 因此，将数据放到全国所有的CDN节点是不太现实的，失效问题、命中率问题都会面临比较大的挑战。更为可行的做法是选择若干CDN节点进行静态化改造，节点的选取通常需要满足以下几个条件：

* 临近访问量集中的地区
* 距离主站较远的地区
* 节点与主站间网络质量良好的地区

&emsp; 基于以上因素，选择CDN的二级缓存比较合适，因为二级缓存数量偏少，容量也更大，访问量相对集中，这样就可以较好解决缓存的失效问题以及命中率问题，是当前比较理想的一种CDN化方案。部署方式如下图所示：  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/web/seckill/sec-9.png)  

##### 1.4.1.1.3. 数据整合
&emsp; 分离出动静态数据之后，前端如何组织数据页就是一个新的问题，主要在于动态数据的加载处理，通常有两种方案：ESI(Edge Side Includes)方案和CSI(Client Side Include)方案。

* ESI方案：Web 代理服务器上请求动态数据，并将动态数据插入到静态页面中，用户看到页面时已经是一个完整的页面。这种方式对服务端性能要求高，但用户体验较好
* CSI方案：Web代理服务器上只返回静态页面，前端单独发起一个异步JS请求动态数据。这种方式对服务端性能友好，但用户体验稍差

##### 1.4.1.1.4. 小结  
&emsp; 动静分离对于性能的提升，抽象起来只有两点，一是数据要尽量少，以便减少没必要的请求，二是路径要尽量短，以便提高单次请求的效率。具体方法其实就是基于这个大方向进行的。  

#### 1.4.1.2. 热点优化
&emsp; 热点分为热点操作和热点数据，以下分开进行讨论。  

##### 1.4.1.2.1. 热点操作  
&emsp; 零点刷新、零点下单、零点添加购物车等都属于热点操作。热点操作是用户的行为，不好改变，但可以做一些限制保护，比如用户频繁刷新页面时进行提示阻断。  

##### 1.4.1.2.2. 热点数据
&emsp; **<font color = "clime">热点数据的处理三步走，一是热点识别，二是热点隔离，三是热点优化。</font>**   

###### 1.4.1.2.2.1. 热点隔离

1. 业务隔离。<font color = "red">从业务上把秒杀和日常的售卖区分开来，把秒杀做为营销活动，要参与秒杀的商品需要提前报名参加活动，</font>这样就能提前知道哪些商家哪些商品要参与秒杀，可以根据提报的商品提前生成静态页面并上传到CDN预热，提报的商品库存也需要提前预热，可以将商品库存在活动开始前预热到Redis，避免秒杀开始后大量的缓存穿透。  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/web/seckill/sec-5.png)  
2. 部署隔离。秒杀相关服务和日常服务要分组部署，不能因为秒杀出问题影响日常售卖业务。可以申请单独的秒杀域名，从网络入口层就开始分流。网关也单独部署，秒杀走自己单独的网关，从而避免日常网关受到影响。秒杀可以复用订单，库存，支付等日常服务，只是需要一些小的改造(比如下单流程走消息队列，批量写入订单库，以及在Redis中扣减库存)。  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/web/seckill/sec-6.png)  
3. 数据隔离。为了避免秒杀活动影响到日常售卖业务，Redis缓存需要单独部署，甚至数据库也需要单独部署！数据隔离后，秒杀剩余的库存怎么办？秒杀活动结束后，剩余库存可以归还到日常库存继续做为普通商品售卖。数据隔离后，秒杀订单和日常订单不在相同的数据库，之后的订单查询怎么展示？可以在创建秒杀订单后发消息到消息队列，日常订单服务采取拉的方式消费消息，这时日常订单服务是主动方，可以采用线程池的方式，根据机器的性能来增加或缩小线程池的大小，控制拉取消息的速度，来控制订单数据库的写入压力。  

###### 1.4.1.2.2.2. 热点优化
&emsp; 热点数据隔离之后，也就方便对这1%的请求做针对性的优化，方式无外乎两种：

* 缓存：热点缓存是最为有效的办法。如果热点数据做了动静分离，那么可以长期缓存静态数据。  
* 限流：流量限制更多是一种保护机制。需要注意的是，各服务要时刻关注请求是否触发限流并及时进行review。  

#### 1.4.1.3. 系统优化
&emsp; 对于一个软件系统，提高性能可以有很多种手段，如提升硬件水平、调优JVM 性能，这里主要关注代码层面的性能优化：

* 减少序列化：减少 Java 中的序列化操作可以很好的提升系统性能。序列化大部分是在 RPC 阶段发生，因此应该尽量减少 RPC 调用，一种可行的方案是将多个关联性较强的应用进行 “合并部署”，从而减少不同应用之间的 RPC 调用(微服务设计规范)。
* 直接输出流数据：只要涉及字符串的I/O操作，无论是磁盘 I/O 还是网络 I/O，都比较耗费 CPU 资源，因为字符需要转换成字节，而这个转换又必须查表编码。所以对于常用数据，比如静态字符串，推荐提前编码成字节并缓存，具体到代码层面就是通过 OutputStream() 类函数从而减少数据的编码转换；另外，热点方法toString()不要直接调用ReflectionToString实现，推荐直接硬编码，并且只打印DO的基础要素和核心要素。
* 裁剪日志异常堆栈：无论是外部系统异常还是应用本身异常，都会有堆栈打出，超大流量下，频繁的输出完整堆栈，只会加剧系统当前负载。可以通过日志配置文件控制异常堆栈输出的深度。
* 去组件框架：极致优化要求下，可以去掉一些组件框架，比如去掉传统的 MVC 框架，直接使用 Servlet 处理请求。这样可以绕过一大堆复杂且用处不大的处理逻辑，节省毫秒级的时间，当然，需要合理评估对框架的依赖程度。

### 1.4.2. 一致性  
&emsp; 秒杀系统中，库存是个关键数据，卖不出去是个问题，超卖更是个问题。秒杀场景下的一致性问题，主要就是库存扣减的准确性问题。  

#### 1.4.2.1. 减库存的方式  
&emsp; 电商场景下的购买过程一般分为两步：下单和付款。“提交订单”即为下单，“支付订单”即为付款。基于此设定，<font color = "clime">减库存一般有以下几个方式：</font>  

* 下单减库存。买家下单后，扣减商品库存。下单减库存是最简单的减库存方式，也是控制最为精确的一种
* 付款减库存。买家下单后，并不立即扣减库存，而是等到付款后才真正扣减库存。但因为付款时才减库存，如果并发比较高，可能出现买家下单后付不了款的情况，因为商品已经被其他人买走了
* 预扣库存。这种方式相对复杂一些，买家下单后，库存为其保留一定的时间(如 15 分钟)，超过这段时间，库存自动释放，释放后其他买家可以购买

&emsp; 能够看到，减库存方式是基于购物过程的多阶段进行划分的，但无论是在下单阶段还是付款阶段，都会存在一些问题，下面进行具体分析。  

#### 1.4.2.2. 减库存的问题  

##### 1.4.2.2.1. 下单减库存
&emsp; 优势：用户体验最好。下单减库存是最简单的减库存方式，也是控制最精确的一种。下单时可以直接通过数据库事务机制控制商品库存，所以一定不会出现已下单却付不了款的情况。  
&emsp; 劣势：可能卖不出去。正常情况下，买家下单后付款概率很高，所以不会有太大问题。但有一种场景例外，就是当卖家参加某个促销活动时，竞争对手通过恶意下单的方式将该商品全部下单，导致库存清零，那么这就不能正常售卖了——要知道，恶意下单的人是不会真正付款的，这正是 “下单减库存” 的不足之处。  

##### 1.4.2.2.2. 付款减库存
&emsp; 优势：一定实际售卖。“下单减库存” 可能导致恶意下单，从而影响卖家的商品销售， “付款减库存” 由于需要付出真金白银，可以有效避免。  
&emsp; 劣势：用户体验较差。用户下单后，不一定会实际付款，假设有 100 件商品，就可能出现 200 人下单成功的情况，因为下单时不会减库存，所以也就可能出现下单成功数远远超过真正库存数的情况，这尤其会发生在大促的热门商品上。如此一来就会导致很多买家下单成功后却付不了款，购物体验自然是比较差的。  

##### 1.4.2.2.3. 预扣库存
&emsp; 优势：缓解了以上两种方式的问题。预扣库存实际就是“下单减库存”和 “付款减库存”两种方式的结合，将两次操作进行了前后关联，下单时预扣库存，付款时释放库存。  
&emsp; 劣势：并没有彻底解决以上问题。比如针对恶意下单的场景，虽然可以把有效付款时间设置为 10 分钟，但恶意买家完全可以在 10 分钟之后再次下单。  

##### 1.4.2.2.4. 小结
&emsp; 减库存的问题主要体现在用户体验和商业诉求两方面，其本质原因在于购物过程存在两步甚至多步操作，在不同阶段减库存，容易存在被恶意利用的漏洞。  


#### 1.4.2.3. ★★★实际如何减库存  
&emsp; <font color = "clime">业界最为常见的是预扣库存。</font>无论是外卖点餐还是电商购物，下单后一般都有个 “有效付款时间”，超过该时间订单自动释放，这就是典型的预扣库存方案。但如上所述，预扣库存还需要解决恶意下单的问题，保证商品卖的出去；另一方面，如何避免超卖，也是一个痛点。  
&emsp; 卖的出去：恶意下单的解决方案主要还是结合安全和反作弊措施来制止。比如，识别频繁下单不付款的买家并进行打标，这样可以在打标买家下单时不减库存；再比如为大促商品设置单人最大购买件数，一人最多只能买 N 件商品；又或者对重复下单不付款的行为进行次数限制阻断等。  
&emsp; 避免超卖：库存超卖的情况实际分为两种。对于普通商品，秒杀只是一种大促手段，即使库存超卖，商家也可以通过补货来解决；而对于一些商品，秒杀作为一种营销手段，完全不允许库存为负，也就是在数据一致性上，需要保证大并发请求时数据库中的库存字段值不能为负，一般有多种方案：  
&emsp; 一是在通过事务来判断，即保证减后库存不能为负，否则就回滚；  
&emsp; 二是直接设置数据库字段类型为无符号整数，这样一旦库存为负就会在执行 SQL 时报错；  
&emsp; 三是使用 CASE WHEN 判断语句：  

```sql
UPDATE item SET inventory = CASE WHEN inventory >= xxx THEN inventory-xxx ELSE inventory END
```

&emsp; 业务手段保证商品卖的出去，技术手段保证商品不会超卖，库存问题从来就不是简单的技术难题，解决问题的视角是多种多样的。

#### 1.4.2.4. 一致性性能的优化  
&emsp; 库存是个关键数据，更是个热点数据。对系统来说，热点的实际影响就是 “高读” 和 “高写”，也是秒杀场景下最为核心的一个技术难题。

##### 1.4.2.4.1. 高并发读
&emsp; 秒杀场景解决高并发读问题，关键词是“分层校验”。即在读链路时，只进行不影响性能的检查操作，如用户是否具有秒杀资格、商品状态是否正常、用户答题是否正确、秒杀是否已经结束、是否非法请求等，而不做一致性校验等容易引发瓶颈的检查操作；直到写链路时，才对库存做一致性检查，在数据层保证最终准确性。  
&emsp; 因此，在分层校验设定下，系统可以采用分布式缓存甚至LocalCache来抵抗高并发读。即允许读场景下一定的脏数据，这样只会导致少量原本无库存的下单请求被误认为是有库存的，等到真正写数据时再保证最终一致性，由此做到高可用和一致性之间的平衡。  
&emsp; 实际上，分层校验的核心思想是：不同层次尽可能过滤掉无效请求，只在“漏斗” 最末端进行有效处理，从而缩短系统瓶颈的影响路径。  

##### 1.4.2.4.2. 高并发写
&emsp; 高并发写的优化方式，一种是更换DB选型，一种是优化DB性能，以下分别进行讨论。

###### 1.4.2.4.2.1. 更换DB选型
&emsp; 秒杀商品和普通商品的减库存是有差异的，核心区别在数据量级小、交易时间短，因此能否把秒杀减库存直接放到缓存系统中实现呢，也就是直接在一个带有持久化功能的缓存中进行减库存操作，比如 Redis。  
&emsp; 如果减库存逻辑非常单一的话，比如没有复杂的 SKU 库存和总库存这种联动关系的话，个人认为是完全可以的。但如果有比较复杂的减库存逻辑，或者需要使用到事务，那就必须在数据库中完成减库存操作。  

###### 1.4.2.4.2.2. 优化DB性能
&emsp; 库存数据落地到数据库实现其实是一行存储(MySQL)，因此会有大量线程来竞争 InnoDB 行锁。但并发越高，等待线程就会越多，TPS 下降，RT 上升，吞吐量会受到严重影响——注意，这里假设数据库已基于上文【性能优化】完成数据隔离，以便于讨论聚焦 。   
&emsp; 解决并发锁的问题，有两种办法：  
&emsp; 1、应用层排队。  
&emsp; 通过缓存加入集群分布式锁，从而控制集群对数据库同一行记录进行操作的并发度，同时也能控制单个商品占用数据库连接的数量，防止热点商品占用过多的数据库连接  
&emsp; 2、数据层排队。  
&emsp; 应用层排队是有损性能的，数据层排队是最为理想的。业界中，阿里的数据库团队开发了针对InnoDB 层上的补丁程序(patch)，可以基于DB层对单行记录做并发排队，从而实现秒杀场景下的定制优化——注意，排队和锁竞争是有区别的，如果熟悉 MySQL 的话，就会知道 InnoDB 内部的死锁检测，以及 MySQL Server 和 InnoDB 的切换都是比较消耗性能的。   
&emsp; 另外阿里的数据库团队还做了很多其他方面的优化，如 COMMIT_ON_SUCCESS 和 ROLLBACK_ON_FAIL的补丁程序，通过在 SQL 里加入提示(hint)，实现事务不需要等待实时提交，而是在数据执行完最后一条 SQL 后，直接根据 TARGET_AFFECT_ROW的结果进行提交或回滚，减少网络等待的时间(毫秒级)。   
&emsp; 目前阿里已将包含这些补丁程序的 MySQL 开源：https://github.com/alibaba/AliSQL?spm=a2c4e.10696291.0.0.34ba19a415ghm4  

##### 1.4.2.4.3. 小结
&emsp; 高读和高写的两种处理方式大相径庭。读请求的优化空间要大一些，而写请求的瓶颈一般都在存储层，优化思路的本质还是基于 CAP 理论做平衡。

#### 1.4.2.5. 总结一下
&emsp; 当然，减库存还有很多细节问题，例如预扣的库存超时后如何进行回补，再比如第三方支付如何保证减库存和付款时的状态一致性，这些也是很大的挑战。  

### 1.4.3. 高可用  
&emsp; 盯过秒杀流量监控的话，会发现它不是一条蜿蜒而起的曲线，而是一条挺拔的直线，这是因为秒杀请求高度集中于某一特定的时间点。这样一来就会造成一个特别高的零点峰值，而对资源的消耗也几乎是瞬时的。所以秒杀系统的可用性保护是不可或缺的。  

#### 1.4.3.1. 流量削峰  
&emsp; 对于秒杀的目标场景，最终能够抢到商品的人数是固定的，无论100人和10000人参加结果都是一样的，即有效请求额度是有限的。并发度越高，无效请求也就越多。但秒杀作为一种商业营销手段，活动开始之前是希望有更多的人来刷页面，只是真正开始后，秒杀请求不是越多越好。因此系统可以设计一些规则，人为的延缓秒杀请求，甚至可以过滤掉一些无效请求。  

##### 1.4.3.1.1. 答题  
&emsp; 早期秒杀只是简单的点击秒杀按钮，后来才增加了答题。为什么要增加答题呢？主要是通过提升购买的复杂度，达到两个目的：  

* 防止作弊。早期秒杀器比较猖獗，存在恶意买家或竞争对手使用秒杀器扫货的情况，商家没有达到营销的目的，所以增加答题来进行限制。  
* 延缓请求。零点流量的起效时间是毫秒级的，答题可以人为拉长峰值下单的时长，由之前的 <1s 延长到 <10s。这个时间对于服务端非常重要，会大大减轻高峰期并发压力；另外，由于请求具有先后顺序，答题后置的请求到来时可能已经没有库存了，因此根本无法下单，此阶段落到数据层真正的写也就非常有限了。  

&emsp; 需要注意的是，答题除了做正确性验证，还需要对提交时间做验证，比如<1s 人为操作的可能性就很小，可以进一步防止机器答题的情况。  
&emsp; 答题目前已经使用的非常普遍了，本质是通过在入口层削减流量，从而让系统更好地支撑瞬时峰值。  

##### 1.4.3.1.2. 排队
&emsp; 最为常见的削峰方案是使用消息队列，通过把同步的直接调用转换成异步的间接推送缓冲瞬时流量。除了消息队列，类似的排队方案还有很多，例如：

* 线程池加锁等待
* 本地内存蓄洪等待
* 本地文件序列化写，再顺序读

&emsp; 排队方式的弊端也是显而易见的，主要有两点：

* 请求积压。流量高峰如果长时间持续，达到了队列的水位上限，队列同样会被压垮，这样虽然保护了下游系统，但是和请求直接丢弃也没多大区别
* 用户体验。异步推送的实时性和有序性自然是比不上同步调用的，由此可能出现请求先发后至的情况，影响部分敏感用户的购物体验

&emsp; 排队本质是在业务层将一步操作转变成两步操作，从而起到缓冲的作用，但鉴于此种方式的弊端，最终还是要基于业务量级和秒杀场景做出妥协和平衡。  

##### 1.4.3.1.3. 过滤
&emsp; 过滤的核心结构在于分层，通过在不同层次过滤掉无效请求，达到数据读写的精准触发。<font color = "clime">尽量将请求拦截在上游。</font>常见的过滤主要有以下几层：  
1、读限流：对读请求做限流保护，将超出系统承载能力的请求过滤掉  
2、读缓存：对读请求做数据缓存，将重复的请求过滤掉  
3、写限流：对写请求做限流保护，将超出系统承载能力的请求过滤掉  
4、写校验：对写请求做一致性校验，只保留最终的有效数据  
&emsp; 过滤的核心目的是通过减少无效请求的数据IO，保障有效请求的IO性能。  


<!-- 
&emsp; 对于秒杀系统来说，系统的瓶颈一般在数据库层，由于资源是有限的，如库中共1万张票，一瞬间并发进来100万的请求，那么有99万都是无用的请求，所以为了更好的保护底层有限的数据库资源，尽量将请求拦截在上游。  

前端页面，相关按钮点击后置灰，防止重复提交  

网关(zuul，nginx)层，为了避免前端恶意请求，比如一些攻击脚本，在网关层要对下单等接口按userID限流，几秒钟只能访问一次。考虑到秒杀场景参与人多，秒杀成功的人极少，可以把绝大部分抢购下单请求在网关层直接拒掉，按秒杀失败处理。这样就极大减少了后端服务的压力。  

假设秒杀库存是200个，我们可以只放行200个请求到后端服务。要注意，为了尽量避免库存被机器人和自动脚本抢走，200个请求不能在秒杀开始瞬间同时放行，可以分段放行，比如秒杀开始后随机选取100ms内的5个请求放行(这100ms内的其他请求直接拒掉，按秒杀失败处理)，之后每隔100ms放行5个请求，4秒钟可以放行完200个请求。分段放行，除了限制了机器人和自动脚本，把请求分散在各个时间段，还进一步缓解了后端服务的压力。  

分段放行总时间不能太长，假如每100ms放行1个请求，放行完所有200个请求需要20秒时间，这样用户就会明显感知到下单早的人没秒杀成功，下单晚的人反而秒杀成功了，用户体验会变差。  


另外，秒杀过程网关压力会比较大，网关可以做成集群，多节点分摊访问压力。  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/web/seckill/sec-4.png)  
-->

##### 1.4.3.1.4. 小结
&emsp; 系统可以通过入口层的答题、业务层的排队、数据层的过滤达到流量削峰的目的，本质是在寻求商业诉求与架构性能之间的平衡。  
&emsp; 另外，新的削峰手段也层出不穷，以业务切入居多，比如零点大促时同步发放优惠券或发起抽奖活动，将一部分流量分散到其他系统，这样也能起到削峰的作用。  


#### 1.4.3.2. 高可用建设  
&emsp; 当一个系统面临持续的高峰流量时，其实是很难单靠自身调整来恢复状态的，日常运维没有人能够预估所有情况，意外总是无法避免。尤其在秒杀这一场景下，为了保证系统的高可用，必须设计一个高可用方案来进行兜底。  
&emsp; 高可用建设，其实是一个系统工程，贯穿在系统建设的整个生命周期。  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/web/seckill/sec-8.png)  
&emsp; 具体来说，系统的高可用建设涉及架构阶段、编码阶段、测试阶段、发布阶段、运行阶段，以及故障发生时，逐一进行分析：  

* 架构阶段：考虑系统的可扩展性和容错性，避免出现单点问题。例如多地单元化部署，即使某个IDC甚至地市出现故障，仍不会影响系统运转
* 编码阶段：保证代码的健壮性，例如RPC调用时，设置合理的超时退出机制，防止被其他系统拖垮，同时也要对无法预料的返回错误进行默认的处理
* 测试阶段：保证CI的覆盖度以及Sonar的容错率，对基础质量进行二次校验，并定期产出整体质量的趋势报告
* 发布阶段：系统部署最容易暴露错误，因此要有前置的checklist模版、中置的上下游周知机制以及后置的回滚机制
* 运行阶段：系统多数时间处于运行态，最重要的是运行时的实时监控，及时发现问题、准确报警并能提供详细数据，以便排查问题
* 故障发生：首要目标是及时止损，防止影响面扩大，然后定位原因、解决问题，最后恢复服务

&emsp; 对于日常运维而言，高可用更多是针对运行阶段而言的，此阶段需要额外进行加强建设，主要有以下几种手段：  

* 预防：建立常态压测体系，定期对服务进行单点压测以及全链路压测，摸排水位
* 管控：做好线上运行的降级、限流和熔断保护。需要注意的是，无论是限流、降级还是熔断，对业务都是有损的，所以在进行操作前，一定要和上下游业务确认好再进行。就拿限流来说，哪些业务可以限、什么情况下限、限流时间多长、什么情况下进行恢复，都要和业务方反复确认
* 监控：建立性能基线，记录性能的变化趋势；建立报警体系，发现问题及时预警
* 恢复：遇到故障能够及时止损，并提供快速的数据订正工具，不一定要好，但一定要有

&emsp; 在系统建设的整个生命周期中，每个环节中都可能犯错，甚至有些环节犯的错，后面是无法弥补的或者成本极高的。所以高可用是一个系统工程，必须放到整个生命周期中进行全面考虑。同时，考虑到服务的增长性，高可用更需要长期规划并进行体系化建设。

## 1.5. 秒杀业务完整流程梳理  

![image](https://gitee.com/wt1814/pic-host/raw/master/images/web/seckill/sec-3.png)  

(1)页面端，如：  

* 按钮置灰：禁止用户重复提交请求
* 通过JS控制：在一定时间内只能提交一次请求

(2)web server层，如：  

* 动静分离：如将几乎不变的静态页面直接通过NG或CDN来路由访问，只有动态变换的页面可以请求到web server端
* 页面缓存化
* Nginx反向代理实现web server端的水平扩展

(3)后端service服务层

* 使用缓存(Redis、Memchched)：将读多写少的业务数据放入缓存，如秒杀业务中可以将更新频繁的商品库存信息放入Redis缓存处理

        注：库存信息放入Redis缓存的时候最好分为多份放入不同key的缓存中，如库存为10万可以分为10份分别放入不同key的缓存中，这样将数据分散操作可以达到更高的读写性能。

* 使用队列处理：将请求放入队列排队处理，以可控的速度来访问底层DB。
* 异步处理：如将秒杀成功的订单通知信息通过消息队列(RabbitMQ、Kafka)来异步处理。

(4)DB层

* 读写分离
* 分表分库
* 数据库集群
