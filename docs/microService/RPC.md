

<!-- TOC -->

- [1. RPC](#1-rpc)
    - [1.1. RPC定义](#11-rpc定义)
    - [1.2. 分布式通信方式（RPC与RESTFul）](#12-分布式通信方式rpc与restful)
    - [1.3. RPC架构](#13-rpc架构)
    - [1.4. RPC核心技术点](#14-rpc核心技术点)
        - [1.4.1. 服务暴露：](#141-服务暴露)
        - [1.4.2. 远程代理对象：](#142-远程代理对象)
        - [1.4.3. 通信：](#143-通信)
        - [1.4.4. 序列化：](#144-序列化)
    - [1.5. 流行的RPC框架](#15-流行的rpc框架)
    - [1.6. RPC和消息队列的差异](#16-rpc和消息队列的差异)

<!-- /TOC -->

# 1. RPC  

<!-- 
几张图帮你弄清楚什么是 RPC 
https://mp.weixin.qq.com/s/9qeuTy6d4t5XI1svFlWcIA
-->

## 1.1. RPC定义  
&emsp; RPC（Remote Procedure Call Protocol）——远程过程调用协议，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。RPC协议假定某些传输协议的存在，如TCP或UDP，为通信程序之间携带信息数据。在OSI网络通信模型中，RPC跨越了传输层和应用层。RPC使得开发包括网络分布式多程序在内的应用程序更加容易。  
&emsp; RPC采用客户机/服务器模式。请求程序就是一 个客户机，而服务提供程序就是一个服务器。首先，客户机调用进程发送一个有进程参数的调用信息到服务进程，然后等待应答信息。在服务器端，进程保持睡眠状 态直到调用信息到达为止。当一个调用信息到达，服务器获得进程参数，计算结果，发送答复信息，然后等待下一个调用信息，最后，客户端调用进程接收答复信 息，获得进程结果，然后调用执行继续进行。  
&emsp; ![image](https://gitee.com/wt1814/pic-host/raw/master/images/microService/RPC/rpc-4.png)   

## 1.2. 分布式通信方式（RPC与RESTFul）  
<!-- 
 
https://blog.csdn.net/u013952133/article/details/79256799
-->

![image](https://gitee.com/wt1814/pic-host/raw/master/images/microService/RPC/rpc-5.png)   
&emsp; RPC支持哪些协议？  
&emsp; 最早的CORBA、Java RMI， WebService方式的RPC风格， Hessian, Thrift甚至Rest API。  

* 基于TCP的RPC  
&emsp; 最简单的方式，例如基于Java Socket API实现RPC，一种非常典型的CS架构，client携带参数和调用方法名请求server，server使用一个while循环来监听客户端请求并予以处理；再往下延伸就涉及到当client请求并发数很大时，是用阻塞IO还是非阻塞IO？如何做服务路由以及负载均衡来将请求分发到多个server？轮询法？  
* 基于HTTP的RPC  
&emsp; 基于HTTP一定程度上就是为了节省在底层细节上的关注，而可以去利用更高层的协议和现有的开源库去实现RPC，例如基于HttpClient库去实现RPC，基于json或者xml作为序列化之后的传输格式，当然这也会带来效率低，定制化程度低等弊端。  
* RESTFul和RPC形式url  
&emsp; RESTFul把所有网络上的实体作为资源，具体的资源通过不同的格式作为表现层，例如图片的表现层可能是jpg，也可能是png；然后通过http协议的常用操作方式(例如GET、POST等)来改变和转换资源状态，也就是表现层转换  
&emsp; 而传统的RPC形式url会把操作类型、需要远程调用的服务接口名、参数都通过queryString携带到服务端，RESTFul则把操作类型放到了http请求方式中，使得url更加简洁，只留下一部分参数在url中  

## 1.3. RPC架构  
<!-- 
RPC
https://zhuanlan.zhihu.com/p/98423247
-->
&emsp; Nelson 的论文中指出实现 RPC 的程序包括 5 个部分：1. User、2. User-stub、3. RPCRuntime、4. Server-stub、5. Server。  
&emsp; 这5个部分的关系如下图所示  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/microService/RPC/rpc-1.png)   
&emsp; 这里 user 就是 client 端，当 user发起一个远程调用时，它实际是通过本地调用user-stub。user-stub 负责将调用的接口、方法和参数通过约定的协议规范进行编码并通过本地的 RPCRuntime 实例传输到远端的实例。远端 RPCRuntime 实例收到请求后交给 server-stub 进行解码后发起本地端调用，调用结果再返回给 user 端。  

-----
&emsp; 一个基本的RPC架构里面应该至少包含以下4个组件：  
1. 客户端（Client）:服务调用方（服务消费者）  
2. 客户端存根（Client Stub）:存放服务端地址信息，将客户端的请求参数数据信息打包成网络消息，再通过网络传输发送给服务端  
3. 服务端存根（Server Stub）:接收客户端发送过来的请求消息并进行解包，然后再调用本地服务进行处理  
4. 服务端（Server）:服务的真正提供者  

&emsp; 具体的调用过程如下：  
1. 服务消费者（client客户端）通过本地调用的方式调用服务  
2. 客户端存根（client stub）接收到调用请求后负责将方法、入参等信息序列化（组装）成能够进行网络传输的消息体  
3. 客户端存根（client stub）找到远程的服务地址，并且将消息通过网络发送给服务端  
4. 服务端存根（server stub）收到消息后进行解码（反序列化操作）  
5. 服务端存根（server stub）根据解码结果调用本地的服务进行相关处理  
6. 本地服务执行具体业务逻辑并将处理结果返回给服务端存根（server stub）   
7. 服务端存根（server stub）将返回结果重新打包成消息（序列化）并通过网络发送至消费方  
8. 客户端存根（client stub）接收到消息，并进行解码（反序列化）  
9. 服务消费方得到最终结果  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/microService/RPC/rpc-6.png)  
&emsp; 而RPC框架的实现目标则是将上面的第2-10步完好地封装起来，也就是把调用、编码/解码的过程给封装起来，让用户感觉上像调用本地服务一样的调用远程服务。  

-----

<!-- 
![image](https://gitee.com/wt1814/pic-host/raw/master/images/microService/RPC/rpc-3.png)   
&emsp; RPC 服务方通过 RpcServer 去导出（export）远程接口方法，而客户方通过 RpcClient 去引入（import）远程接口方法。客户方像调用本地方法一样去调用远程接口方法，RPC 框架提供接口的代理实现，实际的调用将委托给代理RpcProxy 。代理封装调用信息并将调用转交给RpcInvoker 去实际执行。在客户端的RpcInvoker 通过连接器RpcConnector 去维持与服务端的通道RpcChannel，并使用RpcProtocol 执行协议编码（encode）并将编码后的请求消息通过通道发送给服务方。  
&emsp; RPC 服务端接收器 RpcAcceptor 接收客户端的调用请求，同样使用RpcProtocol 执行协议解码（decode）。解码后的调用信息传递给RpcProcessor 去控制处理调用过程，最后再委托调用给RpcInvoker 去实际执行并返回调用结果。如下是各个部分的详细职责：  

1. RpcServer  
负责导出（export）远程接口  
2. RpcClient  
负责导入（import）远程接口的代理实现  
3. RpcProxy  
远程接口的代理实现  
4. RpcInvoker  
客户方实现：负责编码调用信息和发送调用请求到服务方并等待调用结果返回  
服务方实现：负责调用服务端接口的具体实现并返回调用结果  
5. RpcProtocol  
负责协议编/解码  
6. RpcConnector  
负责维持客户方和服务方的连接通道和发送数据到服务方  
7. RpcAcceptor  
负责接收客户方请求并返回请求结果  
8. RpcProcessor  
负责在服务方控制调用过程，包括管理调用线程池、超时时间等  
9. RpcChannel  
数据传输通道  
-->

## 1.4. RPC核心技术点  
&emsp; RPC框架需要解决的问题？  
1. 如何确定客户端和服务端之间的通信协议？  
2. 如何更高效地进行网络通信？  
3. 服务端提供的服务如何暴露给客户端？  
4. 客户端如何发现这些暴露的服务？  
5. 如何更高效地对请求对象和响应结果进行序列化和反序列化操作？  

&emsp; 一个比较完善的 RPC 框架  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/microService/RPC/rpc-7.png)  

&emsp; RPC框架实现的几个核心技术点：  

### 1.4.1. 服务暴露：  
远程提供者需要以某种形式提供服务调用相关的信息，包括但不限于服务接口定义、数据结构、或者中间态的服务定义文件。例如Facebook的Thrift的IDL文件，Web service的WSDL文件；服务的调用者需要通过一定的途径获取远程服务调用相关的信息。  
目前，大部分跨语言平台 RPC 框架采用根据 IDL 定义通过 code generator 去生成 stub 代码，这种方式下实际导入的过程就是通过代码生成器在编译期完成的。代码生成的方式对跨语言平台 RPC 框架而言是必然的选择，而对于同一语言平台的 RPC 则可以通过共享接口定义来实现。这里的导入方式本质也是一种代码生成技术，只不过是在运行时生成，比静态编译期的代码生成看起来更简洁些。  
java 中还有一种比较特殊的调用就是多态，也就是一个接口可能有多个实现，那么远程调用时到底调用哪个？这个本地调用的语义是通过 jvm 提供的引用多态性隐式实现的，那么对于 RPC 来说跨进程的调用就没法隐式实现了。如果前面DemoService 接口有 2 个实现，那么在导出接口时就需要特殊标记不同的实现需要，那么远程调用时也需要传递该标记才能调用到正确的实现类，这样就解决了多态调用的语义问题。  

### 1.4.2. 远程代理对象：  
服务调用者用的服务实际是远程服务的本地代理。说白了就是通过动态代理来实现。  


生成Client Stub（客户端存根）和Server Stub（服务端存根）的时候需要用到java动态代理技术，可以使用jdk提供的原生的动态代理机制，也可以使用开源的：Cglib代理，Javassist字节码生成技术。  

### 1.4.3. 通信：  

出于并发性能的考虑，传统的阻塞式 IO 显然不太合适，因此我们需要异步的 IO，即 NIO。  
Java 提供了 NIO 的解决方案，Java 7 也提供了更优秀的 NIO.2 支持。可以选择Netty或者mina来解决NIO数据传输的问题。 

RPC框架与具体的协议无关。RPC 可基于HTTP 或 TCP 协议，Web Service 就是基于 HTTP 协议的 RPC，它具有良好的跨平台性，但其性能却不如基于 TCP 协议的 RPC。  
    1. TCP/HTTP：众所周知，TCP 是传输层协议，HTTP 是应用层协议，而传输层较应用层更加底层，在数据传输方面，越底层越快，因此，在一般情况下，TCP 一定比 HTTP 快。  
    2. 消息ID：RPC 的应用场景实质是一种可靠的请求应答消息流，和 HTTP 类似。因此选择长连接方式的 TCP 协议会更高效，与 HTTP 不同的是在协议层面我们定义了每个消息的唯一 id，因此可以更容易的复用连接。  
    3. IO方式：为了支持高并发，传统的阻塞式 IO 显然不太合适，因此我们需要异步的 IO，即 NIO。Java 提供了 NIO 的解决方案，Java 7 也提供了更优秀的 NIO.2 支持。  
    4. 多连接：既然使用长连接，那么第一个问题是到底 client 和 server 之间需要多少根连接？实际上单连接和多连接在使用上没有区别，对于数据传输量较小的应用类型，单连接基本足够。单连接和多连接最大的区别在于，每根连接都有自己私有的发送和接收缓冲区，因此大数据量传输时分散在不同的连接缓冲区会得到更好的吞吐效率。所以，如果你的数据传输量不足以让单连接的缓冲区一直处于饱和状态的话，那么使用多连接并不会产生任何明显的提升，反而会增加连接管理的开销。  
    5. 心跳： 连接是由 client 端发起建立并维持。如果 client 和 server 之间是直连的，那么连接一般不会中断（当然物理链路故障除外）。如果 client 和 server 连接经过一些负载中转设备，有可能连接一段时间不活跃时会被这些中间设备中断。为了保持连接有必要定时为每个连接发送心跳数据以维持连接不中断。心跳消息 是 RPC 框架库使用的内部消息，在前文协议头结构中也有一个专门的心跳位，就是用来标记心跳消息的，它对业务应用透明。  

### 1.4.4. 序列化：  

两方面会直接影响 RPC 的性能，一是传输方式，二是序列化。  
1. 序列化方式：毕竟是远程通信，需要将对象转化成二进制流进行传输。不同的RPC框架应用的场景不同，在序列化上也会采取不同的技术。 就序列化而言，Java 提供了默认的序列化方式，但在高并发的情况下，这种方式将会带来一些性能上的瓶颈，于是市面上出现了一系列优秀的序列化框架，比如：Protobuf、Kryo、Hessian、Jackson 等，它们可以取代 Java 默认的序列化，从而提供更高效的性能。  
2. 编码内容：出于效率考虑，编码的信息越少越好（传输数据少），编码的规则越简单越好（执行效率高）  

在网络中，所有的数据都将会被转化为字节进行传送，所以为了能够使参数对象在网络中进行传输，需要对这些参数进行序列化和反序列化操作。  

序列化：把对象转换为字节序列的过程称为对象的序列化，也就是编码的过程。  
反序列化：把字节序列恢复为对象的过程称为对象的反序列化，也就是解码的过程。  

目前比较高效的开源序列化框架：如Kryo、fastjson和Protobuf等。  


3、网络传输  
3.1、序列化  

当A机器上的应用发起一个RPC调用时，调用方法和其入参等信息需要通过底层的网络协议如TCP传输到B机器，由于网络协议是基于二进制的，所有我们传输的参数数据都需要先进行序列化（Serialize）或者编组（marshal）成二进制的形式才能在网络中进行传输。然后通过寻址操作和网络传输将序列化或者编组之后的二进制数据发送给B机器。  
3.2、反序列化  

当B机器接收到A机器的应用发来的请求之后，又需要对接收到的参数等信息进行反序列化操作（序列化的逆操作），即将二进制信息恢复为内存中的表达方式，然后再找到对应的方法（寻址的一部分）进行本地调用（一般是通过生成代理Proxy去调用, 通常会有JDK动态代理、CGLIB动态代理、Javassist生成字节码技术等），之后得到调用的返回值。 


  
 


## 1.5. 流行的RPC框架

<!-- 
Dubbo  
Dubbo 是阿里巴巴公司开源的一个Java高性能优秀的服务框架，使得应用可通过高性能的 RPC 实现服务的输出和输入功能，可以和 Spring框架无缝集成。目前已经进入Apache孵化器。  
Motan  
Motan是新浪微博开源的一个Java RPC框架。2016年5月开源。Motan 在微博平台中已经广泛应用，每天为数百个服务完成近千亿次的调用。  
Thrift  
Thrift是Apache的一个跨语言的高性能的服务框架，也得到了广泛的应用。  
-->

&emsp; 目前常用的RPC框架如下：  
1. Thrift：thrift 是一个软件框架，用来进行可扩展且跨语言的服务的开发。它结合了功能强大的软件堆栈和代码生成引擎，以构建在 C++, Java, Python, PHP, Ruby, Erlang, Perl, Haskell, C#, Cocoa, JavaScript, Node.js, Smalltalk, and OCaml 这些编程语言间无缝结合的、高效的服务。  
2. Dubbo：Dubbo是一个分布式服务框架，以及SOA治理方案。其功能主要包括：高性能NIO通讯及多协议集成，服务动态寻址与路由，软负载均衡与容错，依赖分析与降级等。 Dubbo是阿里巴巴内部的SOA服务化治理方案的核心框架，Dubbo自2011年开源后，已被许多非阿里系公司使用。  
3. gRPC是Google开发的高性能、通用的开源RPC框架，其由Google主要面向移动应用开发并基于HTTP/2协议标准而设计，基于ProtoBuf(Protocol Buffers)序列化协议开发，且支持众多开发语言。本身它不是分布式的，所以要实现上面的框架的功能需要进一步的开发。  
4. Spring Cloud：Spring Cloud由众多子项目组成，如Spring Cloud Config、Spring Cloud Netflix、Spring Cloud Consul 等，提供了搭建分布式系统及微服务常用的工具，如配置管理、服务发现、断路器、智能路由、微代理、控制总线、一次性token、全局锁、选主、分布式会话 和集群状态等，满足了构建微服务所需的所有解决方案。Spring Cloud基于Spring Boot, 使得开发部署极其简单。  

## 1.6. RPC和消息队列的差异  
1. 功能差异  
    在架构上，RPC和Message的差异点是，Message有一个中间结点Message Queue，可以把消息存储。  
    &emsp; 消息的特点：  
    1. Message Queue把请求的压力保存一下，逐渐释放出来，让处理者按照自己的节奏来处理。
    2. Message Queue引入一下新的结点，系统的可靠性会受Message Queue结点的影响。
    3. Message Queue是异步单向的消息。发送消息设计成是不需要等待消息处理的完成。
    所以对于有同步返回需求，用Message Queue则变得麻烦了。  

    &emsp; RPC的特点：  
    &emsp; 同步调用，对于要等待返回结果/处理结果的场景，RPC是可以非常自然直觉的使用方式(RPC也可以是异步调用)。  
    &emsp; 由于等待结果，Consumer（Client）会有线程消耗。如果以异步RPC的方式使用，Consumer（Client）线程消耗可以去掉。但不能做到像消息一样暂存消息/请求，压力会直接传导到服务Provider。  
2. 适用场合差异  
    1. 希望同步得到结果的场合，RPC合适。  
    2. 希望使用简单，则RPC；RPC操作基于接口，使用简单，使用方式模拟本地调用。异步的方式编程比较复杂。  
    3. 不希望发送端（RPC Consumer、Message Sender）受限于处理端（RPC Provider、Message Receiver）的速度时，使用Message Queue。  
    随着业务增长，有的处理端处理量会成为瓶颈，会进行同步调用到异步消息的改造。这样的改造实际上有调整业务的使用方式。比如原来一个操作页面提交后就下一个页面会看到处理结果；改造后异步消息后，下一个页面就会变成“操作已提交，完成后会得到通知”。  
3. 不适用场合说明  
    1. RPC同步调用使用Message Queue来传输调用信息。 上面分析可以知道，这样的做法，发送端是在等待，同时占用一个中间点的资源。变得复杂了，但没有对等的收益。  
    2. 对于返回值是void的调用，可以这样做，因为实际上这个调用业务上往往不需要同步得到处理结果的，只要保证会处理即可。（RPC的方式可以保证调用返回即处理完成，使用消息方式后这一点不能保证了。）  
    3. 返回值是void的调用，使用消息，效果上是把消息的使用方式Wrap成了服务调用（服务调用使用方式成简单，基于业务接口）。  



