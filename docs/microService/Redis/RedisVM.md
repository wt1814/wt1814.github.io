

<!-- TOC -->

- [1. Redis之VM机制](#1-redis之vm机制)
    - [1.1. 前言：redis的内存淘汰策略](#11-前言redis的内存淘汰策略)
    - [1.2. VM介绍](#12-vm介绍)
    - [1.3. VM相关配置](#13-vm相关配置)
    - [1.4. VM的工作机制](#14-vm的工作机制)

<!-- /TOC -->

# 1. Redis之VM机制
<!--
Redis之VM机制
https://www.codenong.com/cs106843764/
https://blog.csdn.net/weixin_43618070/article/details/83894031
-->
## 1.1. 前言：redis的内存淘汰策略
&emsp; 参考[Redis内存](/docs/microService/Redis/RedisEliminate.md)  

## 1.2. VM介绍
&emsp; Redis处理的速度很快，因为它是基于内存的。在内存能够足够容纳数据的时候，所有的数据都存放在内存。这个时候不论是读取数据还是写入数据都是非常快的。但是如果数据量很大，大到内存已经无法全部容纳的时候，我想对存储有一定了解的人都在想，这个时候redis是怎么处理的呢？处理速度是否会直线下降?  

&emsp; 幸亏，答案是否定的。Redis使用到了VM,在redis.conf设置vm-enabled yes 即开启VM功能。  

&emsp; Redis的VM(虚拟内存)机制就是暂时把不经常访问的数据(冷数据)从内存交换到磁盘中，从而腾出宝贵的内存空间用于其它需要访问的数据(热数据)。通过VM功能可以实现冷热数据分离，使热数据仍在内存中、冷数据保存到磁盘。这样就可以避免因为内存不足而造成访问速度下降的问题。Redis提高数据库容量的办法有两种：一种是可以将数据分割到多个Redis Server上；另一种是使用虚拟内存把那些不经常访问的数据交换到磁盘上。需要特别注意的是Redis并没有使用OS提供的Swap，而是自己实现。  

&emsp; **<font color = "clime">Redis为了保证查找的速度，只会将value交换出去，而在内存中保留所有的Key。</font>** 所以它非常适合Key很小，Value很大的存储结构。如果Key很大，value很小，那么vm可能还是无法满足需求。   

## 1.3. VM相关配置  
&emsp; 通过在redis的redis.conf文件里，设置VM的相关参数来实现数据在内存和磁盘之间 换入和 换出操作。相关配置如下：  
```text	
#开启vm功能
vm-enabled yes
#交换出来的value保存的文件路径
vm-swap-file /tmp/redis.swap
#设置当内存消耗达到上限时开始将value交换出来
vm-max-memory 1000000
#设置单个页面的大小，单位是字节
vm-page-size 32
#设置最多能交换保存多少个页到磁盘
vm-pages 13417728
#设置完成交换动作的工作线程数，设置为0表示不使用工作线程而使用主线程,这会以阻塞的方式来运行。建议设置成CPU核个数
vm-max-threads 4
```
&emsp; redis规定同一个数据页面只能保存一个对象，但一个对象可以保存在多个数据页面中。在redis使用的内存没超过vm-max-memory时，是不会交换任何value到磁盘上的。当超过最大内存限制后，redis会选择较老的对象(如果两个对象一样老会优先交换比较大的对象)将它从内存中移除，这样会更加节约内存。  
&emsp; 对于Redis来说，一个数据页面只会保存一个对象，也就是一个Value值，所以应该将vm-page-size设置成大多数value可以保存进去。如果设置太小，一个value对象就会占用几个数据页面，如果设置太大，就会造成页面空闲空间浪费。   

## 1.4. VM的工作机制  
&emsp; redis的VM的工作机制分为两种：一种是vm-max-threads=0，一种是vm-max-threads>0。  

1. 第一种：vm-max-threads = 0
    * 数据换出：主线程定期检查使用的内存大小，如果发现内存超出最大上限，会直接以阻塞的方式，将选中的对象 换出 到磁盘上(保存到文件中)，并释放对象占用的内存，此过程会一直重复，直到下面条件满足任意一条才结束：  
    &emsp; 1.内存使用降到最大限制以下。  
    &emsp; 2.设置的交换文件数量达到上限。  
    &emsp; 3.几乎全部的对象都被交换到磁盘了。  
    * 数据换入：当有client请求key对应的value已被换出到磁盘中时，主线程会以阻塞的方式从换出文件中加载对应的value对象，加载时此时会阻塞所有client，然后再处理client的请求。这种方式会阻塞所有的client。
2. 第二种：vm-max-threads > 0
    * 数据换出：当主线程检测到使用内存超过最大上限，会将选中的要交换的数据放到一个队列中交由工作线程后台处理，主线程会继续处理client请求。  
    * 数据换入：当有client请求key的对应的value已被换出到磁盘中时，主线程先阻塞当前client，然后将加载对象的信息放到一个队列中，让工作线程去加载，此时进主线程继续处理其他client请求。加载完毕后工作线程通知主线程，主线程再执行被阻塞的client的命令。这种方式只阻塞单个client。  

&emsp; 总结：Redis直接自己构建了VM 机制 ，不会像一般的系统会调用系统函数处理，会浪费一定的时间去 移动 和 请求，而Redis不存在。这也是Redis能够那么快的一个原因。   
