
<!-- TOC -->

- [1. 消息驱动模式（Message Driven）](#1-消息驱动模式message-driven)
    - [1.1. 本地消息表（异步确保）-强一致性](#11-本地消息表异步确保-强一致性)
        - [1.1.1. 实现流程](#111-实现流程)
        - [1.1.2. 特点](#112-特点)
    - [1.2. 事务消息-最终一致性](#12-事务消息-最终一致性)
        - [1.2.1. 实现流程](#121-实现流程)
        - [1.2.2. 特点](#122-特点)
    - [1.3. 最大努力通知-最终一致性](#13-最大努力通知-最终一致性)
        - [1.3.1. 实现流程](#131-实现流程)
        - [1.3.2. 特点](#132-特点)
- [2. 事件溯源模式(Event Sourcing)，Saga事务模型-最终一致性](#2-事件溯源模式event-sourcingsaga事务模型-最终一致性)
    - [2.1. Saga组成](#21-saga组成)
    - [2.2. Saga的使用条件](#22-saga的使用条件)
    - [2.3. Saga相关实现](#23-saga相关实现)
    - [2.4. Saga协调](#24-saga协调)
        - [2.4.1. 编排（Choreography）](#241-编排choreography)
            - [2.4.1.1. 实现流程](#2411-实现流程)
            - [2.4.1.2. 特点](#2412-特点)
        - [2.4.2. 控制（Orchestration）](#242-控制orchestration)
            - [2.4.2.1. 实现流程](#2421-实现流程)
                - [2.4.2.1.1. 使用状态机建模SAGA ORCHESTRATORS](#24211-使用状态机建模saga-orchestrators)
                - [2.4.2.1.2. SAGA控制和事务消息](#24212-saga控制和事务消息)
            - [2.4.2.2. 特点](#2422-特点)

<!-- /TOC -->


# 1. 消息驱动模式（Message Driven） 
## 1.1. 本地消息表（异步确保）-强一致性  
&emsp; <font color = "red">本地消息表核心思想是将分布式事务拆分成本地事务进行处理。</font>  

### 1.1.1. 实现流程  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/microService/problems/problem-6.png)  
&emsp; **基本思路：**  
&emsp; 消息生产方，需要额外建一个消息表，并记录消息发送状态。消息表和业务数据要在一个事务里提交，也就是说要在一个数据库里面。然后消息会经过MQ发送到消息的消费方。如果消息发送失败，会进行重试发送。  
&emsp; 消息消费方，需要处理这个消息，并完成自己的业务逻辑。此时如果本地事务处理成功，表明已经处理成功了，如果处理失败，那么就会重试执行。如果是业务上面的失败，可以给生产方发送一个业务补偿消息，通知生产方进行回滚等操作。  
&emsp; 生产方和消费方定时扫描本地消息表，把还没处理完成的消息或者失败的消息再发送一遍。  

&emsp; **具体流程：**  

        A 系统在自己本地一个事务里操作同时，插入一条数据到消息表；  
        接着A系统将这个消息发送到MQ中去；  
        B系统接收到消息之后，在一个事务里，往自己本地消息表里插入一条数据，同时执行其他的业务操作，如果这个消息已经被处理过了，那么此时这个事务会回滚，这样保证不会重复处理消息；  
        B系统执行成功之后，就会更新自己本地消息表的状态以及A系统消息表的状态；  
        如果B系统处理失败了，那么就不会更新消息表状态，那么此时A系统会定时扫描自己的消息表，如果有未处理的消息，会再次发送到MQ中去，让B再次处理；  
        这个方案保证了最终一致性，哪怕B事务失败了，但是A会不断重发消息，直到B那边成功为止。  

### 1.1.2. 特点  

* 优点：从应用设计开发的角度实现了消息数据的可靠性，消息数据的可靠性不依赖于消息中间件，弱化了对 MQ 中间件特性的依赖。  
* 缺点：与具体的业务场景绑定，耦合性强，不可公用。消息数据与业务数据同库，占用业务系统资源。业务系统在使用关系型数据库的情况下，消息服务性能会受到关系型数据库并发性能的局限。  

## 1.2. 事务消息-最终一致性  
&emsp; 该方案基于本地消息表进行优化，不使用本地消息表，而是基于MQ，RocketMQ中间件能够支持一种事务消息机制，确保本地操作和发送消息的异步处理达到本地事务的结果一致。（RocketMQ支持事务消息，RabbitMQ和Kafka都不支持事务消息）  

### 1.2.1. 实现流程  
&emsp; 事务消息作为一种异步确保型事务，将两个事务分支通过MQ进行异步解耦，事务消息的设计流程同样借鉴了两阶段提交理论，整体交互流程如下图所示：  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/microService/problems/problem-7.png)  
&emsp; 事务发起方发送 Prepare 消息到消息中间件。  
&emsp; 发送成功后，执行本地事务。如果事务执行成功，则 Commit，消息中间件将消息下发至消费端。如果事务执行失败，则回滚，消息中间件将这条 Prepare 消息删除。如果执行本地事务过程中，执行端挂掉，或者超时，MQ将会不停的询问其同组的其它producer来获取状态。  
&emsp; 消费端接收到消息进行消费，如果消费失败，则不断重试。  

### 1.2.2. 特点  

* 优点：  
    * 消息数据独立存储，降低业务系统与消息系统之间的耦合。
    * 吞吐量优于本地消息表方案。
* 缺点：
    * 一次消息发送需要两次网络请求(half消息 + commit/rollback)。
    * 需要实现消息回查接口。

## 1.3. 最大努力通知-最终一致性  
&emsp; 最大努力通知型( Best-effort delivery)是最简单的一种柔性事务，适用于一些最终一致性时间敏感度低的业务，且被动方处理结果不影响主动方的处理结果。典型的使用场景：如银行通知、商户通知、短信、邮件等。最大努力通知其实就是消息中间件的使用。  

### 1.3.1. 实现流程  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/microService/problems/problem-8.png)  
&emsp; 在该系统中，A系统执行完本地事务，向MQ发送消息，最大努力通知服务消费消息，比如消息服务，然后调用B系统的接口，执行B系统的本地事务，如果B系统执行成功则OK，否则不断重试，重复多次之后还是失败的话就放弃执行。 
 
### 1.3.2. 特点  
&emsp; **最大努力通知方案和可靠消息最终一致性方案的区别：**  
&emsp; 可靠消息最终一致性方案可以保证的是只要系统A的事务完成，通过不停（无限次）重试来保证系统B的事务总会完成。但是最大努力方案就不同，如果系统B本地事务执行失败了，那么它会重试N次后就不再重试，系统B的本地事务可能就不会完成了。  

# 2. 事件溯源模式(Event Sourcing)，Saga事务模型-最终一致性  
<!--

Saga的核心就是补偿，一阶段就是服务的正常顺序调用（数据库事务正常提交），如果都执行成功，则第二阶段则什么都不做；但如果其中有执行发生异常，则依次调用其补偿服务（一般多逆序调用未已执行服务的反交易）来保证整个交易的一致性。应用实施成本一般。
TCC的特点在于业务资源检查与加锁，一阶段进行校验，资源锁定，如果第一阶段都成功，二阶段对锁定资源进行交易逻辑，否则，对锁定资源进行释放。应用实施成本较高。
基于可靠消息最终一致，一阶段服务正常调用，同时同事务记录消息表，二阶段则进行消息的投递，消费。应用实施成本较低
-->

<!--
~~
https://www.jianshu.com/p/e4b662407c66?from=timeline&isappinstalled=0
https://mp.weixin.qq.com/s/HDSWK2eCOtusroV3Elv1jA

~~
-->

&emsp; Saga模式是一种分布式异步事务，一种最终一致性事务，是一种柔性事务。  
&emsp; Saga模型起源于1987年 Hector Garcia-Molina，Kenneth Salem 发表的论文《Sagas》，是分布式事务相关概念最早出现的。  
&emsp; Saga是一个长活事务可被分解成可以交错运行的子事务集合。其中每个子事务都是一个保持数据库一致性的真实事务。  

    长事务(Long-Lived Transactions)，顾名思义，就是执行时间较长的事务。  

&emsp; <font color = "red">Saga模型可以将一个分布式事务拆分为多个本地事务，每个本地事务都有相应的执行模块和补偿模块（对应TCC中的Confirm和Cancel），当Saga事务中任意一个本地事务出错时，可以通过调用相关的补偿方法恢复之前的事务，达到事务最终一致性。</font>  

## 2.1. Saga组成

&emsp; **Saga的组成：**  

* 每个Saga由一系列sub-transaction Ti 组成  
* 每个Ti 都有对应的补偿动作Ci，补偿动作用于撤销Ti造成的结果  

&emsp; 可以看到，<font color = "red">和TCC相比，Saga没有“预留”动作，它的Ti就是直接提交到库。</font>  

&emsp; **Saga的执行顺序有两种：**  

* T1, T2, T3, ..., Tn  
* T1, T2, ..., Tj, Cj,..., C2, C1，其中0 < j < n  

&emsp; **数据隔离性：**  

* 业务层控制并发
* 在应用层加锁
* 应用层预先冻结资源等

&emsp; **Saga定义了两种恢复策略：**  

* <font color = "red">backward recovery，向后恢复，补偿所有已完成的事务，如果任一子事务失败。</font>即上面提到的第二种执行顺序，其中j是发生错误的sub-transaction，这种做法的效果是撤销掉之前所有成功的sub-transation，使得整个Saga的执行结果撤销。  
* <font color = "red">forward recovery，向前恢复，重试失败的事务，假设每个子事务最终都会成功。适用于必须要成功的场景。</font>执行顺序是类似于这样的：T1, T2, ..., Tj(失败), Tj(重试),..., Tn，其中j是发生错误的sub-transaction。该情况下不需要Ci。  

    &emsp; 显然，向前恢复没有必要提供补偿事务，如果业务中，子事务（最终）总会成功，或补偿事务难以定义或不可能，向前恢复更符合你的需求。  
    &emsp; 理论上补偿事务永不失败，然而，在分布式世界中，服务器可能会宕机，网络可能会失败，甚至数据中心也可能会停电。在这种情况下我们能做些什么？ 最后的手段是提供回退措施，比如人工干预。  

## 2.2. Saga的使用条件  
&emsp; 所有长活事务都可以使用Saga吗？这里有一些限制：  

* Saga只允许两个层次的嵌套，顶级的Saga和简单子事务
* 在外层，全原子性不能得到满足。也就是说，sagas可能会看到其他sagas的部分结果
* 每个子事务应该是独立的原子行为
* 在业务场景下，各个业务环境（如：航班预订、租车、酒店预订和付款）是自然独立的行为，而且每个事务都可以用对应服务的数据库保证原子操作。

&emsp; 补偿也有需考虑的事项：

* 补偿事务从语义角度撤消了事务Ti的行为，但未必能将数据库返回到执行Ti时的状态。（例如，如果事务触发导弹发射， 则可能无法撤消此操作）

&emsp; 但这对业务来说不是问题。其实难以撤消的行为也有可能被补偿。例如，发送电邮的事务可以通过发送解释问题的另一封电邮来补偿。  

&emsp; **对于ACID的保证：**    
&emsp; 从Saga模型的上述定义中，Saga 模型可以满足事务的三个特性：  

* 原子性：Saga 协调器协调事务链中的本地事务要么全部提交，要么全部回滚。
* 一致性：Saga 事务可以实现最终一致性。
* 持久性：基于本地事务，所以这个特性可以很好实现。

&emsp; 从数据隔离性上分析，可以发现Saga模型无法保证外部的原子性和隔离性，因为可以查看其他sagas的部分结果，论文中有对应的表述：  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/microService/problems/problem-42.png)  


&emsp; **<font color = "lime">注意事项：</font>**   
&emsp; <font color = "red">Saga 事务和 TCC 事务一样，都是强依靠业务改造，所以要求业务方在设计上要遵循三个策略：</font>

* 允许空补偿：网络异常导致事务的参与方只收到了补偿操作指令，因为没有执行过正常操作，因此要进行空补偿。  
* 保持幂等性：事务的正向操作和补偿操作都可能被重复触发，因此要保证操作的幂等性。  
* 防止资源悬挂：原因是网络异常导致事务的正向操作指令晚于补偿操作指令到达，则要丢弃本次正常操作，否则会出现资源悬挂问题。  

&emsp; **<font color = "lime">Saga和TCC对比：</font>**  
&emsp; 虽然 Saga 和 TCC 都是补偿事务，但是由于提交阶段不同，所以两者也是有不同的：  

* <font color = "red">Saga 没有Try行为，直接Commit，所以会留下原始事务操作的痕迹，Cancel属于不完美补偿，需要考虑对业务上的影响。</font>TCC Cancel是完美补偿的Rollback，补偿操作会彻底清理之前的原始事务操作，用户是感知不到事务取消之前的状态信息的。
* Saga 的补偿操作通常可以异步执行，TCC的Cancel和Confirm可以根据需要是否异步化。
* Saga 对业务侵入较小，只需要提供一个逆向操作的Cancel即可；而TCC需要对业务进行全局性的流程改造。
* TCC最少通信次数为2n，而Saga为n（n=子事务的数量）。 

## 2.3. Saga相关实现
**Saga Log**  
&emsp; Saga保证所有的子事务都得以完成或补偿，但Saga系统本身也可能会崩溃。Saga崩溃时可能处于以下几个状态：  

* Saga收到事务请求，但尚未开始。因子事务对应的微服务状态未被Saga修改，什么也不需要做。
* 一些子事务已经完成。重启后，Saga必须接着上次完成的事务恢复。
* 子事务已开始，但尚未完成。由于远程服务可能已完成事务，也可能事务失败，甚至服务请求超时，saga只能重新发起之前未确认完成的子事务。这意味着子事务必须幂等。
* 子事务失败，其补偿事务尚未开始。Saga必须在重启后执行对应补偿事务。
* 补偿事务已开始但尚未完成。解决方案与上一个相同。这意味着补偿事务也必须是幂等的。
* 所有子事务或补偿事务均已完成，与第一种情况相同。  

&emsp; 为了恢复到上述状态，必须追踪子事务及补偿事务的每一步。可以通过事件的方式达到以上要求，并将以下事件保存在名为saga log的持久存储中：

* Saga started event 保存整个saga请求，其中包括多个事务/补偿请求
* Transaction started event 保存对应事务请求
* Transaction ended event 保存对应事务请求及其回复
* Transaction aborted event 保存对应事务请求和失败的原因
* Transaction compensated event 保存对应补偿请求及其回复
* Saga ended event 标志着saga事务请求的结束，不需要保存任何内容

![image](https://gitee.com/wt1814/pic-host/raw/master/images/microService/problems/problem-43.png)  

&emsp; <font color = "red">通过将这些事件持久化在saga log中，可以将saga恢复到上述任何状态。</font>  

&emsp; 由于Saga只需要做事件的持久化，而事件内容以JSON的形式存储，Saga log的实现非常灵活，数据库（SQL或NoSQL），持久消息队列，甚至普通文件可以用作事件存储， 当然有些能更快得帮saga恢复状态。  

**注意事项**  
&emsp; 对于服务来说，实现Saga有以下这些要求：  
1. Ti和Ci是幂等的。
2. Ci必须是能够成功的，如果无法成功则需要人工介入。
3. Ti - Ci和Ci - Ti的执行结果必须是一样的：sub-transaction被撤销了。

&emsp; 第一点要求Ti和Ci是幂等的，举个例子，假设在执行Ti的时候超时了，此时是不知道执行结果的，如果采用forward recovery策略就会再次发送Ti，那么就有可能出现Ti被执行了两次，所以要求Ti幂等。如果采用backward recovery策略就会发送Ci，而如果Ci也超时了，就会尝试再次发送Ci，那么就有可能出现Ci被执行两次，所以要求Ci幂等。  
&emsp; 第二点要求Ci必须能够成功，这个很好理解，因为，如果Ci不能执行成功就意味着整个Saga无法完全撤销，这个是不允许的。但总会出现一些特殊情况比如Ci的代码有bug、服务长时间崩溃等，这个时候就需要人工介入了。  
&emsp; 第三点乍看起来比较奇怪，举例说明，还是考虑Ti执行超时的场景，我们采用了backward recovery，发送一个Ci，那么就会有三种情况：  

* Ti的请求丢失了，服务之前没有、之后也不会执行Ti
* Ti在Ci之前执行
* Ci在Ti之前执行

&emsp; 对于第1种情况，容易处理。对于第2、3种情况，则要求Ti和Ci是可交换的（commutative)，并且其最终结果都是sub-transaction被撤销。  

## 2.4. Saga协调  
&emsp; 协调saga：saga的实现包含协调saga步骤的逻辑。当系统命令启动saga时，协调逻辑必须选择并告知第一个saga参与者执行本地事务。一旦该事务完成，saga的排序协调选择并调用下一个saga参与者。这个过程一直持续到saga执行了所有步骤。如果任何本地事务失败，则saga必须以相反的顺序执行补偿事务。构建一个saga的协调逻辑有几种不同的方法：

* 编排（Choreography）：在saga参与者中分配决策和排序。saga参与者主要通过交换事件进行沟通。
* 控制（Orchestration）：在saga控制类中集中saga的协调逻辑。一个saga控制者向saga参与者发送命令消息，告诉sage参与者要执行哪些操作。

### 2.4.1. 编排（Choreography）
&emsp; <font color = "red">编排模式没有中央协调器（没有单点风险）时，每个服务产生并聆听其他服务的事件，并决定是否应采取行动。</font>  
&emsp; 该实现第一个服务执行一个事务，然后发布一个事件。该事件被一个或多个服务进行监听，这些服务再执行本地事务并发布（或不发布）新的事件，当最后一个服务执行本地事务并且不发布任何事件时，意味着分布式事务结束，或者它发布的事件没有被任何Saga参与者听到都意味着事务结束。 

#### 2.4.1.1. 实现流程  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/microService/problems/problem-30.png)  
1. 订单服务保存新订单，将状态设置为pengding挂起状态，并发布名为ORDER_CREATED_EVENT的事件。
2. 支付服务监听ORDER_CREATED_EVENT，并公布事件BILLED_ORDER_EVENT。
3. 库存服务监听BILLED_ORDER_EVENT，更新库存，并发布ORDER_PREPARED_EVENT。
4. 货运服务监听ORDER_PREPARED_EVENT，然后交付产品。最后，它发布ORDER_DELIVERED_EVENT。
5. 最后，订单服务侦听ORDER_DELIVERED_EVENT并设置订单的状态为concluded完成。

&emsp; 假设库存服务在事务过程中失败了。进行回滚：
1. 库存服务产生PRODUCT_OUT_OF_STOCK_EVENT
2. 订购服务和支付服务会监听到上面库存服务的这一事件：
    1. 支付服务会退款给客户。
    2. 订单服务将订单状态设置为失败。  

#### 2.4.1.2. 特点  
* 优点：事件/编排是实现Saga模式的自然方式; 它很简单，容易理解，不需要太多的努力来构建，所有参与者都是松散耦合的，因为它们彼此之间没有直接的耦合。如果事务涉及2至4个步骤，则可能是非常合适的。  

### 2.4.2. 控制（Orchestration）  
&emsp; 中央协调器负责集中处理事件的决策和业务逻辑排序。  
&emsp; saga协调器orchestrator以命令/回复的方式与每项服务进行通信，告诉服务应该执行哪些操作。  


#### 2.4.2.1. 实现流程  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/microService/problems/problem-31.png)  
1. 订单服务保存pending状态，并要求订单Saga协调器（简称OSO）开始启动订单事务。
2. OSO向收款服务发送执行收款命令，收款服务回复Payment Executed消息。
3. OSO向库存服务发送准备订单命令，库存服务将回复OrderPrepared消息。
4. OSO向货运服务发送订单发货命令，货运服务将回复Order Delivered消息。

&emsp; OSO订单Saga协调器必须事先知道执行“创建订单”事务所需的流程(通过读取BPM业务流程XML配置获得)。如果有任何失败，它还负责通过向每个参与者发送命令来撤销之前的操作来协调分布式的回滚。当有一个中央协调器协调一切时，回滚要容易得多，因为协调器默认是执行正向流程，回滚时只要执行反向流程即可。  

##### 2.4.2.1.1. 使用状态机建模SAGA ORCHESTRATORS  
&emsp; 建模saga orchestrator的好方法是作为状态机。状态机由一组状态和一组由事件触发的状态之间的转换组成。每个transition都可以有一个action，对于一个saga来说是一个saga参与者的调用。状态之间的转换由saga参与者执行的本地事务的完成触发。当前状态和本地事务的特定结果决定了状态转换以及执行的操作（如果有的话）。对状态机也有有效的测试策略。因此，使用状态机模型可以更轻松地设计、实施和测试。  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/microService/problems/problem-44.png)  

&emsp; 图显示了Create Order Saga的状态机模型。此状态机由多个状态组成，包括以下内容：

* Verifying Consumer：初始状态。当处于此状态时，该saga正在等待消费者服务部门验证消费者是否可以下订单。  
* Creating Ticket：该saga正在等待对创建票证命令的回复。  
* Authorizing Card：等待Accounting服务授权消费者的信用卡。  
* OrderApproved：表示saga成功完成的最终状态。  
* Order Rejected：最终状态表明该订单被其中一方参与者们拒绝。  

##### 2.4.2.1.2. SAGA控制和事务消息
&emsp; 基于业务流程的saga的每个步骤都包括更新数据库和发布消息的服务。例如，Order Service持久保存Order和Create Order Saga orchestrator，并向第一个saga参与者发送消息。一个saga参与者，例如Kitchen Service，通过更新其数据库并发送回复消息来处理命令消息。 Order Service通过更新saga协调器的状态并向下一个saga参与者发送命令消息来处理参与者的回复消息。服务必须使用事务性消息传递，以便自动更新数据库并发布消息。  


#### 2.4.2.2. 特点  
* 优点：
    * 避免服务之间的循环依赖关系，因为saga协调器会调用saga参与者，但参与者不会调用协调器。
    * 集中分布式事务的编排。
    * 只需要执行命令/回复(其实回复消息也是一种事件消息)，降低参与者的复杂性。
    * 在添加新步骤时，事务复杂性保持线性，回滚更容易管理。
    * 如果在第一笔交易还没有执行完，想改变有第二笔事务的目标对象，则可以轻松地将其暂停在协调器上，直到第一笔交易结束。
* 缺点：协调器中集中太多逻辑的风险。  
