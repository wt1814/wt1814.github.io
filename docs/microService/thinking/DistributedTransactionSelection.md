
<!-- TOC -->

- [1. 分布式事务的选型](#1-分布式事务的选型)
    - [1.1. 选型取舍关键](#11-选型取舍关键)
    - [1.2. 具体选型](#12-具体选型)
    - [1.3. 结论：并非一种事务形态就能打遍天下](#13-结论并非一种事务形态就能打遍天下)

<!-- /TOC -->

&emsp; **<font color = "blue">总结：</font>**  
&emsp; 分布式事务的选型：(判断事务发起方与事务被调用方的关系、以及数据一致的要求)  
* **<font color = "blue">事务被调用方跟随事务发起方，使用最终一致性的消息事务；(基于消息实现的事务适用于分布式事务的提交或回滚只取决于事务发起方的业务需求)</font>**  
* **<font color = "blue">事务被调用方与事务发起方协助完成功能，使用补偿性事务；</font>**  
    * 事务被调用方与事务发起方协助完成功能，事务被调用方与事务发起方的数据保持一致性，使用强一致性的TCC；  
    * SAGA可以看做一个异步的、利用队列实现的补偿事务。适用于不需要同步返回发起方执行最终结果、可以进行补偿、对性能要求较高、不介意额外编码的业务场景。
* **<font color = "blue">单体服务，多数据源，使用XA协议的服务；</font>**

# 1. 分布式事务的选型  
&emsp; 一个好的分布式事务框架应用尽可能满足以下特性：  

* 业务改造成本低；
* 性能损耗低；
* 隔离性保证完整。

## 1.1. 选型取舍关键  

1. 分布式中间件的选型一般基于数据一致性的cap、base理论考虑。重点回顾一下<font color = "red">数据一致性：</font> 

    * 强一致性：数据更新成功后，任意时刻所有副本中的数据都是一致的，一般采用同步的方式实现。  
    * 弱一致性：数据更新成功后，系统不承诺立即可以读到最新写入的值，也不承诺具体多久之后可以读到。    
    * 最终一致性：弱一致性的一种形式，数据更新成功后，系统不承诺立即可以返回最新写入的值，但是保证最终会返回上一次更新操作的值。  
    * 单调一致性(monotonic consistency)。任何时刻，任何用户一旦读到某个数据在某次更新后的值，那么就不会再读到比这个值更旧的值。也就是说，可获取的数据顺序必是单调递增的。
    * 会话一致性(session consistency)。任何用户在某次会话中，一旦读到某个数据在某次更新后的值，那么在本次会话中就不会再读到比这值更旧的值会话一致性是在单调一致性的基础上进一步放松约束，只保证单个用户单个会话内的单调性，在不同用户或同一用户不同会话间则没有保障。示例case：php的session概念。 

2. 除了数据一致性的考虑外，最大的考虑因素就是性能。  

3. <font color = "red">分布式事务解决方案如下：</font>  

    * 一致性协议-XA两阶段提交
    * 一致性协议-XA三阶段提交
    * TCC模式
    * Saga事务模型-最终一致性 
    * 消息驱动模式(Message Driven)
        * 本地消息表(异步确保)-强一致性
        * 事务消息-最终-致性
        * 最大努力通知-最终-致性

## 1.2. 具体选型  
<!-- 
https://www.cnblogs.com/Joy-Hu/p/10766350.html
-->
&emsp; **何时选择基于消息实现的事务？**  
&emsp; <font color = "blue">基于消息实现的事务适用于分布式事务的提交或回滚只取决于事务发起方的业务需求，其他数据源的数据变更跟随发起方进行的业务场景。</font>  

&emsp; 举个例子，假设存在业务规则：某笔订单成功后，为用户加一定的积分。  
&emsp; 在这条规则里，管理订单数据源的服务为事务发起方，管理积分数据源的服务为事务跟随者。  
&emsp; 从这个过程可以看到，基于消息队列实现的事务存在以下操作：  

* 订单服务创建订单，提交本地事务  
* 订单服务发布一条消息  
* 积分服务收到消息后加积分  

&emsp; 可以看到它的整体流程是比较简单的，同时业务开发工作量也不大：  

* 编写订单服务里订单创建的逻辑
* 编写积分服务里增加积分的逻辑

&emsp; 可以看到该事务形态过程简单，性能消耗小，发起方与跟随方之间的流量峰谷可以使用队列填平，同时业务开发工作量也基本与单机事务没有差别，都不需要编写反向的业务逻辑过程。因此基于消息队列实现的事务是除了单机事务外最优先考虑使用的形态。

---
&emsp; **何时选择利用补偿实现的事务？**  
&emsp; 基于消息实现的事务并不能解决所有的业务场景，例如以下场景：某笔订单完成时，同时扣掉用户的现金。  
&emsp; 这里事务发起方是管理订单库的服务，但对整个事务是否提交并不能只由订单服务决定，因为还要确保用户有足够的钱，才能完成这笔交易，而这个信息在管理现金的服务里。这里可以引入基于补偿实现的事务，其流程如下：  

* 创建订单数据，但暂不提交本地事务
* 订单服务发送远程调用到现金服务，以扣除对应的金额
* 上述步骤成功后提交订单库的事务

&emsp; 以上这个是正常成功的流程，异常流程需要回滚的话，将额外发送远程调用到现金服务以加上之前扣掉的金额。  
&emsp; 以上流程比基于消息队列实现的事务的流程要复杂，同时开发的工作量也更多：  

* 编写订单服务里创建订单的逻辑
* 编写现金服务里扣钱的逻辑
* 编写现金服务里补偿返还的逻辑

&emsp; 可以看到，该事务流程相对于基于消息实现的分布式事务更为复杂，需要额外开发相关的业务回滚方法，也失去了服务间流量削峰填谷的功能。但其仅仅只比基于消息的事务复杂多一点，若不能使用基于消息队列的最终一致性事务，那么可以优先考虑使用基于补偿的事务形态。

&emsp; **何时选择利用TCC实现的事务?**  
&emsp; 基于补偿的事务形态也并非能实现所有的需求，如以下场景：某笔订单完成时，同时扣掉用户的现金，但交易未完成，也未被取消时，不能让客户看到钱变少了。  

&emsp; 这时可以引入TCC，其流程如下：

* 订单服务创建订单
* 订单服务发送远程调用到现金服务，冻结客户的现金
* 提交订单服务数据
* 订单服务发送远程调用到现金服务，扣除客户冻结的现金

&emsp; 以上是正常完成的流程，若为异常流程，则需要发送远程调用请求到现金服务，撤销冻结的金额。  
&emsp; 以上流程比基于补偿实现的事务的流程要复杂，同时开发的工作量也更多：

* 订单服务编写创建订单的逻辑
* 现金服务编写冻结现金的逻辑
* 现金服务编写扣除现金的逻辑
* 现金服务编写解冻现金的逻辑

&emsp; TCC实际上是最为复杂的一种情况，其能处理所有的业务场景，但无论出于性能上的考虑，还是开发复杂度上的考虑，都应该尽量避免该类事务。  

&emsp; **何时选择利用SAGA实现的事务？**  
&emsp; **<font color = "red">SAGA可以看做一个异步的、利用队列实现的补偿事务。其适用于无需马上返回业务发起方最终状态的场景，例如：请求已提交，请稍后查询或留意通知之类。</font>**  

&emsp; 将上述补偿事务的场景用SAGA改写，其流程如下：

* 订单服务创建最终状态未知的订单记录，并提交事务
* 现金服务扣除所需的金额，并提交事务
* 订单服务更新订单状态为成功，并提交事务

&emsp; 以上为成功的流程，若现金服务扣除金额失败，那么，最后一步订单服务将会更新订单状态为失败。

&emsp; 其业务编码工作量比补偿事务多一点，包括以下内容：

* 订单服务创建初始订单的逻辑
* 订单服务确认订单成功的逻辑
* 订单服务确认订单失败的逻辑
* 现金服务扣除现金的逻辑
* 现金服务补偿返回现金的逻辑

&emsp; 但其相对于补偿事务形态有性能上的优势，所有的本地子事务执行过程中，都无需等待其调用的子事务执行，减少了加锁的时间，这在事务流程较多较长的业务中性能优势更为明显。同时，其利用队列进行进行通讯，具有削峰填谷的作用。
<font color = "red">因此该形式适用于不需要同步返回发起方执行最终结果、可以进行补偿、对性能要求较高、不介意额外编码的业务场景。</font>  
&emsp; 但当然SAGA也可以进行稍微改造，变成与TCC类似、可以进行资源预留的形态。

---
&emsp; **2PC事务**  
&emsp; 其适用于参与者较少，单个本地事务执行时间较少，并且参与者自身可用性很高的场景，否则，其很可能导致性能下降严重。 


## 1.3. 结论：并非一种事务形态就能打遍天下  
&emsp; 通过分析可以发现，并不存在一种事务形态能解决所有的问题，需要根据特定的业务场景选择合适的事务形态。甚至于有时需要混合多种事务形态才能更好的完成目标，如上面提到的订单、积分、钱包混合的场景：订单的成功与否需要依赖于钱包的余额，但不依赖于积分的多少，因此可以混合基于消息的事务形态以加积分及基于补偿的事务形态以确保扣钱成功，从而得到一个性能更好，编码量更少的形态。  
&emsp; 然而目前很多框架都专注于某单一方面的事务形态，如TCC单独一个框架，可靠消息单独一个框架，SAGA单独一个框架，它们各自独立，容易导致以下问题：

* 由于前期只采用了其中一种类型事务的框架，因为工具目前只有锤子，引入其他工具又涉及测试、阅读代码等过程，因此把所有问题都看做钉子，导致性能偏低或者实现不够优雅。  
* 由于不同框架管理事务的形态可能不一致，导致不能很好的协调工作，如某一个TCC框架和另一个基于消息的事务框架无法很好融合。  

&emsp; 解决方案：Seata、EasyTransaction等混合型分布式事务框架。   

 
---
&emsp; <font color = "blue">不同业务场景应按需引入不同的事务形态，</font>在条件允许的情况下，建议按照如下次序选择对应的事务形态：  

* 单机事务》基于消息的事务》基于补偿的事务》TCC事务  
* 因SAGA事务的形态需要配合较为明显的前端业务交互变更，建议在单一事务执行过程较长、存在较多子事务，并且无法使用基于消息的事务形态时使用。  
