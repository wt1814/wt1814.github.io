
<!-- TOC -->

- [1. 分布式事务](#1-分布式事务)
    - [1.1. 消息驱动模式（Message Driven）](#11-消息驱动模式message-driven)
        - [1.1.1. 本地消息表/消息状态表（异步确保）-最终一致性](#111-本地消息表消息状态表异步确保-最终一致性)
            - [1.1.1.1. 实现流程](#1111-实现流程)
            - [1.1.1.2. 特点](#1112-特点)
        - [1.1.2. ~~事务消息-最终一致性~](#112-事务消息-最终一致性)
            - [1.1.2.1. 实现流程](#1121-实现流程)
            - [1.1.2.2. 特点](#1122-特点)
        - [1.1.3. 最大努力通知-最终一致性](#113-最大努力通知-最终一致性)
            - [1.1.3.1. 实现流程](#1131-实现流程)
            - [1.1.3.2. 特点](#1132-特点)

<!-- /TOC -->

# 1. 分布式事务


## 1.1. 消息驱动模式（Message Driven） 
&emsp; eBay 的架构师 Dan Pritchett，曾在一篇解释 BASE 原理的论文《Base：An Acid Alternative》中提到一个 eBay 分布式系统一致性问题的解决方案。  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/microService/problems/problem-46.png)  
&emsp; 它的核心思想是将需要分布式处理的任务通过消息或者日志的方式来异步执行，消息或日志可以存到本地文件、数据库或消息队列，再通过业务规则进行失败重试，它要求各服务的接口是幂等的。  

### 1.1.1. 本地消息表/消息状态表（异步确保）-最终一致性  
#### 1.1.1.1. 实现流程  
&emsp; 本地消息就是利用了本地事务，会在数据库中存放一直本地事务消息表，在进行本地事务操作中加入了本地消息的插入， **即将业务的执行和将消息放入消息表中的操作放在同一个事务中提交。**  
&emsp; 这样本地事务执行成功的话，消息肯定也插入成功，然后再调用(调用方式可以是同步、异步、mq)其他服务，如果调用成功就修改这条本地消息的状态。  
&emsp; **如果失败也不要紧，会有一个后台线程扫描，发现这些状态的消息，会一直调用相应的服务，一般会设置重试的次数，如果一直不行则特殊记录，待人工介入处理。**  
&emsp; 可以看到还是很简单的，也是一种最大努力通知思想。  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/microService/problems/problem-47.png)  

---
![image](https://gitee.com/wt1814/pic-host/raw/master/images/microService/problems/problem-6.png)  
&emsp; **基本思路：**  
&emsp; 消息生产方，需要额外建一个消息表，并记录消息发送状态。消息表和业务数据要在一个事务里提交，也就是说要在一个数据库里面。然后消息会经过MQ发送到消息的消费方。如果消息发送失败，会进行重试发送。  
&emsp; 消息消费方，需要处理这个消息，并完成自己的业务逻辑。此时如果本地事务处理成功，表明已经处理成功了，如果处理失败，那么就会重试执行。如果是业务上面的失败，可以给生产方发送一个业务补偿消息，通知生产方进行回滚等操作。  
&emsp; 生产方和消费方定时扫描本地消息表，把还没处理完成的消息或者失败的消息再发送一遍。  

&emsp; **具体流程：**  

        A 系统在自己本地一个事务里操作同时，插入一条数据到消息表；  
        接着A系统将这个消息发送到MQ中去；  
        B系统接收到消息之后，在一个事务里，往自己本地消息表里插入一条数据，同时执行其他的业务操作，如果这个消息已经被处理过了，那么此时这个事务会回滚，这样保证不会重复处理消息；  
        B系统执行成功之后，就会更新自己本地消息表的状态以及A系统消息表的状态；  
        如果B系统处理失败了，那么就不会更新消息表状态，那么此时A系统会定时扫描自己的消息表，如果有未处理的消息，会再次发送到MQ中去，让B再次处理；  
        这个方案保证了最终一致性，哪怕B事务失败了，但是A会不断重发消息，直到B那边成功为止。  

#### 1.1.1.2. 特点  

* 优点：从应用设计开发的角度实现了消息数据的可靠性，消息数据的可靠性不依赖于消息中间件，弱化了对MQ中间件特性的依赖。  
* 缺点：与具体的业务场景绑定，耦合性强，不可公用。消息数据与业务数据同库，占用业务系统资源。业务系统在使用关系型数据库的情况下，消息服务性能会受到关系型数据库并发性能的局限。  

### 1.1.2. ~~事务消息-最终一致性~  
&emsp; 该方案基于本地消息表进行优化，不使用本地消息表，而是基于事务消息，确保本地操作和发送消息的异步处理达到本地事务的结果一致。    

#### 1.1.2.1. 实现流程  
&emsp; 事务消息作为一种异步确保型事务，将两个事务分支通过MQ进行异步解耦，事务消息的设计流程同样借鉴了两阶段提交理论，整体交互流程如下图所示：  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/microService/problems/problem-7.png)  
&emsp; 事务发起方发送 Prepare 消息到消息中间件。  
&emsp; 发送成功后，执行本地事务。如果事务执行成功，则 Commit，消息中间件将消息下发至消费端。如果事务执行失败，则回滚，消息中间件将这条 Prepare 消息删除。如果执行本地事务过程中，执行端挂掉，或者超时，MQ将会不停的询问其同组的其它producer来获取状态。  
&emsp; 消费端接收到消息进行消费，如果消费失败，则不断重试。  

#### 1.1.2.2. 特点  

* 优点：  
    * 消息数据独立存储，降低业务系统与消息系统之间的耦合。
    * 吞吐量优于本地消息表方案。
* 缺点：
    * 一次消息发送需要两次网络请求(half消息 + commit/rollback)。
    * 需要实现消息回查接口。

### 1.1.3. 最大努力通知-最终一致性  
<!-- 
其实我觉得本地消息表也可以算最大努力，事务消息也可以算最大努力。

就本地消息表来说会有后台任务定时去查看未完成的消息，然后去调用对应的服务，当一个消息多次调用都失败的时候可以记录下然后引入人工，或者直接舍弃。这其实算是最大努力了。

事务消息也是一样，当半消息被commit了之后确实就是普通消息了，如果订阅者一直不消费或者消费不了则会一直重试，到最后进入死信队列。其实这也算最大努力。

所以最大努力通知其实只是表明了一种柔性事务的思想：我已经尽力我最大的努力想达成事务的最终一致了。

适用于对时间不敏感的业务，例如短信通知。
-->
&emsp; 最大努力通知型(Best-effort delivery)是最简单的一种柔性事务，适用于一些最终一致性时间敏感度低的业务，且被动方处理结果不影响主动方的处理结果。典型的使用场景：如银行通知、商户通知、短信、邮件等。最大努力通知其实就是消息中间件的使用。  

#### 1.1.3.1. 实现流程  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/microService/problems/problem-8.png)  
&emsp; 在该系统中，A系统执行完本地事务，向MQ发送消息，最大努力通知服务消费消息，比如消息服务，然后调用B系统的接口，执行B系统的本地事务，如果B系统执行成功则OK，否则不断重试，重复多次之后还是失败的话就放弃执行。 
 
#### 1.1.3.2. 特点  
&emsp; **最大努力通知方案和可靠消息最终一致性方案的区别：**  
&emsp; 可靠消息最终一致性方案可以保证的是只要系统A的事务完成，通过不停（无限次）重试来保证系统B的事务总会完成。但是最大努力方案就不同，如果系统B本地事务执行失败了，那么它会重试N次后就不再重试，系统B的本地事务可能就不会完成了。  
