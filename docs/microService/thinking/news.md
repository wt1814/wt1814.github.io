
<!-- TOC -->

- [1. 分布式事务](#1-分布式事务)
    - [1.1. 消息驱动模式(Message Driven)](#11-消息驱动模式message-driven)
        - [1.1.1. 本地消息表/消息状态表(异步确保)-最终一致性](#111-本地消息表消息状态表异步确保-最终一致性)
            - [1.1.1.1. 基本思想(eBay的论文)](#1111-基本思想ebay的论文)
            - [1.1.1.2. 实现流程](#1112-实现流程)
                - [1.1.1.2.1. 方案一：定时任务重试](#11121-方案一定时任务重试)
                - [1.1.1.2.2. 方案二：通过mq重试](#11122-方案二通过mq重试)
            - [1.1.1.3. 特点](#1113-特点)
        - [1.1.2. ~~事务消息-最终一致性~~](#112-事务消息-最终一致性)
            - [1.1.2.1. 实现流程](#1121-实现流程)
            - [1.1.2.2. 特点](#1122-特点)
        - [1.1.3. 最大努力通知-最终一致性](#113-最大努力通知-最终一致性)
            - [1.1.3.1. 实现流程](#1131-实现流程)
            - [1.1.3.2. 特点](#1132-特点)

<!-- /TOC -->

&emsp; **<font color = "red">总结：</font>**  
1. **基于本地消息表：**  
&emsp; 基本思想：调用方存储业务表和消息表；调用其他服务，如果成功修改消息表状态， **<font color = "clime">如果失败发起重试（重试方式可以基于定时任务、mq等）</font>**。    
2. **基于事务消息：** ~~相比于最终一致性方案可靠性高，但也非强一致性。~~   
    1. 调用方开启消息事务；
    2. 发送消息；
    3. 调用方执行本地事务；  
    4. 调用方提交或回滚事务消息。
3. **最大努力通知方案和可靠消息最终一致性方案的区别：**  
&emsp; 可靠消息最终一致性方案可以保证的是只要系统A的事务完成，通过不停(无限次)重试来保证系统B的事务总会完成。但是最大努力方案就不同，如果系统B本地事务执行失败了，那么它会重试N次后就不再重试，系统B的本地事务可能就不会完成了。  


# 1. 分布式事务
## 1.1. 消息驱动模式(Message Driven) 
### 1.1.1. 本地消息表/消息状态表(异步确保)-最终一致性  
#### 1.1.1.1. 基本思想(eBay的论文)
&emsp; eBay的架构师Dan Pritchett，曾在一篇解释BASE原理的论文《Base：An Acid Alternative》中提到一个eBay分布式系统一致性问题的解决方案。  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/microService/problems/problem-46.png)  
&emsp; 它的核心思想是将需要分布式处理的任务通过消息或者日志的方式来异步执行，消息或日志可以存到本地文件、数据库或消息队列， **<font color = "red">再通过业务规则进行失败重试，</font>** 它要求各服务的接口是幂等的。  

#### 1.1.1.2. 实现流程  
##### 1.1.1.2.1. 方案一：定时任务重试
&emsp; 本地消息就是利用了本地事务，会在数据库中存放一张本地事务消息表。  
1. 在进行本地事务操作中加入了本地消息的插入， **即将业务的执行和将消息放入消息表中的操作放在同一个事务中提交。** 这样本地事务执行成功的话，消息肯定也插入成功。  
2. 然后再调用(调用方式可以是同步、异步、mq)其他服务，如果调用成功就修改这条本地消息的状态。 **<font color = "red">如果失败也不要紧，会有一个后台线程扫描，发现这些状态的消息，会一直调用相应的服务，一般会设置重试的次数，如果一直不行则特殊记录，待人工介入处理。</font>**  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/microService/problems/problem-47.png)  

##### 1.1.1.2.2. 方案二：通过mq重试

![image](https://gitee.com/wt1814/pic-host/raw/master/images/microService/problems/problem-6.png)  
&emsp; **基本思路：**  
&emsp; 消息生产方，需要额外建一个消息表，并记录消息发送状态。消息表和业务数据要在一个事务里提交，也就是说要在一个数据库里面。  
&emsp; 然后消息会经过MQ发送到消息的消费方。如果消息发送失败，会进行重试发送。  
&emsp; 消息消费方，需要处理这个消息，并完成自己的业务逻辑。此时如果本地事务处理成功，表明已经处理成功了，如果处理失败，那么就会重试执行。如果是业务上面的失败，可以给生产方发送一个业务补偿消息，通知生产方进行回滚等操作。  
&emsp; 生产方和消费方定时扫描本地消息表，把还没处理完成的消息或者失败的消息再发送一遍。  

&emsp; **具体流程：**  

        A 系统在自己本地一个事务里操作同时，插入一条数据到消息表；  
        接着A系统将这个消息发送到MQ中去；  
        B系统接收到消息之后，在一个事务里，往自己本地消息表里插入一条数据，同时执行其他的业务操作，如果这个消息已经被处理过了，那么此时这个事务会回滚，这样保证不会重复处理消息；  
        B系统执行成功之后，就会更新自己本地消息表的状态以及A系统消息表的状态；  
        如果B系统处理失败了，那么就不会更新消息表状态，那么此时A系统会定时扫描自己的消息表，如果有未处理的消息，会再次发送到MQ中去，让B再次处理；  
        这个方案保证了最终一致性，哪怕B事务失败了，但是A会不断重发消息，直到B那边成功为止。  

#### 1.1.1.3. 特点  

* 优点：从应用设计开发的角度实现了消息数据的可靠性，消息数据的可靠性不依赖于消息中间件，弱化了对MQ中间件特性的依赖。  
* 缺点：与具体的业务场景绑定，耦合性强，不可公用。消息数据与业务数据同库，占用业务系统资源。业务系统在使用关系型数据库的情况下，消息服务性能会受到关系型数据库并发性能的局限。  

### 1.1.2. ~~事务消息-最终一致性~~  
<!-- 
利用事务消息实现分布式事务
https://www.cnblogs.com/chjxbt/p/11412727.html
-->
&emsp; 该方案基于本地消息表进行优化，不使用本地消息表，而是基于事务消息，确保本地操作和发送消息的异步处理达到本地事务的结果一致。    
&emsp; **可以参考[kafka事务消息](/docs/microService/mq/kafka/kafkaTraction.md)的consume-Transform-Produce模式。**  

&emsp; 事务消息适用的场景主要是那些需要异步更新数据，并且对数据实时性要求不太高的场景。比如在创建订单后，如果出现短暂的几秒，购物车里的商品没有被及时情况，也不是完全不可接受的，只要最终购物车的数据和订单数据保持一致就可。  

#### 1.1.2.1. 实现流程  
&emsp; 事务消息需要消息队列提供相应的功能才能实现，kafka和RocketMQ都提供了事务相关功能。  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/microService/problems/problem-48.png)  

* 对于订单系统：  
    * 首先，订单系统在消息队列上开启一个事务。  
    * 然后订单系统给消息服务器发送一个“半消息”，这个半消息不是说消息内容不完整，它包含的内容就是完整的消息内容，半消息和普通消息的唯一区别是，在事务提交之前，对于消费者来说，这个消息是不可见的。  
    * 半消息发送成功后，订单系统就可以执行本地事务了，在订单库中创建一条订单记录，并提交订单库的数据库事务。  
    * 然后根据本地事务的执行结果决定提交或者回滚事务消息。如果订单创建成功，那就提交事务消息，购物车系统就可以消费到这条消息继续后续的流程。如果订单创建失败，那就回滚事务消息，购物车系统就不会收到这条消息。这样就基本实现了“要么都成功，要么都失败”的一致性要求。  
* 对于购物车系统：
    * 对于购物车系统收到订单创建成功消息清理购物车这个操作来说，失败的处理比较简单，只要成功执行购物车清理后再提交消费确认即可，如果失败，由于没有提交消费确认，消息队列会自动重试。


&emsp; 如果在第四步提交事务消息时失败了怎么办？Kafka和RocketMQ给出了2种不同的解决方案：  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/microService/problems/problem-48.png)  
1. Kafka的解决方案：  
&emsp; 直接抛出异常，让用户自行处理。可以在业务代码中反复重试提交，直到提交成功，或者删除之前创建的订单进行补偿。
2. RocketMQ的解决方案：  
&emsp; 在 RocketMQ 中的事务实现中，增加了事务反查的机制来解决事务消息提交失败的问题。如果 Producer 也就是订单系统，在提交或者回滚事务消息时发生网络异常，RocketMQ 的 Broker 没有收到提交或者回滚的请求，Broker 会定期去 Producer 上反查这个事务对应的本地事务的状态，然后根据反查结果决定提交或者回滚这个事务。为了支撑这个事务反查机制，我们的业务代码需要实现一个反查本地事务状态的接口，告知 RocketMQ 本地事务是成功还是失败。  


&emsp; 综合上面讲的通用事务消息的实现和RocketMQ的事务反查机制，使用RocketMQ事务消息功能实现分布式事务的流程如下图：  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/microService/problems/problem-49.png)  

#### 1.1.2.2. 特点  

* 优点：  
    * 消息数据独立存储，降低业务系统与消息系统之间的耦合。
    * 吞吐量优于本地消息表方案。
* 缺点：
    * 一次消息发送需要两次网络请求(half消息 + commit/rollback)。
    * 需要实现消息回查接口。

### 1.1.3. 最大努力通知-最终一致性  
<!-- 
其实我觉得本地消息表也可以算最大努力，事务消息也可以算最大努力。

就本地消息表来说会有后台任务定时去查看未完成的消息，然后去调用对应的服务，当一个消息多次调用都失败的时候可以记录下然后引入人工，或者直接舍弃。这其实算是最大努力了。

事务消息也是一样，当半消息被commit了之后确实就是普通消息了，如果订阅者一直不消费或者消费不了则会一直重试，到最后进入死信队列。其实这也算最大努力。

所以最大努力通知其实只是表明了一种柔性事务的思想：我已经尽力我最大的努力想达成事务的最终一致了。

适用于对时间不敏感的业务，例如短信通知。
-->
&emsp; 最大努力通知型(Best-effort delivery)是最简单的一种柔性事务，适用于一些最终一致性时间敏感度低的业务，且被动方处理结果不影响主动方的处理结果。典型的使用场景：如银行通知、商户通知、短信、邮件等。最大努力通知其实就是消息中间件的使用。  
&emsp; **<font color = "red">此种模式可以认为是mq的一般使用。</font>**

#### 1.1.3.1. 实现流程  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/microService/problems/problem-8.png)  
&emsp; 在该系统中，A系统执行完本地事务，向MQ发送消息，最大努力通知服务消费消息，比如消息服务，然后调用B系统的接口，执行B系统的本地事务，如果B系统执行成功则OK，否则不断重试，重复多次之后还是失败的话就放弃执行。 
 
#### 1.1.3.2. 特点  
&emsp; **最大努力通知方案和可靠消息最终一致性方案的区别：**  
&emsp; 可靠消息最终一致性方案可以保证的是只要系统A的事务完成，通过不停(无限次)重试来保证系统B的事务总会完成。但是最大努力方案就不同，如果系统B本地事务执行失败了，那么它会重试N次后就不再重试，系统B的本地事务可能就不会完成了。  
