<!-- TOC -->

- [1. ~~MySql分布式锁~~](#1-mysql分布式锁)
    - [1.1. 基于表记录实现](#11-基于表记录实现)
    - [1.2. 基于排他锁/悲观锁(for update)实现](#12-基于排他锁悲观锁for-update实现)
    - [1.3. 乐观锁实现](#13-乐观锁实现)
        - [1.3.1. 基于状态机的乐观锁](#131-基于状态机的乐观锁)

<!-- /TOC -->

# 1. ~~MySql分布式锁~~  
<!-- 
分布式锁之数据库实现
https://blog.csdn.net/u022812849/article/details/108621556
基于数据库实现的分布式锁
https://blog.csdn.net/u013256816/article/details/92854794

https://mp.weixin.qq.com/s/WygcVhELp8x6k9Ez_svO9Q
悲观锁：顾名思义很悲观，每次去拿数据的时候都认为别人修改，所以每次在拿数据的时候都会上锁，这样如果中间有人想拿数据就会一直阻塞除非锁被释放获取到锁。传统的关系型数据库里，用到了很多种这种锁机制，比如行锁，表锁，写锁等
乐观锁：顾名思义很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量

https://segmentfault.com/a/1190000023045815
https://blog.csdn.net/u013474436/article/details/104924782/
https://www.cnblogs.com/dengheng/p/11435067.html
-->

## 1.1. 基于表记录实现  
&emsp; 要实现分布式锁，最简单的方式可能就是直接创建一张锁表，然后通过操作该表中的数据来实现了。想要获得锁的时候，就可以在该表中增加一条记录，想要释放锁的时候就删除这条记录。  

## 1.2. 基于排他锁/悲观锁(for update)实现  
&emsp; 获取锁可以通过，在select语句后增加for update，数据库会在查询过程中给数据库表增加排他锁。当某条记录被加上排他锁之后，其他线程无法再在该行记录上增加排他锁，可以认为获得排它锁的线程即可获得分布式锁；  
&emsp; 其余实现与使用唯一索引相同；  
&emsp; 释放锁通过connection.commit();操作，提交事务来实现。  

## 1.3. 乐观锁实现  
&emsp; **<font color = "red">一般是通过为数据库表添加一个version字段来实现读取出数据时，将此版本号一同读出。</font>**  
&emsp; 之后更新时，对此版本号加1，在更新过程中，会对版本号进行比较，如果是一致的，没有发生改变，则会成功执行本次操作；如果版本号不一致，则会更新失败。  
&emsp; 实际就是个CAS过程。  

### 1.3.1. 基于状态机的乐观锁

