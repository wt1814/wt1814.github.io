

<!-- TOC -->

- [1. 分布式事务](#1-分布式事务)
    - [1.1. 分布式事务模型DTP](#11-分布式事务模型dtp)
    - [1.2. 基于DTP的XA实现](#12-基于dtp的xa实现)
        - [1.2.1. 一致性协议-XA两阶段提交](#121-一致性协议-xa两阶段提交)
            - [引入协调者](#引入协调者)
            - [1.2.1.1. 实现流程](#1211-实现流程)
            - [1.2.1.2. 特点](#1212-特点)
            - [1.2.1.3. ※※※XA二阶段问题](#1213-※※※xa二阶段问题)
            - [附录：mySql XA](#附录mysql-xa)
        - [1.2.2. ~~一致性协议-XA三阶段提交~~](#122-一致性协议-xa三阶段提交)
            - [1.2.2.1. 实现流程](#1221-实现流程)
            - [1.2.2.2. 特点](#1222-特点)

<!-- /TOC -->

# 1. 分布式事务  
## 1.1. 分布式事务模型DTP  
&emsp; DTP是由X/Open组织提出的一种分布式事务模型——X/Open Distributed Transaction Processing Reference Model。  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/microService/problems/problem-3.png)  

&emsp; **DTP中的几个概念：**  

* 全局事务：对于一次性操作多个资源管理器的事务，就是全局事务。  
* 分支事务：在全局事务中，某一个资源管理器有自己独立的任务，这些任务的集合作为这个资源管理器的分支任务。  
* 控制线程：用来表示一个工作线程，主要是关联AP,TM,RM三者的一个线程，也就是事务上下文环境。简单的说，就是需要标识一个全局事务以及分支事务的关系。  

&emsp; **X/Open DTP中的角色：**  

* AP(Application Program)：应用程序。  
&emsp; 主要是定义事务边界以及那些组成事务的特定于应用程序的操作。在开发的过程中，可以使用资源管理器提供的事务接口来实现分布式事务。  
* <font color = "lime">TM(Transaction Manager)：事务管理器。</font>  
&emsp; <font color = "lime">管理全局事务，协调事务的提交或者回滚，并协调故障恢复。</font>常见的事务管理器（TM）是交易中间件。  
&emsp; <font color = "lime">分布式事务的实现由事务管理器来完成，它会提供分布式事务的操作接口供业务系统调用，这些接口称为TX接口；事务管理器还管理着所有的资源管理器，通过它们提供的XA接口来统一调度这些资源管理器，以实现分布式事务。</font>  
&emsp; DTP只是一套实现分布式事务的规范，并没有定义具体如何实现分布式事务，TM可以采用2PC、3PC、Paxos等协议实现分布式事务。 
* RM(Resouces Manager)：资源管理器。  
&emsp; 资源管理器能够提供单数据源的事务能力，它们通过XA接口，将本数据库的提交、回滚等能力提供给事务管理器调用，以帮助事务管理器实现分布式的事务管理。能够提供数据服务的对象都可以是资源管理器，比如：数据库、消息中间件、缓存等。大部分场景下，数据库即为分布式事务中的资源管理器。  

&emsp; XA是DTP模型定义的接口，指的是模型中TM（事务管理器）和RM（资源管理器）之间进行通信的接口，用于向事务管理器提供该资源管理器(该数据库)的提交、回滚等能力。目前大多数实现XA的都是数据库或者MQ，所以提起XA往往多指基于资源层的底层分布式事务解决方案。其实现在也有些数据分片框架或者中间件也支持XA协议，毕竟它的兼容性、普遍性更好。  

&emsp; **DTP模型执行流程：**  
1. AP使用一组来自RM的资源；  
2. AP通过TM接口定义事务的边界；  
3. TM和RM交换事务信息；  

## 1.2. 基于DTP的XA实现
### 1.2.1. 一致性协议-XA两阶段提交  

#### 引入协调者
&emsp; 在分布式系统中，每个节点虽然可以知晓自己的操作是成功或者失败，却无法知道其他节点的操作是成功或失败。当一个事务跨越多个节点时，为了保持事务的ACID特性，需要引入一个作为协调者的组件来统一掌控所有节点（称作参与者）的操作结果并最终指示这些节点是否要把操作结果进行真正的提交（比如将更新后的数据写入磁盘等等）。 

#### 1.2.1.1. 实现流程  
&emsp; 二阶段提交的算法思路可以概括为：参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈情报决定各参与者是否要提交操作还是中止操作。  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/microService/problems/problem-4.png)  
&emsp; <font color = "lime">二阶段提交将分布式事务的提交拆分为2个阶段：准备阶段prepare和提交阶段commit/rollback。</font>  
1. 第一阶段：准备阶段  
&emsp; 协调者向所有参与者发送事务执行请求，并等待参与者反馈事务执行结果。  
&emsp; <font color = "red">事务参与者收到请求之后，本地执行事务，但不提交。</font>  
&emsp; 参与者将自己事务执行情况反馈给协调者，同时等待协调者的下一步通知。  

2. 第二阶段：提交阶段（执行阶段）  
&emsp; 在第一阶段协调者的询盘之后，各个参与者会回复自己事务的执行情况，这时候存在三种可能：  
    * 所有的参与者回复能够正常执行事务。  

            协调者向各个参与者发送commit通知，请求提交事务。  
            参与者收到事务提交通知之后，执行commit操作。  
            参与者向协调者返回事务commit结果信息。  
    * 一个或多个参与者回复事务执行失败。  
    * 协调者等待超时。  
    
            协调者向各个参与者发送事务rollback通知，请求回滚事务。  
            参与者收到事务回滚通知之后，执行rollback操作。  
            参与者向协调者返回事务rollback结果信息。  

#### 1.2.1.2. 特点  

* 优点：尽量保证了数据的强一致，适合对数据强一致要求很高的关键领域。（其实也不能100%保证强一致）。  
* **使用场景：** 2PC牺牲了一部分可用性来换取的一致性。<font color = "red">XA事务适合单个应用里，跨多个库的分布式事务</font>，而且因为严重依赖于数据库层面来搞定复杂的事务，效率很低，绝对不适合高并发的场景。可以基于spring + JTA实现。

#### 1.2.1.3. ※※※XA二阶段问题   
1. 单点故障问题：  
&emsp; 参与者发生故障。协调者需要给每个参与者额外指定超时机制，超时后整个事务失败。  
&emsp; 协调者发生故障。参与者会一直阻塞下去。需要额外的备机进行容错。  
<!-- 
如果协调者在发送准备命令前挂了还行，毕竟每个资源都还未执行命令，那么资源是没被锁定的。

可怕的是在发送完准备命令之后挂了，这时候每个本地资源都执行完处于锁定状态了，都杵着了，这就很僵硬了，如果是某个热点资源都阻塞了，这估计就要GG了。
-->
2. 同步阻塞问题：  
&emsp; 执行过程中，所有参与节点都是事务阻塞型的。当参与者占有公共资源时，其他第三方节点访问公共资源不得不处于阻塞状态。  
3. 丢失消息导致的数据不一致问题：  
&emsp; 在二阶段提交的阶段二中，当协调者向参与者发送commit请求之后，发生了局部网络异常或者在发送commit请求过程中协调者发生了故障，这会导致只有一部分参与者接受到了commit请求。而在这部分参与者接到commit请求之后就会执行commit操作。但是其他部分未接到commit请求的机器则无法执行事务提交。于是整个分布式系统便出现了数据部一致性的现象。  
4. 二阶段无法解决的问题：  
&emsp; <font color = "lime">协调者在发出commit消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了。</font><font color = "red">那么即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没人知道事务是否被已经提交。</font>  


#### 附录：mySql XA
......

### 1.2.2. ~~一致性协议-XA三阶段提交~~  
<!-- 
&emsp; 三阶段提交是在二阶段提交上的改进版本，<font color = "red">3PC解决了协调者和参与者同时挂掉的问题</font>，所以3PC把2PC的准备阶段再次一分为二，这样三阶段提交。   
-->
&emsp; 3PC的引入是为了解决2PC的同步阻塞，解决协调者和参与者同时挂掉的问题，减少了数据不一致的情况。  
&emsp; 3PC也就是多了一个阶段，一个询问的阶段，分别是准备、预提交和提交这三个阶段。  

* 准备阶段单纯就是协调者去访问参与者，类似于你还好吗？能接请求不。  
* 预提交其实就是 2PC 的准备阶段，除了事务的提交啥都干了。  
* 提交阶段和 2PC 的提交一致。  

#### 1.2.2.1. 实现流程  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/microService/problems/problem-5.png)  

&emsp; <font color = "lime">XA三阶段提交包含询问阶段CanCommit、准备阶段PreCommit、提交阶段DoCommit三个阶段</font>：  
1. <font color = "lime">询问阶段：CanCommit阶段。</font>  
 &emsp; <font color = "red">协调者向参与者发送commit请求，参与者如果可以提交就返回Yes响应，否则返回No响应。</font>  
2. <font color = "lime">准备阶段：PreCommit阶段。</font>  
 &emsp; <font color = "red">协调者根据参与者的反应情况来决定是否可以进行事务</font>的PreCommit操作。根据响应情况，有以下两种可能：  
   * 假如协调者从所有的参与者获得的反馈都是Yes响应，那么就会执行事务的预执行。  

            发送预提交请求：协调者向参与者发送PreCommit请求，并进入Prepared阶段。  
            事务预提交：参与者接收到PreCommit请求后，会执行事务操作，并将undo和redo信息记录到事务日志中。  
            响应反馈：如果参与者成功的执行了事务操作，则返回ACK响应，同时开始等待最终指令。  
   * 假如有任何一个参与者向协调者发送了No响应，或者等待超时之后，协调者都没有接到参与者的响应，那么就执行事务的中断。  

            发送中断请求：协调者向所有参与者发送abort请求。  
            中断事务：参与者收到来自协调者的abort请求之后（或超时之后，仍未收到协调者的请求），执行事务的中断。 
3. <font color = "lime">提交阶段：doCommit阶段。</font>  
    该阶段进行真正的事务提交，也可以分为以下两种情况。  
    * 执行提交：  

            发送提交请求：协调接收到参与者发送的ACK响应，那么它将从预提交状态进入到提交状态。并向所有参与者发送doCommit请求。    
            事务提交：参与者接收到doCommit请求之后，执行正式的事务提交。并在完成事务提交之后释放所有事务资源。  
            响应反馈：事务提交完之后，向协调者发送Ack响应。  
            完成事务：协调者接收到所有参与者的ack响应之后，完成事务。  
    * 中断事务：  

            协调者没有接收到参与者发送的ACK响应（可能是接受者发送的不是ACK响应，也可能响应超时），那么就会执行中断事务。  
            发送中断请求：协调者向所有参与者发送abort请求。  
            事务回滚：参与者接收到abort请求之后，利用其在阶段二记录的undo信息来执行事务的回滚操作，并在完成回滚之后释放所有的事务资源。  
            反馈结果：参与者完成事务回滚之后，向协调者发送ACK消息。  
            中断事务：协调者接收到参与者反馈的ACK消息之后，执行事务的中断。  

#### 1.2.2.2. 特点  

* 优点：相比二阶段提交，<font color = "red">三阶段提交降低了阻塞范围</font>，在等待超时后协调者或参与者会中断事务；<font color = "red">避免了协调者单点问题</font>，阶段3中协调者出现问题时，参与者会继续提交事务。  
* 缺点：<font color = "red">数据不一致问题依然存在。</font>当在参与者收到preCommit请求后等待do commite指令时，此时如果协调者请求中断事务，而协调者无法与参与者正常通信，会导致参与者继续提交事务，造成数据不一致。  

<!-- 
&emsp; 与两阶段提交不同的是，三阶段提交有两个改动点。  
1. 引入超时机制。同时在协调者和参与者中都引入超时机制。一旦事物参与者迟迟没有接到协调者的commit请求，会自动进行本地commit。这样有效解决了协调者单点故障的问题。但是性能问题和不一致的问题仍然没有根本解决。  
2. 3PC把2PC的准备阶段再次一分为二，保证了在最后提交阶段之前各参与节点的状态是一致的。   
~~&emsp; 三阶段提交在两阶段提交的第一阶段与第二阶段之间插入了一个准备阶段，使得原先在两阶段提交中，参与者在投票之后，由于协调者发生崩溃或错误，而导致参与者处于无法知晓是否提交或者中止的“不确定状态”所产生的可能相当长的延时的问题得以解决。（3PC最关键要解决的就是协调者和参与者同时挂掉的问题）~~   

&emsp; 解决二阶段提交时的问题：在三阶段提交中，如果在第三阶段协调者发送提交请求之后挂掉，并且唯一的接受的参与者执行提交操作之后也挂掉了，这时协调者通过选举协议产生了新的协调者。  
&emsp; 在二阶段提交时存在的问题就是新的协调者不确定已经执行过事务的参与者是执行的提交事务还是中断事务。  
&emsp; 但是在三阶段提交时，肯定得到了第二阶段的再次确认，那么第二阶段必然是已经正确的执行了事务操作，只等待提交事务了。  
&emsp; 所以新的协调者可以从第二阶段中分析出应该执行的操作，进行提交或者中断事务操作，这样即使挂掉的参与者恢复过来，数据也是一致的。  

&emsp; 所以，三阶段提交解决了二阶段提交中存在的由于协调者和参与者同时挂掉可能导致的数据一致性问题和单点故障问题，并减少阻塞。  
&emsp; 因为一旦参与者无法及时收到来自协调者的信息之后，它会默认执行提交事务，而不会一直持有事务资源并处于阻塞状态。  
&emsp; 三阶段提交的问题：在提交阶段如果发送的是中断事务请求，但是由于网络问题，导致部分参与者没有接到请求。  
&emsp; 那么参与者会在等待超时之后执行提交事务操作，这样这些由于网络问题导致提交事务的参与者的数据就与接受到中断事务请求的参与者存在数据不一致的问题。  
&emsp; 所以无论是2PC还是3PC都不能保证分布式系统中的数据100%一致。 --> 
