

<!-- TOC -->

- [1. xxxTCC异常xxx](#1-xxxtcc异常xxx)
    - [1.1. TCC的注意点](#11-tcc的注意点)
    - [1.2. TCC的异常场景](#12-tcc的异常场景)
    - [1.3. 幂等处理](#13-幂等处理)
        - [1.3.1. 产生原因](#131-产生原因)
        - [1.3.2. 应对策略](#132-应对策略)
    - [1.4. 空回滚](#14-空回滚)
        - [1.4.1. 产生原因](#141-产生原因)
        - [1.4.2. 应对策略](#142-应对策略)
    - [1.5. 资源悬挂](#15-资源悬挂)
        - [1.5.1. 产生原因](#151-产生原因)
        - [1.5.2. 应对策略](#152-应对策略)
    - [1.6. 三种异常总结](#16-三种异常总结)
    - [1.7. 参考](#17-参考)

<!-- /TOC -->

&emsp; **<font color = "red">总结：</font>**  
1.  **<font color = "clime">TCC的数据最终一致性：基于Confirm和Cancel的`幂等性`，保证事务最终完成确认或者取消，保证数据的一致性。</font>**  
2. TCC的问题：  
    &emsp; **<font color = "clime">TCC两个阶段都由业务代码控制，由于网络阻塞等原因，可能导致两个阶段执行顺序相反，</font>** 引发问题：  
    1. `【允许】空回滚`（Try方法由于网络问题没收到超时了，此时事务管理器就会发出Cancel命令。需要支持Cancel在未执行Try的情况下能正常的Cancel）；  
    2. `【防止】资源悬挂`（TC回滚事务调用二阶段完成空回滚后，一阶段try请求又到了）。

&emsp; **<font color = "clime">解决方案：使用一张事务状态控制表（包含全局事务ID、分支事务ID、执行状态）。</font>**  
1. 什么是空回滚？空回滚就是对于一个分布式事务，在没有调用 TCC 资源 Try 方法的情况下，调用了二阶段的 Cancel 方法，Cancel 方法需要识别出这是一个空回滚，然后直接返回成功。  
&emsp; 思路很简单就是需要知道一阶段是否执行，如果执行了，那就是正常回滚；如果没执行，那就是空回滚。因此，需要一张额外的事务控制表，其中有分布式事务 ID 和分支事务 ID，第一阶段 Try 方法里会插入一条记录，表示一阶段执行了。Cancel 接口里读取该记录，如果该记录存在，则正常回滚；如果该记录不存在，则是空回滚。  
2. 怎么解决重复执行的幂等问题呢？一个简单的思路就是记录每个分支事务的执行状态。在执行前状态，如果已执行，那就不再执行；否则，正常执行。前面在讲空回滚的时候，已经有一张事务控制表了，事务控制表的每条记录关联一个分支事务，那我们完全可以在这张事务控制表上加一个状态字段，用来记录每个分支事务的执行状态。  
&emsp; 该状态字段有三个值，分别是初始化、已提交、已回滚。Try 方法插入时，是初始化状态。二阶段 Confirm 和 Cancel 方法执行后修改为已提交或已回滚状态。当重复调用二阶段接口时，先获取该事务控制表对应记录，检查状态，如果已执行，则直接返回成功；否则正常执行。  
3. 怎么实现才能做到防悬挂呢？根据悬挂出现的条件先来分析下，悬挂是指二阶段 Cancel 执行完后，一阶段才执行。也就是说，为了避免悬挂，如果二阶段执行完成，那一阶段就不能再继续执行。因此，当一阶段执行时，需要先检查二阶段是否已经执行完成，如果已经执行，则一阶段不再执行；否则可以正常执行。那怎么检查二阶段是否已经执行呢？大家是否想到了刚才解决空回滚和幂等时用到的事务控制表，可以在二阶段执行时插入一条事务控制记录，状态为已回滚，这样当一阶段执行时，先读取该记录，如果记录存在，就认为二阶段已经执行；否则二阶段没执行。  

# 1. xxxTCC异常xxx

<!-- 
*** https://www.sofastack.tech/blog/sofa-channel-4-retrospect/
https://blog.csdn.net/xiaozhu0301/article/details/111322711
-->

## 1.1. TCC的注意点  


&emsp; **<font color = "clime">TCC两个阶段都由业务代码控制，由于网络阻塞等原因，可能导致两个阶段执行顺序相反，</font>** 引发问题：  
1. 空回滚（Try方法由于网络问题没收到超时了，此时事务管理器就会发出Cancel命令。需要支持Cancel在未执行Try的情况下能正常的Cancel。）；  
2. 资源悬挂（TC回滚事务调用二阶段完成空回滚后，一阶段try请求又到了）。  


&emsp; **<font color = "clime">解决方案：使用一张事务状态控制表（包含全局事务ID、分支事务ID、执行状态）。</font>**  


--------------

* 幂等问题，因为网络调用无法保证请求一定能到达，所以都会有重调机制，因此对于Try、Confirm、Cancel三个方法都需要幂等实现，避免重复执行产生错误。  
* 空回滚问题，指的是Try方法由于网络问题没收到超时了，此时事务管理器就会发出Cancel命令，那么需要支持Cancel在未执行Try的情况下能正常的Cancel。  
* 悬挂问题，这个问题也是指 Try 方法由于网络阻塞超时触发了事务管理器发出了Cancel命令，但是执行了Cancel命令之后Try请求到了。  
&emsp; 已经执行Cancel 了，又来个 Try请求，对于事务管理器来说这时候事务已经是结束了的，这冻结操作就被“悬挂”了，所以空回滚之后还得记录一下，防止Try的再调用。

-----

* 幂等  
&emsp; 问题：TC重复调用二阶段。(因为网络抖动等原因，分布式事务框架可能会重复调用同一个分布式事务中的一个分支事务的二阶段接口。所以分支事务的二阶段接口Confirm/Cancel需要能够保证幂等性)。  
&emsp; 解决：事务状态控制记录作为控制手段，只有存在INIT记录时才执行，存在CONFIRMED/ROLLBACKED记录时不再执行。  

* 空回滚  
&emsp; 问题：TC回滚事务调用二阶段，但一阶段尚未执行。  
&emsp; 解决：事务状态控制记录作为控制手段，无记录时即为空回滚。  

* 资源悬挂  
&emsp; 问题：TC回滚事务调用二阶段完成空回滚后，一阶段执行成功。  
&emsp; 解决：事务状态控制记录作为控制手段，二阶段发现无记录时插入记录，一阶段执行时检查记录是否存在。  

* 三者共通点：  
&emsp; 核心的解决方案就是事务状态控制表。  
&emsp; 幂等控制作为最基础的异常处理手段；资源悬挂的前置条件是空回滚，所以发生空回滚时会插入。  
&emsp; 一条状态为ROLLBACKED的控制记录。


<!-- 

Saga 事务和 TCC 事务一样，对业务实现要求高，要求业务设计实现上遵循三个策略：

允许空补偿：网络异常导致事务的参与方只收到了补偿操作指令，因为没有执行过正常操作，因此要进行空补偿。

保持幂等性：事务的正向操作和补偿操作都可能被重复触发，因此要保证操作的幂等性。

防止资源悬挂：网络异常导致事务的正向操作指令晚于补偿操作指令到达，则要丢弃本次正常操作，否则会出现资源悬挂问题。
-->


---------------------

## 1.2. TCC的异常场景
&emsp; 在分布式系统中，随时随地都需要面对网络超时，网络重发和服务器宕机等问题。所以分布式事务框架作为搭载在分布式系统之上的一个框架型应用也绕不开这些问题。具体而言，有以下常见问题：  

1. 幂等处理  
2. 空回滚  
3. 资源悬挂  

&emsp; 这些异常的应对需要TCC框架的支持和解决方案。  

## 1.3. 幂等处理
### 1.3.1. 产生原因  
&emsp; 因为网络抖动等原因，分布式事务框架可能会重复调用同一个分布式事务中的一个分支事务的二阶段接口。所以分支事务的二阶段接口Confirm/Cancel需要能够保证幂等性。如果二阶段接口不能保证幂等性，则会产生严重的问题，造成资源的重复使用或者重复释放，进而导致业务故障。  
![image](http://182.92.69.8:8081/img/microService/problems/problem-51.png)  
&emsp; 从上图中红色部分可以看到：如果当TC调用参与者的二阶段方法时，发生了异常(TC本身异常或者网络异常丢失结果)。此时TC无法感知到调用的结果。为了保证分布式事务能够走到终态，此时TC会按照一定的规则重复调用参与者的二阶段方法。  

### 1.3.2. 应对策略
&emsp; 对于幂等类型的问题，通常的手段是引入幂等字段进行防重放攻击。对于分布式事务框架中的幂等问题，同样可以祭出这一利器。我们可以通过 **<font color= "red">增加一张事务状态控制表来实现，这个表的关键字段有以下几个：</font>**  

1. 主事务ID
2. 分支事务ID
3. 分支事务状态

&emsp; 其中1和2构成表的联合主键来唯一标识一笔分布式事务中的一条分支事务。3用来标识该分支事务的状态，一共有3种状态：  

1. INIT(I) - 初始化
2. CONFIRMED© - 已提交
3. ROLLBACKED® - 已回滚

&emsp; **<font color= "clime">幂等记录的插入时机是参与者的Try方法，此时的分支事务状态会被初始化为INIT。然后当二阶段的Confirm/Cancel执行时会将其状态置为CONFIRMED/ROLLBACKED。</font>**  

&emsp; 当TC重复调用二阶段接口时，参与者会先获取事务状态控制表的对应记录查看其事务状态。如果状态已经为CONFIRMED/ROLLBACKED，那么表示参与者已经处理完其分内之事，不需要再次执行，可以直接返回幂等成功的结果给TC，帮助其推进分布式事务。增加了幂等记录的写入和读取判断后，时序图如下(蓝色部分)：  
![image](http://182.92.69.8:8081/img/microService/problems/problem-52.png)  

## 1.4. 空回滚
### 1.4.1. 产生原因
&emsp; 先来说定义，当没有调用参与方Try方法的情况下，就调用了二阶段的Cancel方法，Cancel方法需要有办法识别出此时Try有没有执行。如果Try还没执行，表示这个Cancel操作是无效的，即本次Cancel属于空回滚；如果Try已经执行，那么执行的是正常的回滚逻辑。  
![image](http://182.92.69.8:8081/img/microService/problems/problem-53.png)  
&emsp; 如上图所示，红色部分的一阶段Try可能失败。  

&emsp; 首先发起方在调用参与者之前，会向TC申请开始一笔分布式事务。然后发起方调用参与者的一阶段方法，在调用实际发生之前，一般会有切面拦截器感知到此次Try调用，然后写入一条分支事务记录。紧接着，在实际调用参与者的Try方法时发生了异常。异常原因可以是发起方宕机，网络抖动等。  

&emsp; 总而言之，就是Try方法没有执行成功，然而此时这笔分布式事务和分支事务已经落库。有两种情况会触发分布式事务的回滚：  

1. 发起方认为当前分布式事务无法成功，主动通知TC回滚
2. TC发现分布式事务超时，被动触发回滚

&emsp; 触发回滚操作后，TC会对该分布式事务关联的分支事务调用其二阶段Cancel。在执行Cancel时，Try还未执行成功，触发空回滚。如果不对空回滚加以防范的话，可能会造成资源的无效释放。即在没有预留资源的情况下就释放资源，造成故障。  

### 1.4.2. 应对策略
&emsp; 可以发现，要应对空回滚的问题，就需要让参与者在二阶段的Cancel方法中有办法识别到一阶段的Try是否已经执行。  

&emsp; 很显然，可以继续利用事务状态控制表来实现这个功能。  

&emsp; 前面提到过为了保证幂等性，当Try方法被成功执行后，会插入一条记录，标识该分支事务处于INIT状态。所以后续 **<font color = "red">当二阶段的Cancel方法被调用时，可以通过查询控制表的对应记录进行判断。如果记录存在且状态为INIT，就表示一阶段已成功执行，可以正常执行回滚操作，释放预留的资源；如果记录不存在则表示一阶段未执行，本次为空回滚，不释放任何资源。</font>**  

&emsp; 时序图如下所示：  
![image](http://182.92.69.8:8081/img/microService/problems/problem-54.png)  

## 1.5. 资源悬挂
### 1.5.1. 产生原因

&emsp; 悬挂，顾名思义，是有一些资源被悬挂起来后续无法处理了。那么什么场景下才会出现这种现象呢？  

&emsp; 上一节中提到过空回滚，指的是当一阶段Try未执行成功，而二阶段Cancel就因TC回滚整个分布式事务而被调用。  

&emsp; 但是考虑一种极端情况，当分布式事务到终态后，参与者的一阶段Try才被执行，此时参与者会根据业务需求预留相关资源。预留资源只有当前事务才能使用，然而此时分布式事务已经走到终态，后续再没有任何手段能够处理这些预留资源。至此，就形成了资源悬挂。  

&emsp; 这种一阶段比二阶段执行的还晚的情况看似不可能，但是仔细考虑RPC调用的时序，其实这种情况在复杂多变的网络中是完全可能的，下面的时序展示了这种可能性：  

1. 发起方通过RPC调用参与者一阶段Try，但是发生网络阻塞导致RPC超时
2. RPC超时后，TC会回滚分布式事务(可能是发起方主动通知TC回滚或者是TC发现事务超时后回滚)，调用已注册的各个参与方的二阶段Cancel
3. 参与方空回滚后，发起方对参与者的一阶段Try才开始执行，进行资源预留从而形成悬挂

&emsp; 使用时序图来描述，红色部分为产生资源悬挂的关键步骤：  
![image](http://182.92.69.8:8081/img/microService/problems/problem-55.png)  

### 1.5.2. 应对策略
&emsp; 资源悬挂的本质原因在于，一阶段和二阶段的执行顺序没有被严格地保证。所以相应的解决方案还是通过读取事务状态控制表的事务状态。  

&emsp; 前面在幂等方案的讨论中说过：  

    幂等记录的插入时机是参与者的Try方法，此时的分支事务状态会被初始化为INIT。然后当二阶段的Confirm/Cancel执行时会将其状态置为CONFIRMED/ROLLBACKED。

&emsp; 由于悬挂的产生背景是一阶段方法根本就未执行，所以此时事务控制记录是不存在的，需要在二阶段中处理ROLLBACK的情况(因为超时后触发回滚不可能存在二阶段为CONFIRM)。  

&emsp; 处理方案为在判断为空回滚的场景下(体现在对应一阶段事务控制记录不存在)，插入一条状态为ROLLBACKED的控制记录。  

&emsp; 那么下次当一阶段Try抵达执行的时候，首先会尝试插入状态为INIT的事务控制记录。如果插入失败，表示当前分支事务的记录已经存在，Try无需继续执行。有几种可能性会导致此情形：  

1. 一阶段Try重复请求，网络抖动情况可能发生，可以理解为命中幂等
2. 二阶段插入了防悬挂记录，一阶段不可继续执行

&emsp; 时序图描述如下，蓝色部分为防止资源悬挂增加的检查项：  
![image](http://182.92.69.8:8081/img/microService/problems/problem-56.png)  

## 1.6. 三种异常总结
&emsp; 前面讨论了分布式事务三种典型的异常类型，它们的解决方案都依赖于一张事务状态控制表。来尝试总结一下它们各自的特点。  

&emsp; **幂等**  
&emsp; 问题：TC重复调用二阶段  
&emsp; 解决：事务状态控制记录作为控制手段，只有存在INIT记录时才执行，存在CONFIRMED/ROLLBACKED记录时不再执行  

&emsp; **空回滚**  
&emsp; 问题：TC回滚事务调用二阶段，但一阶段尚未执行  
&emsp; 解决：事务状态控制记录作为控制手段，无记录时即为空回滚  

&emsp; **资源悬挂**  
&emsp; 问题：TC回滚事务调用二阶段完成空回滚后，一阶段执行成功  
&emsp; 解决：事务状态控制记录作为控制手段，二阶段发现无记录时插入记录，一阶段执行时检查记录是否存在  

&emsp; **共通点**  
1. 核心的解决方案就是事务状态控制表  
2. 幂等控制作为最基础的异常处理手段；资源悬挂的前置条件是空回滚，所以发生空回滚时会插入一条状态为ROLLBACKED的控制记录  


## 1.7. 参考
https://blog.csdn.net/dm_vincent/article/details/92432059  

