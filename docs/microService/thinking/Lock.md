
<!-- TOC -->

- [1. 分布式锁](#1-分布式锁)
    - [1.1. 分布式锁使用场景](#11-分布式锁使用场景)
    - [1.2. 实现分布式锁需要关注哪些细节呢？](#12-实现分布式锁需要关注哪些细节呢)
    - [1.3. 分布式锁实现](#13-分布式锁实现)
        - [1.3.1. 分布式锁实现方案](#131-分布式锁实现方案)
        - [1.3.2. 分布式锁选型/各种锁的区别](#132-分布式锁选型各种锁的区别)

<!-- /TOC -->

![image](http://182.92.69.8:8081/img/draw/Lock.png)  


&emsp; **<font color = "red">总结：</font>**  
1. 分布式锁使用场景（什么是分布式锁？）：
    1. 避免不同节点重复相同的工作，实现幂等。  
    2. 避免破坏数据的正确性：在分布式环境下解决多实例对数据的访问一致性。如果多个节点在同一条数据上同时进行操作，可能会造成数据错误或不一致的情况出现。  
2. 实现分布式锁的细节（特点）：  
    * **<font color = "blue">确保互斥：在同一时刻，必须保证锁至多只能被一个客户端持有。</font>**  
    * **<font color = "clime">`不能死锁：`在一个客户端在持有锁的期间崩溃而没有主动解锁情况下，`也能保证后续其他客户端能加锁`。</font>**    
    * **<font color = "clime">`避免活锁：`在获取锁失败的情况下，`反复进行重试操作，占用CPU资源，影响性能。`</font>**    
    * 实现更多锁特性：锁中断、锁重入、锁超时等。确保客户端只能解锁自己持有的锁。  
3. 分布式锁选型（各种锁的对比）：  
&emsp; ~~CAP只能满足其二、数据一致性、性能。~~  
&emsp; 分布式中间件的选型无非就是AP、CP模型（CAP原理）中的一种。针对常用的分布式锁，redis是AP模型、zookeeper是CP模型。  
&emsp; ★★★具体选择哪一种看使用场景对数据一致性的要求。`解决幂等时，一般情况下使用redis分布式锁，但是分布式锁编码问题、中间件部署问题都有可能影响分布式锁的使用。所以数据一致性要求高的，要结合数据库乐观锁（状态控制）。`    


# 1. 分布式锁  
<!-- 
*** 分布式锁需要满足的特性有这么几点：
https://mp.weixin.qq.com/s/1IIKb3Uitdd_wHcq7pKdxg
*** 聊聊redis分布式锁的8大坑 
https://mp.weixin.qq.com/s/mNcmx_RTyeKPjWu4-y5qFA

-->

## 1.1. 分布式锁使用场景  
<!-- 
***分布式锁使用场景
https://www.cnblogs.com/aoshicangqiong/p/12173550.html
-->
&emsp; **分布式锁的使用场景：**  
1. 避免不同节点重复相同的工作。幂等  

        比如用户执行了某个操作有可能不同节点会发送多封邮件。  
        比如多台机器都可以定时执行某个任务，如果限制任务每次只能被一台机器执行，不能重复执行，就可以用分布式锁来做标记。

2. 避免破坏数据的正确性：在分布式环境下解决多实例对数据的访问一致性。如果多个节点在同一条数据上同时进行操作，可能会造成数据错误或不一致的情况出现。  

        比较敏感的数据比如金额修改，同一时间只能有一个人操作，如果2个人同时修改金额，一个加金额一个减金额，为了防止同时操作造成数据不一致，需要锁，如果是数据库需要的就是行锁或表锁，如果是在集群里，多个客户端同时修改一个共享的数据就需要分布式锁。  
        比如秒杀场景，要求并发量很高，那么同一件商品只能被一个用户抢到，那么就可以使用分布式锁实现。 

      
----

&emsp; 另一番理解：  
&emsp; **锁使用在不同线程共享资源。**  
1. 单机环境中使用synchronized、Lock就可以了。现在大部分都是分布式、集群，线程处于不同JVM中，针对共享资源应该使用分布式锁了。  
2. 共享资源概念比较宽泛，共享资源可是是数据库、同一份文件....。  

&emsp; 一些具体的使用场景：  
1. 电商中的减库存，超卖问题。  
2. 调用外部系统，过期Token。如果不使用分布式锁，Token过期时，多个线程同时请求，会导致浪费了好多Token值。    

&emsp; **用来解决幂等**  

## 1.2. 实现分布式锁需要关注哪些细节呢？  

* **<font color = "blue">确保互斥：在同一时刻，必须保证锁至多只能被一个客户端持有。</font>**  
* **<font color = "clime">不能死锁：在一个客户端在持有锁的期间崩溃而没有主动解锁情况下，也能保证后续其他客户端能加锁。</font>**    
* **<font color = "clime">避免活锁：在获取锁失败的情况下，反复进行重试操作，占用CPU资源，影响性能。</font>**    
* 实现更多锁特性：锁中断、锁重入、锁超时等。确保客户端只能解锁自己持有的锁。  

## 1.3. 分布式锁实现  
### 1.3.1. 分布式锁实现方案
&emsp; 分布式锁一般有三种基础的实现方式：1.数据库悲观锁、乐观锁；2.[基于缓存(redis，memcached，tair)的分布式锁](/docs/microService/thinking/redisLock.md)；3.[基于ZooKeeper临时顺序节点的分布式锁](/docs/microService/thinking/ZKLock.md)。  
&emsp; <font color="red">基于Redis的分布式锁是AP模型，基于Zookeeper的分布式锁是CP模型的。</font> 

&emsp; **Spring Integration**    
&emsp; Spring Integration提供的全局锁目前为如下存储提供了实现：Gemfire、JDBC、Redis、Zookeeper。它们使用相同的API抽象。即不论使用哪种存储，编码体验是一样的，若想更换实现，只需要修改依赖和配置，无需修改代码。  

### 1.3.2. 分布式锁选型/各种锁的区别  
&emsp; 分布式中间件的选型无非就是AP、CP模型(CAP原理)中的一种。针对常用的分布式锁，redis是AP模型、zookeeper是CP模型。具体选择哪一种看使用场景对数据一致性的要求。  
 
&emsp; 目前使用比较多的是redis锁，但是redis单机会有宕机风险；主从复制、Redisson实现锁，都有节点宕机，锁丢失，多个线程同时抢到锁的问题。  
&emsp; 由RedLock、ZK实现的锁，相对安全，但是又有性能问题。  
&emsp; 所以对于分布式锁的选型还是，针对具体业务、具体场景是要数据一致性好点，还是性能好点。  

