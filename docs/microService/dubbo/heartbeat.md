
&emsp; **<font color = "red">总结：</font>**  
&emsp; 主流的RPC框架都会追求性能选择使用长连接，所以如何保活连接就是一个重要的话题。如何确保连接的有效性呢，在TCP中用到了KeepAlive机制。有了KeepAlive机制往往是不够用的，还需要配合心跳机制来一起使用。  
&emsp; 何为心跳机制，简单来讲就是客户端启动一个定时器用来定时发送请求，服务端接到请求进行响应，如果多次没有接受到响应，那么客户端认为连接已经断开，可以断开半打开的连接或者进行重连处理。   
&emsp; Dubbo的心跳方案：Dubbo 对于建立的每一个连接，同时在客户端和服务端开启了 2个定时器，一个用于定时发送心跳，一个用于定时重连、断连，执行的频率均为各自检测周期的 1/3。定时发送心跳的任务负责在连接空闲时，向对端发送心跳包。定时重连、断连的任务负责检测 lastRead 是否在超时周期内仍未被更新，如果判定为超时，客户端处理的逻辑是重连，服务端则采取断连的措施。  

# Dubbo心跳机制
<!--
https://www.cnblogs.com/caoxb/p/13140384.html
https://juejin.cn/post/6844904192784629768
-->

## 为什么需要心跳机制
&emsp; 长连接和短连接  

    短连接：每次通信结束后关闭连接，下次通信需要重新创建连接；优点就是无需管理连接，无需保活连接；
    长连接：每次通信结束不关闭连接，连接可以复用，保证了性能；缺点就是连接需要统一管理，并且需要保活；

&emsp; 主流的RPC框架都会追求性能选择使用长连接，所以如何保活连接就是一个重要的话题，也是本文的主题，下面会重点介绍一些保活策略；  
 
&emsp; 为什么需要保活  
&emsp; **<font color = "red">上面介绍的长连接、短连接并不是TCP提供的功能，所以长连接是需要应用端自己来实现的，</font>** 包括：连接的统一管理，如何保活等；如何保活之前我们了解一下为什么需要保活？主要原因是网络不是100%可靠的，我们创建好的连接可能由于网络原因导致连接已经不可用了，如果连接一直有消息往来，那么系统马上可以感知到连接断开；但是我们系统可能长时间没有消息来往，导致系统不能及时感知到连接不可用，也就是不能及时处理重连或者释放连接；常见的保活策略使用心跳机制由应用层来实现，还有网络层提供的TCP Keepalive保活探测机制；  
 
&emsp; TCP Keepalive机制  
&emsp; TCP Keepalive是操作系统实现的功能，并不是TCP协议的一部分，需要在操作系统下进行相关配置，开启此功能后，如果连接在一段时间内没有数据往来，TCP将发送Keepalive探针来确认连接的可用性，Keepalive几个内核参数配置：  

    tcp_keepalive_time：连接多长时间没有数据往来发送探针请求，默认为7200s（2h）；
    tcp_keepalive_probes：探测失败重试的次数默认为10次；
    tcp_keepalive_intvl：重试的间隔时间默认75s；

&emsp; 以上参数可以修改到/etc/sysctl.conf文件中；是否使用Keepalive用来保活就够了，其实还不够，Keepalive只是在网络层就行保活，如果网络本身没有问题，但是系统由于其他原因已经不可用了，这时候Keepalive并不能发现；所以往往还需要结合心跳机制来一起使用；  

----------
Dubbo客户端和Dubbo服务端之间存在心跳，目的是维持provider和consumer之间的长链接。由Dubbo客户端主动发起，可参见Dubbo源码 HeartbeatTimerTask和ReconnectTimerTask。  

谈到RPC肯定绕不开TCP通信，而主流的RPC框架都依赖于Netty等通信框架，这时候我们还要考虑是使用长连接还是短连接。主流的RPC框架都会追求性能选择使用长连接，所以如何保活连接就是一个重要的话题，本文就会以这个为中心来介绍一下保活策略。  

KeepAlive机制
Dubbo中的通信是基于TCP的，TCP本身并没有长短连接的区别。  


在短连接中，每次通信时，都会创建Socket，当该次通信结束后，就会调用socket.close()，下次通信需要重新创建连接。优点就是无需管理连接，无需保活连接；缺点就是每次创建连接需要耗费时间。  


在长连接中，每次通信完毕后，不会关闭连接，这样子就实现了连接可以复用，保证了性能；长连接的优点是省去了创建连接时所耗费的时间；缺点就是连接需要统一管理，并且需要保活。  


那么如何确保连接的有效性呢，在TCP中用到了KeepAlive机制，keepalive并不是TCP协议的一部分，但是大多数操作系统都实现了这个机制，在一定时间内，在链路上如果没有数据传送的情况下，TCP层将会发送相应的keepalive探针来确定连接可用性，Keepalive几个内核参数配置：  

    tcp_keepalive_time：连接多长时间没有数据往来发送探针请求，默认为7200s（2h）；
    tcp_keepalive_probes：探测失败重试的次数默认为10次；
    tcp_keepalive_intvl：重试的间隔时间默认75s；

Dubbo心跳机制  
有了KeepAlive机制往往是不够用的，还需要配合心跳机制来一起使用。何为心跳机制，简单来讲就是客户端启动一个定时器用来定时发送请求，服务端接到请求进行响应，如果多次没有接受到响应，那么客户端认为连接已经断开，可以断开半打开的连接或者进行重连处理。   


## 源码解析
<!-- 
https://juejin.cn/post/6844904192784629768#heading-0
-->




