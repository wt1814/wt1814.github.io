
<!-- TOC -->

- [1. kafka持久化](#1-kafka持久化)
    - [1.1. 概述](#11-概述)
    - [1.2. Kafka的持久化](#12-kafka的持久化)

<!-- /TOC -->

# 1. kafka持久化  
<!--
https://blog.csdn.net/gududedabai/article/details/80002453 
https://www.jianshu.com/p/8a4154780204
https://blog.csdn.net/zhaoyuqiang/article/details/106907496?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-1.control&spm=1001.2101.3001.4242
https://www.jianshu.com/p/8a4154780204

kafka——高效读写数据
https://www.jianshu.com/p/ce8253609b6b

Kafka为什么吞吐量大、速度快？ 
https://mp.weixin.qq.com/s/QIK1N-ePm6DQE4tMQ9N3Gw
-->

&emsp; kafka的消息是不断追加到文件中的，这个特性使kafka可以充分利用磁盘的顺序读写性能。Kafka会将数据顺序插入到文件末尾，消费者端通过控制偏移量来读取消息，这样做会导致数据无法删除，时间一长，磁盘空间会满，kafka提供了2种策略来删除数据：基于时间删除和基于partition文件的大小删除。  

    顺序读写不需要硬盘磁头的寻道时间，只需很少的扇区旋转时间，所以速度远快于随机读写。  

## 1.1. 概述
&emsp; Kafka很大程度上依赖文件系统来存储和缓存消息。有一普遍的认识：磁盘很慢。这让人们怀疑使用磁盘作为持久化的性能。实际上，磁盘是快还是慢完全取决于我们是如何使用它。  
&emsp; 就目前来说，一个 six 7200rpm SATA RAID-5磁盘线性（顺序）写入的性能能达到600MB/sec，而任意位置写（寻址再写）的性能只有100k/sec。这些线性读写是所有使用模式中最可预测的，并且由操作系统进行了大量优化。现在的操作系统提供了预读取和后写入的技术。实际上你会发现，顺序的磁盘读写比任意的内存读写更快。  

&emsp; 基于jvm内存有以下缺点：  

* 对象的内存开销非常高，通常会让存储数据的大小加倍（或更多）  
* 随着堆内数据的增加，GC的速度越来越慢，而且可能导致错误  

&emsp; 基于操作系统的文件系统来设计有以下好处：  

* 可以通过os的pagecache来有效利用主内存空间，由于数据紧凑，可以cache大量数据，并且没有gc的压力  
* 即使服务重启，缓存中的数据也是热的（不需要预热）。而基于进程的缓存，需要程序进行预热，而且会消耗很长的时间。（10G大概需要10分钟）  
* 大大简化了代码。因为在缓存和文件系统之间保持一致性的所有逻辑都在OS中。以上建议和设计使得代码实现起来十分简单，不需要尽力想办法去维护内存中的数据，数据会立即写入磁盘。  

&emsp; ~~这种以页面缓存（pagecache）为中心的设计风格在一篇关于Varnish设计的文章中有详细描述。~~  
&emsp; 总的来说，Kafka不会保持尽可能多的内容在内存空间，而是尽可能把内容直接写入到磁盘。所有的数据都及时的以持久化日志的方式写入到文件系统，而不必要把内存中的内容刷新到磁盘中。  

## 1.2. Kafka的持久化
1. 数据持久化：
    * 发现线性的访问磁盘（即：按顺序的访问磁盘），很多时候比随机的内存访问快得多，而且有利于持久化；
    * 传统的使用内存做为磁盘的缓存
    * Kafka直接将数据写入到日志文件中，以追加的形式写入
2. 日志数据持久化特性：  
&emsp; 写操作：通过将数据追加到文件中实现  
&emsp; 读操作：读的时候从文件中读就好了   
3. 优势：    
&emsp; 读操作不会阻塞写操作和其他操作（因为读和写都是追加的形式，都是顺序的，不会乱，所以不会发生阻塞），数据大小不对性能产生影响；  
&emsp; 没有容量限制（相对于内存来说）的硬盘空间建立消息系统；  
&emsp; 线性访问磁盘，速度快，可以保存任意一段时间！  
4. 持久化的具体实现：  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/microService/mq/kafka/kafka-122.png)  
5. 索引  
&emsp; 为数据文件建索引：稀疏存储，每隔一定字节的数据建立一条索引（这样的目的是为了减少索引文件的大小）。   
&emsp; 下图为一个partition的索引示意图：  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/microService/mq/kafka/kafka-123.png)  
&emsp; 注：  
    1. 现在对6.和8建立了索引，如果要查找7，则会先查找到8然后，再找到8后的一个索引6，然后两个索引之间做二分法，找到7的位置  
    2. 每一个log文件中又分为多个segment  

