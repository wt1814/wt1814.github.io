


# MQ常见面试题  
<!-- TOC -->

- [MQ常见面试题](#mq常见面试题)
- [1. ~~mq~~](#1-mq)
    - [1.1. 消息队列简介](#11-消息队列简介)
    - [1.2. 为什么使用消息队列](#12-为什么使用消息队列)
        - [1.2.1. 消息队列优点](#121-消息队列优点)
        - [1.2.2. 消息队列缺点](#122-消息队列缺点)
    - [1.3. 消息队列设计](#13-消息队列设计)
    - [1.4. 消息队列中间件选型](#14-消息队列中间件选型)
    - [1.5. 消息队列使用事项](#15-消息队列使用事项)
        - [1.5.1. 保障可用性](#151-保障可用性)
        - [1.5.2. 丢失消息（可靠性传输）](#152-丢失消息可靠性传输)
        - [1.5.3. 重复消费](#153-重复消费)
        - [1.5.4. 顺序消费](#154-顺序消费)
        - [1.5.5. 消息积压(消费消息延迟)](#155-消息积压消费消息延迟)

<!-- /TOC -->

![image](http://182.92.69.8:8081/img/draw/164.MQ.png)  


&emsp; **<font color = "red">总结：</font>**  
1. 为什么使用mq？  
    * 优点：解耦（调用多个系统，非同步调用）、异步、削锋（削qps）  
2. 消息队列选型  
    * RabbitMQ  
    * Kafka  
    * RocketMQ  
3. 消息队列使用事项  
    1. 架构  
        1. 保障高可用  
    2. 生产者  
        1. 消息队列丢失消息有3种情况：生产者丢失数据、mq客户端丢失数据、消费者丢失数据。提供两种方案解决。    
    3. 消费者  
        1. 重复消费  
            消费接口幂等性。  
        2. 顺序消费  
            发送到单个queue或partition，单线程消费。  
        3. **<font color = "red">~~消息积压~~</font>**  
            `修复消费者问题` ---> ~~将原topic下的消息迁移到一个新的扩容的topic下（分区/队列扩容）~~ ---> 扩容消费者  


# 1. ~~mq~~  
<!-- 
为什么使用消息队列
https://mp.weixin.qq.com/s/OZspOzSdA1aUoy0C4-XArQ

分布式消息队列面试题  
https://gitee.com/shishan100/Java-Interview-Advanced/tree/master#%E5%88%86%E5%B8%83%E5%BC%8F%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97
消息队列常见问题总结和分析 
https://mp.weixin.qq.com/s/pHyBTR_liNocLt1XHhNMlw
MQ夺命连环11问
https://juejin.im/post/6877741789680238600
MQ消息中间件，面试能问些什么？     
https://mp.weixin.qq.com/s/-H83SlULvQf50fgHGcDMzA
-->

<!-- 
RocketMQ
如何基于RocketMQ设计一套全链路消息不丢失方案？ 
https://mp.weixin.qq.com/s/7MGeSFjg6HlKzjQidRJeXw
-->

## 1.1. 消息队列简介
&emsp; 消息队列中间件是分布式系统中最为重要的组件之一，主要解决应用耦合，异步消息，流量削锋等问题，是大型分布式系统不可缺少的中间件。消息队列技术是分布式应用间交换信息的一种技术，消息可驻留在内存或磁盘上，队列存储消息直到它们被应用程序读走。通过消息队列，应用程序可以相对独立地执行，它们不需要知道彼此的位置，只需要处理从消息队列发送来的消息和向消息队列发送消息。  
&emsp; 消息中间件的发展：第一代以ActiveMQ为代表，遵循JMS（java消息服务）规范；第二代以RabbitMQ为代表是一个有Erlang语言开发的AMQP（高级消息队列协议）的开源实现；第三代以Kafka为代表，是一代高吞吐、高可用的消息中间件，以及RocketMQ；   

&emsp; 常用的几种信息交互技术：httpClient、hessian、dubbo、jms、webservice。  
&emsp; RPC和消息中间件的差异：  

* RPC同步请求、消息中间件异步消息；  
* RPC和消息中间件的场景的差异很大程度上在于就是“依赖”和“量”。  

## 1.2. 为什么使用消息队列

### 1.2.1. 消息队列优点  
&emsp; <font color = "clime">消息队列在实际应用中常用的使用场景：异步处理，应用解耦，流量削锋。</font>  
 
* **应用/业务解耦**  
&emsp; **<font color = "clime">使用多线程开发，并不能做到解耦。</font>**  
&emsp; 场景说明：用户下单后，订单系统需要通知库存系统。传统的做法是，订单系统调用库存系统的接口。  
&emsp; 传统模式的缺点：1）假如库存系统无法访问，则订单减库存将失败，从而导致订单失败；2）订单系统与库存系统耦合；  
&emsp; 引入应用消息队列方案，解决上述问题：   
&emsp; 订单系统：用户下单后，订单系统完成持久化处理，将消息写入消息队列，返回用户订单下单成功。  
&emsp; 库存系统：订阅下单的消息，采用拉/推的方式，获取下单信息，库存系统根据下单信息，进行库存操作。  
&emsp; 假如：在下单时库存系统不能正常使用。也不影响正常下单，因为下单后，订单系统写入消息队列就不再关心其他的后续操作了。实现订单系统与库存系统的应用解耦。  
* **异步处理**  
&emsp; 引入消息队列，将不是必须的业务逻辑，异步处理。 
* **流量削锋/限流**  
&emsp; 上游系统的吞吐能力高于下游系统，在流量洪峰时可能会冲垮下游系统，消息中间件可以在峰值时堆积消息，而在峰值过去后下游系统慢慢消费消息解决流量洪峰的问题。  
&emsp; **流量削锋是消息队列中的常用场景，一般在秒杀或团抢活动中使用广泛。** 秒杀活动，一般会因为流量过大，导致流量暴增，应用挂掉。为解决这个问题，一般需要在应用前端加入消息队列。用户的请求，服务器接收后，首先写入消息队列。假如消息队列长度超过最大数量，则直接抛弃用户请求或跳转到错误页面。  
&emsp; 秒杀业务根据消息队列中的请求信息，再做后续处理。  
&emsp; 优点：可以控制活动的人数；可以缓解短时间内高流量压垮应用。  

----

&emsp; 先说一下消息队列的常见使用场景吧，其实场景有很多，但是比较核心的有3个：解耦、异步、削峰。  

* 解耦：现场画个图来说明一下：  
    ![image](http://182.92.69.8:8081/img/microService/mq/mq-6.png)  
    &emsp; A系统发送个数据到BCD三个系统，接口调用发送，那如果E系统也要这个数据呢？那如果C系统现在不需要了呢？现在A系统又要发送第二种数据了呢？A系统负责人濒临崩溃中。。。再来点更加崩溃的事儿，A系统要时时刻刻考虑BCDE四个系统如果挂了咋办？我要不要重发？我要不要把消息存起来？头发都白了啊。。。  
    ![image](http://182.92.69.8:8081/img/microService/mq/mq-7.png)  
    &emsp; **<font color = "clime">你需要去考虑一下你负责的系统中是否有类似的场景，就是一个系统或者一个模块，调用了多个系统或者模块，互相之间的调用很复杂，维护起来很麻烦。但是其实这个调用是不需要直接同步调用接口的，如果用MQ给他异步化解耦，也是可以的，你就需要去考虑在你的项目里，是不是可以运用这个MQ去进行系统的解耦。</font>**  
* 异步：现场画个图来说明一下，  
    ![image](http://182.92.69.8:8081/img/microService/mq/mq-8.png)  
    ![image](http://182.92.69.8:8081/img/microService/mq/mq-9.png)  
    &emsp; A系统接收一个请求，需要在自己本地写库，还需要在BCD三个系统写库，自己本地写库要3ms，BCD三个系统分别写库要300ms、450ms、200ms。最终请求总延时是3 + 300 + 450 + 200 = 953ms，接近1s，用户感觉搞个什么东西，慢死了慢死了。  
* 削峰：  
    &emsp; 每天0点到11点，A系统风平浪静，每秒并发请求数量就100个。结果每次一到11点~1点，每秒并发请求数量突然会暴增到1万条。但是系统最大的处理能力就只能是每秒钟处理1000个请求啊。。。尴尬了，系统会死。。。  

        说明，一般的MySQL扛到每秒2000个请求就差不多了，如果每秒请求到5000点话，可能就直接把MySql给打死了。  

    ![image](http://182.92.69.8:8081/img/microService/mq/mq-10.png)  
    ![image](http://182.92.69.8:8081/img/microService/mq/mq-11.png)  

### 1.2.2. 消息队列缺点  
![image](http://182.92.69.8:8081/img/microService/mq/mq-12.png)  
&emsp; **系统可用性降低：** 系统引入的外部依赖越多，越容易挂掉，本来你就是A系统调用BCD三个系统的接口就好了，人ABCD四个系统好好的，没啥问题，你偏加个MQ进来，万一MQ挂了咋整？MQ挂了，整套系统崩溃了，你不就完了么。  
&emsp; **系统复杂性提高：** 硬生生加个MQ进来，你怎么保证消息没有重复消费？怎么处理消息丢失的情况？怎么保证消息传递的顺序性？头大头大，问题一大堆，痛苦不已。  
&emsp; **一致性问题：** A系统处理完了直接返回成功了，人都以为你这个请求就成功了；但是问题是，要是BCD三个系统那里，BD两个系统写库成功了，结果C系统写库失败了，咋整？你这数据就不一致了。  
&emsp; 所以消息队列实际是一种非常复杂的架构，你引入它有很多好处，但是也得针对它带来的坏处做各种额外的技术方案和架构来规避掉，最好之后，你会发现，妈呀，系统复杂度提升了一个数量级，也许是复杂了10倍。但是关键时刻，用，还是得用的。。。  


<!-- 
https://blog.csdn.net/caodongfang126/article/details/102570555
-->

## 1.3. 消息队列设计
&emsp; [消息推拉机制](/docs/microService/mq/PushPull.md)  

## 1.4. 消息队列中间件选型  
&emsp; 电商使用RocketMQ，有序，事务；大数据使用Kafka。  

## 1.5. 消息队列使用事项
### 1.5.1. 保障可用性  
&emsp; ......
<!-- 
引入消息队列之后如何保证其高可用性
https://blog.csdn.net/zhaoziyun21/article/details/88376421
-->

### 1.5.2. 丢失消息（可靠性传输） 
&emsp; 消息队列丢失消息有3种情况：生产者丢失数据、mq客户端丢失数据、消费者丢失数据。  
&emsp; 两种方案解决。参考[kafka如何保证消息队列不丢失?](/docs/microService/mq/kafka/kafkaReliability.md)  
<!-- 
我发到消息队列里面的数据怎么不见了？
https://blog.csdn.net/hanjungua8144/article/details/86240261
-->

----

### 1.5.3. 重复消费  
<!-- 
04 我为什么在消息队列里消费到了重复的数据？
https://blog.csdn.net/hanjungua8144/article/details/86239428

MQ，究竟如何保证消息幂等？ 
https://mp.weixin.qq.com/s/lh1yLcKHDLSCatdA9EY6wQ
-->
&emsp; **消费消息的接口幂等。**  
1. 首先，上半场幂等。  
&emsp; MQ-client生成inner-msg-id，保证上半场幂等。  
&emsp; 这个ID全局唯一，业务无关，由MQ保证。  
2. 然后，下半场幂等。  
&emsp; 业务发送方带入biz-id，业务接收方去重保证幂等。  
&emsp; 这个ID对单业务唯一，业务相关，对MQ透明。  


### 1.5.4. 顺序消费  
<!-- 
我该怎么保证从消息队列里拿到的数据按顺序执行？
https://blog.csdn.net/hanjungua8144/article/details/86244930
https://www.cnblogs.com/jack1995/p/10908814.html
-->
&emsp; ......

### 1.5.5. 消息积压(消费消息延迟)  
&emsp; 查看[消息积压](/docs/microService/mq/MessageBacklog.md)  




