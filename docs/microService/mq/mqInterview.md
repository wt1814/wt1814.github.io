


<!-- TOC -->

- [1. MQ常见面试题](#1-mq常见面试题)
    - [1.1. 消息队列简介](#11-消息队列简介)
    - [1.2. 为什么使用消息队列](#12-为什么使用消息队列)
        - [1.2.1. 消息队列优点](#121-消息队列优点)
        - [1.2.2. 消息队列缺点](#122-消息队列缺点)
    - [1.3. 消息队列设计](#13-消息队列设计)
    - [1.4. 消息队列中间件选型](#14-消息队列中间件选型)
        - [1.4.1. 消息队列对比](#141-消息队列对比)
        - [1.4.2. 消息队列选型](#142-消息队列选型)
    - [1.5. 消息队列使用事项](#15-消息队列使用事项)
        - [1.5.1. 保障可用性](#151-保障可用性)
        - [1.5.2. 丢失消息（可靠性传输）](#152-丢失消息可靠性传输)
        - [1.5.3. 重复消费](#153-重复消费)
        - [1.5.4. 顺序消费](#154-顺序消费)
        - [1.5.5. 消息积压(消费消息延迟)](#155-消息积压消费消息延迟)

<!-- /TOC -->


&emsp; **<font color = "red">总结：</font>**  
1. 为什么使用mq？/应用场景   
    * 优点：解耦（调用多个系统，非同步调用）、异步、削锋（削qps）  
    * 日志处理：将消息队列用在日志处理中，比如 Kafka 的应用，解决大量日志传输的问题。  
    * 消息通讯：消息队列一般都内置了高效的通信机制，因此也可以用在纯消息通讯，比如实现聊天室等。  
    * 消息广播：如果没有消息队列，每当一个新业务方接入，都要接入一次新接口。有了消息队列，只需要关心消息是否送达了队列，至于谁订阅，是下游的事，无疑极大地减少了开发和联调的工作量。  
2. 消息队列选型  
    * RabbitMQ  
    * Kafka， 一开始的目的就是用于日志收集和传输，适合有大量数据产生的互联网业务，特别是大数据领域的实时计算、日志采集等场景，用 Kafka 绝对没错，社区活跃度高，业内标准。  
    * RocketMQ，特别适用于金融互联网领域这类对于可靠性要求很高的场景，比如订单交易等，而且 RocketMQ 是阿里出品的，经历过那么多次淘宝双十一的考验，大品牌，在稳定性值得信赖。但如果阿里不再维护这个技术了，社区有可能突然黄掉的风险。因此如果公司对自己的技术实力有自信，基础架构研发实力较强，推荐用 RocketMQ。 
3. 消息队列使用事项  
    1. 架构  
        1. 保障高可用  
    2. 生产者  
        1. 消息队列丢失消息有3种情况：生产者丢失数据、mq客户端丢失数据、消费者丢失数据。提供两种方案解决。    
    3. 消费者  
        1. 重复消费  
            消费接口幂等性。  
        2. 顺序消费  
            发送到单个queue或partition，单线程消费。  
        3. **<font color = "red">~~消息积压~~</font>**  
            `修复消费者问题` ---> ~~将原topic下的消息迁移到一个新的扩容的topic下（分区/队列扩容）~~ ---> 扩容消费者  


# 1. MQ常见面试题  
<!-- 
为什么使用消息队列
https://mp.weixin.qq.com/s/OZspOzSdA1aUoy0C4-XArQ

分布式消息队列面试题  
https://gitee.com/shishan100/Java-Interview-Advanced/tree/master#%E5%88%86%E5%B8%83%E5%BC%8F%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97
消息队列常见问题总结和分析 
https://mp.weixin.qq.com/s/pHyBTR_liNocLt1XHhNMlw
MQ夺命连环11问
https://juejin.im/post/6877741789680238600
MQ消息中间件，面试能问些什么？     
https://mp.weixin.qq.com/s/-H83SlULvQf50fgHGcDMzA
-->

<!-- 
RocketMQ
如何基于RocketMQ设计一套全链路消息不丢失方案？ 
https://mp.weixin.qq.com/s/7MGeSFjg6HlKzjQidRJeXw
-->

## 1.1. 消息队列简介
&emsp; 消息队列中间件是分布式系统中最为重要的组件之一，主要解决应用耦合，异步消息，流量削锋等问题，是大型分布式系统不可缺少的中间件。消息队列技术是分布式应用间交换信息的一种技术，消息可驻留在内存或磁盘上，队列存储消息直到它们被应用程序读走。通过消息队列，应用程序可以相对独立地执行，它们不需要知道彼此的位置，只需要处理从消息队列发送来的消息和向消息队列发送消息。  
&emsp; 消息中间件的发展：第一代以ActiveMQ为代表，遵循JMS（java消息服务）规范；第二代以RabbitMQ为代表是一个有Erlang语言开发的AMQP（高级消息队列协议）的开源实现；第三代以Kafka为代表，是一代高吞吐、高可用的消息中间件，以及RocketMQ；   

&emsp; 常用的几种信息交互技术：httpClient、hessian、dubbo、jms、webservice。  
&emsp; RPC和消息中间件的差异：  

* RPC同步请求、消息中间件异步消息；  
* RPC和消息中间件的场景的差异很大程度上在于就是“依赖”和“量”。  

## 1.2. 为什么使用消息队列

### 1.2.1. 消息队列优点  
&emsp; <font color = "clime">消息队列在实际应用中常用的使用场景：异步处理，应用解耦，流量削锋。</font>  
 
* **应用/业务解耦**  
&emsp; **<font color = "clime">使用多线程开发，并不能做到解耦。</font>**  
&emsp; 场景说明：用户下单后，订单系统需要通知库存系统。传统的做法是，订单系统调用库存系统的接口。  
&emsp; 传统模式的缺点：1）假如库存系统无法访问，则订单减库存将失败，从而导致订单失败；2）订单系统与库存系统耦合；  
&emsp; 引入应用消息队列方案，解决上述问题：   
&emsp; 订单系统：用户下单后，订单系统完成持久化处理，将消息写入消息队列，返回用户订单下单成功。  
&emsp; 库存系统：订阅下单的消息，采用拉/推的方式，获取下单信息，库存系统根据下单信息，进行库存操作。  
&emsp; 假如：在下单时库存系统不能正常使用。也不影响正常下单，因为下单后，订单系统写入消息队列就不再关心其他的后续操作了。实现订单系统与库存系统的应用解耦。  
* **异步处理**  
&emsp; 引入消息队列，将不是必须的业务逻辑，异步处理。 
* **流量削锋/限流**  
&emsp; 上游系统的吞吐能力高于下游系统，在流量洪峰时可能会冲垮下游系统，消息中间件可以在峰值时堆积消息，而在峰值过去后下游系统慢慢消费消息解决流量洪峰的问题。  
&emsp; **流量削锋是消息队列中的常用场景，一般在秒杀或团抢活动中使用广泛。** 秒杀活动，一般会因为流量过大，导致流量暴增，应用挂掉。为解决这个问题，一般需要在应用前端加入消息队列。用户的请求，服务器接收后，首先写入消息队列。假如消息队列长度超过最大数量，则直接抛弃用户请求或跳转到错误页面。  
&emsp; 秒杀业务根据消息队列中的请求信息，再做后续处理。  
&emsp; 优点：可以控制活动的人数；可以缓解短时间内高流量压垮应用。  

----

&emsp; 先说一下消息队列的常见使用场景吧，其实场景有很多，但是比较核心的有3个：解耦、异步、削峰。  

* 解耦：现场画个图来说明一下：  
    ![image](http://182.92.69.8:8081/img/microService/mq/mq-6.png)  
    &emsp; A系统发送个数据到BCD三个系统，接口调用发送，那如果E系统也要这个数据呢？那如果C系统现在不需要了呢？现在A系统又要发送第二种数据了呢？A系统负责人濒临崩溃中。。。再来点更加崩溃的事儿，A系统要时时刻刻考虑BCDE四个系统如果挂了咋办？我要不要重发？我要不要把消息存起来？头发都白了啊。。。  
    ![image](http://182.92.69.8:8081/img/microService/mq/mq-7.png)  
    &emsp; **<font color = "clime">你需要去考虑一下你负责的系统中是否有类似的场景，就是一个系统或者一个模块，调用了多个系统或者模块，互相之间的调用很复杂，维护起来很麻烦。但是其实这个调用是不需要直接同步调用接口的，如果用MQ给他异步化解耦，也是可以的，你就需要去考虑在你的项目里，是不是可以运用这个MQ去进行系统的解耦。</font>**  
* 异步：现场画个图来说明一下，  
    ![image](http://182.92.69.8:8081/img/microService/mq/mq-8.png)  
    ![image](http://182.92.69.8:8081/img/microService/mq/mq-9.png)  
    &emsp; A系统接收一个请求，需要在自己本地写库，还需要在BCD三个系统写库，自己本地写库要3ms，BCD三个系统分别写库要300ms、450ms、200ms。最终请求总延时是3 + 300 + 450 + 200 = 953ms，接近1s，用户感觉搞个什么东西，慢死了慢死了。  
* 削峰：  
    &emsp; 每天0点到11点，A系统风平浪静，每秒并发请求数量就100个。结果每次一到11点~1点，每秒并发请求数量突然会暴增到1万条。但是系统最大的处理能力就只能是每秒钟处理1000个请求啊。。。尴尬了，系统会死。。。  

        说明，一般的MySQL扛到每秒2000个请求就差不多了，如果每秒请求到5000点话，可能就直接把MySql给打死了。  

    ![image](http://182.92.69.8:8081/img/microService/mq/mq-10.png)  
    ![image](http://182.92.69.8:8081/img/microService/mq/mq-11.png) 

--------------------------

<!--
十分钟搞懂消息队列的选型
https://blog.csdn.net/weixin_44668898/article/details/127718300
-->

* 应用解耦：消息队列减少了服务之间的耦合性，不同的服务可以通过消息队列进行通信，而不用关心彼此的实现细节。  
* 异步处理：消息队列本身是异步的，它允许接收者在消息发送很长时间后再取回消息。  
* 流量削锋：当上下游系统处理能力存在差距的时候，利用消息队列做一个通用的”载体”，在下游有能力处理的时候，再进行分发与处理。  
* 日志处理：将消息队列用在日志处理中，比如 Kafka 的应用，解决大量日志传输的问题。  
* 消息通讯：消息队列一般都内置了高效的通信机制，因此也可以用在纯消息通讯，比如实现聊天室等。  
* 消息广播：如果没有消息队列，每当一个新业务方接入，都要接入一次新接口。有了消息队列，我们只需要关心消息是否送达了队列，至于谁订阅，是下游的事，无疑极大地减少了开发和联调的工作量。  



### 1.2.2. 消息队列缺点  
![image](http://182.92.69.8:8081/img/microService/mq/mq-12.png)  
&emsp; **系统可用性降低：** 系统引入的外部依赖越多，越容易挂掉，本来你就是A系统调用BCD三个系统的接口就好了，人ABCD四个系统好好的，没啥问题，你偏加个MQ进来，万一MQ挂了咋整？MQ挂了，整套系统崩溃了，你不就完了么。  
&emsp; **系统复杂性提高：** 硬生生加个MQ进来，你怎么保证消息没有重复消费？怎么处理消息丢失的情况？怎么保证消息传递的顺序性？头大头大，问题一大堆，痛苦不已。  
&emsp; **一致性问题：** A系统处理完了直接返回成功了，人都以为你这个请求就成功了；但是问题是，要是BCD三个系统那里，BD两个系统写库成功了，结果C系统写库失败了，咋整？你这数据就不一致了。  
&emsp; 所以消息队列实际是一种非常复杂的架构，你引入它有很多好处，但是也得针对它带来的坏处做各种额外的技术方案和架构来规避掉，最好之后，你会发现，妈呀，系统复杂度提升了一个数量级，也许是复杂了10倍。但是关键时刻，用，还是得用的。。。  


<!-- 
https://blog.csdn.net/caodongfang126/article/details/102570555
-->

## 1.3. 消息队列设计
&emsp; [消息推拉机制](/docs/microService/mq/PushPull.md)  

## 1.4. 消息队列中间件选型  
&emsp; 电商使用RocketMQ，有序，事务；大数据使用Kafka。  

<!-- 

https://blog.csdn.net/weixin_44668898/article/details/127718300
-->

### 1.4.1. 消息队列对比
消息队列有 ActiveMQ、ZeroMQ、RabbitMQ、RocketMQ、Kafka，其中 ZeroMQ 太过轻量，主要用于学习，实际是不会应用到生产，所以主要对比 Kafka、RocketMQ、RabbitMQ、ActiveMQ 这四种 MQ。  

|特性	|Kafka|	RocketMQ	|RabbitMQ	|ActiveMQ|
|---|---|---|---|---|
|单机吞吐量|	10万级别，吞吐量高是kafka最大的优点	|10万级，RocketMQ 也是可以支撑高吞吐的 |MQ	万级，吞吐量比RocketMQ和Kafka要低了一个数量级|	万级，吞吐量比RocketMQ和Kafka要低了一个数量级|
|支持主题数	|百级，topic 达到百级时吞吐量会大幅度下降，要尽量保证 topic 数量不要过多，否则需要增加更多机器资源|	千级，topic 达到千级时吞吐量会有较小幅度的下降。可以支撑大量 topic 是 RocketMQ 的一大优点 |	百万级	|千级|
|消息顺序性|	分区有序|	有序	|有序|	有序|
|消息重复	|至少一次，最多一次	至少一次，最多一次|	至少一次	|至少一次|
|时效性|	ms级	|ms级	|微秒级，RabbitMQ的一大优点	|ms级|
|可用性	非常高，分布式架构，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用|	非常高，分布式架构	|高，基于主从架构实现高可用性|	高，基于主从架构实现高可用性|
|消息可靠性|	经过参数优化配置，理论上消息可以做到0丢失|	经过参数优化配置，理论上消息可以做到0丢失|	有较低的概率丢失数据|	有较低的概率丢失数据|
|消息回溯|	支持（按offset回溯）|	支持（按时间回溯）|	不支持	|不支持|
|功能支持|	功能较为简单，主要支持简单的MQ功能，在大数据领域的实时计算以及日志采集被大规模使用，是事实上的标准|	MQ功能较为完善，还是分布式的，扩展性好|	基于erlang开发，所以并发能力很强，性能极其好，延时很低|	MQ领域的功能极其完备|
|伸缩性	|高伸缩性，每个主题（topic）包含多个分区（partition），主题中的分区可以分布在不同的主机（broker）中	|高伸缩性，灵活的分布式横向扩展部署架构，整体架构和 kafka 很像	|一般	| |
|管理界面|	普通|	完善|	普通|	普通|
|持久化	|消息可以持久化到磁盘|	消息可以持久化到磁盘|	持久化不好，可以持久化到内存、文件	|可以持久化到内存、文件、数据库|
|消息路由|	不支持|	不支持|	支持| |	
|语言支持	|支持多语言，Java优先|	支持Java、C++，但C++不成熟	|支持几乎所有最受欢迎的编程语言：Java，C，C ++，C＃，Ruby，Perl，Python，PHP等|	支持多语言，Java优先|
|社区活跃度|	高	|一般	|高	|高|


### 1.4.2. 消息队列选型
&emsp; Kafka 和 RocketMQ 都支持 10w 级别的高吞吐量。  
&emsp; Kafka 一开始的目的就是用于日志收集和传输，适合有大量数据产生的互联网业务，特别是大数据领域的实时计算、日志采集等场景，用 Kafka 绝对没错，社区活跃度高，业内标准。  
&emsp; RocketMQ 特别适用于金融互联网领域这类对于可靠性要求很高的场景，比如订单交易等，而且 RocketMQ 是阿里出品的，经历过那么多次淘宝双十一的考验，大品牌，在稳定性值得信赖。但如果阿里不再维护这个技术了，社区有可能突然黄掉的风险。因此如果公司对自己的技术实力有自信，基础架构研发实力较强，推荐用 RocketMQ。  
&emsp; RabbitMQ 适用于公司对外提供能力，可能会有很多主题接入的中台业务场景，毕竟它是百万级主题数的。它的时效性是毫秒级的，但实际毫秒级和微秒级在感知上没有什么太大的区别，所以它的这一大优点并不太会作为考量标准。同时，它的功能是比较完善的，开源社区活跃度高，能解决开发中遇到的bug，所以万级别数据量业务场景的小公司可以优先选择功能完善的RabbitMQ。它的缺点就是用 Erlang 语言编写，所以很多开发人员很难去看懂源码并进行二次开发和维护，也就是说对于公司来说可能处于不可控的状态。  
&emsp; ActiveMQ 现在很少有人用，没怎么经过大规模吞吐量场景的考验，社区不怎么活跃，官方社区现在对 ActiveMQ 5.x 维护也越来越少，所以不推荐使用。  


## 1.5. 消息队列使用事项
### 1.5.1. 保障可用性  
&emsp; ......
<!-- 
引入消息队列之后如何保证其高可用性
https://blog.csdn.net/zhaoziyun21/article/details/88376421
-->

### 1.5.2. 丢失消息（可靠性传输） 
&emsp; 消息队列丢失消息有3种情况：生产者丢失数据、mq客户端丢失数据、消费者丢失数据。  
&emsp; 两种方案解决。参考[kafka如何保证消息队列不丢失?](/docs/microService/mq/kafka/kafkaReliability.md)  
<!-- 
我发到消息队列里面的数据怎么不见了？
https://blog.csdn.net/hanjungua8144/article/details/86240261
-->

----

### 1.5.3. 重复消费  
<!-- 
04 我为什么在消息队列里消费到了重复的数据？
https://blog.csdn.net/hanjungua8144/article/details/86239428

MQ，究竟如何保证消息幂等？ 
https://mp.weixin.qq.com/s/lh1yLcKHDLSCatdA9EY6wQ
-->
&emsp; **消费消息的接口幂等。**  
1. 首先，上半场幂等。  
&emsp; MQ-client生成inner-msg-id，保证上半场幂等。  
&emsp; 这个ID全局唯一，业务无关，由MQ保证。  
2. 然后，下半场幂等。  
&emsp; 业务发送方带入biz-id，业务接收方去重保证幂等。  
&emsp; 这个ID对单业务唯一，业务相关，对MQ透明。  


### 1.5.4. 顺序消费  
<!-- 
我该怎么保证从消息队列里拿到的数据按顺序执行？
https://blog.csdn.net/hanjungua8144/article/details/86244930
https://www.cnblogs.com/jack1995/p/10908814.html
-->
&emsp; ......

### 1.5.5. 消息积压(消费消息延迟)  
&emsp; 查看[消息积压](/docs/microService/mq/MessageBacklog.md)  




