---
title: NIO
date: 2020-05-30 00:00:00
tags:
    - 分布式通信
---

<!-- TOC -->

- [1. IO模型](#1-io模型)
    - [1.1. 同步、异步](#11-同步异步)
    - [1.2. 阻塞、非阻塞](#12-阻塞非阻塞)
    - [1.3. IO模型，BIO、NIO、AIO](#13-io模型bionioaio)
- [2. NIO简介](#2-nio简介)

<!-- /TOC -->



# 1. IO模型  

## 1.1. 同步、异步  
&emsp; 同步请求，A调用B，B的处理是同步的，在处理完之前不会通知A，只有处理完之后才会明确的通知A。  
&emsp; 异步请求，A调用B，B的处理是异步的，B在接到请求后先告诉A已经接到请求了，然后异步去处理，处理完之后通过回调等方式再通知A。  
&emsp; 所以说，同步和异步最大的区别就是被调用方的执行方式和返回时机。同步指的是被调用方做完事情之后再返回，异步指的是被调用方先返回，然后再做事情，做完之后再想办法通知调用方。  

## 1.2. 阻塞、非阻塞  
&emsp; 阻塞请求，A调用B，A一直等着B的返回，别的事情什么也不干。  
&emsp; 非阻塞请求，A调用B，A不用一直等着B的返回，先去处理其他事情。  
&emsp; 所以说，阻塞非阻塞最大的区别就是在被调用方返回结果之前的这段时间内，调用方是否一直等待。阻塞指的是调用方一直等待别的事情什么都不做。非阻塞指的是调用方先去忙别的事情。  

&emsp; ***阻塞、非阻塞和同步、异步的区别：***  
&emsp; 阻塞、非阻塞和同步、异步其实针对的对象是不一样的。阻塞、非阻塞说的是调用者，同步、异步说的是被调用者。  

## 1.3. IO模型，BIO、NIO、AIO  
* 同步阻塞IO（BIO，Block-IO）：用户进程在发起一个IO操作以后，必须等待IO操作的完成。只有当真正完成了IO操作以后，用户进程才能运行。Java传统的IO模型属于此种方式！  
* 同步非阻塞IO（NIO，Non-Block IO）：在此种方式下，用户进程发起一个IO操作以后便可返回做其它事情，但是用户进程需要时不时的询问IO操作是否就绪，这就要求用户进程不停的去询问，从而引入不必要的CPU资源浪费。其中目前Java的NIO就属于同步非阻塞IO。  
* 异步阻塞IO：此种方式下是指应用发起一个IO操作以后，不等待内核IO操作的完成，等内核完成IO操作以后会通知应用程序，这其实就是同步和异步最关键的区别，同步必须等待或者主动的去询问IO是否完成，那么为什么说是阻塞的呢？因为此时是通过select系统调用来完成的，而select函数本身的实现方式是阻塞的，而采用select函数有个好处就是它可以同时监听多个文件句柄，从而提高系统的并发性！  
* 异步非阻塞IO（AIO，Asynchronous IO）：在此种模式下，用户进程只需要发起一个IO操作然后立即返回，等IO操作真正的完成以后，应用程序会得到IO操作完成的通知，此时用户进程只需要对数据进行处理就好了，不需要进行实际的IO读写操作，因为真正的IO读取或者写入操作已经由内核完成了。  

&emsp; 适用场景：  

* BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解。  
* NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持。  
* AIO方式适用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK1.7开始支持。  

# 2. NIO简介  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/microService/communication/NIO-14.png)  

&emsp; ***<font color = "red">NIO基本组件</font>***  
&emsp; NIO读写是I/O的基本过程。读写操作中使用的核心部件有：Channels、Buffers、Selectors。在标准I/O中，使用字符流和字节流；在NIO中使用通道和缓冲区。  

* Channel(通道)：在缓冲区和位于通道另一侧的服务之间进行数据传输，支持单向或双向传输，支持阻塞或非阻塞模式。  
    &emsp; 通道列表：  

    |通道类型|作用|
    |---|---|
    |FileChannel|从文件中读写数据|
    |SocketChannel|能通过TCP读写网络中的数据|
    |DatagramChannel|能通过UDP读写网络中的数据|
    |ServerSocketChannel|可以监听新进来的TCP连接，对每一个新进来的连接都会创建一个SocketChannel|
* Buffer(缓冲区)：高效数据容器。本质上是一块内存区，用于数据的读写，NIO Buffer将其包裹并提供开发时常用的接口，便于数据操作。  
    &emsp; NIO中的所有I/O都是通过一个通道开始的。数据总是从缓冲区写入通道，并从通道读取到缓冲区。从通道读取：创建一个缓冲区，然后请求通道读取数据。通道写入：创建一个缓冲区，填充数据，并要求通道写入数据。  
    &emsp; 缓冲列表：  
    &emsp; 在NIO中使用的核心缓冲区如下：CharBuffer、DoubleBuffer、IntBuffer、LongBuffer、ByteBuffer、ShortBuffer、FloatBuffer。上述缓冲区覆盖了通过I/O发送的基本数据类型：characters，double，int，long，byte，short和float。
* Selectors（选择器）  
    &emsp; Selector(IO复用器/选择器)：多路复用的重要组成部分，检查一个或多个Channel(通道)是否是可读、写状态，实现单线程管理多Channel(通道)，优于使用多线程或线程池产生的系统资源开销。如果应用程序有多个通道(连接)打开，但每个连接的流量都很低，则可考虑使用Selectors。


