<!-- TOC -->

- [1. 数据库分布式](#1-数据库分布式)
    - [1.1. MySql性能(最大数据量、最大并发数、查询耗时)](#11-mysql性能最大数据量最大并发数查询耗时)
    - [1.2. 数据库瓶颈](#12-数据库瓶颈)
    - [1.3. 数据库分布式](#13-数据库分布式)

<!-- /TOC -->

# 1. 数据库分布式
## 1.1. MySql性能(最大数据量、最大并发数、查询耗时)

* 最大并发数：  
&emsp; 并发数是指同一时刻数据库能处理多少个请求，由max_connections和max_user_connections决定。max_connections是指MySQL实例的最大连接数，上限值是16384，max_user_connections是指每个数据库用户的最大连接数。  
&emsp; **MySQL会为每个连接提供缓冲区，意味着消耗更多的内存。** 如果连接数设置太高，硬件吃不消，太低又不能充分利用硬件。一般要求两者比值超过10%，计算方法如下：  
        
        max_used_connections / max_connections * 100% = 3/100 *100% ≈ 3%
 
    &emsp; 查看最大连接数与响应最大连接数：  

    ```sql
    show variables like '%max_connections%';
    show variables like '%max_user_connections%';
    ```

    &emsp; 在配置文件my.cnf中修改最大连接数  

        [mysqld]
        max_connections = 100
        max_used_connections = 20

* 查询耗时0.5秒：  
&emsp; 建议将单次查询耗时控制在0.5秒以内，0.5秒是个经验值，源于用户体验的3秒原则。如果用户的操作3秒内没有响应，将会厌烦甚至退出。响应时间=客户端UI渲染耗时+网络请求耗时+应用程序处理耗时+查询数据库耗时，0.5秒就是留给数据库1/6的处理时间。 

* 最大数据量：  
&emsp; MySQL没有限制单表最大记录数，它取决于操作系统对文件大小的限制。  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/SQL/sql-28.png)  
&emsp; <font color = "red">《阿里巴巴Java开发手册》提出单表行数超过500万行或者单表容量超过2GB，才推荐分库分表。</font>500万仅供参考，并非铁律。  


## 1.2. 数据库瓶颈
<!-- 
CTO：这四种情况下，才是考虑分库分表的时候！ 
https://mp.weixin.qq.com/s/aR53IsVYLKmx06_2zrG_Ig
-->
&emsp; **数据库瓶颈：<font color = "clime">`不管是IO瓶颈，还是CPU瓶颈，最终都会导致数据库的活跃连接数增加，进而逼近甚至达到数据库可承载活跃连接数的阈值。在业务Service来看就是，可用数据库连接少甚至无连接可用。`</font>**   
1. IO瓶颈：  
&emsp; 第一种：磁盘读IO瓶颈，热点数据太多，数据库缓存放不下，每次查询时会产生大量的IO，降低查询速度。---> 分库和垂直分表。  
&emsp; 第二种：网络IO瓶颈，请求的数据太多(MySql一般并发数200～500)，网络带宽不够。---> 分库。  
2. CPU瓶颈：  
&emsp; 第一种：SQL问题，如SQL中包含join，group by，order by，非索引字段条件查询等，增加CPU运算的操作。 ---> SQL优化，建立合适的索引，在业务Service层进行业务计算。  
&emsp; 第二种：单表数据量太大(达到1000W或100G以后)，查询时扫描的行太多，SQL效率低，CPU率先出现瓶颈。---> 水平分表。  


## 1.3. 数据库分布式
&emsp; 数据库分布式核心内容是数据切分(Sharding)，以及切分后对数据的定位、整合。数据切分就是将数据分散存储到多个数据库中，使得单一数据库中的数据量变小，通过扩充主机的数量缓解单一数据库的性能问题，从而达到提升数据库操作性能的目的。 **数据库拆分过程基本遵循的顺序是：1).垂直拆分(业务拆分)、2).读写分离、3).分库分表(水平拆分)。每个拆分过程都能解决业务上的一些问题，但同时也面临了一些挑战。**  


&emsp; [主从复制](/docs/SQL/replication.md)  
&emsp; &emsp; [主从复制的问题](/docs/SQL/replicationProblem.md)  
&emsp; [分区](/docs/SQL/partition.md)  
&emsp; [分库分表](/docs/SQL/sub.md)  
&emsp; [数据库分布式实现](/docs/SQL/subRealize.md)  
&emsp; &emsp; [MyCat中间件](/docs/SQL/MyCat.md) 

&emsp; **分表和分区的联系：**  
1. 实现方式上：
    * mysql的分表是真正的分表，一张表分成很多表后，每一个小表都是完整的一张表，都对应三个文件，一个.MYD数据文件，.MYI索引文件，.frm表结构文件。  
    * 分区不一样，一张大表进行分区后，还是一张表，不会变成多张表，但是存放数据的区块变多了。  
2. 数据处理上： 
    * 分表后，数据都是存放在分表里，总表只是一个外壳，存取数据发生在一个一个的分表里面。  
    * 分区不存在分表的概念，分区只不过把存放数据的文件分成了许多小块，分区后的表还是一张表。数据处理还是由自己来完成。  

&emsp; **分表和分区的联系：**  
1. 都能提高mysql的性能，在高并发状态下都有一个良好的表面。 
2. **<font color = "clime">分表和分区不矛盾，可以相互配合。</font>** 对于那些大访问量，并且表数据比较多的表，可以采取分表和分区结合的方式(如果merge这种分表方式，不能和分区配合的话，可以用其他的分表试)，访问量不大，但是表数据很多的表，可以采取分区的方式等。

&emsp; **分库分表与读写分离：** `读写分离实现了数据库读能力的水平扩展，分库分表实现了写能力的水平扩展。`  
1. 存储能力的水平扩展：在读写分离的情况下，每个集群中的master和slave基本上数据是完全一致的，从存储能力来说，存在海量数据的情况下，可能由于磁盘空间的限制，无法存储所有的数据。而在分库分表的情况下，可以搭建多个mysql主从复制集群，每个集群只存储部分分片的数据，实现存储能力的水平扩展。  
2. 写能力的水平扩展：在读写分离的情况下，由于每个集群只有一个master，所有的写操作压力都集中在这一个节点上，在写入并发非常高的情况下，这里会成为整个系统的瓶颈。  

&emsp; 而在分库分表的情况下，每个分片所属的集群都有一个master节点，都可以执行写入操作，实现写能力的水平扩展。此外减小建立索引开销，降低写操作的锁操作耗时等，都会带来很多显然的好处。  
