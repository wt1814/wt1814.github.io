
<!-- TOC -->

- [1. 各种索引](#1-各种索引)
    - [1.1. 聚簇索引和非聚簇索引](#11-聚簇索引和非聚簇索引)
    - [1.2. 普通索引和唯一索引的区别？](#12-普通索引和唯一索引的区别)
    - [1.3. 为什么官方建议InnoDB使用自增长主键作为索引？](#13-为什么官方建议innodb使用自增长主键作为索引)

<!-- /TOC -->

&emsp; **<font color = "red">总结：</font>**  
1. 聚簇索引和非聚簇索引  
    1. 什么是？  
    2. 非聚簇索引一定会回表查询吗?(覆盖索引)

2. 普通索引和唯一索引的区别？  


# 1. 各种索引  

## 1.1. 聚簇索引和非聚簇索引 
&emsp; <font color = "red">InnoDB索引类型可以分为主键索引和辅助索引（非主键索引）。</font>  
&emsp; **<font color = "clime">主键索引树中，叶子结点保存着主键和对应行的全部数据。主键索引又被称为聚簇索引。</font>**   
![image](http://182.92.69.8:8081/img/SQL/sql-34.png)  
&emsp; **<font color = "clime">辅助索引树中，叶子结点保存着索引值和主键值。辅助索引又被称为非聚簇索引。当使用辅助索引进行查询时，一般需要进行回表操作。</font>**   

        什么是回表？  
        如果是通过主键索引查询的，会直接搜索B+树，从而查询到数据。
        如果不是通过主键索引查询到，需要先搜索索引树，得到在B+树上的值，再到B+树上搜索符合条件的数据，这个过程就是“回表”。
<!-- 
什么是回表查询？
InnoDB 中，对于主键索引，只需要走一遍主键索引的查询就能在叶子节点拿到数据。
而对于普通索引，叶子节点存储的是 key + 主键值，因此需要再走一次主键索引，通过主键索引找到行记录，这就是所谓的回表查询，先定位主键值，再定位行记录。
-->
&emsp; <font color = "red">非聚簇索引一定会回表查询吗?(覆盖索引)</font>  
&emsp; 不一定，这涉及到查询语句所要求的字段是否全部命中了索引，如果全部命中了索引，即索引覆盖，那么就不必再进行回表查询。  
    
        索引覆盖，要查询的字段都建立了索引，那么引擎会直接在索引表中查询而不会访问原始数据(否则只要有一个字段没有建立索引就会做全表扫描)，这叫索引覆盖。

&emsp; 总结：B+树在满足聚簇索引和覆盖索引的时候不需要回表查询数据。  
![image](http://182.92.69.8:8081/img/SQL/sql-35.png)  

## 1.2. 普通索引和唯一索引的区别？
&emsp; 唯一索引和普通索引的区别？  

* 查询过程：  
&emsp; 执行查询的语句是`select id from T where k=5`。  
&emsp; 对于普通索引来说，查找到满足条件的第一个记录(5,500)后，需要查找下一个记录，直到碰到第一个不满足k=5条件的记录。  
&emsp; 对于唯一索引来说，<font color = "red">由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止继续检索。</font>  
* 更新过程：  
&emsp; **<font color = "clime">普通索引会使用[ChangeBuffer](/docs/SQL/ChangeBuffer.md)提升性能。而change buffer不适用于唯一索引。</font>**  

* 索引选择和实践：  
&emsp; 其实，这两类索引在查询能力上是没差别的，主要考虑的是对更新性能的影响。所以，建议尽量选择普通索引。  
&emsp; **<font color = "clime">如果所有的更新后面，都马上伴随着对这个记录的查询，那么应该关闭change buffer。而在其他情况下，change buffer都能提升更新性能。</font>**  
&emsp; 在实际使用中，普通索引和change buffer的配合使用，对于数据量大的表的更新优化还是很明显的。  

## 1.3. 为什么官方建议InnoDB使用自增长主键作为索引？  
<!-- 
InnoDB 表必须要有主键，并且推荐使用整型自增主键  
如果我们在设计表结构时没有显式指定索引列的话，MySQL 会从表中选择数据不重复的列建立索引，如果没有符合的列，则 MySQL 自动为 InnoDB 表生成一个隐含字段作为主键，并且这个字段长度为6个字节，类型为整型。  
那为什么推荐使用整型自增主键而不是选择UUID？  
    UUID是字符串，比整型消耗更多的存储空间；

    在B+树中进行查找时需要跟经过的节点值比较大小，整型数据的比较运算比字符串更快速；

    自增的整型索引在磁盘中会连续存储，在读取一页数据时也是连续；UUID是随机产生的，读取的上下两行数据存储是分散的，不适合执行where id > 5 && id < 20的条件查询语句。

    在插入或删除数据时，整型自增主键会在叶子结点的末尾建立新的叶子节点，不会破坏左侧子树的结构；UUID主键很容易出现这样的情况，B+树为了维持自身的特性，有可能会进行结构的重构，消耗更多的时间。
-->

        适合用业务字段做主键的场景需求：  
        1).只有一个索引；2).该索引必须是唯一索引。这就是典型的KV场景。由于没有其他索引，所以也就不用考虑其他索引的叶子节点大小的问题。 

```text
没有定义主键，InnoDB会如何处理？  
    如果定义了主键(PRIMARY KEY)，那么InnoDB会选择主键作为聚集索引。  
    如果没有显式定义主键，则InnoDB会选择第一个不包含有NULL值的唯一索引作为主键索引。  
    如果也没有这样的唯一索引，则InnoDB会选择内置6字节长的ROWID作为隐含的聚集索引(ROWID随着行记录的写入而主键递增，这个ROWID不像ORACLE的ROWID那样可引用，是隐含的)。  
```

1. 存储空间：  
&emsp; 由于每个非主键索引的叶子节点上都是主键的值。如果用业务字段做主键，那么每个二级索引的叶子节点占用约xxx个字节，而如果用整型做主键，则只要4个字节，如果是长整型(bigint)则是8个字节。<font color = "red">即主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。</font>  
2. 性能：  
&emsp; <font color = "red">根据B+Tree的特点，自增主键是连续的，在插入过程中尽量减少InnoDB存储引擎的页分裂，</font>即使要进行页分裂，也只会分裂很少一部分。并且能减少数据的移动，每次插入都是插入到最后。即减少分裂和移动的频率。  
&emsp; <font color = "clime">如果写入是乱序的，InnoDB不得不频繁地做页分裂操作，以便为新的行分配空间。</font>页分裂会导致移动大量数据，一次插入最少需要修改三个页而不是一个页。 <font color = "clime">如果频繁的页分裂，页会变得稀疏并被不规则地填充，所以最终数据会有[碎片](/docs/SQL/Fragment.md)  。</font>  

