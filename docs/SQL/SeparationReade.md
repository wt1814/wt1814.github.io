


# 1. 读写分离  
&emsp; 读写分离在数据库主从复制技术基础上实现（主从复制针对写入数据，读写分离主要针对读取数据）。  

## 1.1. 读写分离带来的问题  
* 数据不一致问题（主从数据同步延迟问题）：当主库的TPS并发较高时，由于主库上面是多线程写入的，而从库的SQL线程是单线程的，导致从库SQL可能会跟不上主库的处理速度。因此有可能出现在master节点中已经插入了数据，但是从slave节点却读取不到的问题。 **<font color = "red">对于一些强一致性的业务场景，要求插入后必须能读取到，对于这种情况，需要提供一种方式，让读请求也可以走主库。</font>**  
&emsp; 延迟的解决：    
    1. 网络方面：将从库分布在相同局域网内或网络延迟较小的环境中。  
    2. 硬件方面：从库配置更好的硬件，提升随机写的性能。  
    3. 配置方面：从库配置sync_binlog=0，innodb_flush_log_at_trx_commit=2，logs-slave-updates=0，增大innodb_buffer_pool_size，让更多操作在Mysql内存中完成，减少磁盘操作。或者升级Mysql5.7版本使用并行复制。  
    4. 架构方面：比如在事务当中尽量对主库读写，其他非事务中的读在从库。消除一部分延迟带来的数据库不一致。增加缓存降低一些从库的负载。  
* 事务问题：读写分离属于分布式事务的范畴。但是对于读写分离，目前主流的做法是，事务中的所有sql统一都走主库，由于只涉及到一个库，本地事务就可以搞定。  
* 感知集群信息变更：如果访问的数据库集群信息变更了，例如主从切换了，写流量就要到新的主库上；又例如增加了从库数量，流量需要可以打到新的从库上；又或者某个从库延迟或者失败率比较高，应该将这个从库进行隔离，读流量尽量打到正常的从库上。  
* 运维：例如集群搭建、主从切换、从库扩容、缩容等。例如master配置了多个slave节点，如果其中某个slave节点挂了，那么之后的读请求，应用将其转发到正常工作的slave节点上。另外，如果新增了slave节点，应用也应该感知到，可以将读请求转发到新的slave节点上。  

