

<!-- TOC -->

- [1. Sql索引优化](#1-sql索引优化)
    - [1.1. 索引简介](#11-索引简介)
    - [1.2. 索引底层原理](#12-索引底层原理)
        - [1.2.1. InnoDB引擎的索引实现](#121-innodb引擎的索引实现)
            - [1.2.1.1. InnoDB逻辑结构页介绍](#1211-innodb逻辑结构页介绍)
            - [1.2.1.2. 为什么 InnoDB会使用B+树？](#1212-为什么-innodb会使用b树)
            - [1.2.1.3. InnoDB索引B+tree实现过程](#1213-innodb索引btree实现过程)
            - [1.2.1.4. InnoDB索引类型](#1214-innodb索引类型)
            - [1.2.1.5. InnoDB引擎的索引物理文件](#1215-innodb引擎的索引物理文件)
            - [1.2.1.6. 为什么官方建议InnoDB使用自增长主键作为索引？](#1216-为什么官方建议innodb使用自增长主键作为索引)
                - [1.2.1.6.1. ***碎片问题](#12161-碎片问题)
            - [1.2.1.7. 普通索引和唯一索引的区别](#1217-普通索引和唯一索引的区别)
        - [1.2.2. MyISAM引擎的索引](#122-myisam引擎的索引)
        - [1.2.3. Hash索引介绍](#123-hash索引介绍)
    - [1.3. 创建索引原则](#13-创建索引原则)
    - [1.4. 索引条件下推（ICP）](#14-索引条件下推icp)
    - [1.5. 索引失效](#15-索引失效)
    - [1.6. 索引维护、索引工具的使用](#16-索引维护索引工具的使用)

<!-- /TOC -->

![image](https://gitee.com/wt1814/pic-host/raw/master/images/SQL/sql-56.png)  

# 1. Sql索引优化  
## 1.1. 索引简介  
&emsp; 索引（Index）是帮助MySQL高效获取数据的数据结构。  
&emsp; **创建索引的优势：**  

* 提高数据的检索速度，降低数据库IO成本：使用索引的意义就是通过缩小表中需要查询的记录的数目从而加快搜索的速度。  
* 降低数据排序的成本，降低CPU消耗：索引之所以查的快，是因为先将数据排好序，若该字段正好需要排序，则会降低排序的成本。  

&emsp; **创建索引的劣势：**  

* 占用存储空间：索引实际上也是一张表，记录了主键与索引字段，一般以索引文件的形式存储在磁盘上。  
* 降低更新表的速度：表的数据发生了变化，对应的索引也需要一起变更，从而减低的更新速度。否则索引指向的物理数据可能不对，这也是索引失效的原因之一。  
* 优质索引创建难：索引的创建并非一日之功，也并非一直不变。需要频繁根据用户的行为和具体的业务逻辑去创建最佳的索引。  

&emsp; **索引的分类：**  
<!-- 
https://mp.weixin.qq.com/s/N6chmfcxnm6a3pOQYWAcbA
-->
* 从存储结构角度：BTree索引（B-Tree或B+Tree索引），Hash索引，full-index全文索引，R-Tree索引。这里所描述的是索引存储时保存的形式。  
* 从物理存储角度：根据数据的物理顺序与键值的逻辑（索引）顺序关系，有聚集索引、非聚集索引。  
* 从逻辑角度：索引类型有主键索引、单值索引、唯一索引、复合索引、全文索引。    

    * 主键和唯一索引  
    主键保证数据库里面的每一行都是唯一的。  
    唯一索引的作用跟主键的作用一样。  
    不同的是，在一张表里面只能有一个主键，主键不能为空，唯一索引可以有多个，唯一索引可以有一条记录为空。
    * 普通索引和唯一索引  
    普通索引可以重复，唯一索引和主键一样不能重复。     

    * 全文（Fulltext）：针对比较大的数据，比如存放的是消息内容，有几 KB 的数 据的这种情况，如果要解决 like 查询效率低的问题，可以创建全文索引。只有文本类型 的字段才可以创建全文索引，比如 char、varchar、text。  

-----

## 1.2. 索引底层原理  
<!-- 
https://mp.weixin.qq.com/s/I02vl5AFxrgMGmTa3SQ3ew
-->
&emsp; 不同的存储引擎支持的索引类型不一样：  

* InnoDB支持事务，支持行级别锁定，支持B-tree、Full-text等索引，不支持Hash索引；  
* MyISAM不支持事务，支持表级别锁定，支持B-tree、Full-text等索引，不支持Hash索引；  

### 1.2.1. InnoDB引擎的索引实现  
#### 1.2.1.1. InnoDB逻辑结构页介绍  
<!-- 
https://www.cnblogs.com/bdsir/p/8745553.html
-->
&emsp; 页是InnoDB磁盘管理的最小单位，每次读取数据都会读取一个页大小的数据。在InnoDB存储引擎中，默认每个页的大小为16KB。 (在操作系统中默认页大小是4KB。) 可以使用命令SHOW GLOBAL STATUS LIKE 'Innodb_page_size' 查看。  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/SQL/sql-99.png)  

 
&emsp; 页结构如下：  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/SQL/sql-79.png)  

&emsp; B+树中一个节点到底多大合适？  
&emsp; 1页或页的倍数最为合适。因为如果一个节点的大小小于1页，那么读取这个节点的时候其实也会读出1页，造成资源的浪费。所以为了不造成浪费，所以最后把一个节点的大小控制在1页、2页、3页等倍数页大小最为合适。 
&emsp; 在 MySQL 中 B+ 树的一个节点大小为“1页”，也就是16k。   

#### 1.2.1.2. 为什么 InnoDB会使用B+树？  

&emsp; B+Tree树介绍  
* BTree  
    &emsp; BTree是平衡搜索多叉树，设树的度为2d（d>1），高度为h，那么BTree要满足以一下条件：  
    * 每个叶子结点的高度一样，等于h；
    * 每个非叶子结点由n-1个key和n个指针point组成，其中d<=n<=2d,key和point相互间隔，结点两端一定是key；
    * 叶子结点指针都为null；
    * 非叶子结点的key都是[key,data]二元组，其中key表示作为索引的键，data为键值所在行的数据；

    &emsp; BTree的结构如下：  
    ![image](https://gitee.com/wt1814/pic-host/raw/master/images/SQL/sql-91.png)  
    &emsp; 在BTree的机构下，就可以使用二分查找的查找方式，查找复杂度为h*log(n)，一般来说树的高度是很小的，一般为3左右，因此BTree是一个非常高效的查找结构。  

* B+Tree树  
    &emsp; B+Tree是BTree的一个变种，设d为树的度数，h为树的高度，B+Tree和BTree的不同主要在于：  

    * B+Tree中的非叶子结点不存储数据，只存储键值；
    * B+Tree的叶子结点没有指针，所有键值都会出现在叶子结点上，且key存储的键值对应data数据的物理地址；
    * <font color = "red">B+Tree的每个非叶子节点由n个键值key和n个指针point组成；</font>  
    
    &emsp; B+Tree的结构如下：  
    ![image](https://gitee.com/wt1814/pic-host/raw/master/images/SQL/sql-92.png)  

&emsp; <font color = "red">为什么索引结构默认使用B+Tree，而不是BTree，二叉树，红黑树？</font>  
<!-- 
https://www.jianshu.com/p/c82148473235
-->
1. 操作系统中以页这种结构作为读写的基本单位。  
2. 操作系统IO消耗：<font color = "red">一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。</font>这样的话，索引查找过程中就要产生磁盘I/O消耗，相对于内存存取，I/O存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I/O操作次数的渐进复杂度。换句话说，索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数。  
3. 具体分析：（重点B树和B+树的对比）  
    1. 二叉树：树的高度不均匀，不能自平衡，查找效率跟数据有关（树的高度），并且IO代价高。  
    2. 红黑树：树的高度随着数据量增加而增加，IO代价高。 
    3. **<font color = "lime">B树：</font>**  
        1. B树中每个节点中不仅包含数据的key值，还有data值。而每一个页的存储空间是有限的，<font color = "lime">如果data数据较大时将会导致每个节点（即一个页）能存储的key的数量很小。**当存储的数据量很大时同样会导致B树的深度较大，**增大查询时的磁盘I/O次数进而影响查询效率。</font>  
        2. 范围查询，磁盘I/O高。示例：  
            ![image](https://gitee.com/wt1814/pic-host/raw/master/images/SQL/sql-93.png)  
            &emsp; 假设需要访问所有『大于 4，并且小于 9 的数据』：如果不考虑任何优化，在上面的简单 B 树中需要进行4次磁盘的随机 I/O 才能找到所有满足条件的数据行：
            1. 加载根节点所在的页，发现根节点的第一个元素是 6，大于 4；
            2. 通过根节点的指针加载左子节点所在的页，遍历页面中的数据，找到 5；
            3. 重新加载根节点所在的页，发现根节点不包含第二个元素；
            4. 通过根节点的指针加载右子节点所在的页，遍历页面中的数据，找到 7 和 8；
            &emsp; 当然可以通过各种方式来对上述的过程进行优化，不过 B 树能做的优化 B+ 树基本都可以，所以不需要考虑优化 B 树而带来的收益。
    4. **<font color = "lime">B+树：</font>** 
        1. **<font color = "red">从物理存储结构上说，B-Tree和B+Tree都以页(4K)来划分节点的大小，但是由于B+Tree中中间节点不存储数据，因此B+Tree能够在同样大小的节点中，存储更多的key，提高查找效率。</font>**
        2. **<font color = "red">叶子节点之间会有个指针指向，这个也是B+树的核心点，可以大大提升范围查询效率，也方便遍历整个树。</font>** 
        3. **<font color = "red">B+tree的查询效率更加稳定。由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</font>**   

#### 1.2.1.3. InnoDB索引B+tree实现过程  
&emsp; **B+树中一个节点到底多大合适？**  
&emsp; 1页或页的倍数最为合适。因为如果一个节点的大小小于1页，那么读取这个节点的时候其实也会读出1页，造成资源的浪费。所以为了不造成浪费，所以最后把一个节点的大小控制在1页、2页、3页等倍数页大小最为合适。  
&emsp; 在 MySQL 中 B+ 树的一个节点大小为“1页”，也就是16k。  

<!-- 
二狗：为什么一个节点为1页就够了？
https://mp.weixin.qq.com/s/Ad3PJM3sBKJD2j2NvMno7w
-->

![image](https://gitee.com/wt1814/pic-host/raw/master/images/SQL/sql-78.png)  
&emsp; InnoDB的B+tree的节点：  
* 叶子节点，存储行数据，叫做目录页。  
* 非叶子节点，存储索引数据，叫做页目录。  

&emsp; 索引插入过程中会对索引进行排序。一页插满会进行页分裂。  


&emsp; <font color = "red">联合索引（复合索引）的底层实现？最佳左前缀原则？</font>  
&emsp; 联合索引底层还是使用B+树索引，并且还是只有一棵树，只是此时的排序会：首先按照第一个索引排序，在第一个索引相同的情况下，再按第二个索引排序，依次类推。  
&emsp; 这也是为什么有“最佳左前缀原则”的原因，因为右边（后面）的索引都是在左边（前面）的索引排序的基础上进行排序的，如果没有左边的索引，单独看右边的索引，其实是无序的。  


#### 1.2.1.4. InnoDB索引类型  
&emsp; <font color = "red">InnoDB索引类型可以分为主键索引和辅助索引（非主键索引）。</font>  
&emsp; **<font color = "lime">主键索引树中，叶子结点保存着主键和对应行的全部数据。主键索引又被称为聚簇索引。</font>**   
![image](https://gitee.com/wt1814/pic-host/raw/master/images/SQL/sql-34.png)  
&emsp; **<font color = "lime">辅助索引树中，叶子结点保存着索引值和主键值。辅助索引又被称为非聚簇索引。当使用辅助索引进行查询时，一般需要进行回表操作。</font>**   

        如果是通过主键索引查询的，会直接搜索B+树，从而查询到数据。
        如果不是通过主键索引查询到，需要先搜索索引树，得到在B+树上的值，再到B+树上搜索符合条件的数据，这个过程就是“回表”。

<!-- 
什么是回表查询？
InnoDB 中，对于主键索引，只需要走一遍主键索引的查询就能在叶子节点拿到数据。
而对于普通索引，叶子节点存储的是 key + 主键值，因此需要再走一次主键索引，通过主键索引找到行记录，这就是所谓的回表查询，先定位主键值，再定位行记录。
-->

&emsp; <font color = "red">非聚簇索引一定会回表查询吗?（覆盖索引）</font>  
&emsp; 不一定，这涉及到查询语句所要求的字段是否全部命中了索引，如果全部命中了索引，即索引覆盖，那么就不必再进行回表查询。  
    
        索引覆盖，要查询的字段都建立了索引，那么引擎会直接在索引表中查询而不会访问原始数据（否则只要有一个字段没有建立索引就会做全表扫描），这叫索引覆盖。

&emsp; 总结：B+树在满足聚簇索引和覆盖索引的时候不需要回表查询数据。  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/SQL/sql-35.png)  

----

#### 1.2.1.5. InnoDB引擎的索引物理文件
<!-- 
https://www.cnblogs.com/tongxiaoda/p/7874535.html
-->
&emsp; <font color = "red">在InnoDB中，数据和索引文件是合起来储存的，如图所示，InnoDB 的存储文件有两个，后缀名分别是 .frm 和 .idb，其中 .frm 是表的定义文件，</font>**<font color = "lime">而idb是数据文件/索引文件。</font>**   
![image](https://gitee.com/wt1814/pic-host/raw/master/images/SQL/sql-33.png)  

* .frm文件：与表相关的元数据信息都存放在frm文件，包括表结构的定义信息等。  
* .ibd文件或.ibdata文件：这两种文件都是存放InnoDB数据的文件，之所以有两种文件形式存放 InnoDB 的数据，是因为InnoDB的数据存储方式能够通过配置来决定是使用共享表空间存放存储数据，还是用独享表空间存放存储数据。  
&emsp; 独享表空间存储方式使用.ibd文件，并且每个表一个.ibd文件 共享表空间存储方式使用.ibdata文件，所有表共同使用一个.ibdata文件（或多个，可自己配置）。  

<!--
&emsp; **.ibd文件或.ibdata文件详解：**  
1. 表空间  
&emsp; Innodb存储引擎可将所有数据存放于ibdata*的共享表空间，也可将每张表存放于独立的.ibd文件的独立表空间。  
&emsp; 共享表空间以及独立表空间都是针对数据的存储方式而言的。

* 共享表空间: 某一个数据库的所有的表数据，索引文件全部放在一个文件中，默认这个共享表空间的文件路径在data目录下。 默认的文件名为:ibdata1 初始化为10M。
* 独立表空间: 每一个表都将会生成以独立的文件方式来进行存储，每一个表都有一个.frm表描述文件，还有一个.ibd文件。 其中这个文件包括了单独一个表的数据内容以及索引内容，默认情况下它的存储位置也是在表的位置之中。  

    ```sql
    [root@localhost data]# ls
    a1  a2  a3  auto.cnf  ib_buffer_pool  ibdata1  ib_logfile0  ib_logfile1  ibtmp1  localhost.localdomain.err  localhost.localdomain.pid  mysql  performance_schema  sys
    ```

    &emsp; ibdata1就是InnoDB表的共享存储空间，默认innodb所有表的数据都在一个ibdata1里。  

2. 优缺点  
（1）共享表空间：
优点：
可以将表空间分成多个文件存放到各个磁盘上（表空间文件大小不受表大小的限制，如一个表可以分布在不同的文件上）。数据和文件放在一起方便管理。
缺点：
所有的数据和索引存放到一个文件中，虽然可以把一个大文件分成多个小文件，但是多个表及索引在表空间中混合存储，这样对于一个表做了大量删除操作后表空间中将会有大量的空隙，特别是对于统计分析，日值系统这类应用最不适合用共享表空间。

（2）独立表空间：
在配置文件（my.cnf）中设置： innodb_file_per_table
优点：
1）每个表都有自已独立的表空间。
2）每个表的数据和索引都会存在自已的表空间中。
3）可以实现单表在不同的数据库中移动。
4）空间可以回收（除drop table操作处，表空不能自已回收）

    Drop table操作自动回收表空间，如果对于统计分析或是日值表，删除大量数据后可以通过:alter table TableName engine=innodb;回缩不用的空间。
    对于使innodb-plugin的Innodb使用turncate table也会使空间收缩。
    对于使用独立表空间的表，不管怎么删除，表空间的碎片不会太严重的影响性能，而且还有机会处理。

缺点：
单表增加过大，如超过100个G。
相比较之下，使用独占表空间的效率以及性能会更高一点。
-->

-----

#### 1.2.1.6. 为什么官方建议InnoDB使用自增长主键作为索引？  

        适合用业务字段做主键的场景需求：1).只有一个索引；2).该索引必须是唯一索引。这就是典型的KV场景。由于没有其他索引，所以也就不用考虑其他索引的叶子节点大小的问题。 

```text
没有定义主键，InnoDB会如何处理？  
    如果定义了主键(PRIMARY KEY)，那么InnoDB会选择主键作为聚集索引。  
    如果没有显式定义主键，则InnoDB会选择第一个不包含有NULL值的唯一索引作为主键索引。  
    如果也没有这样的唯一索引，则InnoDB会选择内置6字节长的ROWID作为隐含的聚集索引(ROWID随着行记录的写入而主键递增，这个ROWID不像ORACLE的ROWID那样可引用，是隐含的)。  
```

1. 存储空间：  
&emsp; 由于每个非主键索引的叶子节点上都是主键的值。如果用业务字段做主键，那么每个二级索引的叶子节点占用约xxx个字节，而如果用整型做主键，则只要4个字节，如果是长整型（bigint）则是8个字节。<font color = "red">即主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。</font>  
2. 性能：  
&emsp; <font color = "red">根据B+Tree的特点，自增主键是连续的，在插入过程中尽量减少InnoDB存储引擎的页分裂，</font>即使要进行页分裂，也只会分裂很少一部分。并且能减少数据的移动，每次插入都是插入到最后。即减少分裂和移动的频率。  
&emsp; <font color = "lime">如果写入是乱序的，InnoDB不得不频繁地做页分裂操作，以便为新的行分配空间。</font>页分裂会导致移动大量数据，一次插入最少需要修改三个页而不是一个页。 <font color = "lime">如果频繁的页分裂，页会变得稀疏并被不规则地填充，所以最终数据会有碎片。</font>  

##### 1.2.1.6.1. ***碎片问题  

1. 碎片问题的产生：  
    * 页分裂产生碎片。  
    * 删除数据产生碎片：每当MySQL从列表中删除了一行内容，该段空间就会被留空。而在一段时间内的大量删除操作，会使这种留空的空间变得比存储列表内容所使用的空间更大。当MySQL对数据进行扫描时，它扫描的对象实际是列表的容量需求上限，也就是数据被写入的区域中处于峰值位置的部分。<font color = "red">如果进行新的插入操作，MySQL将尝试利用这些留空的区域，但仍然无法将其彻底占用。</font>  
 

2. 碎片优化  
&emsp; 这种额外的破碎的存储空间在读取效率方面比正常占用的空间要低得多。  
&emsp; 对MySQL进行碎片整理的方法非常简单，因为MySQL已经给提供了对应的SQL指令，这个SQL指令就是OPTIMIZE TABLE，其完整语法如下：  
&emsp; OPTIMIZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE table_name1 [, table_name2] ...  
&emsp; 从上面的语法描述中，可以得知，OPTIMIZE TABLE可以一次性对多个表进行碎片整理，只需要在OPTIMIZE TABLE后面接多个表名，并以英文逗号隔开即可。  
&emsp; 此外，OPTIMIZE TABLE语句有两个可选的关键字：LOCAL和NO_WRITE_TO_BINLOG。在默认情况下，OPTIMIZE TABLE语句将会被记录到二进制日志中，如果指定了LOCAL或NO_WRITE_TO_BINLOG关键字，则不会记录。当然，一般情况下，也无需关注这两个关键字。  


#### 1.2.1.7. 普通索引和唯一索引的区别
<!-- 
https://www.cnblogs.com/wangchunli-blogs/p/10416046.html
-->
&emsp; 唯一索引和普通索引的区别？  

* 查询过程：  
&emsp; 执行查询的语句是select id from T where k=5。  
&emsp; 对于普通索引来说，查找到满足条件的第一个记录(5,500)后，需要查找下一个记录，直到碰到第一个不满足k=5条件的记录。  
&emsp; 对于唯一索引来说，<font color = "red">由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止继续检索。</font>  
* 更新过程：  
&emsp; 普通索引会使用[change buffer](/docs/SQL/InnoDB.md)提升性能。而change buffer不适用于唯一索引。  

* 索引选择和实践：  
&emsp; 其实，这两类索引在查询能力上是没差别的，主要考虑的是对更新性能的影响。所以，建议尽量选择普通索引。  
&emsp; 如果所有的更新后面，都马上伴随着对这个记录的查询，那么应该关闭change buffer。而在其他情况下，change buffer都能提升更新性能。  
&emsp; 在实际使用中，普通索引和change buffer的配合使用，对于数据量大的表的更新优化还是很明显的。  

### 1.2.2. MyISAM引擎的索引  
&emsp; <font color = "red">MyISAM也是B+树结构，但是MyISAM索引的叶子节点的数据保存的是行数据的地址。</font>因此，MyISAM中索引检索的算法首先在索引树中找到行数据的地址，然后根据地址找到对应的行数据。  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/SQL/sql-37.png)  
&emsp; MyISAM的索引文件仅仅保存数据记录的地址。主键索引和辅助索引，只是主索引要求key是唯一的，而辅助索引的key可以重复。如果在Col2上建立一个辅助索引，则此索引的如下图：  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/SQL/sql-38.png)  

&emsp; <font color = "red">在MyISAM储存引擎中，数据和索引文件是分开储存的，Myisam的存储文件有三个，后缀名分别是 .frm、.MYD、MYI，其中 .frm 是表的定义文件，.MYD 是数据文件，.MYI 是索引文件。</font>  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/SQL/sql-36.png)  

* .frm文件：与表相关的元数据信息都存放在frm文件，包括表结构的定义信息等。
* .MYD (MYData) 文件：MyISAM 存储引擎专用，用于存储MyISAM 表的数据。  
* .MYI (MYIndex)文件：MyISAM 存储引擎专用，用于存储MyISAM 表的索引相关信息。  

### 1.2.3. Hash索引介绍  
&emsp; 哈希索引底层的数据结构就是哈希表。对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码（hash code），并且Hash索引将所有的哈希码存储在索引中，同时在索引表中保存指向每个数据行的指针。  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/SQL/sql-39.png)  
&emsp; 在 MySQL 中，只有 Memory 存储引擎显式的支持哈希索引，而innodb是隐式支持哈希索引的。  

&emsp; <font color = "red">哈希索引适用的场景</font>：等值查询。  
&emsp; <font color = "red">哈希索引不适用的场景</font>：hash函数的不可预测性，hash索引中经过hash函数建立索引之后，索引的顺序与原顺序无法保持一致。不支持范围查询、不支持索引完成排序、不支持联合索引的最左前缀匹配规则、不支持部分匹配、只支持等值查询如=，IN()，不支持 < >。  

-----

## 1.3. 创建索引原则  
<!-- 
https://mp.weixin.qq.com/s/IsZjLI7QAB6t7H7NyGscGg
-->
&emsp; 为了使索引的使用效率更高，<font color = "red">在创建索引时，必须考虑在哪些字段上创建索引和创建什么类型的索引。</font>  

* 在去重distinct字段上建立索引；  
* 多表连接的字段上需要建立索引；  
* where条件字段上需要建立索引；  
&emsp; 注：=和in可以乱序。比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式。  
* 分组字段上需要建立索引；  
* 排序字段上需要建立索引；  
&emsp; 利用索引进行排序操作是非常快的，而且可以利用同一索引同时进 行查找和排序操作。当索引的顺序与ORDER BY中的列顺序相同且所有的列是同一方向(全部升序或者全部降序)时，可以使用索引来排序，如果查询是连接多个表，仅当ORDER BY中的所有列都是第一个表的列时才会使用索引，其它情况都会使用filesort。  
* 在联合UNION字段上建立索引；  
<br/>  
* <font color = "red">尽量选择区分度高的列作为索引</font>  
&emsp; 区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，比例越大，扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就 是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段要求是0.1以上，即平均1条扫描10条 记录 
* 尽量使用前缀来索引  
&emsp; 如果索引字段的值很长，最好使用值的前缀来索引。例如，TEXT和BLOG类型的字段，进行全文检索会很浪费时间。如果只检索字段的前面的若干个字符，这样可以提高检索速度。  
* 使用基于函数的索引  
&emsp; 任何对列的操作都可能导致全表扫描，例如：select * from emp where substr(ename,1,2)=’SM’；但是这种查询在客服系统又经常使用。可以创建一个带有substr函数的基于函数的索引，create index emp_ename_substr on eemp (substr(ename,1,2));这样在执行上面的查询语句时，会使用基于函数的索引。  
* 根据业务场景建立<font color = "red">覆盖索引</font>  
&emsp; 覆盖索引（covering index）指一个查询语句的执行只用从索引中就能够取得，不必从数据表中读取。也可以称之为实现了索引覆盖。  
&emsp; 当一条查询语句符合覆盖索引条件时，MySQL只需要通过索引就可以返回查询所需要的数据，这样避免了查到索引后再返回表操作，减少I/O提高效率。  
<br/>  
* 限制索引的数目  
&emsp; 索引的数目不是越多越好。每个索引都需要占用磁盘空间，索引越多，需要的磁盘空间就越大。修改表时，对索引的重构和更新很麻烦。越多的索引，会使更新表变得很浪费时间。  
* 尽量使用数据量少的索引  
&emsp; 如果索引的值很长，那么查询的速度会受到影响。例如，对一个CHAR（100）类型的字段进行全文检索需要的时间肯定要比对CHAR（10）类型的字段需要的时间要多。  
* 删除不再使用或者很少使用的索引  
&emsp; 表中的数据被大量更新，或者数据的使用方式被改变后，原有的一些索引可能不再需要。数据库管理员应当定期找出这些索引，将它们删除，从而减少索引对更新操作的影响。  
<br/>   
* 根据需要建立多列联合索引：  
    &emsp; **联合索引最左前缀匹配原则：**  
    &emsp; mysql查询时索引会一直向右匹配，直到遇到范围查询(>、<、between、like)就停止匹配。mysql从左到右的使用索引中的字段，一个查询可以只使用索引中的一部份，但只能是最左侧部分。例如索引是key index(a,b,c)。可以支持 a|a,b|a,b,c 3种组合进行查找，但不支持b,c进行查找。当最左侧字段是常量引用时，索引就十分有效。  

    &emsp; **<font color = "red">WHERE+ 多个字段ORDER BY，满足最左前缀。</font>**  
    &emsp; SELECT * FROM [table] WHERE uid=1 ORDER x,y LIMIT 0,10;  
    &emsp; 建立索引(uid,x,y)实现order by的优化,比建立(x,y,uid)索引效果要好得多。  

    &emsp; **单列索引和联合索引的选择：**  
    1. 联合索引的几个字段是否经常同时以AND方式出现在Where子句中？单字段查询是否极少甚至没有？假如是，则可以建立联合索引；否则考虑单字段索引；  
    &emsp; 当出现多个索引做相交操作时（多个AND条件），通常来说一个包含所有相关列的索引要优于多个独立索引。  
    2. 假如联合索引中包含的字段经常单独出现在where子句中，则分解为多个单字段索引；  
    &emsp; 当出现多个索引做联合操作时（多个OR条件），对结果集的合并、排序等操作需要耗费大量的CPU和内存资源，特别是当其中的某些索引的选择性不高，需要返回合并大量数据时，查询成本更高。所以这种情况下还不如走全表扫描。  
    &emsp; 因此explain时如果发现有索引合并（Extra字段出现Using union），应该好好检查一下查询和表结构是不是已经是最优的，如果查询和表都没有问题，那只能说明索引建的非常糟糕，应当慎重考虑索引是否合适，有可能一个包含所有相关列的多列索引更适合。  
    3. 假如联合索引所包含的字段超过3个，那么仔细考虑其必要性，考虑减少联合的字段；  
    4. 假如既有单字段索引，又有这几个字段上的联合索引，一般可以删除联合索引；  

## 1.4. 索引条件下推（ICP）  
&emsp; 官方文档：https://dev.mysql.com/doc/refman/5.7/en/index-condition-pushdown-optimization.html  

&emsp; 索引下推（Index Condition Pushdown，ICP）：MySQL5.6引入了索引下推优化，默认开启。  
&emsp; 索引条件下推是针对MySQL使用索引从表中检索行的情况进行的优化。在没有ICP的情况下，存储引擎遍历索引以定位基表中的行，并将它们返回给MySQL服务器，后者评估这些行的WHERE条件。**<font color = "red">如果启用了ICP，并且只使用索引中的列来计算WHERE条件的一部分，MySQL服务器会将WHERE条件的这一部分向下推送到存储引擎。</font><font color = "lime">然后，存储引擎通过使用索引项来评估推式索引条件，并且只有满足此条件时，才会从表中读取行。ICP可以减少存储引擎必须访问基表的次数以及MySQL服务器必须访问存储引擎的次数。</font>**  
&emsp; **<font color = "red">索引下推简而言之就是在复合索引由于某些条件(比如 like %aa)失效的情况下，当存在失效的过滤字段在索引覆盖范围内，使用比较的方式在不回表的情况下进一步缩小查询的范围。其实就是对索引失效的进一步修复，属于最左前缀索引原则的一个特殊情况。</font>**  

<font color = "lime">

* 索引--->回表--->条件过滤
* 索引--->条件过滤--->回表  

</font>

<br/>
&emsp; 示例：people表中（zipcode，lastname，firstname）构成一个索引。  

```sql
SELECT * FROM people WHERE zipcode='95054' AND lastname LIKE '%etrunia%' AND address LIKE '%Main Street%';
```
&emsp; 如果没有使用索引下推技术，则MySQL会通过zipcode='95054'从存储引擎中查询对应的数据，返回到MySQL服务端，然后MySQL服务端基于lastname LIKE '%etrunia%'和address LIKE '%Main Street%'来判断数据是否符合条件。  
&emsp; <font color = "lime">如果使用了索引下推技术，则MYSQL首先会返回符合zipcode='95054'的索引，然后根据lastname LIKE '%etrunia%'和address LIKE '%Main Street%'来判断索引是否符合条件。如果符合条件，则根据该索引来定位对应的数据，如果不符合，则直接reject掉。有了索引下推优化，可以在有like条件查询的情况下，减少回表次数。</font>  

<!-- 
https://www.cnblogs.com/zengkefu/p/5684101.html
-->
-----

## 1.5. 索引失效  
1. 联合索引最左前缀匹配原则。  
4. 对索引进行模糊查询like时可能使索引失效（以%开头）。  
&emsp; 前导模糊查询不能利用索引(like '%XX'或者like '%XX%')。假如有这样一列code的值为'AAA','AAB','BAA','BAB' ,如果where code like '%AB'条件，由于条件首字母是是模糊%的，所以不能利用索引的顺序，必须一个个去查询。这样会导致全索引扫描或者全表扫描。如果是这样的条件where code like 'A % '，就可以查找CODE中A开头的CODE的位置，当碰到B开头的数据时，就可以停止查找了，因为后面的数据一定不满足要求。这样就可以利用索引了。  
&emsp; 解决办法：可采用在建立索引时用reverse(columnName)这种方法处理。  
1. 隐式转换导致索引失效。  
&emsp; 由于表的字段tu_mdn定义为varchar2(20)，但在查询时把该字段作为number类型以where条件传给sql语句,这样会导致索引失效。  
&emsp; 错误的例子：select * from test where tu_mdn=13333333333;  
&emsp; 正确的例子：select * from test where tu_mdn='13333333333';  
2. 对索引列进行null值运算。  
&emsp; 索引无法存储null值。B-tree索引is null不会走，is not null会走。  
3. 对索引列进行运算导致索引失效。  
&emsp; 逻辑运算（NOT、OR）；比较运算（=、<>、!=、>、>=、!>、<、<=、!<）、all，some，many关键字；范围查询in，exist关键字、like关键字。  
&emsp; <font color = "red">用or分割条件，若or前后只要有一个列没有索引，就都不会用索引。</font>  
5. 对索引列使用函数导致索引失效。  
&emsp; 对于这样情况应当创建基于函数的索引。  
&emsp; 错误的例子：select * from test where round(id)=10; 此时id的索引已经不起作用了。  
&emsp; 正确的例子：首先建立函数索引，create index test_id_fbi_idx on test(round(id));然后 select * from test where round(id)=10; 这时函数索引起作用了。  




## 1.6. 索引维护、索引工具的使用  
1. 冗余和重复索引：冗余索引是指在相同的列上按照相同的顺序创建的相同类型的索引，应当尽量避免这种索引，发现后立即删除。比如有一个索引(A,B)，再创建索引(A)就是冗余索引。冗余索引经常发生在为表添加新索引时，比如有人新建了索引(A,B)，但这个索引不是扩展已有的索引(A)。
2. 大多数情况下都应该尽量扩展已有的索引而不是创建新索引。但有极少情况下出现性能方面的考虑需要冗余索引，比如扩展已有索引而导致其变得过大，从而影响到其他使用该索引的查询。
3. 删除长期未使用的索引。

&emsp; MySql索引工具：1.mysqlidxchx 2.pt-index-usage 3.userstat 4.check-unused-keys  
