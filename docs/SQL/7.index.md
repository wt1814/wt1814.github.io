

<!-- TOC -->

- [1. Sql索引优化](#1-sql索引优化)
    - [1.1. 索引简介](#11-索引简介)
    - [1.2. 创建索引原则](#12-创建索引原则)
    - [1.3. 索引条件下推（ICP）](#13-索引条件下推icp)
    - [1.4. 索引失效](#14-索引失效)
    - [1.5. 索引底层原理](#15-索引底层原理)
        - [1.5.1. BTree索引](#151-btree索引)
            - [1.5.1.1. B+ Tree简介](#1511-b-tree简介)
            - [1.5.1.2. 为什么使用B+树？](#1512-为什么使用b树)
            - [1.5.1.3. InnoDB引擎的底层实现](#1513-innodb引擎的底层实现)
            - [1.5.1.4. MyISAM引擎的底层实现](#1514-myisam引擎的底层实现)
            - [1.5.1.5. 为什么官方建议InnoDB使用自增长主键作为索引？-1](#1515-为什么官方建议innodb使用自增长主键作为索引-1)
        - [1.5.2. Hash索引](#152-hash索引)
    - [1.6. 索引维护、索引工具的使用](#16-索引维护索引工具的使用)

<!-- /TOC -->

![image](https://gitee.com/wt1814/pic-host/raw/master/images/SQL/sql-56.png)  

# 1. Sql索引优化  
## 1.1. 索引简介  
&emsp; 索引（Index）是帮助MySQL高效获取数据的数据结构。  
&emsp; **创建索引的优势：**  

* 提高数据的检索速度，降低数据库IO成本：使用索引的意义就是通过缩小表中需要查询的记录的数目从而加快搜索的速度。  
* 降低数据排序的成本，降低CPU消耗：索引之所以查的快，是因为先将数据排好序，若该字段正好需要排序，则会降低排序的成本。  

&emsp; **创建索引的劣势：**  

* 占用存储空间：索引实际上也是一张表，记录了主键与索引字段，一般以索引文件的形式存储在磁盘上。  
* 降低更新表的速度：表的数据发生了变化，对应的索引也需要一起变更，从而减低的更新速度。否则索引指向的物理数据可能不对，这也是索引失效的原因之一。  
* 优质索引创建难：索引的创建并非一日之功，也并非一直不变。需要频繁根据用户的行为和具体的业务逻辑去创建最佳的索引。  

&emsp; **索引的分类：**  
<!-- 
https://mp.weixin.qq.com/s/N6chmfcxnm6a3pOQYWAcbA
-->
* 从存储结构角度：BTree索引（B-Tree或B+Tree索引），Hash索引，full-index全文索引，R-Tree索引。这里所描述的是索引存储时保存的形式。  
* 从物理存储角度：根据数据的物理顺序与键值的逻辑（索引）顺序关系，有聚集索引、非聚集索引。  
* 从逻辑角度：索引类型有主键索引、单值索引、唯一索引、复合索引、全文索引。    

    * 主键和唯一索引  
    主键保证数据库里面的每一行都是唯一的。  
    唯一索引的作用跟主键的作用一样。  
    不同的是，在一张表里面只能有一个主键，主键不能为空，唯一索引可以有多个，唯一索引可以有一条记录为空。
    * 普通索引和唯一索引  
    普通索引可以重复，唯一索引和主键一样不能重复。     

    * 全文（Fulltext）：针对比较大的数据，比如存放的是消息内容，有几 KB 的数 据的这种情况，如果要解决 like 查询效率低的问题，可以创建全文索引。只有文本类型 的字段才可以创建全文索引，比如 char、varchar、text。  

## 1.2. 创建索引原则  
<!-- 
https://mp.weixin.qq.com/s/IsZjLI7QAB6t7H7NyGscGg
-->
&emsp; 为了使索引的使用效率更高，<font color = "red">在创建索引时，必须考虑在哪些字段上创建索引和创建什么类型的索引。</font>  

* 在去重distinct字段上建立索引；  
* 多表连接的字段上需要建立索引；  
* where条件字段上需要建立索引；  
&emsp; 注：=和in可以乱序。比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式。  
* 分组字段上需要建立索引；  
* 排序字段上需要建立索引；  
&emsp; 利用索引进行排序操作是非常快的，而且可以利用同一索引同时进 行查找和排序操作。当索引的顺序与ORDER BY中的列顺序相同且所有的列是同一方向(全部升序或者全部降序)时，可以使用索引来排序，如果查询是连接多个表，仅当ORDER BY中的所有列都是第一个表的列时才会使用索引，其它情况都会使用filesort。  
* 在联合UNION字段上建立索引；  
<br/>  
* <font color = "red">尽量选择区分度高的列作为索引</font>  
&emsp; 区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，比例越大，扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就 是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段要求是0.1以上，即平均1条扫描10条 记录 
* 尽量使用前缀来索引  
&emsp; 如果索引字段的值很长，最好使用值的前缀来索引。例如，TEXT和BLOG类型的字段，进行全文检索会很浪费时间。如果只检索字段的前面的若干个字符，这样可以提高检索速度。  
* 使用基于函数的索引  
&emsp; 任何对列的操作都可能导致全表扫描，例如：select * from emp where substr(ename,1,2)=’SM’；但是这种查询在客服系统又经常使用。可以创建一个带有substr函数的基于函数的索引，create index emp_ename_substr on eemp (substr(ename,1,2));这样在执行上面的查询语句时，会使用基于函数的索引。  
* 根据业务场景建立<font color = "red">覆盖索引</font>  
&emsp; 覆盖索引（covering index）指一个查询语句的执行只用从索引中就能够取得，不必从数据表中读取。也可以称之为实现了索引覆盖。  
&emsp; 当一条查询语句符合覆盖索引条件时，MySQL只需要通过索引就可以返回查询所需要的数据，这样避免了查到索引后再返回表操作，减少I/O提高效率。  
<br/>  
* 限制索引的数目  
&emsp; 索引的数目不是越多越好。每个索引都需要占用磁盘空间，索引越多，需要的磁盘空间就越大。修改表时，对索引的重构和更新很麻烦。越多的索引，会使更新表变得很浪费时间。  
* 尽量使用数据量少的索引  
&emsp; 如果索引的值很长，那么查询的速度会受到影响。例如，对一个CHAR（100）类型的字段进行全文检索需要的时间肯定要比对CHAR（10）类型的字段需要的时间要多。  
* 删除不再使用或者很少使用的索引  
&emsp; 表中的数据被大量更新，或者数据的使用方式被改变后，原有的一些索引可能不再需要。数据库管理员应当定期找出这些索引，将它们删除，从而减少索引对更新操作的影响。  
<br/>   
* 根据需要建立多列联合索引：  
    &emsp; **联合索引最左前缀匹配原则：**  
    &emsp; mysql查询时索引会一直向右匹配，直到遇到范围查询(>、<、between、like)就停止匹配。mysql从左到右的使用索引中的字段，一个查询可以只使用索引中的一部份，但只能是最左侧部分。例如索引是key index(a,b,c)。可以支持 a|a,b|a,b,c 3种组合进行查找，但不支持b,c进行查找。当最左侧字段是常量引用时，索引就十分有效。  

    &emsp; **<font color = "red">WHERE+ 多个字段ORDER BY，满足最左前缀。</font>**  
    &emsp; SELECT * FROM [table] WHERE uid=1 ORDER x,y LIMIT 0,10;  
    &emsp; 建立索引(uid,x,y)实现order by的优化,比建立(x,y,uid)索引效果要好得多。  

    &emsp; **单列索引和联合索引的选择：**  
    1. 联合索引的几个字段是否经常同时以AND方式出现在Where子句中？单字段查询是否极少甚至没有？假如是，则可以建立联合索引；否则考虑单字段索引；  
    &emsp; 当出现多个索引做相交操作时（多个AND条件），通常来说一个包含所有相关列的索引要优于多个独立索引。  
    2. 假如联合索引中包含的字段经常单独出现在where子句中，则分解为多个单字段索引；  
    &emsp; 当出现多个索引做联合操作时（多个OR条件），对结果集的合并、排序等操作需要耗费大量的CPU和内存资源，特别是当其中的某些索引的选择性不高，需要返回合并大量数据时，查询成本更高。所以这种情况下还不如走全表扫描。  
    &emsp; 因此explain时如果发现有索引合并（Extra字段出现Using union），应该好好检查一下查询和表结构是不是已经是最优的，如果查询和表都没有问题，那只能说明索引建的非常糟糕，应当慎重考虑索引是否合适，有可能一个包含所有相关列的多列索引更适合。  
    3. 假如联合索引所包含的字段超过3个，那么仔细考虑其必要性，考虑减少联合的字段；  
    4. 假如既有单字段索引，又有这几个字段上的联合索引，一般可以删除联合索引；  

## 1.3. 索引条件下推（ICP）  
&emsp; 官方文档：https://dev.mysql.com/doc/refman/5.7/en/index-condition-pushdown-optimization.html  

&emsp; 索引下推（Index Condition Pushdown，ICP）：MySQL5.6引入了索引下推优化，默认开启。  
&emsp; 索引条件下推是针对MySQL使用索引从表中检索行的情况进行的优化。在没有ICP的情况下，存储引擎遍历索引以定位基表中的行，并将它们返回给MySQL服务器，后者评估这些行的WHERE条件。**<font color = "red">如果启用了ICP，并且只使用索引中的列来计算WHERE条件的一部分，MySQL服务器会将WHERE条件的这一部分向下推送到存储引擎。</font><font color = "lime">然后，存储引擎通过使用索引项来评估推式索引条件，并且只有满足此条件时，才会从表中读取行。ICP可以减少存储引擎必须访问基表的次数以及MySQL服务器必须访问存储引擎的次数。</font>**  
&emsp; **<font color = "red">索引下推简而言之就是在复合索引由于某些条件(比如 like %aa)失效的情况下，当存在失效的过滤字段在索引覆盖范围内，使用比较的方式在不回表的情况下进一步缩小查询的范围。其实就是对索引失效的进一步修复，属于最左前缀索引原则的一个特殊情况。</font>**  
<br/>
&emsp; 示例：people表中（zipcode，lastname，firstname）构成一个索引。  

```sql
SELECT * FROM people WHERE zipcode='95054' AND lastname LIKE '%etrunia%' AND address LIKE '%Main Street%';
```
&emsp; 如果没有使用索引下推技术，则MySQL会通过zipcode='95054'从存储引擎中查询对应的数据，返回到MySQL服务端，然后MySQL服务端基于lastname LIKE '%etrunia%'和address LIKE '%Main Street%'来判断数据是否符合条件。  
&emsp; <font color = "lime">如果使用了索引下推技术，则MYSQL首先会返回符合zipcode='95054'的索引，然后根据lastname LIKE '%etrunia%'和address LIKE '%Main Street%'来判断索引是否符合条件。如果符合条件，则根据该索引来定位对应的数据，如果不符合，则直接reject掉。有了索引下推优化，可以在有like条件查询的情况下，减少回表次数。</font>  

<!-- 
https://www.cnblogs.com/zengkefu/p/5684101.html
-->

## 1.4. 索引失效  
1. 联合索引最左前缀匹配原则。  
4. 对索引进行模糊查询like时可能使索引失效（以%开头）。  
&emsp; 前导模糊查询不能利用索引(like '%XX'或者like '%XX%')。假如有这样一列code的值为'AAA','AAB','BAA','BAB' ,如果where code like '%AB'条件，由于条件首字母是是模糊%的，所以不能利用索引的顺序，必须一个个去查询。这样会导致全索引扫描或者全表扫描。如果是这样的条件where code like 'A % '，就可以查找CODE中A开头的CODE的位置，当碰到B开头的数据时，就可以停止查找了，因为后面的数据一定不满足要求。这样就可以利用索引了。  
&emsp; 解决办法：可采用在建立索引时用reverse(columnName)这种方法处理。  
1. 隐式转换导致索引失效。  
&emsp; 由于表的字段tu_mdn定义为varchar2(20)，但在查询时把该字段作为number类型以where条件传给sql语句,这样会导致索引失效。  
&emsp; 错误的例子：select * from test where tu_mdn=13333333333;  
&emsp; 正确的例子：select * from test where tu_mdn='13333333333';  
2. 对索引列进行null值运算。  
&emsp; 索引无法存储null值。B-tree索引is null不会走，is not null会走。  
3. 对索引列进行运算导致索引失效。  
&emsp; 逻辑运算（NOT、OR）；比较运算（=、<>、!=、>、>=、!>、<、<=、!<）、all，some，many关键字；范围查询in，exist关键字、like关键字。  
&emsp; <font color = "red">用or分割条件，若or前后只要有一个列没有索引，就都不会用索引。</font>  
5. 对索引列使用函数导致索引失效。  
&emsp; 对于这样情况应当创建基于函数的索引。  
&emsp; 错误的例子：select * from test where round(id)=10; 此时id的索引已经不起作用了。  
&emsp; 正确的例子：首先建立函数索引，create index test_id_fbi_idx on test(round(id));然后 select * from test where round(id)=10; 这时函数索引起作用了。  


## 1.5. 索引底层原理  
<!-- 
https://mp.weixin.qq.com/s/I02vl5AFxrgMGmTa3SQ3ew
-->
&emsp; 不同的存储引擎支持的索引类型不一样：  

* InnoDB支持事务，支持行级别锁定，支持B-tree、Full-text等索引，不支持Hash索引；  
* MyISAM不支持事务，支持表级别锁定，支持B-tree、Full-text等索引，不支持Hash索引；  

### 1.5.1. BTree索引  
&emsp; MySQL的BTree索引使用的是B树中的B+Tree，但对于MyIsam与InnoDB两种存储引擎的实现方式是不同的。  

#### 1.5.1.1. B+ Tree简介  
B+ Tree请查看： [B+ Tree章节](/docs/java/function/structure/tree.md)  

#### 1.5.1.2. 为什么使用B+树？  
&emsp; <font color = "red">为什么索引结构默认使用B+Tree，而不是Hash，二叉树，红黑树？</font>  
&emsp; **<font color = "red">1. B+的磁盘读写代价更低。</font>**  
&emsp; <font color = "red">一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。</font>这样的话，索引查找过程中就要产生磁盘I/O消耗，相对于内存存取，I/O存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I/O操作次数的渐进复杂度。换句话说，索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数。  
&emsp; B-tree：因为B树不管叶子节点还是非叶子节点，都会保存数据，这样导致在非叶子节点中能保存的指针数量变少，指针少的情况下要保存大量数据，只能增加树的高度，导致IO操作变多，查询性能变低；  
&emsp; （从物理存储结构上说，B-Tree和B+Tree都以页(4K)来划分节点的大小，但是由于B+Tree中中间节点不存储数据，因此B+Tree能够在同样大小的节点中，存储更多的key，提高查找效率。）  
&emsp; Hash：虽然可以快速定位，但是没有顺序，IO复杂度高。  
&emsp; 二叉树：树的高度不均匀，不能自平衡，查找效率跟数据有关（树的高度），并且IO代价高。  
&emsp; 红黑树：树的高度随着数据量增加而增加，IO代价高。  
&emsp; **<font color = "red">2. B+-tree的查询效率更加稳定。</font>**  
&emsp; 由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。  

#### 1.5.1.3. InnoDB引擎的底层实现 
&emsp; <font color = "red">在InnoDB中，数据和索引文件是合起来储存的，如图所示，InnoDB 的存储文件有两个，后缀名分别是 .frm 和 .idb，其中 .frm 是表的定义文件，而idb是数据文件/索引文件。</font>   
![image](https://gitee.com/wt1814/pic-host/raw/master/images/SQL/sql-33.png)  

* .frm 文件：与表相关的元数据信息都存放在frm文件，包括表结构的定义信息等  
* .ibd 文件或 .ibdata 文件：这两种文件都是存放 InnoDB 数据的文件，之所以有两种文件形式存放 InnoDB 的数据，是因为 InnoDB 的数据存储方式能够通过配置来决定是使用共享表空间存放存储数据，还是用独享表空间存放存储数据。  

&emsp; 独享表空间存储方式使用.ibd文件，并且每个表一个.ibd文件 共享表空间存储方式使用.ibdata文件，所有表共同使用一个.ibdata文件（或多个，可自己配置）。  

&emsp; <font color = "red">InnoDB索引类型可以分为主键索引和辅助索引（非主键索引）。</font>  
&emsp; **<font color = "lime">主键索引树中，叶子结点保存着主键和对应行的全部数据。主键索引又被称为聚簇索引。</font>**   
![image](https://gitee.com/wt1814/pic-host/raw/master/images/SQL/sql-34.png)  
&emsp; **<font color = "lime">辅助索引树中，叶子结点保存着索引值和主键值。辅助索引又被称为非聚簇索引。当使用辅助索引进行查询时，一般需要进行回表操作。</font>**   
&emsp; <font color = "red">非聚簇索引一定会回表查询吗?（覆盖索引）</font>  
&emsp; 不一定，这涉及到查询语句所要求的字段是否全部命中了索引，如果全部命中了索引，即索引覆盖，那么就不必再进行回表查询。  
    
        索引覆盖，要查询的字段都建立了索引，那么引擎会直接在索引表中查询而不会访问原始数据（否则只要有一个字段没有建立索引就会做全表扫描），这叫索引覆盖。

&emsp; 总结：B+树在满足聚簇索引和覆盖索引的时候不需要回表查询数据。  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/SQL/sql-35.png)  

&emsp; **<font color = "red">自适应哈希索引：</font>**  
&emsp; InnoDB引擎中默认使用的是B+树索引，它会实时监控表上索引的使用情况。如果认为建立哈希索引可以提高查询效率，则自动在内存中的“自适应哈希索引缓冲区”建立哈希索引（在InnoDB中默认开启自适应哈希索引）。  
&emsp; 通过观察搜索模式，MySQL会利用index key的前缀建立哈希索引，如果一个表几乎大部分都在缓冲池中，那么建立一个哈希索引能够加快等值查询。  
&emsp; 注意：在某些工作负载下，通过哈希索引查找带来的性能提升远大于额外的监控索引搜索情况和保持这个哈希表结构所带来的开销。  
&emsp; 但某些时候，在负载高的情况下，自适应哈希索引中添加的read/write锁也会带来竞争，比如高并发的join操作。like操作和%的通配符操作也不适用于自适应哈希索引，可能要关闭自适应哈希索引。  

#### 1.5.1.4. MyISAM引擎的底层实现  
&emsp; <font color = "red">在MyISAM储存引擎中，数据和索引文件是分开储存的，Myisam的存储文件有三个，后缀名分别是 .frm、.MYD、MYI，其中 .frm 是表的定义文件，.MYD 是数据文件，.MYI 是索引文件。</font>  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/SQL/sql-36.png)  

* .frm文件：与表相关的元数据信息都存放在frm文件，包括表结构的定义信息等。
* .MYD (MYData) 文件：MyISAM 存储引擎专用，用于存储MyISAM 表的数据。  
* .MYI (MYIndex)文件：MyISAM 存储引擎专用，用于存储MyISAM 表的索引相关信息。  

&emsp; <font color = "red">MyISAM也是B+树结构，但是MyISAM索引的叶子节点的数据保存的是行数据的地址。</font>因此，MyISAM中索引检索的算法首先在索引树中找到行数据的地址，然后根据地址找到对应的行数据。  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/SQL/sql-37.png)  
&emsp; MyISAM的索引文件仅仅保存数据记录的地址。主键索引和辅助索引，只是主索引要求key是唯一的，而辅助索引的key可以重复。如果在Col2上建立一个辅助索引，则此索引的如下图：  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/SQL/sql-38.png)  

#### 1.5.1.5. 为什么官方建议InnoDB使用自增长主键作为索引？-1  

        适合用业务字段做主键的场景需求：1).只有一个索引；2).该索引必须是唯一索引。这就是典型的KV场景。由于没有其他索引，所以也就不用考虑其他索引的叶子节点大小的问题。 

```text
没有定义主键，InnoDB会如何处理？  
    如果定义了主键(PRIMARY KEY)，那么InnoDB会选择主键作为聚集索引。  
    如果没有显式定义主键，则InnoDB会选择第一个不包含有NULL值的唯一索引作为主键索引。  
    如果也没有这样的唯一索引，则InnoDB会选择内置6字节长的ROWID作为隐含的聚集索引(ROWID随着行记录的写入而主键递增，这个ROWID不像ORACLE的ROWID那样可引用，是隐含的)。  
```

&emsp; 存储空间：由于每个非主键索引的叶子节点上都是主键的值。如果用业务字段做主键，那么每个二级索引的叶子节点占用约xxx个字节，而如果用整型做主键，则只要4个字节，如果是长整型（bigint）则是8个字节。<font color = "red">即主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。</font>  
&emsp; 性能：<font color = "red">根据B+Tree的特点，自增主键是连续的，在插入过程中尽量减少InnoDB存储引擎的页分裂，</font>即使要进行页分裂，也只会分裂很少一部分。并且能减少数据的移动，每次插入都是插入到最后。即减少分裂和移动的频率。  
&emsp; 碎片问题：  

### 1.5.2. Hash索引  
&emsp; 哈希索引底层的数据结构就是哈希表。对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码（hash code），并且Hash索引将所有的哈希码存储在索引中，同时在索引表中保存指向每个数据行的指针。  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/SQL/sql-39.png)  
&emsp; 在 MySQL 中，只有 Memory 存储引擎显式的支持哈希索引，而innodb是隐式支持哈希索引的。  

&emsp; <font color = "red">哈希索引适用的场景</font>：等值查询。  
&emsp; <font color = "red">哈希索引不适用的场景</font>：hash函数的不可预测性，hash索引中经过hash函数建立索引之后，索引的顺序与原顺序无法保持一致。不支持范围查询、不支持索引完成排序、不支持联合索引的最左前缀匹配规则、不支持部分匹配、只支持等值查询如=，IN()，不支持 < >。  

## 1.6. 索引维护、索引工具的使用  
1. 冗余和重复索引：冗余索引是指在相同的列上按照相同的顺序创建的相同类型的索引，应当尽量避免这种索引，发现后立即删除。比如有一个索引(A,B)，再创建索引(A)就是冗余索引。冗余索引经常发生在为表添加新索引时，比如有人新建了索引(A,B)，但这个索引不是扩展已有的索引(A)。
2. 大多数情况下都应该尽量扩展已有的索引而不是创建新索引。但有极少情况下出现性能方面的考虑需要冗余索引，比如扩展已有索引而导致其变得过大，从而影响到其他使用该索引的查询。
3. 删除长期未使用的索引。

&emsp; MySql索引工具：1.mysqlidxchx 2.pt-index-usage 3.userstat 4.check-unused-keys  
