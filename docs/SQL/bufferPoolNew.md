
<!-- TOC -->

- [1. 缓冲池(buffer pool)](#1-缓冲池buffer-pool)
    - [1.1. 为什么要有缓存池？](#11-为什么要有缓存池)
    - [1.2. 缓存池读写原理](#12-缓存池读写原理)
        - [1.2.1. ~~基本读写原理~~](#121-基本读写原理)
        - [1.2.2. 缓冲池的预读机制(加载哪些数据)](#122-缓冲池的预读机制加载哪些数据)
            - [1.2.2.1. 预读失效与缓存污染](#1221-预读失效与缓存污染)
        - [1.2.3. 缓冲池的空间管理](#123-缓冲池的空间管理)
            - [1.2.3.1. Free链表](#1231-free链表)
            - [1.2.3.2. 改进的Lru链表](#1232-改进的lru链表)
            - [1.2.3.3. Flush链表](#1233-flush链表)
        - [1.2.4. 读写操作再次讲解](#124-读写操作再次讲解)
            - [1.2.4.1. 读操作](#1241-读操作)
            - [1.2.4.2. 写操作](#1242-写操作)
    - [1.3. 缓冲池相关参数设置](#13-缓冲池相关参数设置)

<!-- /TOC -->

&emsp; **<font color = "red">总结：</font>**  
1. 缓冲池是主内存中的一个区域，在InnoDB访问表和索引数据时会在其中进行高速缓存。**在专用服务器上，通常将多达80％的物理内存分配给缓冲池。**  
1. **预读：**   
&emsp; 数据访问，通常都遵循“集中读写”的原则，使用一些数据，大概率会使用附近的数据，这就是所谓的“局部性原理”，它表明提前加载是有效的，确实能够减少磁盘IO。  
&emsp; **<font color = "clime">预读机制能把一些“可能要访问”的页提前加入缓冲池，避免未来的磁盘IO操作；</font>**  
2. **预读失效与缓存污染：**    
&emsp; 预读失效：读取连续的缓存页，将lru链表尾部经常被访问的页清除了。缓存污染：当执行一条 SQL 语句时，如果扫描了大量数据或是进行了全表扫描，从而将缓冲池中已存在的所有页替换出去。  
3. **读操作：改进的lru算法：**    
&emsp; **<font color = "clime">为了提高缓存命中率，InnoDB 在传统 Lru 算法的基础上做了优化，解决了两个问题：1、预读失效 2、缓存池污染。</font>**   
&emsp; 将LRU链表分为两部分，一部分为热数据区域，一部分为冷数据区域。当数据页第一次被加载到缓冲池中的时候，先将其放到冷数据区域的链表头部，1s（由 innodb_old_blocks_time 参数控制） 后该缓存页被访问了再将其移至热数据区域的链表头部。  
5. **写操作：**    
&emsp; **Buffer pool 另一个主要的功能是「加速写」，即当需要修改一个页面的时候，先将这个页面在缓冲池中进行修改，记下相关的重做日志，这个页面的修改就算已经完成了。**  


# 1. 缓冲池(buffer pool)  
<!--
mysql-缓冲池
https://mp.weixin.qq.com/s/3CR8EUXaHRmUbi055Siiqg
https://blog.csdn.net/jaylaozhou/article/details/103921807

mysql缓冲池_详解MySQL中的缓冲池（buffer pool）
https://blog.csdn.net/weixin_33974017/article/details/113150429

MySQL 缓冲池 是什么？ 
https://mp.weixin.qq.com/s/rCTJDh3_WbEAbGLZdZiQzg

https://mp.weixin.qq.com/s/XbvSZ3X6c-tToe-FKsEafA

https://blog.csdn.net/mocas_wang/article/details/110306656
https://blog.csdn.net/weixin_33974017/article/details/113150429
https://blog.csdn.net/jaylaozhou/article/details/103921807

-->
<!-- 
~~
能说一说Mysql缓存池吗？ 
https://mp.weixin.qq.com/s/AbiYMbDUJsMWK-_g0mFNwg
-->
<!-- 
&emsp; InnoDB 会将那些热点数据和一些 InnoDB 认为即将访问到的数据存在 Buffer Pool 中，以提升数据的读取性能。  
&emsp; InnoDB 在修改数据时，如果数据的页在 Buffer Pool 中，则会直接修改 Buffer Pool，此时称这个页为脏页，InnoDB 会以一定的频率将脏页刷新到磁盘，这样可以尽量减少磁盘I/O，提升性能。 
-->
&emsp; 缓冲池是主内存中的一个区域，在InnoDB访问表和索引数据时会在其中进行高速缓存。**在专用服务器上，通常将多达80％的物理内存分配给缓冲池。**  
&emsp; 为了提高大容量读取操作的效率，缓冲池被分为多个页面，这些页面可能包含多个行。为了提高缓存管理的效率，缓冲池被实现为页面的链接列表。使用LRU算法的变体将很少使用的数据从缓存中老化掉。  
&emsp; **缓冲池允许直接从内存中处理经常使用的数据，从而加快了处理速度。**  

## 1.1. 为什么要有缓存池？
&emsp; Mysql 的 innodb 存储引擎是基于磁盘存储的，并且是按照页的方式进行管理的。  
&emsp; 在数据库系统中，CPU 速度与磁盘速度之间的差距是非常大的，为了最大可能的弥补之间的差距，提出了缓存池的概念。  
&emsp; 所以缓存池，简单来说就是一块「内存区域」，通过内存的速度来弥补磁盘速度较慢，导致对数据库造成性能的影响。  

## 1.2. 缓存池读写原理

### 1.2.1. ~~基本读写原理~~  
* 读数据操作：
    * 首先将从磁盘读到的页存放在缓冲池中，这个过程称为将页“FIX”在缓冲池中
    * 下一次再读相同的页时，首先判断该页是否在缓冲池中
    * 若在缓冲池中，称该页在缓冲池中被命中，直接读取该页。否则，读取磁盘上的页
* 写数据操作：
    * **<font color = "clime">如果数据的页在 Buffer Pool 中，首先修改在缓冲池中的页，此时称这个页为脏页。</font>** 然后再以一定的频率刷新到磁盘上
    * 页从缓冲池刷新回磁盘的操作并不是在每次页发生更新时触发
    * 通过一种称为Checkpoint的机制刷新回磁盘

<!-- 
「读操作」:

在数据库中进行读取页的操作，首先把从磁盘读到的页存放在缓存池中，下一次读取相同的页时，首先判断该页是不是在缓存池中。

若在，称该页在缓存池中被命中，则直接读取该页，否则，还是去读取磁盘上的页。

「写操作」:

对于数据库中页的修改操作，首先修改在缓存池中的页，然后在以一定的频率刷新到磁盘，并不是每次页发生改变就刷新回磁盘，而是通过 checkpoint 的机制把页刷新回磁盘。

可以看到，无论是读操作还是写操纵，都是对缓存池进行操作，而不是直接对磁盘进行操纵。
-->

---------------

### 1.2.2. 缓冲池的预读机制(加载哪些数据)  
&emsp; 什么是预读？  
&emsp; 磁盘读写，并不是按需读取，而是按页读取， **<font color = "clime">一次至少读一页数据(一般是4K)，如果未来要读取的数据就在页中，就能够省去后续的磁盘IO，提高效率。</font>**  

&emsp; 预读为什么有效？  
&emsp; 数据访问，通常都遵循“集中读写”的原则，使用一些数据，大概率会使用附近的数据，这就是所谓的“局部性原理”，它表明提前加载是有效的，确实能够减少磁盘IO。  

&emsp; 按页(4K)读取，和InnoDB的缓冲池设计有什么关系？  
&emsp; (1)磁盘访问按页读取能够提高性能，所以缓冲池一般也是按页缓存数据；  
&emsp; (2) **<font color = "clime">预读机制能把一些“可能要访问”的页提前加入缓冲池，避免未来的磁盘IO操作；</font>**  

&emsp; InnoDB使用两种预读算法来提高I/O性能：线性预读(linear read-ahead)和随机预读(randomread-ahead)。其中，线性预读以 extent(块，1个 extent 等于64个 page)为单位，而随机预读放到以 extent 中的 page 为单位。线性预读着眼于将下一个extent 提前读取到 buffer pool 中，而随机预读着眼于将当前 extent 中的剩余的 page 提前读取到 buffer pool 中。  

* 线性预读(Linear read-ahead)：线性预读方式有一个很重要的变量innodb_read_ahead_threshold，可以控制Innodb执行预读操作的触发阈值。如果一个 extent中的被顺序读取的page超过或者等于该参数变量时，Innodb将会异步的将下一个extent读取到buffer pool中，innodb_read_ahead_threshold可以设置为0-64(一个 extend 上限就是64页)的任何值，默认值为56，值越高，访问模式检查越严格。  
* 随机预读(Random read-ahead)：随机预读方式则是表示当同一个extent中的一些page在buffer pool中发现时，Innodb会将该extent中的剩余page一并读到buffer pool中，由于随机预读方式给Innodb code带来了一些不必要的复杂性，同时在性能也存在不稳定性，在5.5中已经将这种预读方式废弃。要启用此功能，请将配置变量设置innodb_random_read_ahead 为ON。 

<!-- 
预读(read ahead)  
&emsp; InnoDB 在 I/O 的优化上有个比较重要的特性为预读，<font color = "red">当 InnoDB 预计某些 page 可能很快就会需要用到时，它会异步地将这些 page 提前读取到缓冲池(buffer pool)中，</font>这其实有点像空间局部性的概念。  
&emsp; 空间局部性(spatial locality)：如果一个数据项被访问，那么与它的址相邻的数据项也可能很快被访问。  
&emsp; InnoDB使用两种预读算法来提高I/O性能：线性预读(linear read-ahead)和随机预读(randomread-ahead)。  
&emsp; 其中，线性预读以 extent(块，1个 extent 等于64个 page)为单位，而随机预读放到以 extent 中的 page 为单位。线性预读着眼于将下一个extent 提前读取到 buffer pool 中，而随机预读着眼于将当前 extent 中的剩余的 page 提前读取到 buffer pool 中。  
&emsp; 线性预读(Linear read-ahead)：线性预读方式有一个很重要的变量 innodb_read_ahead_threshold，可以控制 Innodb 执行预读操作的触发阈值。如果一个 extent 中的被顺序读取的 page 超过或者等于该参数变量时，Innodb将会异步的将下一个 extent 读取到 buffer pool中，innodb_read_ahead_threshold 可以设置为0-64(一个 extend 上限就是64页)的任何值，默认值为56，值越高，访问模式检查越严格。  
&emsp; 随机预读(Random read-ahead): 随机预读方式则是表示当同一个 extent 中的一些 page 在 buffer pool 中发现时，Innodb 会将该 extent 中的剩余 page 一并读到 buffer pool中，由于随机预读方式给 Innodb code 带来了一些不必要的复杂性，同时在性能也存在不稳定性，在5.5中已经将这种预读方式废弃。要启用此功能，请将配置变量设置 innodb_random_read_ahead 为ON。  
-->
#### 1.2.2.1. 预读失效与缓存污染  
&emsp; ......


### 1.2.3. 缓冲池的空间管理  
#### 1.2.3.1. Free链表  
<!-- 
LRU列表用来管理已经读取的页，但当数据库刚启动时，LRU列表是空的，即没有任何的页。这时页都存放在Free列表中.

当需要从缓冲池中分页时，首先从Free列表中查找是否有可用的空闲页，若有则将该页从Free列表中删除，放入到LRU列表中。否则，根据LRU算法，淘汰LRU列表末尾的页，将该内存空间分配给新的页

当页从LRU列表的old部分加入到new部分时，称此时发生的操作为page made young，而因为innodb_old_blocks_time的设置而导致页没有从old部分移动到new部分的操作称为page not made young

可以通过命令SHOW ENGINE INNODBSTATUS来观察LRU列表及Free列表的使用情况和运行状态
-->
&emsp; 当启动Mysql服务器的时候，需要完成对Buffer Pool的初始化过程，即分配Buffer Pool的内存空间，把它划分为若干对控制块和缓存页，但是此时并没有真正的磁盘页被缓存到Buffer Pool 中，之后随着程序的运行，会不断的有磁盘上的页被缓存到Buffer Pool中。  
&emsp; 在使用过程中，为了记录哪些缓存页是可用的，把所有空闲的页包装成一个节点组成一个链表，这个链表可以称作为 Free 链表（空闲链表）。因为刚刚完成初始化的 Buffer Pool 中所有的缓存页都是空闲的，所以每一个缓存页都会被加入到 Free 链表中。  
&emsp; 为了方便管理 Free 链表，特意为这个链表定义了一些「控制信息」，里面包含链表的头节点地址，尾节点地址，以及当前链表中节点的数量等信息。  
&emsp; 另外会在每个 Free 链表的节点中都记录了某个「缓存页控制块」的地址，而每个「缓存页控制块」都记录着对应的「缓存页地址」，所以相当于每个 Free 链表节点都对应一个空闲的缓存页。  

&emsp; 结构如下图：  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/SQL/sql-105.png)  

#### 1.2.3.2. 改进的Lru链表  
&emsp; Lru 链表用来管理已经读取的页，当数据库刚启动时，Lru 链表是空的，此时页也都放在 Free 列表中，当需要读取数据时，会从Free链表中申请一个页，把从放入到磁盘读取的数据放入到申请的页中，这个页的集合叫做Lru链表。  

&emsp; ......

#### 1.2.3.3. Flush链表  
<!--
    LRU列表用来管理缓冲池中页的可用性，Flush列表用来管理将页刷新回磁盘，二者互不影响

    在LRU列表中的页被修改后，称该页为脏页（dirty page），即缓冲池中的页和磁盘上的页的数据产生了不一致。

    这时数据库会通过CHECKPOINT机制将脏页刷新回磁盘，而Flush列表中的页即为脏页列表。

    脏页既存在于LRU列表中，也存在于Flush列表中。

缓冲池中的页还可能会被分配给自适应哈希索引、Lock信息、InsertBuffer等页，而这部分页不需要LRU算法进行维护，因此不存在于LRU列表中。
-->
&emsp; Flush 链表用来管理被修改的页，Buffer Pool 中被修改的页也被称之为「脏页」，脏页既存在于 Lru 链表中，也存在于 Flush 链表中，Flush 链表中存的是一个指向 Lru 链表中具体数据的指针。  
&emsp; 因此只有 Lru 链表中的页第一次被修改时，对应的指针才会存入到 Flush 中，若之后再修改这个页，则是直接更新 Lru 链表中的页对应的数据。  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/SQL/sql-149.png)  

### 1.2.4. 读写操作再次讲解  
#### 1.2.4.1. 读操作  
&emsp; Buffer Pool 一个最主要的功能是「加速读」。加速读是当需要访问一个数据页面的时候，如果这个页面已经在缓存池中，那么就不再需要访问磁盘，直接从缓冲池中就能获取这个页面的内容。当需要访问某个页中的数据时，就会把该页加载到 Buffer Pool 中，如果该页已经在 Buffer Pool 中的话直接使用就可以了。  

&emsp; 问题：那么如何快速查找在 Buffer Pool 中的页呢？  
&emsp; 为了避免查询数据页时扫描 Lru，其实是根据表空间号 + 页号来定位一个页的，也就相当于表空间号 + 页号是一个 key，缓存页就是对应的 value。用表空间号 + 页号作为 key，缓存页作为 value 创建一个哈希表，在需要访问某个页的数据时，先从哈希表中根据表空间号 + 页号看看有没有对应的缓存页。  
&emsp; 如果有，直接使用该缓存页就好。  
&emsp; 如果没有，那就从 Free 链表中选一个空闲的缓存页，然后把磁盘中对应的页加载到该缓存页的位置。每当需要从磁盘中加载一个页到 Buffer Pool 中时，就从 Free 链表中取一个空闲的缓存页，并且把该缓存页对应的控制块的信息填上，然后把该缓存页对应的 Free 链表节点从链表中移除，表示该缓存页已经被使用了，并且把该页写入 Lru 链表。  
&emsp; 在初始化的时候，Buffer pool 中所有的页都是空闲页，需要读数据时，就会从 Free 链表中申请页，但是物理内存不可能无限增大，数据库的数据却是在不停增大的，所以 Free 链表的页是会用完的。  
&emsp; 因此需要考虑把已经缓存的页从 Buffer pool 中删除一部分，进而需要考虑如何删除及删除哪些已经缓存的页。假设一共访问了 n 次页，那么被访问的页在缓存中的次数除以 n 就是缓存命中率，缓存命中率越高，和磁盘的 IO 交互也就越少 。  
&emsp; **<font color = "clime">为了提高缓存命中率，InnoDB 在传统 Lru 算法的基础上做了优化，解决了两个问题：1、预读失效 2、缓存池污染。</font>**   


#### 1.2.4.2. 写操作  
&emsp; **Buffer pool 另一个主要的功能是「加速写」，即当需要修改一个页面的时候，先将这个页面在缓冲池中进行修改，记下相关的重做日志，这个页面的修改就算已经完成了。**  
&emsp; 被修改的页面真正刷新到磁盘，这个是后台刷新线程来完成的。前面页面更新是在缓存池中先进行的，那它就和磁盘上的页不一致了，这样的缓存页被称为脏页（dirty page）。  

&emsp; 问题：这些被修改的页面什么时候刷新到磁盘？以什么样的顺序刷新到磁盘？  
&emsp; 最简单的做法就是每发生一次修改就立即同步到磁盘上对应的页上，但是频繁的往磁盘中写数据会严重的影响程序的性能。所以每次修改缓存页后，不能立即把修改同步到磁盘上，而是在未来的某个时间点进行同步，由后台刷新线程依次刷新到磁盘，实现修改落地到磁盘。  
&emsp; 但是如果不立即同步到磁盘的话，那之后再同步的时候如何判断 Buffer Pool 中哪些页是脏页，哪些页从来没被修改过呢？  
&emsp; InnoDB 并没有一次性把所有的缓存页都同步到磁盘上，InnoDB 创建一个存储脏页的链表，凡是在 Lru 链表中被修改过的页都需要加入这个链表中，因为这个链表中的页都是需要被刷新到磁盘上的，所以这个链表也叫 Flush 链表，链表的构造和 Free 链表一致。  
&emsp; 这里的脏页修改指的此页被加载进 Buffer Pool 后第一次被修改，只有第一次被修改时才需要加入 Flush 链表，对于已经存在在 Flush 链表中的页，如果这个页被再次修改就不会再放到 Flush 链表。  
&emsp; 需要注意，脏页数据实际还在 Lru 链表中，而 Flush 链表中的脏页记录只是通过指针指向 Lru 链表中的脏页。并且在 Flush 链表中的脏页是根据 oldest_lsn（这个值表示这个页第一次被更改时的 lsn 号，对应值 oldest_modification，每个页头部记录）进行排序刷新到磁盘的，值越小表示要最先被刷新，避免数据不一致。  

----------

## 1.3. 缓冲池相关参数设置  
<!-- 
配置参数：

    innodb_buffer_pool_instances， 缓冲池实例个数默认1，InnoDB 1.0.x版本开始使用，每个页根据哈希值平均分配到不同缓冲池实例中。减少数据库内部的资源竞争，增加数据库的并发处理能力。
    innodb_buffer_pool_size，缓冲池大小

命令参数：

    可通过命令查看缓冲池大小 SHOW VARIABLES LIKE 'innodb_buffer_pool_size'
    通过命令可查看缓冲池实例个数 SHOW VARIABLES LIKE 'innodb_buffer_pool_instances'
-->

&emsp; 有三个比较重要的参数。  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/SQL/sql-105.png)  
&emsp; 参数：innodb_buffer_pool_size  
&emsp; 介绍：配置缓冲池的大小，在内存允许的情况下，DBA往往会建议调大这个参数，越多数据和索引放到内存里，数据库的性能会越好。  

&emsp; 参数：innodb_old_blocks_pct  
&emsp; 介绍：老生代占整个LRU链长度的比例，默认是37，即整个LRU中新生代与老生代长度比例是63:37。如果把这个参数设为100，就退化为普通LRU了。  

&emsp; 参数：innodb_old_blocks_time  
&emsp; 介绍：老生代停留时间窗口，单位是毫秒，默认是1000，即同时满足“被访问”与“在老生代停留时间超过1秒”两个条件，才会被插入到新生代头部。  
