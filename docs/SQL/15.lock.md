

<!-- TOC -->

- [1. MySql的锁](#1-mysql的锁)
    - [1.1. 数据库锁简介](#11-数据库锁简介)
    - [1.2. 锁的粒度](#12-锁的粒度)
    - [1.3. 锁的类别](#13-锁的类别)
        - [1.3.1. MyISAM存储引擎](#131-myisam存储引擎)
        - [1.3.2. InnoDB存储引擎](#132-innodb存储引擎)
            - [1.3.2.1. 共享/排它锁（行级锁）](#1321-共享排它锁行级锁)
            - [1.3.2.2. 意向锁(表级锁)](#1322-意向锁表级锁)
            - [1.3.2.3. 记录锁(Record Locks) ，锁定记录](#1323-记录锁record-locks-锁定记录)
            - [1.3.2.4. 间隙锁（Gap Lock），锁定范围](#1324-间隙锁gap-lock锁定范围)
            - [1.3.2.5. 临键锁(Next-key Locks) ，锁定范围加记录](#1325-临键锁next-key-locks-锁定范围加记录)
            - [1.3.2.6. 插入意向锁](#1326-插入意向锁)
            - [1.3.2.7. 自增锁](#1327-自增锁)
    - [1.4. 锁使用方式：乐观锁、悲观锁](#14-锁使用方式乐观锁悲观锁)
    - [1.5. 锁表](#15-锁表)
    - [1.6. 死锁](#16-死锁)
        - [1.6.1. 死锁简介](#161-死锁简介)
        - [1.6.2. 死锁情况](#162-死锁情况)
    - [1.7. 生产问题-死锁解决](#17-生产问题-死锁解决)
        - [1.7.1. 前提](#171-前提)
        - [1.7.2. 死锁场景复现](#172-死锁场景复现)
        - [1.7.3. 导致死锁的原因](#173-导致死锁的原因)
        - [1.7.4. 解决方案](#174-解决方案)
        - [1.7.5. 小结](#175-小结)

<!-- /TOC -->

![image](https://gitee.com/wt1814/pic-host/raw/master/images/SQL/sql-58.png)  

# 1. MySql的锁  

<!-- 

什么是死锁？怎么解决？、数据库的乐观锁和悲观锁是什么？怎么实现的？
https://mp.weixin.qq.com/s/vQIQA4nWcwYsifoSxQ60IQ

 MySQL的一些琐事 
 https://mp.weixin.qq.com/s/VcHjBPCvscjtNKVkqhQ5vQ

-->

## 1.1. 数据库锁简介  

&emsp; **~~存储引擎与锁~~：**  

* InnoDB：对于UPDATE、DELETE、INSERT语句，InnoDB会自动给涉及数据集加排他锁（X)。  
* MyISAM：MyISAM在执行查询语句SELECT前，会自动给涉及的所有表加读锁，在执行更新操作（UPDATE、DELETE、INSERT等）前，会自动给涉及的表加写锁，这个过程并不需要用户干预。  

&emsp; **事务和锁的关联：**  
1. 事务与锁是不同的。事务具有ACID（原子性、一致性、隔离性和持久性），<font color = "red">锁是用于解决隔离性的一种机制。</font>  
2. <font color = "red">事务的隔离级别通过锁的机制来实现。</font>另外锁有不同的粒度，同时事务也是有不同的隔离级别的。  
3. 开启事务就自动加锁。  

&emsp; **锁的分类：**  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/SQL/sql-42.png)  

* 按使用方式：乐观锁、悲观锁。  
* 锁类别：有共享锁（读锁）和排他锁（写锁）。锁类别取决于存储引擎执行的sql语句。  
    ![image](https://gitee.com/wt1814/pic-host/raw/master/images/SQL/sql-47.png)  
* 按粒度：锁的粒度的不同可以分为表锁、页锁、行锁。  

---
---
---
## 1.2. 锁的粒度  

* 页锁  
&emsp; 页级锁定是MySQL中比较独特的一种锁定级别，在其他数据库管理软件中也并不是太常见。页级锁定的特点是锁定粒度介于行级锁定与表级锁之间，所以获取锁定所需要的资源开销，以及所能提供的并发处理能力也同样是介于上面二者之间。另外，页级锁定和行级锁定一样，会发生死锁。  
&emsp; 在数据库实现资源锁定的过程中，随着锁定资源颗粒度的减小，锁定相同数据量的数据所需要消耗的内存数量是越来越多的，实现算法也会越来越复杂。不过，随着锁定资源颗粒度的减小，应用程序的访问请求遇到锁等待的可能性也会随之降低，系统整体并发度也随之提升。  
&emsp; 使用页级锁定的主要是BerkeleyDB存储引擎。  

* 表锁  
&emsp; 特点：对整张表加锁。开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。  
&emsp; 存储引擎的支持：使用表级锁定的主要是MyISAM，MEMORY，CSV等一些非事务性存储引擎。  
&emsp; 如何加表锁？MyISAM在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁，在执行更新操作（UPDATE、DELETE、INSERT等）前，会自动给涉及的表加写锁。这个过程并不需要用户干预，因此，用户一般不需要直接用LOCK TABLE命令给MyISAM表显式加锁。  

* 行锁  
&emsp; 行级锁：对某行记录加锁。开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。  
&emsp; 使用行级锁定的主要是InnoDB存储引擎。  
&emsp; **适用场景：** 从锁的角度来说，表级锁更适合于以查询为主，只有少量按索引条件更新数据的应用，如Web应用。而行级锁则更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用，如一些在线事务处理（OLTP）系统。  

        InnoDB 的行锁是怎么实现的？  
        InnoDB 行锁是通过索引上的索引项来实现的。意味者：只有通过索引条件检索数据，InnoDB 才会使用行级锁，否则，InnoDB将使用表锁！  
        对于主键索引：直接锁住锁住主键索引即可。  
        对于普通索引：先锁住普通索引，接着锁住主键索引，这是因为一张表的索引可能存在多个，通过主键索引才能确保锁是唯一的，不然如果同时有2个事务对同1条数据的不同索引分别加锁，那就可能存在2个事务同时操作一条数据了。  

&emsp; 不同的存储引擎支持的锁粒度是不一样的。  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/SQL/sql-43.png)  
&emsp; **<font color = "red">InnoDB实现了行级锁，页级锁，表级锁。InnoDB只有通过索引条件检索数据才使用行级锁，否则，InnoDB将使用表锁。即InnoDB的行锁是基于索引的！</font><font color = "lime">这些锁的粒度之间也是会发生升级的，锁升级的意思就是将当前锁的粒度降低，数据库可以把一个表的1000个行锁升级为一个页锁，或者将页锁升级为表锁。</font>**  
&emsp; MyISAM只支持表锁！  

## 1.3. 锁的类别  
### 1.3.1. MyISAM存储引擎  
&emsp; MyISAM存储引擎只支持表级锁定。  
&emsp; <font color = "red">MyISAM在执行查询语句（select）前，会自动给涉及的所有表加读锁，在执行增删改操作前，会自动给涉及的表加写锁。读锁和写锁是互斥的，读写操作是串行。在表读锁和表写锁的环境下：读读不阻塞，读写阻塞，写写阻塞！</font>  

* 读读不阻塞：当前用户在读数据，其他的用户也在读数据，不会加锁！  
* 读写阻塞：当前用户在读数据，其他的用户不能修改当前用户读的数据，会加锁！  
* 写写阻塞：当前用户在修改数据，其他的用户不能修改当前用户正在修改的数据，会加锁！  

![image](https://gitee.com/wt1814/pic-host/raw/master/images/SQL/sql-48.png)  

&emsp; <font color = "red">默认情况下，写锁比读锁具有更高的优先级：当一个锁释放时，这个锁会优先给写锁队列中等候的获取锁请求，然后再给读锁队列中等候的获取锁请求。</font>


### 1.3.2. InnoDB存储引擎  
<!-- 
https://mp.weixin.qq.com/s/y7Jo67stdbakETo2UV1ivg
http://blog.itpub.net/31556440/viewspace-2642668/
-->
&emsp; InnoDB共有七种类型的锁：  

* 共享/排它锁(Shared and Exclusive Locks)  
* 意向锁(Intention Locks)  
* 记录锁(Record Locks)  
* 间隙锁(Gap Locks)  
* 临键锁(Next-key Locks)  
* 插入意向锁(Insert Intention Locks)  
* 自增锁(Auto-inc Locks)  

&emsp; InnoDB存储引擎的锁的算法有三种  
1. Record lock：单个行记录上的锁  
2. Gap lock：间隙锁，锁定一个范围，不包括记录本身  
3. Next-key lock：record+gap 锁定一个范围，包含记录本身  

#### 1.3.2.1. 共享/排它锁（行级锁）  
&emsp; InnoDB 存储引擎行锁，当数据查询时针对索引数据进行时，会使用行级锁。  

* 共享锁（S）：当一个事务读取一条记录的时候，不会阻塞其他事务对同一记录的读请求，但会阻塞对其的写请求。当读锁释放后，才会执行其他事务的写操作。例如：select … lock in share mode  
* 排他锁（X）：当一个事务对一条记录进行写操作时，会阻塞其他事务对同一表的读写操作，当该锁释放后，才会执行其他事务的读写操作。例如：select … for update  

&emsp;在高并发的情况下，多个事务同时请求更新数据，由于资源被占用等待事务增多。  
&emsp;如此，会造成性能问题，可以通过innodb_lock_wait_timeout 来解决。innodb_lock_wait_timeout 是事务等待获取资源的最长时间，单位为秒。如果超过时间还未分配到资源，则会返回应用失败。  

#### 1.3.2.2. 意向锁(表级锁)  
&emsp; InnoDB 存储引擎表锁：当没有对数据表中的索引数据进行查询时，会执行表锁操作。采用两种意向锁（Intention Locks)。  

* 意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前，必须先取得该表的 IS 锁。  
* 意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前，必须先取得该表的 IX 锁。  

&emsp; 意向共享锁和意向排他锁是数据库主动加的，不需要手动处理。对于 UPDATE、DELETE 和 INSERT 语句，InnoDB 会自动给数据集加排他锁。  

&emsp; 行级锁和表级锁的兼容情况：  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/SQL/sql-49.png)  
<center>共享锁，排他锁，意向共享锁，意向排他锁兼容图例</center>    
&emsp; 如果一个事务请求的锁模式与当前的锁兼容， InnoDB 就将请求的锁授予该事务；反之， 如果两者不兼容，该事务就要等待锁释放。  

---

#### 1.3.2.3. 记录锁(Record Locks) ，锁定记录 
![image](https://gitee.com/wt1814/pic-host/raw/master/images/SQL/sql-124.png)  

&emsp; <font color = "red">record lock 是一个在索引行记录的锁。</font>  
&emsp; 比如，SELECT c1 FROM t WHERE c1 = 10 FOR UPDATE，如果c1 上的索引被使用到。防止任何其他事务变动 c1 = 10 的行。  
&emsp; record lock 总是会在索引行上加锁。即使一个表并没有设置任何索引，这种时候 innoDB 会创建一个隐式的聚集索引（primary Key）,然后在这个聚集索引上加锁。  
&emsp; 当查询字段没有索引时，比如 update table set columnA="A" where columnB=“B".如果 columnB 字段不存在索引（或者不是组合索引前缀），这条语句会锁住所有记录也就是锁表。如果语句的执行能够执行一个 columnB 字段的索引，那么仅会锁住满足 where 的行(RecordLock)。  

#### 1.3.2.4. 间隙锁（Gap Lock），锁定范围  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/SQL/sql-123.png)  

&emsp; **<font color = "red">当使用范围条件（> 、< 、between......）检索数据，InnoDB会给符合条件的已有数据记录的索引项加锁。对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)”，InnoDB也会对这个“间隙”加锁，这就是间隙锁。</font>**  
&emsp; **<font color = "red">InnoDB 除了通过范围条件加锁时使用间隙锁外，如果使用相等条件请求给一个不存在的记录加锁，InnoDB 也会使用间隙锁。</font>**  

&emsp; 假如emp表中只有101条记录，其empid的值分别是1,2,...,100,101，下面的 SQL：  

```sql
select * from emp where empid > 100 for update;
```  
&emsp; 这是一个范围条件的检索，InnoDB 不仅会对符合条件的empid值为101的记录加锁，也会对empid大于101（这些记录并不存在）的“间隙”加锁。  

&emsp; **<font color = "lime">InnoDB 使用间隙锁的目的：</font>**  
&emsp; 一方面是为了防止幻读。对于上例，如果不使用间隙锁，其他事务插入了 empid大于 100的任何记录，本事务再次执行 select 语句，就会发生幻读。  
&emsp; 另一方面，也是为了满足恢复和复制的需要。    

&emsp; **<font color = "red">InnoDB使用间隙锁的危害：</font>**  
&emsp; 因为执行SELECT语句中，如果通过范围查找的话，间隙锁会锁定整个范围内所有的索引键值，即使这个键值并不存在。这个就是间隙锁最致命的缺点，就是当锁定一个范围键值之后，即使某些不存在的键值也会被无辜的锁定，而造成在锁定的时候无法插入锁定值范围内的任何数据，在某些场景下这可能会针对性造成很大的危害。  

&emsp; **<font color = "red">间隙锁和行锁合称临键锁（Next-Key锁）。</font>**  

#### 1.3.2.5. 临键锁(Next-key Locks) ，锁定范围加记录 
![image](https://gitee.com/wt1814/pic-host/raw/master/images/SQL/sql-122.png)  

&emsp; 临键锁，是记录锁与间隙锁的组合，它的封锁范围，既包含索引记录，又包含索引区间。  
&emsp; <font color = "red">默认情况下，innodb使用next-key locks来锁定记录。</font><font color = "lime">但当查询的索引含有唯一属性的时候，Next-Key Lock 会进行优化，将其降级为Record Lock，即仅锁住索引本身，不是范围。</font>  

---

#### 1.3.2.6. 插入意向锁  
&emsp; 对已有数据行的修改与删除，必须加强互斥锁(X锁)，那么对于数据的插入，是否还需要加这么强的锁，来实施互斥呢？插入意向锁，孕育而生。  
&emsp; 插入意向锁，是间隙锁(Gap Locks)的一种（所以，也是实施在索引上的），它是专门针对insert操作的。多个事务，在同一个索引，同一个范围区间插入记录时，如果插入的位置不冲突，不会阻塞彼此。  

#### 1.3.2.7. 自增锁  
&emsp; 自增锁是一种特殊的表级别锁（table-level lock），专门针对事务插入AUTO_INCREMENT类型的列。最简单的情况，如果一个事务正在往表中插入记录，所有其他事务的插入必须等待，以便第一个事务插入的行，是连续的主键值。  

## 1.4. 锁使用方式：乐观锁、悲观锁  
&emsp; 乐观锁是一种思想，具体实现是，表中有一个版本字段，第一次读的时候，获取到这个字段。处理完业务逻辑开始更新的时候，需要再次查看该字段的值是否和第一次的一样。如果一样更新，反之拒绝。之所以叫乐观，因为这个模式没有从数据库加锁，等到更新的时候再判断是否可以更新。  
&emsp; 悲观锁是数据库层面加锁，都会阻塞去等待锁。  

    乐观锁：更新时带上版本号（cas更新）  
    悲观锁：使用共享锁和排它锁，select...lock in share mode，select…for update。  

## 1.5. 锁表  
1. 锁表发生在insert、update、delete中。  
2. 锁表的原理是数据库使用独占式封锁机制，当执行上面的语句时，对表进行锁住，直到发生commite 或者 回滚 或者 退出数据库用户。  
3. 锁表的原因  
&emsp; 第一、 A程序执行了对 tableA 的 insert ，并还未 commite时，B程序也对tableA 进行insert 则此时会发生资源正忙的异常 就是锁表  
&emsp; 第二、锁表常发生于并发而不是并行（并行时，一个线程操作数据库时，另一个线程是不能操作数据库的，cpu 和 i/o 分配原则）  

&emsp; (1)字段不加索引：在执行事务的时候，如果表中没有索引，会执行全表扫描，如果这时候有其他的事务过来，就会发生锁表！  
&emsp; (2)事务处理时间长：事务处理时间较长，当越来越多事务堆积的时候，会发生锁表！  
&emsp; (3)关联操作太多：涉及到很多张表的修改等，在并发量大的时候，会造成大量表数据被锁！  

4. 减少锁表的概率  
&emsp; 减少insert 、update 、delete 语句执行 到 commite 之间的时间。具体点批量执行改为单个执行、优化sql自身的非执行速度  
&emsp; 如果异常对事物进行回滚  

&emsp; 出现锁表的解决方法有：  
&emsp; (1)通过相关的sql语句可以查出是否被锁定，和被锁定的数据！  
&emsp; (2)为加锁进行时间限定，防止无限死锁！  
&emsp; (3)加索引，避免全表扫描！  
&emsp; (4)尽量顺序操作数据！  
&emsp; (5)根据引擎选择合理的锁粒度！  
&emsp; (6)事务中的处理时间尽量短！  


## 1.6. 死锁  

<!-- 
 MySQL死锁产生原因和解决方法 
 https://mp.weixin.qq.com/s/F3IPSiKzabuDd8S5UKI-WQ

 
-->
<!-- 
死锁的发生与否，并不在于事务中有多少条SQl语句，死锁的关键在于：两个（或以上）的Session加锁的顺序不一致。而使用本文上面提到的，分析MySQL每条SQL语句的加锁规则，分析出每条语句的加锁顺序，然后检查多个并发SQL间是否存在相反的顺序加锁的情况，就可以分析出各种潜在的死锁情况，也可以分析出线上死锁发生的原因。  
-->

&emsp; **<font color = "lime">一句话总结：</font>**  
&emsp; **<font color = "lime">1. MySql如何处理死锁？1). 发起死锁检测，主动回滚其中一条事务，让其他事务继续执行。2). 设置超时时间，超时后自动释放。</font>**   
&emsp; **<font color = "lime">2. 如果出现死锁？除了以上两种方案外，开发人员还需要检查代码。</font>**

### 1.6.1. 死锁简介
&emsp; 死锁发生了如何解决，MySQL 有没有提供什么机制去解决死锁。
  
---
**<font color = "red">死锁产生：</font>**  

* <font color = "red">死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环。</font>  
* <font color = "red">当事务试图以不同的顺序锁定资源时，就可能产生死锁。多个事务同时锁定同一个资源时也可能会产生死锁。</font>  
* <font color = "red">锁的行为和顺序和存储引擎相关。以同样的顺序执行语句，有些存储引擎会产生死锁有些不会——死锁有双重原因：真正的数据冲突；存储引擎的实现方式。</font>  

---
**<font color = "red">检测死锁</font>** ：数据库系统实现了各种死锁检测和死锁超时的机制。InnoDB存储引擎能检测到死锁的循环依赖并立即返回一个错误。  

**<font color = "red">死锁恢复</font>** ：死锁发生以后，只有部分或完全回滚其中一个事务，才能打破死锁，InnoDB目前处理死锁的方法是，将持有最少行级排他锁的事务进行回滚。所以事务型应用程序在设计时必须考虑如何处理死锁，多数情况下只需要重新执行因死锁回滚的事务即可。  

**<font color = "red">外部锁的死锁检测</font>** ：发生死锁后，InnoDB 一般都能自动检测到，并使一个事务释放锁并回退，另一个事务获得锁，继续完成事务。但在涉及外部锁，或涉及表锁的情况下，InnoDB 并不能完全自动检测到死锁， 这需要通过设置锁等待超时参数 innodb_lock_wait_timeout 来解决。  

---
**<font color = "red">死锁影响性能</font>** ：死锁会影响性能而不是会产生严重错误，因为InnoDB会自动检测死锁状况并回滚其中一个受影响的事务。在高并发系统上，当许多线程等待同一个锁时，死锁检测可能导致速度变慢。有时当发生死锁时，禁用死锁检测（使用innodb_deadlock_detect配置选项）可能会更有效，这时可以依赖innodb_lock_wait_timeout设置进行事务回滚。  

---
**<font color = "red">MyISAM避免死锁：</font>**   

* 在自动加锁的情况下，MyISAM 总是一次获得 SQL 语句所需要的全部锁，所以 MyISAM 表不会出现死锁。  

**<font color = "red">InnoDB避免死锁：</font>**   

* 为了在单个InnoDB表上执行多个并发写入操作时避免死锁，可以在事务开始时通过为预期要修改的每个元祖（行）使用SELECT ... FOR UPDATE语句来获取必要的锁，即使这些行的更改语句是在之后才执行的。  
* 在事务中，如果要更新记录，应该直接申请足够级别的锁，即排他锁，而不应先申请共享锁、更新时再申请排他锁，因为这时候当用户再申请排他锁时，其他事务可能又已经获得了相同记录的共享锁，从而造成锁冲突，甚至死锁  
* 如果事务需要修改或锁定多个表，则应在每个事务中以相同的顺序使用加锁语句。在应用中，如果不同的程序会并发存取多个表，应尽量约定以相同的顺序来访问表，这样可以大大降低产生死锁的机会  
* 通过SELECT ... LOCK IN SHARE MODE获取行的读锁后，如果当前事务再需要对该记录进行更新操作，则很有可能造成死锁。  
* 改变事务隔离级别  

---
**<font color = "lime">如果出现死锁</font>** ，<font color = "lime">可以用 show engine innodb status;命令来确定最后一个死锁产生的原因。</font>返回结果中包括死锁相关事务的详细信息，如引发死锁的SQL语句，事务已经获得的锁，正在等待什么锁，以及被回滚的事务等。据此可以分析死锁产生的原因和改进措施。  

**<font color = "lime">死锁的解决方案：</font>**   
1. 首先在程序的设计上，当发现程序有高并发的访问某一个表时，尽量对该表的执行操作串行化，或者锁升级，一次性获取所有的锁资源。  

        编码中，insert、delete、update这些操作，独占锁占用事务时间过长，是会锁表的。  
        解决方案：操作要进行拆分，重整数据库策略，比如限制处理1000条。删除操作，删除数据的速度和创建的索引数量是成正比的。所以在超大型数据库中，删除时处理好索引关系非常重要。推荐的折中方法：在删除数据之前删除表中索引，然后删除其中无用数据，删除完成后重新创建索引。  
        
        死锁的避免
        1. 顺序访问
        2. 数据排序
        3. 申请足够级别的锁
        4. 避免没有where条件的操作
        5. 大事务分解成小事务
        6. 使用等值查询而不是范围查询
         
2. 然后也可以在服务器上设置参数innodb_lock_wait_timeout(超时时间)，并且将参数innodb_deadlock_detect 打开，当发现死锁的时候，自动回滚其中的某一个事务。  

### 1.6.2. 死锁情况  
<!-- 

常见的表死锁情况及解决方法
https://www.cnblogs.com/jeffry/p/6014881.html
-->
&emsp; 常见的表死锁情况及解决方法  
1. 死锁的第一种情况 
    &emsp; 一个用户A 访问表A(锁住了表A),然后又访问表B；另一个用户B 访问表B(锁住了表B)，然后企图访问表A；这时用户A由于用户B已经锁住表B，它必须等待用户B释放表B才能继续，同样用户B要等用户A释放表A才能继续，这就死锁就产生了。  
    &emsp; 解决方法  
    &emsp; 这种死锁比较常见，是由于程序的BUG产生的，除了调整的程序的逻辑没有其它的办法。仔细分析程序的逻辑，对于数据库的多表操作时，尽量按照相同的顺序进行处理，尽量避免同时锁定两个资源，如操作A和B两张表时，总是按先A后B的顺序处理， 必须同时锁定两个资源时，要保证在任何时刻都应该按照相同的顺序来锁定资源。  
2. 死锁的第二种情况
    &emsp; 用户A查询一条纪录，然后修改该条纪录；这时用户B修改该条纪录，这时用户A的事务里锁的性质由查询的共享锁企图上升到独占锁，而用户B里的独占锁由于A有共享锁存在所以必须等A释放掉共享锁，而A由于B的独占锁而无法上升的独占锁也就不可能释放共享锁，于是出现了死锁。这种死锁比较隐蔽，但在稍大点的项目中经常发生。如在某项目中，页面上的按钮点击后，没有使按钮立刻失效，使得用户会多次快速点击同一按钮，这样同一段代码对数据库同一条记录进行多次操作，很容易就出现这种死锁的情况。  
    &emsp; 解决方法  
    1. 对于按钮等控件，点击后使其立刻失效，不让用户重复点击，避免对同时对同一条记录操作。  
    2. 使用乐观锁进行控制。乐观锁大多是基于数据版本（Version）记录机制实现。即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个“version”字段来实现。读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。乐观锁机制避免了长事务中的数据库加锁开销（用户A和用户B操作过程中，都没有对数据库数据加锁），大大提升了大并发量下的系统整体性能表现。  
    &emsp; 在其数据访问引擎中内置了乐观锁实现。需要注意的是，由于乐观锁机制是在系统中实现，来自外部系统的用户更新操作不受我们系统的控制，因此可能会造成脏数据被更新到数据库中。
    3. 使用悲观锁进行控制。悲观锁大多数情况下依靠数据库的锁机制实现，如Oracle的Select … for update语句，以保证操作最大程度的独占性。但随之而来的就是数据库性能的大量开销，特别是对长事务而言，这样的开销往往无法承受。如一个金融系统，当某个操作员读取用户的数据，并在读出的用户数据的基础上进行修改时（如更改用户账户余额），如果采用悲观锁机制，也就意味着整个操作过程中（从操作员读出数据、开始修改直至提交修改结果的全过程，甚至还包括操作员中途去煮咖啡的时间），数据库记录始终处于加锁状态，可以想见，如果面对成百上千个并发，这样的情况将导致灾难性的后果。所以，采用悲观锁进行控制时一定要考虑清楚。
3. 死锁的第三种情况
    &emsp; 如果在事务中执行了一条不满足条件的update语句，则执行全表扫描，把行级锁上升为表级锁，多个这样的事务执行后，就很容易产生死锁和阻塞。类似的情况还有当表中的数据量非常庞大而索引建的过少或不合适的时候，使得经常发生全表扫描，最终应用系统会越来越慢，最终发生阻塞或死锁。
    &emsp; 解决方法
    &emsp; SQL语句中不要使用太复杂的关联多表的查询；使用“执行计划”对SQL语句进行分析，对于有全表扫描的SQL语句，建立相应的索引进行优化。

## 1.7. 生产问题-死锁解决
<!--
~~ 
MySQL死锁如何处理？ 
https://mp.weixin.qq.com/s/1mO8q-RJrxx1OTtM8dR4Ng
~~
-->
### 1.7.1. 前提  
&emsp; 笔者负责的一个系统最近有新功能上线后突然在预警模块不定时报出MySQL死锁导致事务回滚。幸亏，上游系统采用了异步推送和同步查询结合的方式，感知到推送失败及时进行了补偿。  

### 1.7.2. 死锁场景复现  
&emsp; 首先，MySQL的服务端版本是5.7(小版本可以基本忽略)，使用了InnoDB。有一张用户数据表的schema设计如下（无关字段已经屏蔽掉）：  

```sql
CREATE TABLE `t_user_data`
(
    id      BIGINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,
    user_id BIGINT UNSIGNED NOT NULL COMMENT '用户ID',
    data_id VARCHAR(50)     NOT NULL COMMENT '数据ID',
    INDEX idx_user_id (user_id),
    INDEX idx_data_id (data_id)
) COMMENT '用户数据表';
```

&emsp; 业务代码中发生死锁的伪代码如下：  

```java
process_method(dataId,userDataDtoList){
    start transaction:
    userDataDao.deleteByDataId(dataId);
    for dto in userDataDtoList:
        UserData userData = convert(dto);
        userDataDao.insert(dto);
    commit;
}
```

&emsp; 这里的逻辑是，如果已经存在对应dataId的数据要先进行删除，然后写入新的用户数据。  
&emsp; 尝试用两个Session提交两个事务重现死锁问题：  

|时间序列|Tx-Session-1|Tx-Session-2|
|---|---|---|
|T1	START TRANSACTION;| |	
|T2	| |START TRANSACTION;|
|T3	|DELETE FROM t_user_data WHERE data_id = ‘xxxxx’;|  |	
|T4	| |DELETE FROM t_user_data WHERE data_id = ‘yyyyy’;|
|T5	|INSERT INTO t_user_data(USER_ID, DATA_ID) VALUES (1, ‘xxxxx’);	| |
|T6	| |INSERT INTO t_user_data(USER_ID, DATA_ID) VALUES (2, ‘yyyyy’);|
|T7	| |Deadlock found when trying to get lock; try restarting transaction(Rollback)|
|T8	|COMMIT;|	|

&emsp; 这里会出现两个现象：  

1. Tx-Session-2会话T4执行完毕之后，Tx-Session-1会话T5执行的时候，Tx-Session-1会话客户端会处于阻塞状态。
2. Tx-Session-2会话T6执行完毕之后，MySQL提示死锁事务被回滚，此时，Tx-Session-1会话客户端会解除阻塞。


### 1.7.3. 导致死锁的原因  
&emsp; 直接排查InnoDB的死锁日志：  

    mysql> show engine innodb status;

&emsp; 输出的死锁日志如下：  

```text
------------------------
LATEST DETECTED DEADLOCK
------------------------
2019-05-11 19:16:04 0x5804
*** (1) TRANSACTION:
TRANSACTION 3882, ACTIVE 13 sec inserting
mysql tables in use 1, locked 1
LOCK WAIT 3 lock struct(s), heap size 1136, 2 row lock(s), undo log entries 1
MySQL thread id 32, OS thread handle 9876, query id 358 localhost ::1 doge update
INSERT INTO t_user_data(USER_ID, DATA_ID) VALUES (1, 'xxxxx')
*** (1) WAITING FOR THIS LOCK TO BE GRANTED:
RECORD LOCKS space id 33 page no 6 n bits 72 index idx_data_id of table `test`.`t_user_data` trx id 3882 lock_mode X insert intention waiting
Record lock, heap no 1 PHYSICAL RECORD: n_fields 1; compact format; info bits 0
 0: len 8; hex 73757072656d756d; asc supremum;;

*** (2) TRANSACTION:
TRANSACTION 3883, ACTIVE 9 sec inserting, thread declared inside InnoDB 5000
mysql tables in use 1, locked 1
3 lock struct(s), heap size 1136, 2 row lock(s), undo log entries 1
MySQL thread id 11, OS thread handle 22532, query id 359 localhost ::1 doge update
INSERT INTO t_user_data(USER_ID, DATA_ID) VALUES (2, 'yyyyy')
*** (2) HOLDS THE LOCK(S):
RECORD LOCKS space id 33 page no 6 n bits 72 index idx_data_id of table `test`.`t_user_data` trx id 3883 lock_mode X
Record lock, heap no 1 PHYSICAL RECORD: n_fields 1; compact format; info bits 0
 0: len 8; hex 73757072656d756d; asc supremum;;

*** (2) WAITING FOR THIS LOCK TO BE GRANTED:
RECORD LOCKS space id 33 page no 6 n bits 72 index idx_data_id of table `test`.`t_user_data` trx id 3883 lock_mode X insert intention waiting
Record lock, heap no 1 PHYSICAL RECORD: n_fields 1; compact format; info bits 0
 0: len 8; hex 73757072656d756d; asc supremum;;

*** WE ROLL BACK TRANSACTION (2)
```

&emsp; 这里要参考MySQL关于InnoDB锁的关于next-key锁描述那一节，注意死锁日志关键字supremum的意义：  

    next-key锁将gap锁定在索引中最大值之上，而supremum伪记录的值高于索引中实际的任何值。supremum不是真正的索引记录，因此，实际上，此next-key锁仅锁定最大索引值之后的间隙。  

&emsp; <font color = "red">两个事务的锁属性可以通过select * from information_schema.innodb_locks;进行查询，</font>数据如下表：  

|lock_id	|lock_tx_id	|lock_mode	|lock_type	|lock_table	|lock_index	|lock_space|lock_page|lock_rec|lock_data|
|---|---|---|---|---|---|---|---|---|---|
|3882:33:6:1	|3882|	X|	RECORD|	test.t_user_data|	idx_data_id	|33|	6	|1|	supremum pseudo-record|
|3883:33:6:1	3883	|X	|RECORD	|test.t_user_data	|idx_data_id	|33	|6	|1	|supremum pseudo-record|

    DELETE FROM t_user_data WHERE data_id = '不存在的索引值';   

&emsp; 上面的SQL执行时候，如果条件刚好是索引列，并且查询的值是当前表(索引)中不存在的数据，根据next-key锁的描述和死锁日志中的asc supremum关键字，执行该DELETE语句的时候，会锁定目标值和高于目标值的任何值，如果条件是"xxxxx"，那么相当于锁定区间为(“xxxxx”,最大上界]。  

&emsp; next-key锁是索引记录上的记录锁(Record Lock)和索引记录之前的间隙上的间隙锁(Gap Lock)定的组合。间隙锁有两个特点：  
1. 两个事务即使锁定的区间一致（或者有部分重合），不会影响它们之间获取到锁（可以参考行锁的兼容性矩阵）。  
2. 间隙锁G会阻止非持有G的其他事务向锁定的区间中插入数据，以避免产生冲突数据。  

&emsp; 分析到这里，就很好解释上面出现死锁的执行时序：  
1. 两个事务的DELETE语句都可以正确执行，这个时候，两者的间隙锁锁定的区域分别是(‘xxxxx’,最大上界]和(‘yyyyy’,最大上界]。
2. 事务1执行INSERT语句的时候阻塞，是因为事务2的间隙锁不允许事务1插入索引值’xxxxx’。
3. 事务2执行INSERT语句的时候阻塞，是因为事务1的间隙锁不允许事务1插入索引值’yyyyy’，执行到这一步，MySQL的死锁检查模块应该起效了，因为两个事务依赖的锁资源已经成环(或者成有向图)。
4. 事务2的优先级比较低，于是抛出死锁异常并且被回滚了。  

### 1.7.4. 解决方案  
&emsp; 参考MySQL的文档，解决方案有两个：  

1. 方案一：降低数据库的事务隔离级别，需要降低到READ COMMITED，这样子可以关闭间隙锁的扫描。（<== 并不推荐这种做法，修改事务隔离级别有可能出现新的问题）
2. 方案二：针对对应的原因修改业务代码。

&emsp; 这里方案二只需要把伪代码逻辑修改如下：  

```java
process_method(dataId,userDataDtoList){
    List<UserData> userDataList = userDataDao.selectByDataId(dataId);
    start transaction:
    if userDataList is not empty: 
       List<Long> ids = collectIdList(userDataList);
       userDataDao.deleteByIds(ids);       
    for dto in userDataDtoList:
        UserData userData = convert(dto);
        userDataDao.insert(dto);
    commit;
}
```

&emsp; 就是先根据dataId进行查询，如果存在数据，聚合主键列表，通过主键列表进行删除，然后再进行数据插入。  

### 1.7.5. 小结  
&emsp; InnoDB提供的死锁日志其实并没有提供完整的事务提交的SQL，所以对于复杂的场景需要细致结合代码和死锁日志进行排查，很多时候对应的代码逻辑是多处的。这里列举一下处理死锁问题的一些步骤：  
1. 及时止损，如果可以回滚导致死锁的代码，那么最好果敢地回滚；如果重试可以解决问题并且出现死锁问题的规模不大，可以尝试短时间内进行问题排查。  
2. 通过业务系统日志迅速定位到发生死锁的代码块，JVM应用一般底层是依赖JDBC，出现死锁的时候会抛出一个SQLException的子类，异常栈的信息中带有"Deadlock"字样。  
3. 分析InnoDB的死锁日志，一般会列出竞争锁的多个事务的相对详细的信息，这些信息是排查死锁问题的第一手资料。  
4. 修复问题上线后注意做好监控和预警，确定问题彻底解决。

