

<!-- TOC -->

- [1. MySql的锁](#1-mysql的锁)
    - [1.1. 数据库锁简介](#11-数据库锁简介)
    - [1.2. 锁的粒度](#12-锁的粒度)
    - [1.3. 锁的类别](#13-锁的类别)
        - [1.3.1. MyISAM存储引擎](#131-myisam存储引擎)
        - [1.3.2. InnoDB存储引擎](#132-innodb存储引擎)
            - [1.3.2.1. 共享/排它锁（行级锁）](#1321-共享排它锁行级锁)
            - [1.3.2.2. 意向锁(表级锁)](#1322-意向锁表级锁)
            - [1.3.2.3. 记录锁(Record Locks) ，锁定记录](#1323-记录锁record-locks-锁定记录)
            - [1.3.2.4. 间隙锁（Gap Lock），锁定范围](#1324-间隙锁gap-lock锁定范围)
            - [1.3.2.5. 临键锁(Next-key Locks) ，锁定范围加记录](#1325-临键锁next-key-locks-锁定范围加记录)
            - [1.3.2.6. 插入意向锁](#1326-插入意向锁)
            - [1.3.2.7. 自增锁](#1327-自增锁)
    - [1.4. 锁使用方式：乐观锁、悲观锁](#14-锁使用方式乐观锁悲观锁)
    - [1.5. 死锁](#15-死锁)
        - [1.5.1. 死锁简介](#151-死锁简介)
        - [1.5.2. 死锁案例](#152-死锁案例)

<!-- /TOC -->

![image](https://gitee.com/wt1814/pic-host/raw/master/images/SQL/sql-58.png)  

# 1. MySql的锁  
## 1.1. 数据库锁简介  

&emsp; **~~存储引擎与锁~~：**  

* InnoDB：对于UPDATE、DELETE、INSERT语句，InnoDB会自动给涉及数据集加排他锁（X)。  
* MyISAM：MyISAM在执行查询语句SELECT前，会自动给涉及的所有表加读锁，在执行更新操作（UPDATE、DELETE、INSERT等）前，会自动给涉及的表加写锁，这个过程并不需要用户干预。  

&emsp; **事务和锁的关联：**  
1. 事务与锁是不同的。事务具有ACID（原子性、一致性、隔离性和持久性），<font color = "red">锁是用于解决隔离性的一种机制。</font>  
2. <font color = "red">事务的隔离级别通过锁的机制来实现。</font>另外锁有不同的粒度，同时事务也是有不同的隔离级别的。  
3. 开启事务就自动加锁。  

&emsp; **锁的分类：**  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/SQL/sql-42.png)  

* 按使用方式：乐观锁、悲观锁。  
* 锁类别：有共享锁（读锁）和排他锁（写锁）。锁类别取决于存储引擎执行的sql语句。  
    ![image](https://gitee.com/wt1814/pic-host/raw/master/images/SQL/sql-47.png)  
* 按粒度：锁的粒度的不同可以分为表锁、页锁、行锁。  

---
---
---
## 1.2. 锁的粒度  

* 页锁  
&emsp; 页级锁定是MySQL中比较独特的一种锁定级别，在其他数据库管理软件中也并不是太常见。页级锁定的特点是锁定粒度介于行级锁定与表级锁之间，所以获取锁定所需要的资源开销，以及所能提供的并发处理能力也同样是介于上面二者之间。另外，页级锁定和行级锁定一样，会发生死锁。  
&emsp; 在数据库实现资源锁定的过程中，随着锁定资源颗粒度的减小，锁定相同数据量的数据所需要消耗的内存数量是越来越多的，实现算法也会越来越复杂。不过，随着锁定资源颗粒度的减小，应用程序的访问请求遇到锁等待的可能性也会随之降低，系统整体并发度也随之提升。  
&emsp; 使用页级锁定的主要是BerkeleyDB存储引擎。  

* 表锁  
&emsp; 特点：对整张表加锁。开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。  
&emsp; 存储引擎的支持：使用表级锁定的主要是MyISAM，MEMORY，CSV等一些非事务性存储引擎。  
&emsp; 如何加表锁？MyISAM在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁，在执行更新操作（UPDATE、DELETE、INSERT等）前，会自动给涉及的表加写锁。这个过程并不需要用户干预，因此，用户一般不需要直接用LOCK TABLE命令给MyISAM表显式加锁。  

* 行锁  
&emsp; 行级锁：对某行记录加锁。开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。  
&emsp; 使用行级锁定的主要是InnoDB存储引擎。  
&emsp; **适用场景：** 从锁的角度来说，表级锁更适合于以查询为主，只有少量按索引条件更新数据的应用，如Web应用。而行级锁则更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用，如一些在线事务处理（OLTP）系统。  

        InnoDB 的行锁是怎么实现的？  
        InnoDB 行锁是通过索引上的索引项来实现的。意味者：只有通过索引条件检索数据，InnoDB 才会使用行级锁，否则，InnoDB将使用表锁！  
        对于主键索引：直接锁住锁住主键索引即可。  
        对于普通索引：先锁住普通索引，接着锁住主键索引，这是因为一张表的索引可能存在多个，通过主键索引才能确保锁是唯一的，不然如果同时有2个事务对同1条数据的不同索引分别加锁，那就可能存在2个事务同时操作一条数据了。  

&emsp; 不同的存储引擎支持的锁粒度是不一样的。  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/SQL/sql-43.png)  
&emsp; **<font color = "red">InnoDB实现了行级锁，页级锁，表级锁。InnoDB只有通过索引条件检索数据才使用行级锁，否则，InnoDB将使用表锁。即InnoDB的行锁是基于索引的！</font><font color = "lime">这些锁的粒度之间也是会发生升级的，锁升级的意思就是将当前锁的粒度降低，数据库可以把一个表的1000个行锁升级为一个页锁，或者将页锁升级为表锁。</font>**  
&emsp; MyISAM只支持表锁！  

## 1.3. 锁的类别  
### 1.3.1. MyISAM存储引擎  
&emsp; MyISAM存储引擎只支持表级锁定。  
&emsp; <font color = "red">MyISAM在执行查询语句（select）前，会自动给涉及的所有表加读锁，在执行增删改操作前，会自动给涉及的表加写锁。读锁和写锁是互斥的，读写操作是串行。在表读锁和表写锁的环境下：读读不阻塞，读写阻塞，写写阻塞！</font>  

* 读读不阻塞：当前用户在读数据，其他的用户也在读数据，不会加锁！  
* 读写阻塞：当前用户在读数据，其他的用户不能修改当前用户读的数据，会加锁！  
* 写写阻塞：当前用户在修改数据，其他的用户不能修改当前用户正在修改的数据，会加锁！  

![image](https://gitee.com/wt1814/pic-host/raw/master/images/SQL/sql-48.png)  

&emsp; <font color = "red">默认情况下，写锁比读锁具有更高的优先级：当一个锁释放时，这个锁会优先给写锁队列中等候的获取锁请求，然后再给读锁队列中等候的获取锁请求。</font>


### 1.3.2. InnoDB存储引擎  
<!-- 
https://mp.weixin.qq.com/s/y7Jo67stdbakETo2UV1ivg
http://blog.itpub.net/31556440/viewspace-2642668/
-->
&emsp; InnoDB共有七种类型的锁：  

* 共享/排它锁(Shared and Exclusive Locks)  
* 意向锁(Intention Locks)  
* 记录锁(Record Locks)  
* 间隙锁(Gap Locks)  
* 临键锁(Next-key Locks)  
* 插入意向锁(Insert Intention Locks)  
* 自增锁(Auto-inc Locks)  

&emsp; InnoDB存储引擎的锁的算法有三种  
1. Record lock：单个行记录上的锁  
2. Gap lock：间隙锁，锁定一个范围，不包括记录本身  
3. Next-key lock：record+gap 锁定一个范围，包含记录本身  

#### 1.3.2.1. 共享/排它锁（行级锁）  
&emsp; InnoDB 存储引擎行锁，当数据查询时针对索引数据进行时，会使用行级锁。  

* 共享锁（S）：当一个事务读取一条记录的时候，不会阻塞其他事务对同一记录的读请求，但会阻塞对其的写请求。当读锁释放后，才会执行其他事务的写操作。例如：select … lock in share mode  
* 排他锁（X）：当一个事务对一条记录进行写操作时，会阻塞其他事务对同一表的读写操作，当该锁释放后，才会执行其他事务的读写操作。例如：select … for update  

&emsp;在高并发的情况下，多个事务同时请求更新数据，由于资源被占用等待事务增多。  
&emsp;如此，会造成性能问题，可以通过innodb_lock_wait_timeout 来解决。innodb_lock_wait_timeout 是事务等待获取资源的最长时间，单位为秒。如果超过时间还未分配到资源，则会返回应用失败。  

#### 1.3.2.2. 意向锁(表级锁)  
&emsp; InnoDB 存储引擎表锁：当没有对数据表中的索引数据进行查询时，会执行表锁操作。采用两种意向锁（Intention Locks)。  

* 意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前，必须先取得该表的 IS 锁。  
* 意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前，必须先取得该表的 IX 锁。  

&emsp; 意向共享锁和意向排他锁是数据库主动加的，不需要手动处理。对于 UPDATE、DELETE 和 INSERT 语句，InnoDB 会自动给数据集加排他锁。  

&emsp; 行级锁和表级锁的兼容情况：  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/SQL/sql-49.png)  
<center>共享锁，排他锁，意向共享锁，意向排他锁兼容图例</center>    
&emsp; 如果一个事务请求的锁模式与当前的锁兼容， InnoDB 就将请求的锁授予该事务；反之， 如果两者不兼容，该事务就要等待锁释放。  

---

#### 1.3.2.3. 记录锁(Record Locks) ，锁定记录 
![image](https://gitee.com/wt1814/pic-host/raw/master/images/SQL/sql-124.png)  

&emsp; <font color = "red">record lock 是一个在索引行记录的锁。</font>  
&emsp; 比如，SELECT c1 FROM t WHERE c1 = 10 FOR UPDATE，如果c1 上的索引被使用到。防止任何其他事务变动 c1 = 10 的行。  
&emsp; record lock 总是会在索引行上加锁。即使一个表并没有设置任何索引，这种时候 innoDB 会创建一个隐式的聚集索引（primary Key）,然后在这个聚集索引上加锁。  
&emsp; 当查询字段没有索引时，比如 update table set columnA="A" where columnB=“B".如果 columnB 字段不存在索引（或者不是组合索引前缀），这条语句会锁住所有记录也就是锁表。如果语句的执行能够执行一个 columnB 字段的索引，那么仅会锁住满足 where 的行(RecordLock)。  

#### 1.3.2.4. 间隙锁（Gap Lock），锁定范围  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/SQL/sql-123.png)  

&emsp; **<font color = "red">当使用范围条件（> 、< 、between......）检索数据，InnoDB会给符合条件的已有数据记录的索引项加锁。对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)”，InnoDB也会对这个“间隙”加锁，这就是间隙锁。</font>**  
&emsp; **<font color = "red">InnoDB 除了通过范围条件加锁时使用间隙锁外，如果使用相等条件请求给一个不存在的记录加锁，InnoDB 也会使用间隙锁。</font>**  

&emsp; 假如emp表中只有101条记录，其empid的值分别是1,2,...,100,101，下面的 SQL：  

```sql
select * from emp where empid > 100 for update;
```  
&emsp; 这是一个范围条件的检索，InnoDB 不仅会对符合条件的empid值为101的记录加锁，也会对empid大于101（这些记录并不存在）的“间隙”加锁。  

&emsp; **<font color = "lime">InnoDB 使用间隙锁的目的：</font>**  
&emsp; 一方面是为了防止幻读。对于上例，如果不使用间隙锁，其他事务插入了 empid大于 100的任何记录，本事务再次执行 select 语句，就会发生幻读。  
&emsp; 另一方面，也是为了满足恢复和复制的需要。    

&emsp; **<font color = "red">InnoDB使用间隙锁的危害：</font>**  
&emsp; 因为执行SELECT语句中，如果通过范围查找的话，间隙锁会锁定整个范围内所有的索引键值，即使这个键值并不存在。这个就是间隙锁最致命的缺点，就是当锁定一个范围键值之后，即使某些不存在的键值也会被无辜的锁定，而造成在锁定的时候无法插入锁定值范围内的任何数据，在某些场景下这可能会针对性造成很大的危害。  

&emsp; **<font color = "red">间隙锁和行锁合称临键锁（Next-Key锁）。</font>**  

#### 1.3.2.5. 临键锁(Next-key Locks) ，锁定范围加记录 
![image](https://gitee.com/wt1814/pic-host/raw/master/images/SQL/sql-122.png)  

&emsp; 临键锁，是记录锁与间隙锁的组合，它的封锁范围，既包含索引记录，又包含索引区间。  
&emsp; <font color = "red">默认情况下，innodb使用next-key locks来锁定记录。</font><font color = "lime">但当查询的索引含有唯一属性的时候，Next-Key Lock 会进行优化，将其降级为Record Lock，即仅锁住索引本身，不是范围。</font>  

---

#### 1.3.2.6. 插入意向锁  
&emsp; 对已有数据行的修改与删除，必须加强互斥锁(X锁)，那么对于数据的插入，是否还需要加这么强的锁，来实施互斥呢？插入意向锁，孕育而生。  
&emsp; 插入意向锁，是间隙锁(Gap Locks)的一种（所以，也是实施在索引上的），它是专门针对insert操作的。多个事务，在同一个索引，同一个范围区间插入记录时，如果插入的位置不冲突，不会阻塞彼此。  

#### 1.3.2.7. 自增锁  
&emsp; 自增锁是一种特殊的表级别锁（table-level lock），专门针对事务插入AUTO_INCREMENT类型的列。最简单的情况，如果一个事务正在往表中插入记录，所有其他事务的插入必须等待，以便第一个事务插入的行，是连续的主键值。  

## 1.4. 锁使用方式：乐观锁、悲观锁  
&emsp; 乐观锁是一种思想，具体实现是，表中有一个版本字段，第一次读的时候，获取到这个字段。处理完业务逻辑开始更新的时候，需要再次查看该字段的值是否和第一次的一样。如果一样更新，反之拒绝。之所以叫乐观，因为这个模式没有从数据库加锁，等到更新的时候再判断是否可以更新。  
&emsp; 悲观锁是数据库层面加锁，都会阻塞去等待锁。  

    乐观锁：更新时带上版本号（cas更新）  
    悲观锁：使用共享锁和排它锁，select...lock in share mode，select…for update。  

## 1.5. 死锁  
&emsp; **<font color = "lime">一句话总结：</font>**  
&emsp; **<font color = "lime">1. MySql如何处理死锁？1). 发起死锁检测，主动回滚其中一条事务，让其他事务继续执行。2). 设置超时时间，超时后自动释放。</font>**   
&emsp; **<font color = "lime">2. 如果出现死锁？除了以上两种方案外，开发人员还需要检查代码。</font>**

### 1.5.1. 死锁简介
&emsp; 死锁发生了如何解决，MySQL 有没有提供什么机制去解决死锁。
  
---
**<font color = "red">死锁产生：</font>**  

* 死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环。  
* 当事务试图以不同的顺序锁定资源时，就可能产生死锁。多个事务同时锁定同一个资源时也可能会产生死锁。  
* 锁的行为和顺序和存储引擎相关。以同样的顺序执行语句，有些存储引擎会产生死锁有些不会——死锁有双重原因：真正的数据冲突；存储引擎的实现方式。  

---
**<font color = "red">检测死锁</font>** ：数据库系统实现了各种死锁检测和死锁超时的机制。InnoDB存储引擎能检测到死锁的循环依赖并立即返回一个错误。  

**<font color = "red">死锁恢复</font>** ：死锁发生以后，只有部分或完全回滚其中一个事务，才能打破死锁，InnoDB目前处理死锁的方法是，将持有最少行级排他锁的事务进行回滚。所以事务型应用程序在设计时必须考虑如何处理死锁，多数情况下只需要重新执行因死锁回滚的事务即可。  

**<font color = "red">外部锁的死锁检测</font>** ：发生死锁后，InnoDB 一般都能自动检测到，并使一个事务释放锁并回退，另一个事务获得锁，继续完成事务。但在涉及外部锁，或涉及表锁的情况下，InnoDB 并不能完全自动检测到死锁， 这需要通过设置锁等待超时参数 innodb_lock_wait_timeout 来解决。  

---
**<font color = "red">死锁影响性能</font>** ：死锁会影响性能而不是会产生严重错误，因为InnoDB会自动检测死锁状况并回滚其中一个受影响的事务。在高并发系统上，当许多线程等待同一个锁时，死锁检测可能导致速度变慢。有时当发生死锁时，禁用死锁检测（使用innodb_deadlock_detect配置选项）可能会更有效，这时可以依赖innodb_lock_wait_timeout设置进行事务回滚。  

---
**<font color = "red">MyISAM避免死锁：</font>**   

* 在自动加锁的情况下，MyISAM 总是一次获得 SQL 语句所需要的全部锁，所以 MyISAM 表不会出现死锁。  

**<font color = "red">InnoDB避免死锁：</font>**   

* 为了在单个InnoDB表上执行多个并发写入操作时避免死锁，可以在事务开始时通过为预期要修改的每个元祖（行）使用SELECT ... FOR UPDATE语句来获取必要的锁，即使这些行的更改语句是在之后才执行的。  
* 在事务中，如果要更新记录，应该直接申请足够级别的锁，即排他锁，而不应先申请共享锁、更新时再申请排他锁，因为这时候当用户再申请排他锁时，其他事务可能又已经获得了相同记录的共享锁，从而造成锁冲突，甚至死锁  
* 如果事务需要修改或锁定多个表，则应在每个事务中以相同的顺序使用加锁语句。在应用中，如果不同的程序会并发存取多个表，应尽量约定以相同的顺序来访问表，这样可以大大降低产生死锁的机会  
* 通过SELECT ... LOCK IN SHARE MODE获取行的读锁后，如果当前事务再需要对该记录进行更新操作，则很有可能造成死锁。  
* 改变事务隔离级别  

---
**<font color = "lime">如果出现死锁</font>** ，可以用 show engine innodb status;命令来确定最后一个死锁产生的原因。返回结果中包括死锁相关事务的详细信息，如引发死锁的SQL语句，事务已经获得的锁，正在等待什么锁，以及被回滚的事务等。据此可以分析死锁产生的原因和改进措施。  

**<font color = "lime">死锁的解决方案：</font>**   
1. 首先在程序的设计上，当发现程序有高并发的访问某一个表时，尽量对该表的执行操作串行化，或者锁升级，一次性获取所有的锁资源。  

        编码中，insert、delete、update这些操作，独占锁占用事务时间过长，是会锁表的。  
        解决方案：操作要进行拆分，重整数据库策略，比如限制处理1000条。删除操作，删除数据的速度和创建的索引数量是成正比的。所以在超大型数据库中，删除时处理好索引关系非常重要。推荐的折中方法：在删除数据之前删除表中索引，然后删除其中无用数据，删除完成后重新创建索引。  
        
        死锁的避免
        1. 顺序访问
        2. 数据排序
        3. 申请足够级别的锁
        4. 避免没有where条件的操作
        5. 大事务分解成小事务
        6. 使用等值查询而不是范围查询
         

2. 然后也可以在服务器上设置参数innodb_lock_wait_timeout(超时时间)，并且将参数innodb_deadlock_detect 打开，当发现死锁的时候，自动回滚其中的某一个事务。  

### 1.5.2. 死锁案例  
<!-- 
MySQL死锁如何处理？ 
https://mp.weixin.qq.com/s/1mO8q-RJrxx1OTtM8dR4Ng
-->

