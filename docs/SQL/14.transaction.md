

<!-- TOC -->

- [1. MySql的事务](#1-mysql的事务)
    - [1.1. 事务简介](#11-事务简介)
    - [1.2. 事务的状态](#12-事务的状态)
    - [1.3. 并发事务处理带来的问题](#13-并发事务处理带来的问题)
    - [1.4. 事务的隔离级别](#14-事务的隔离级别)
    - [1.5. Innodb事务实现原理](#15-innodb事务实现原理)
        - [1.5.1. 原子性的实现](#151-原子性的实现)
        - [1.5.2. 持久性的实现](#152-持久性的实现)
        - [1.5.3. 隔离性（事务的隔离级别）的实现](#153-隔离性事务的隔离级别的实现)
        - [1.5.4. 一致性的实现](#154-一致性的实现)
    - [1.6. 事务SQL语句](#16-事务sql语句)

<!-- /TOC -->

![image](https://gitee.com/wt1814/pic-host/raw/master/images/SQL/sql-57.png)  

# 1. MySql的事务  
&emsp; MySql的事务基于InnoDB存储引擎讲解。  

## 1.1. 事务简介  
&emsp; 事务的定义：事务是逻辑上的一组操作，要么都执行，要么都不执行。  
&emsp; **事务的四大特性(ACID)：**  

* 原子性(Atomicity)：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；  
* 一致性(Consistency)：执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；  
* 隔离性(Isolation）：并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；  
* 持久性(Durability）：一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。  

## 1.2. 事务的状态  
&emsp; 根据事务所处的不同阶段，事务大致可以分为以下5个状态：  
1. 活动的（active） 当事务对应的数据库操作正在执行过程中，则该事务处于活动状态。  
2. 部分提交的（partially committed） 当事务中的最后一个操作执行完成，但还未将变更刷新到磁盘时，则该事务处于部分提交状态。  
3. 失败的（failed） 当事务处于活动或者部分提交状态时，由于某些错误导致事务无法继续执行，则事务处于失败状态。  
4. 中止的（aborted） 当事务处于失败状态，且回滚操作执行完毕，数据恢复到事务执行之前的状态时，则该事务处于中止状态。  
5. 提交的（committed） 当事务处于部分提交状态，并且将修改过的数据都同步到磁盘之后，此时该事务处于提交状态。  

![image](https://gitee.com/wt1814/pic-host/raw/master/images/SQL/sql-126.png)  


## 1.3. 并发事务处理带来的问题  
&emsp; 多事务的并发进行一般会造成以下几个问题： 

* <font color = "red">脏读（Dirty read）: （一个事务读了另一个事务未提交的数据。）</font>  
&emsp; 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。  
* <font color = "red">丢失修改（Lost to modify）: （一个事务覆盖了另一个事务的数据。）</font>  
&emsp; 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。例如：事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失。  
* <font color = "red">不可重复读（Unrepeatableread）: （一个事务多次读，另一事务中间修改了数据。）</font>  
&emsp; 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。  
* <font color = "red">幻读（Phantom read）: （一个事务多次读，另一事务中间新增了数据。）</font>  
&emsp; 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。  

        不可重复度和幻读区别：  
        不可重复读的重点是修改：在同一事务中，同样的条件，第一次读的数据和第二次读的数据不一样。（因为中间有其他事务提交了修改）
        幻读的重点在于新增或者删除：在同一事务中，同样的条件，第一次和第二次读出来的记录数不一样。（因为中间有其他事务提交了插入/删除） 

<!-- 
&emsp; 并发事务处理带来的问题的解决办法：  

* “更新丢失”通常是应该完全避免的。但防止更新丢失，并不能单靠数据库事务控制器来解决，需要应用程序对要更新的数据加必要的锁来解决，因此，防止更新丢失应该是应用的责任。
* “脏读” 、 “不可重复读”和“幻读” ，其实都是数据库读一致性问题，必须由数据库提供一定的事务隔离机制来解决：
    * 一种是加锁：在读取数据前，对其加锁，阻止其他事务对数据进行修改。
    * 另一种是数据多版本并发控制（MultiVersion Concurrency Control，简称 MVCC 或 MCC），也称为多版本数据库：不用加任何锁， 通过一定机制生成一个数据请求时间点的一致性数据快照 （Snapshot)， 并用这个快照来提供一定级别 （语句级或事务级） 的一致性读取。从用户的角度来看，好象是数据库可以提供同一数据的多个版本。
-->

## 1.4. 事务的隔离级别  
&emsp; MySQL的事务隔离级别解决并发事务问题。数据库的事务隔离越严格，并发副作用越小，但付出的代价也就越大。这是因为事务隔离实质上是将事务在一定程度上"串行"进行，这显然与"并发"是矛盾的。  
&emsp; SQL标准定义了四个隔离级别：  

* READ-UNCOMMITTED(读取未提交)：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。  
* READ-COMMITTED(读取已提交)：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。  
* REPEATABLE-READ(可重复读)：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<font color = "red">可以阻止脏读和不可重复读，但幻读仍有可能发生</font>。  
* SERIALIZABLE(可串行化)：最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。  

|隔离级别 |读数据一致性 |脏读|不可重复读|幻读|
|---|---|---|---|---|
|未提交读(Read uncommitted)	|最低级别|是|是|是|
|已提交读(Read committed)|语句级|否 |是	|是|
|可重复读(Repeatable read)|事务级 |否 |否 |是|
|可序列化(Serializable) |最高级别，事务级|否|否 |否| 

&emsp; **<font color = "lime">以上是SQL-92标准中定义的四种隔离级别。在MySQL中，默认的隔离级别是REPEATABLE-READ（可重复读），并且解决了幻读问题。</font>** 简单的来说，mysql的默认隔离级别解决了脏读、幻读、不可重复读问题。  

&emsp; RR和RC区别：  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/SQL/sql-121.png)  


## 1.5. Innodb事务实现原理  
<!-- 
面试官：你说熟悉MySQL事务，那来谈谈事务的实现原理吧！ 
https://mp.weixin.qq.com/s/jrfZr3YzE_E0l3KjWAz1aQ
https://mp.weixin.qq.com/s/9VQYgYvM7KCr-8BQpxtaEA

https://blog.csdn.net/IT_townlet/article/details/104402035
 
-->
&emsp; 实现事务采取了哪些技术以及思想？  

* 原子性：使用[事务日志](/docs/SQL/log.md)undo log，从而达到回滚；  
* 持久性：使用事务日志redo log，从而达到故障后恢复；  
* 隔离性：使用[锁](/docs/SQL/15.lock.md)以及[MVCC](/docs/SQL/MVCC.md)，运用的优化思想有读写分离，读读并行，读写并行；  
* 一致性：通过回滚，以及恢复，和在并发环境下的隔离做到一致性。  

&emsp; 原子性，持久性，隔离性的目的也是为了保障数据的一致性！  
&emsp; 总之，ACID只是个概念，事务最终目的是要保障数据的可靠性，一致性。  

### 1.5.1. 原子性的实现  
&emsp; 利用Innodb的undo log。undo log名为回滚日志，是实现原子性的关键，当事务回滚时能够撤销所有已经成功执行的sql语句，它需要记录要回滚的相应日志信息。例如：  

* 当delete一条数据的时候，就需要记录这条数据的信息，回滚的时候，insert这条旧数据  
* 当update一条数据的时候，就需要记录之前的旧值，回滚的时候，根据旧值执行update操作  
* 当insert一条数据的时候，就需要这条记录的主键，回滚的时候，根据主键执行delete操作  

&emsp; undo log记录了这些回滚需要的信息，当事务执行失败或调用了rollback，导致事务需要回滚，便可以利用undo log中的信息将数据回滚到修改之前的样子。  

### 1.5.2. 持久性的实现  
&emsp; 利用Innodb的redo log。当做数据修改的时候，不仅在内存中操作，还会在redo log中记录这次操作。<font color = "red">当事务提交的时候，会将redo log日志进行刷盘(redo log一部分在内存中，一部分在磁盘上)。</font><font color = "lime">当数据库宕机重启的时候，会将redo log中的内容恢复到数据库中，再根据undo log和binlog内容决定回滚数据还是提交数据。</font>  

&emsp; 采用redo log的好处？其实好处就是将redo log进行刷盘比对数据页刷盘效率高，具体表现如下  

* redo log体积小，毕竟只记录了哪一页修改了啥，因此体积小，刷盘快。
* redo log是一直往末尾进行追加，属于顺序IO。效率显然比随机IO来的快。

### 1.5.3. 隔离性（事务的隔离级别）的实现  
&emsp; 隔离性（事务的隔离级别）的实现，利用的是锁和MVCC机制。  

&emsp; **<font color = "lime">RR可重复读是怎么解决幻读的？</font>**  
&emsp; 幻读：在一个事务中使用相同的 SQL 两次读取，第二次读取到了其他事务新插入的行，则称为发生了幻读。  
&emsp; 例如：  
1. 事务1第一次查询：select * from user where id < 10 时查到了 id = 1 的数据；  
2. 事务2插入了 id = 2 的数据；  
3. 事务1使用同样的语句第二次查询时，查到了 id = 1、id = 2 的数据，出现了幻读。  

&emsp; 谈到幻读，首先要引入“当前读”和“快照读”的概念：  
* 快照读：生成一个事务快照（ReadView），之后都从这个快照获取数据。普通 select 语句就是快照读。  
* 当前读：读取数据的最新版本。常见的 update/insert/delete、还有 select ... for update、select ... lock in share mode 都是当前读。  

&emsp; <font color = "lime">对于快照读，MVCC因为从ReadView读取，所以必然不会看到新插入的行，所以天然就解决了幻读的问题。</font>  
&emsp; <font color = "lime">而对于当前读的幻读，MVCC是无法解决的。需要使用 Gap Lock 或 Next-Key Lock（Gap Lock + Record Lock）来解决。</font>  
&emsp; 其实原理也很简单，用上面的例子稍微修改下以触发当前读：select * from user where id < 10 for update，当使用了Gap Lock时，Gap锁会锁住id < 10 的整个范围，因此其他事务无法插入id < 10 的数据，从而防止了幻读。  

<!-- 
&emsp; 可重复读是怎么实现的？  
&emsp; (1)<font color = "red">利用[间隙锁](/docs/SQL/15.lock.md)，防止幻读的出现，保证了可重复读</font>  
&emsp; 幻读的问题存在是因为新增或者更新操作，这时如果进行范围查询的时候（加锁查询），会出现不一致的问题，这时使用不同的行锁已经没有办法满足要求，需要对一定范围内的数据进行加锁。  
&emsp; (2)MVCC的快照生成时机不同  
&emsp; 在可重复读这个隔离级别下，遇到事务中的第一个SELECT请求才创建read view，因此是无法读到其他事务提交的更改。而在读已提交这个隔离级别下，每个SELECT都会获取最新的read view，因此能读到其他事务提交的数据。 
-->

### 1.5.4. 一致性的实现  
&emsp; Mysql怎么保证一致性的？这个问题分为两个层面来说。  
&emsp; 从数据库层面，数据库通过原子性、隔离性、持久性来保证一致性。也就是说ACID四大特性之中，C(一致性)是目的，A(原子性)、I(隔离性)、D(持久性)是手段，是为了保证一致性，数据库提供的手段。数据库必须要实现AID三大特性，才有可能实现一致性。例如，原子性无法保证，显然一致性也无法保证。  
&emsp; 从应用层面，通过代码判断数据库数据是否有效，然后决定回滚还是提交数据！如果在事务里故意写出违反约束的代码，一致性还是无法保证的。

## 1.6. 事务SQL语句  
......
