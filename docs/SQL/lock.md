

<!-- TOC -->

- [1. MySql的锁](#1-mysql的锁)
    - [1.1. 数据库锁简介](#11-数据库锁简介)
    - [1.2. 锁的粒度](#12-锁的粒度)
    - [1.3. 锁的类别](#13-锁的类别)
        - [1.3.1. MyISAM存储引擎](#131-myisam存储引擎)
        - [1.3.2. InnoDB存储引擎](#132-innodb存储引擎)
            - [1.3.2.1. 共享/排它锁(行级锁)](#1321-共享排它锁行级锁)
            - [1.3.2.2. 意向锁(表级锁)](#1322-意向锁表级锁)
            - [1.3.2.3. 记录锁(Record Locks) ，锁定记录](#1323-记录锁record-locks-锁定记录)
            - [1.3.2.4. 间隙锁(Gap Lock)，锁定范围](#1324-间隙锁gap-lock锁定范围)
            - [1.3.2.5. 临键锁(Next-key Locks) ，锁定范围加记录](#1325-临键锁next-key-locks-锁定范围加记录)
            - [1.3.2.6. 插入意向锁](#1326-插入意向锁)
            - [1.3.2.7. 自增锁](#1327-自增锁)
    - [1.4. 锁使用方式：乐观锁、悲观锁](#14-锁使用方式乐观锁悲观锁)

<!-- /TOC -->

&emsp; **<font color = "red">总结：</font>**  
1. 数据库锁  
    &emsp; **锁的分类：**  
    ![image](http://182.92.69.8:8081/img/SQL/sql-42.png)  

    * 按使用方式：乐观锁、悲观锁。  
    * 锁类别：有共享锁(读锁)和排他锁(写锁)。锁类别取决于存储引擎执行的sql语句。  
        ![image](http://182.92.69.8:8081/img/SQL/sql-47.png)  
    * 按粒度：锁的粒度的不同可以分为表锁、页锁、行锁。  
2. InnoDB共有七种类型的锁：共享/排它锁、意向锁、记录锁（Record lock）、间隙锁（Gap lock）、临键锁（Next-key lock）、插入意向锁、自增锁。  
3. **<font color = "red">InnoDB存储引擎的锁的算法有三种：</font>**  
    1. Record lock：单个行记录上的锁。  
    2. Gap lock：间隙锁，锁定一个范围，不包括记录本身。  
    &emsp; **<font color = "red">当使用范围条件（> 、< 、between...）检索数据，InnoDB会给符合条件的已有数据记录的索引项加锁。对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP）”，InnoDB也会对这个“间隙”加锁，这就是间隙锁。</font>**  
    &emsp; **<font color = "red">InnoDB除了通过范围条件加锁时使用间隙锁外，如果使用相等条件请求给一个不存在的记录加锁，InnoDB 也会使用间隙锁。</font>**  
    3. Next-key lock：record+gap锁定一个范围，包含记录本身。  
    &emsp; 临键锁，是记录锁与间隙锁的组合，它的封锁范围，既包含索引记录，又包含索引区间。  
    &emsp; <font color = "red">默认情况下，innodb使用next-key locks来锁定记录。</font><font color = "clime">但当查询的索引含有唯一属性的时候，Next-Key Lock会进行优化，将其降级为Record Lock，即仅锁住索引本身，不是范围。</font>  
4. 锁使用方式：乐观锁、悲观锁  
&emsp; 乐观锁，开发自定义；悲观锁，Mysql内置。   


# 1. MySql的锁  
<!-- 
隔离级别与锁的关系
在Read Uncommitted级别下，读取数据不需要加共享锁，这样就不会跟被修改的数据上的排他锁冲突

在Read Committed级别下，读操作需要加共享锁，但是在语句执行完以后释放共享锁。

在Repeatable Read级别下，读操作需要加共享锁，但是在事务提交之前并不释放共享锁，也就是必须等待事务执行完毕以后才释放共享锁。

SERIALIZABLE 是限制性最强的隔离级别，因为该级别锁定整个范围的键，并一直持有锁，直到事务完成。
-->

## 1.1. 数据库锁简介  
&emsp; **存储引擎与锁：**  

* **<font color = "clime">InnoDB：对于UPDATE、DELETE、INSERT语句，InnoDB会自动给涉及数据集加排他锁(X)。</font>**  
* MyISAM：MyISAM在执行查询语句SELECT前，会自动给涉及的所有表加读锁，在执行更新操作(UPDATE、DELETE、INSERT)前，会自动给涉及的表加写锁，这个过程并不需要用户干预。  

&emsp; **事务和锁的关联：**  
1. 事务与锁是不同的。事务具有ACID（原子性、一致性、隔离性和持久性），<font color = "red">锁是用于解决隔离性的一种机制。</font>  
2. <font color = "red">事务的隔离级别通过锁的机制来实现。</font>另外锁有不同的粒度，同时事务也是有不同的隔离级别的。  
3. 开启事务就自动加锁。  

&emsp; **锁的分类：**  
![image](http://182.92.69.8:8081/img/SQL/sql-42.png)  

* 按使用方式：乐观锁、悲观锁。  
* 锁类别：有共享锁(读锁)和排他锁(写锁)。锁类别取决于存储引擎执行的sql语句。  
    ![image](http://182.92.69.8:8081/img/SQL/sql-47.png)  
* 按粒度：锁的粒度的不同可以分为表锁、页锁、行锁。  

---

## 1.2. 锁的粒度  

* 页锁  
&emsp; 页级锁定是MySQL中比较独特的一种锁定级别，在其他数据库管理软件中也并不是太常见。页级锁定的特点是锁定粒度介于行级锁定与表级锁之间，所以获取锁定所需要的资源开销，以及所能提供的并发处理能力也同样是介于上面二者之间。另外，页级锁定和行级锁定一样，会发生死锁。  
&emsp; 在数据库实现资源锁定的过程中，随着锁定资源颗粒度的减小，锁定相同数据量的数据所需要消耗的内存数量是越来越多的，实现算法也会越来越复杂。不过，随着锁定资源颗粒度的减小，应用程序的访问请求遇到锁等待的可能性也会随之降低，系统整体并发度也随之提升。  
&emsp; 使用页级锁定的主要是BerkeleyDB存储引擎。  

* 表锁  
&emsp; 特点：对整张表加锁。开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。  
&emsp; 存储引擎的支持：使用表级锁定的主要是MyISAM，MEMORY，CSV等一些非事务性存储引擎。  
&emsp; 如何加表锁？MyISAM在执行查询语句(SELECT)前，会自动给涉及的所有表加读锁，在执行更新操作(UPDATE、DELETE、INSERT等)前，会自动给涉及的表加写锁。这个过程并不需要用户干预，因此，用户一般不需要直接用LOCK TABLE命令给MyISAM表显式加锁。  

* 行锁  
&emsp; 行级锁：对某行记录加锁。开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。  
&emsp; 使用行级锁定的主要是InnoDB存储引擎。  
&emsp; **适用场景：**从锁的角度来说，表级锁更适合于以查询为主，只有少量按索引条件更新数据的应用，如Web应用。而行级锁则更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用，如一些在线事务处理(OLTP)系统。  

        InnoDB的行锁是怎么实现的？  
        InnoDB 行锁是通过索引上的索引项来实现的。意味者：只有通过索引条件检索数据，InnoDB 才会使用行级锁，否则，InnoDB将使用表锁！  
        对于主键索引：直接锁住锁住主键索引即可。  
        对于普通索引：先锁住普通索引，接着锁住主键索引，这是因为一张表的索引可能存在多个，通过主键索引才能确保锁是唯一的，不然如果同时有2个事务对同1条数据的不同索引分别加锁，那就可能存在2个事务同时操作一条数据了。  

&emsp; 不同的存储引擎支持的锁粒度是不一样的。  
![image](http://182.92.69.8:8081/img/SQL/sql-43.png)  
&emsp; **<font color = "red">InnoDB实现了行级锁，页级锁，表级锁。InnoDB只有通过索引条件检索数据才使用行级锁，否则，InnoDB将使用表锁。即InnoDB的行锁是基于索引的！</font><font color = "clime">这些锁的粒度之间也是会发生升级的，锁升级的意思就是将当前锁的粒度降低，数据库可以把一个表的1000个行锁升级为一个页锁，或者将页锁升级为表锁。</font>**  
&emsp; MyISAM只支持表锁！  

## 1.3. 锁的类别  
<!-- 
如何加锁？
mysql InnoDB引擎默认的修改数据语句：update,delete,insert都会自动给涉及到的数据加上排他锁，select语句默认不会加任何锁类型，如果加排他锁可以使用select …for update语句，加共享锁可以使用select … lock in share mode语句。所以加过排他锁的数据行在其他事务种是不能修改数据的，也不能通过for update和lock in share mode锁的方式查询数据，但可以直接通过select …from…查询数据，因为普通查询没有任何锁机制。
-->

### 1.3.1. MyISAM存储引擎  
&emsp; MyISAM存储引擎只支持表级锁定。  
&emsp; <font color = "red">MyISAM在执行查询语句(select)前，会自动给涉及的所有表加读锁，在执行增删改操作前，会自动给涉及的表加写锁。读锁和写锁是互斥的，读写操作是串行。在表读锁和表写锁的环境下：读读不阻塞，读写阻塞，写写阻塞！</font>  

* 读读不阻塞：当前用户在读数据，其他的用户也在读数据，不会加锁！  
* 读写阻塞：当前用户在读数据，其他的用户不能修改当前用户读的数据，会加锁！  
* 写写阻塞：当前用户在修改数据，其他的用户不能修改当前用户正在修改的数据，会加锁！  

![image](http://182.92.69.8:8081/img/SQL/sql-48.png)  

&emsp; <font color = "red">默认情况下，写锁比读锁具有更高的优先级：当一个锁释放时，这个锁会优先给写锁队列中等候的获取锁请求，然后再给读锁队列中等候的获取锁请求。</font>

### 1.3.2. InnoDB存储引擎  
&emsp; InnoDB共有七种类型的锁：  

* 共享/排它锁(Shared and Exclusive Locks)  
* 意向锁(Intention Locks)  
* 记录锁(Record Locks)  
* 间隙锁(Gap Locks)  
* 临键锁(Next-key Locks)  
* 插入意向锁(Insert Intention Locks)  
* 自增锁(Auto-inc Locks)  

&emsp; **<font color = "red">InnoDB存储引擎的锁的算法有三种</font>**  
1. Record lock：单个行记录上的锁。  
2. Gap lock：间隙锁，锁定一个范围，不包括记录本身。  
3. Next-key lock：record+gap锁定一个范围，包含记录本身。  

#### 1.3.2.1. 共享/排它锁(行级锁)  
&emsp; InnoDB 存储引擎行锁，当数据查询时针对索引数据进行时，会使用行级锁。  

* 共享锁(S)：当一个事务读取一条记录的时候，不会阻塞其他事务对同一记录的读请求，但会阻塞对其的写请求。当读锁释放后，才会执行其他事务的写操作。例如：select … lock in share mode  
* 排他锁(X)：当一个事务对一条记录进行写操作时，会阻塞其他事务对同一表的读写操作，当该锁释放后，才会执行其他事务的读写操作。例如：select … for update  

&emsp;在高并发的情况下，多个事务同时请求更新数据，由于资源被占用等待事务增多。  
&emsp;如此，会造成性能问题，可以通过innodb_lock_wait_timeout 来解决。innodb_lock_wait_timeout 是事务等待获取资源的最长时间，单位为秒。如果超过时间还未分配到资源，则会返回应用失败。  

#### 1.3.2.2. 意向锁(表级锁)  
&emsp; InnoDB 存储引擎表锁：当没有对数据表中的索引数据进行查询时，会执行表锁操作。采用两种意向锁(Intention Locks)。  

* 意向共享锁(IS)：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前，必须先取得该表的 IS 锁。  
* 意向排他锁(IX)：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前，必须先取得该表的 IX 锁。  

&emsp; 意向共享锁和意向排他锁是数据库主动加的，不需要手动处理。对于 UPDATE、DELETE 和 INSERT 语句，InnoDB 会自动给数据集加排他锁。  

&emsp; 行级锁和表级锁的兼容情况：  
![image](http://182.92.69.8:8081/img/SQL/sql-49.png)  
<center>共享锁，排他锁，意向共享锁，意向排他锁兼容图例</center>    
&emsp; 如果一个事务请求的锁模式与当前的锁兼容， InnoDB 就将请求的锁授予该事务；反之， 如果两者不兼容，该事务就要等待锁释放。  

---

#### 1.3.2.3. 记录锁(Record Locks) ，锁定记录 
![image](http://182.92.69.8:8081/img/SQL/sql-124.png)  
&emsp; <font color = "red">record lock 是一个在索引行记录的锁。</font>  
&emsp; 比如，SELECT c1 FROM t WHERE c1 = 10 FOR UPDATE，如果c1上的索引被使用到。防止任何其他事务变动 c1 = 10 的行。  
&emsp; record lock总是会在索引行上加锁。即使一个表并没有设置任何索引，这种时候 innoDB 会创建一个隐式的聚集索引(primary Key)，然后在这个聚集索引上加锁。  
&emsp; 当查询字段没有索引时，比如 update table set columnA="A" where columnB=“B"，如果columnB字段不存在索引(或者不是组合索引前缀)，这条语句会锁住所有记录也就是锁表。如果语句的执行能够执行一个columnB字段的索引，那么仅会锁住满足where的行(RecordLock)。  

#### 1.3.2.4. 间隙锁(Gap Lock)，锁定范围  
![image](http://182.92.69.8:8081/img/SQL/sql-123.png)  

&emsp; **<font color = "red">当使用范围条件(> 、< 、between......)检索数据，InnoDB会给符合条件的已有数据记录的索引项加锁。对于键值在条件范围内但并不存在的记录，叫做“间隙(GAP)”，InnoDB也会对这个“间隙”加锁，这就是间隙锁。</font>**  
&emsp; **<font color = "red">InnoDB除了通过范围条件加锁时使用间隙锁外，如果使用相等条件请求给一个不存在的记录加锁，InnoDB 也会使用间隙锁。</font>**  

&emsp; 假如emp表中只有101条记录，其empid的值分别是1,2,...,100,101，下面的 SQL：  

```sql
select * from emp where empid > 100 for update;
```  
&emsp; 这是一个范围条件的检索，InnoDB 不仅会对符合条件的empid值为101的记录加锁，也会对empid大于101(这些记录并不存在)的“间隙”加锁。  

&emsp; **<font color = "clime">InnoDB 使用间隙锁的目的：</font>**  
&emsp; 一方面是为了防止幻读。对于上例，如果不使用间隙锁，其他事务插入了empid大于100的任何记录，本事务再次执行 select 语句，就会发生幻读。  
&emsp; 另一方面，也是为了满足恢复和复制的需要。    

&emsp; **<font color = "red">InnoDB使用间隙锁的危害：</font>**  
&emsp; 因为执行SELECT语句中，如果通过范围查找的话，间隙锁会锁定整个范围内所有的索引键值，即使这个键值并不存在。这个就是间隙锁最致命的缺点，就是当锁定一个范围键值之后，即使某些不存在的键值也会被无辜的锁定，而造成在锁定的时候无法插入锁定值范围内的任何数据，在某些场景下这可能会针对性造成很大的危害。  

&emsp; **<font color = "red">间隙锁和行锁合称临键锁(Next-Key锁)。</font>**  

#### 1.3.2.5. 临键锁(Next-key Locks) ，锁定范围加记录 
![image](http://182.92.69.8:8081/img/SQL/sql-122.png)  

&emsp; 临键锁，是记录锁与间隙锁的组合，它的封锁范围，既包含索引记录，又包含索引区间。  
&emsp; <font color = "red">默认情况下，innodb使用next-key locks来锁定记录。</font><font color = "clime">但当查询的索引含有唯一属性的时候，Next-Key Lock会进行优化，将其降级为Record Lock，即仅锁住索引本身，不是范围。</font>  

---

#### 1.3.2.6. 插入意向锁  
&emsp; 对已有数据行的修改与删除，必须加强互斥锁(X锁)，那么对于数据的插入，是否还需要加这么强的锁，来实施互斥呢？插入意向锁，孕育而生。  
&emsp; 插入意向锁，是间隙锁(Gap Locks)的一种(所以，也是实施在索引上的)，它是专门针对insert操作的。多个事务，在同一个索引，同一个范围区间插入记录时，如果插入的位置不冲突，不会阻塞彼此。  

#### 1.3.2.7. 自增锁  
&emsp; 自增锁是一种特殊的表级别锁(table-level lock)，专门针对事务插入AUTO_INCREMENT类型的列。最简单的情况，如果一个事务正在往表中插入记录，所有其他事务的插入必须等待，以便第一个事务插入的行，是连续的主键值。  

## 1.4. 锁使用方式：乐观锁、悲观锁  
<!--

Mysql的乐观锁和悲观锁 
https://www.cnblogs.com/lucky815/p/15244794.html
https://blog.csdn.net/qq_37469055/article/details/117791459

-->

&emsp; 乐观锁是一种思想，具体实现是，表中有一个版本字段，第一次读的时候，获取到这个字段。处理完业务逻辑开始更新的时候，需要再次查看该字段的值是否和第一次的一样。如果一样更新，反之拒绝。之所以叫乐观，因为这个模式没有从数据库加锁，等到更新的时候再判断是否可以更新。  
&emsp; 悲观锁是数据库层面加锁，都会阻塞去等待锁。  

    乐观锁：更新时带上版本号(cas更新)  
    悲观锁：使用共享锁和排它锁，select...lock in share mode，select…for update。  
