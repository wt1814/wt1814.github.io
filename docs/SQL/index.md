
<!-- TOC -->

- [1. Sql索引优化](#1-sql索引优化)
    - [1.1. 索引简介](#11-索引简介)
    - [1.2. 创建索引的几种方式](#12-创建索引的几种方式)
    - [1.3. ★★★索引使用](#13-★★★索引使用)
        - [1.3.1. 创建索引原则](#131-创建索引原则)
        - [1.3.2. 索引失效](#132-索引失效)
    - [1.4. ★★★索引条件下推(ICP)](#14-★★★索引条件下推icp)
        - [1.4.1. 概念](#141-概念)
        - [1.4.2. 示例分析](#142-示例分析)
        - [1.4.3. ★★★示例二](#143-★★★示例二)
    - [1.5. 索引维护](#15-索引维护)

<!-- /TOC -->

&emsp; **<font color = "red">总结：</font>**  
1. 创建索引：为了使索引的使用效率更高，在创建索引时，必须考虑在哪些字段上创建索引和创建什么类型的索引。  
    * 多表连接的字段、where条件字段、分组字段、排序字段、联合UNION字段、去重distinct字段上建立索引。  
    * 尽量选择区分度高的列作为索引。  
    * ...  
2. 索引失效：进行null值运算、进行运算、隐式转换、对索引列使用函数 导致索引失效，进行模糊查询like时可能使索引失效(以%开头)，不满足联合索引最左前缀匹配原则。    
3. 【索引条件】下推：  
&emsp; 理解索引条件下推：1. 【什么是索引条件？】 2. 什么是下推？  
&emsp; 索引下推简而言之就是在复合索引由于某些条件（比如 like %aa）失效的情况下，当存在失效的过滤字段在索引覆盖范围内，使用比较的方式在不回表的情况下进一步缩小查询的范围。其实就是对索引失效的进一步修复。  
&emsp; **<font color = "clime">~~MySQL 5.6 引入了「索引下推优化」，可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。~~</font>**  
    * 关闭ICP：索引--->回表--->条件过滤。  
    * 开启ICP：索引--->条件过滤--->回表。</font>在支持ICP后，`MySQL在取出索引数据的同时，判断是否可以进行where条件过滤，`<font color = "blue">将where的部分过滤操作放在存储引擎层提前过滤掉不必要的数据，</font>减少了不必要数据被扫描带来的IO开销。  


# 1. Sql索引优化  
<!-- 
*****Mysql：好好的索引，为什么要下推？ 
https://mp.weixin.qq.com/s/6Q87MzhVI-rRMQ-E9IOPiw
索引下推
https://mp.weixin.qq.com/s/QAfxurLy2W1xIkQshjmYSw

-->

## 1.1. 索引简介  
&emsp; 索引(Index)是帮助MySQL高效获取数据的数据结构。  
&emsp; **创建索引的优势：**  

* 提高数据的检索速度，降低数据库IO成本：使用索引的意义就是通过缩小表中需要查询的记录的数目，从而加快搜索的速度。  
* 降低数据排序的成本，降低CPU消耗：索引之所以查的快，是因为先将数据排好序，若该字段正好需要排序，则会降低排序的成本。  

&emsp; **创建索引的劣势：**  

* 占用存储空间：索引实际上也是一张表，记录了主键与索引字段，一般以索引文件的形式存储在磁盘上。  
* 降低更新表的速度：表的数据发生了变化，对应的索引也需要一起变更，从而减低的更新速度。否则索引指向的物理数据可能不对，这也是索引失效的原因之一。  
* 优质索引创建难：索引的创建并非一日之功，也并非一直不变。需要频繁根据用户的行为和具体的业务逻辑去创建最佳的索引。  

&emsp; **索引的分类：**  
<!-- 
https://mp.weixin.qq.com/s/N6chmfcxnm6a3pOQYWAcbA
-->
* 从存储结构角度：BTree索引(B-Tree或B+Tree索引)，Hash索引，full-index全文索引，R-Tree索引。这里所描述的是索引存储时保存的形式。  
* 从物理存储角度：根据数据的物理顺序与键值的逻辑(索引)顺序关系，有聚集索引、非聚集索引。  
* 从逻辑角度：索引类型有主键索引、唯一索引、普通索引、复合索引、全文索引。    

    * 主键和唯一索引  
    &emsp; 主键保证数据库里面的每一行都是唯一的。  
    &emsp; 唯一索引的作用跟主键的作用一样。  
    &emsp; 不同的是，在一张表里面只能有一个主键，主键不能为空，唯一索引可以有多个，唯一索引可以有一条记录为空。
    * 普通索引和唯一索引  
    &emsp; 普通索引可以重复，唯一索引和主键一样不能重复。     

    * 全文(Fulltext)：针对比较大的数据，比如存放的是消息内容，有几KB的数据的这种情况，如果要解决like查询效率低的问题，可以创建全文索引。只有文本类型 的字段才可以创建全文索引，比如char、varchar、text。  

<!-- 
1.主键索引: 数据列不允许重复，不允许为NULL，一个表只能有一个主键。
2.唯一索引: 数据列不允许重复，允许为NULL值，一个表允许多个列创建唯一索引。
可以通过 ALTER TABLE table_name ADD UNIQUE (column); 创建普通索引。
可以通过 ALTER TABLE table_name ADD UNIQUE (column1,column2)， 创建唯一组合索引。
3.普通索引: 基本的索引类型，没有唯一性的限制，允许为NULL值。
可以通过ALTER TABLE table_name ADD INDEX index_name (column)，创建普通索引。
可以通过ALTER TABLE table_name ADD INDEX index_name(column1, column2, column3)，创建组合索引。
4.全文索引：是目前搜索引擎使用的一种关键技术。
可以通过ALTER TABLE table_name ADD FULLTEXT (column)，创建全文索引。
-->

## 1.2. 创建索引的几种方式  
&emsp; ...
<!-- 
https://mp.weixin.qq.com/s/Mvl3OURNurdrJ2o9OyM6KQ
-->


## 1.3. ★★★索引使用
### 1.3.1. 创建索引原则  
&emsp; **<font color = "clime">为了使索引的使用效率更高，在创建索引时，必须考虑在哪些字段上创建索引和创建什么类型的索引。</font>**  

&emsp; **创建索引的位置：**  

* 在去重distinct字段上建立索引；  
* 多表连接的字段上需要建立索引；  
* where条件字段上需要建立索引；  
&emsp; 注：=和in可以乱序。比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会优化成索引可以识别的形式。  
* 分组字段上需要建立索引；  
* 排序字段上需要建立索引；  
&emsp; 利用索引进行排序操作是非常快的，而且可以利用同一索引同时进行查找和排序操作。当索引的顺序与ORDER BY中的列顺序相同且所有的列是同一方向(全部升序或者全部降序)时，可以使用索引来排序，如果查询是连接多个表，仅当ORDER BY中的所有列都是第一个表的列时才会使用索引，其它情况都会使用filesort。  
* 在联合UNION字段上建立索引；  
<br/>  

&emsp; **建立索引的字段：**  

* <font color = "red">尽量选择区分度高的列作为索引</font>  
&emsp; 区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，比例越大，扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就 是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段要求是0.1以上，即平均1条扫描10条 记录 
* 尽量使用前缀来索引  
&emsp; 如果索引字段的值很长，最好使用值的前缀来索引。例如，TEXT和BLOG类型的字段，进行全文检索会很浪费时间。如果只检索字段的前面的若干个字符，这样可以提高检索速度。  
* 使用基于函数的索引  
&emsp; 任何对列的操作都可能导致全表扫描，例如：`select * from emp where substr(ename,1,2)=’SM’；`但是这种查询在客服系统又经常使用。可以创建一个带有substr函数的基于函数的索引，`create index emp_ename_substr on eemp (substr(ename,1,2));`这样在执行上面的查询语句时，会使用基于函数的索引。  
* 根据业务场景建立<font color = "red">覆盖索引</font>  
&emsp; 覆盖索引(covering index)指一个查询语句的执行只用从索引中就能够取得，不必从数据表中读取。也可以称之为实现了索引覆盖。  
&emsp; 当一条查询语句符合覆盖索引条件时，MySQL只需要通过索引就可以返回查询所需要的数据，这样避免了查到索引后再返回表操作，减少I/O提高效率。  
* 更新频繁字段不适合创建索引。
<br/>  
* 限制索引的数目  
&emsp; 索引的数目不是越多越好。每个索引都需要占用磁盘空间，索引越多，需要的磁盘空间就越大。修改表时，对索引的重构和更新很麻烦。越多的索引，会使更新表变得很浪费时间。  
* 尽量使用数据量少的索引  
&emsp; 如果索引的值很长，那么查询的速度会受到影响。例如，对一个CHAR(100)类型的字段进行全文检索需要的时间肯定要比对CHAR(10)类型的字段需要的时间要多。  
* 删除不再使用或者很少使用的索引  
&emsp; 表中的数据被大量更新，或者数据的使用方式被改变后，原有的一些索引可能不再需要。数据库管理员应当定期找出这些索引，将它们删除，从而减少索引对更新操作的影响。  
<br/>   
* 根据需要建立多列联合索引：  
    &emsp; **联合索引最左前缀匹配原则：**  
    &emsp; mysql查询时索引会一直向右匹配，直到遇到范围查询(>、<、between、like)就停止匹配。mysql从左到右的使用索引中的字段，一个查询可以只使用索引中的一部份，但只能是最左侧部分。例如索引是key index(a,b,c)。可以支持 a|a,b|a,b,c 3种组合进行查找，但不支持b，c进行查找。当最左侧字段是常量引用时，索引就十分有效。  

    &emsp; **<font color = "red">WHERE+ 多个字段ORDER BY，满足最左前缀。</font>**  
    &emsp; `SELECT * FROM [table] WHERE uid=1 ORDER x,y LIMIT 0,10;` 建立索引(uid,x,y)实现order by的优化,比建立(x,y,uid)索引效果要好得多。  
    
    &emsp; <font color = "red">联合索引，选择区分度较高的字段在前列。</font>  

    &emsp; **单列索引和联合索引的选择：**  
    1. 联合索引的几个字段是否经常同时以AND方式出现在Where子句中？单字段查询是否极少甚至没有？假如是，则可以建立联合索引；否则考虑单字段索引；  
    &emsp; 当出现多个索引做相交操作时(多个AND条件)，通常来说一个包含所有相关列的索引要优于多个独立索引。  
    2. 假如联合索引中包含的字段经常单独出现在where子句中，则分解为多个单字段索引；  
    &emsp; 当出现多个索引做联合操作时(多个OR条件)，对结果集的合并、排序等操作需要耗费大量的CPU和内存资源，特别是当其中的某些索引的选择性不高，需要返回合并大量数据时，查询成本更高。所以这种情况下还不如走全表扫描。  
    &emsp; 因此explain时如果发现有索引合并(Extra字段出现Using union)，应该好好检查一下查询和表结构是不是已经是最优的，如果查询和表都没有问题，那只能说明索引建的非常糟糕，应当慎重考虑索引是否合适，有可能一个包含所有相关列的多列索引更适合。  
    3. 假如联合索引所包含的字段超过3个，那么仔细考虑其必要性，考虑减少联合的字段；  
    4. 假如既有单字段索引，又有这几个字段上的联合索引，一般可以删除联合索引；  


### 1.3.2. 索引失效  
1. 联合索引最左前缀匹配原则。  
2. 对索引列进行null值运算。  
&emsp; 索引无法存储null值。B-tree索引is null不会走，is not null会走。  
3. 对索引列进行运算导致索引失效。  
&emsp; 逻辑运算(NOT、OR)；比较运算(=、<>、!=、>、>=、!>、<、<=、!<)、all，some，many关键字；范围查询in，exist关键字、like关键字。  
&emsp; <font color = "red">用or分割条件，若or前后只要有一个列没有索引，就都不会用索引。</font>  
4. 对索引进行模糊查询like时可能使索引失效(以%开头)。  
&emsp; 前导模糊查询不能利用索引(like '%XX'或者like '%XX%')。假如有这样一列code的值为'AAA','AAB','BAA','BAB'，如果where code like '%AB'条件，由于条件首字母是是模糊%的，所以不能利用索引的顺序，必须一个个去查询。这样会导致全索引扫描或者全表扫描。如果是这样的条件where code like 'A % '，就可以查找CODE中A开头的CODE的位置，当碰到B开头的数据时，就可以停止查找了，因为后面的数据一定不满足要求。这样就可以利用索引了。  
&emsp; 解决办法：可采用在建立索引时用reverse(columnName)这种方法处理。  
5. 隐式转换导致索引失效。 **<font color = "clime">⚠️注：包含类型转换和字符集转换。</font>**    
&emsp; 由于表的字段tu_mdn定义为varchar2(20)，但在查询时把该字段作为number类型以where条件传给sql语句，这样会导致索引失效。  
&emsp; 错误的例子：`select * from test where tu_mdn=13333333333;`  
&emsp; 正确的例子：`select * from test where tu_mdn='13333333333';` 
6. 对索引列使用函数导致索引失效。  
&emsp; 对于这样情况应当创建基于函数的索引。  
&emsp; 错误的例子：select * from test where round(id)=10; 此时id的索引已经不起作用了。  
&emsp; 正确的例子：首先建立函数索引，`create index test_id_fbi_idx on test(round(id));`然后 `select * from test where round(id)=10;` 这时函数索引起作用了。

<!-- 
字符编码，原来是SQL不走索引的元凶之一！ 
https://mp.weixin.qq.com/s/xIdglQdGvgeDHdGCb5KUpg
-->

## 1.4. ★★★索引条件下推(ICP)  
<!--
神奇的 SQL 之 ICP → 索引条件下推 
https://mp.weixin.qq.com/s/nxxblJJY2W6ryCGoqOh0XQ
神奇的 SQL 之 ICP → 索引条件下推 
https://mp.weixin.qq.com/s/8e8rz6FFSSNIJLNmh_MoLQ
https://mp.weixin.qq.com/s/ygvuP35B_sJAlBHuuEJhfg
-->
### 1.4.1. 概念
&emsp; MySQL5.6引入了索引条件下推优化(Index Condition Pushdown，ICP)，默认开启。官方文档： https://dev.mysql.com/doc/refman/5.7/en/index-condition-pushdown-optimization.html 。  

    理解索引条件下推：1. 【什么是索引条件？】 2. 什么是下推？ 

&emsp; 索引条件下推是针对MySQL使用索引从表中检索行的情况进行的优化。在没有ICP的情况下，存储引擎遍历索引以定位基表中的行，并将它们返回给MySQL服务器，后者评估这些行的WHERE条件。 **<font color = "red">如果启用了ICP，并且【只使用索引中的列来计算WHERE条件的一部分】，MySQL服务器会将WHERE条件的这一部分向下推送到存储引擎。</font><font color = "clime">然后，存储引擎通过使用索引项来评估推式索引条件，并且只有满足此条件时，才会从表中读取行。ICP可以减少存储引擎必须访问基表的次数以及MySQL服务器必须访问存储引擎的次数。</font>**   

&emsp; **<font color = "red">索引下推简而言之就是在复合索引由于某些条件（比如 like %aa）失效的情况下，当存在失效的过滤字段在索引覆盖范围内，使用比较的方式在不回表的情况下进一步缩小查询的范围。其实就是对索引失效的进一步修复，属于最左前缀索引原则的一个特殊情况。</font>**  

* <font color = "clime">关闭ICP：索引--->回表--->条件过滤。</font>不支持ICP之前，当进行索引查询时，首先根据索引来查找数据，然后再根据where条件来过滤，扫描了大量不必要的数据，增加了数据库IO操作。  
* <font color = "clime">开启ICP：索引--->条件过滤--->回表。</font>在支持ICP后，`MySQL在取出索引数据的同时，判断是否可以进行where条件过滤，`<font color = "blue">将where的部分过滤操作放在存储引擎层提前过滤掉不必要的数据，</font>减少了不必要数据被扫描带来的IO开销。  

&emsp; 在某些查询下，可以减少Server层对存储引擎层数据的读取，从而提供数据库的整体性能。  

### 1.4.2. 示例分析  
<!-- 
~~
https://www.cnblogs.com/zengkefu/p/5684101.html
-->
&emsp; 示例：people表中(zipcode，lastname，firstname)构成一个索引。  

```sql
SELECT * FROM people WHERE zipcode='95054' AND lastname LIKE '%etrunia%' AND address LIKE '%Main Street%';
```
&emsp; 如果没有使用索引下推技术，则MySQL会通过zipcode='95054'从存储引擎中查询对应的数据，返回到MySQL服务端，然后MySQL服务端基于lastname LIKE '%etrunia%'和address LIKE '%Main Street%'来判断数据是否符合条件。  
&emsp; <font color = "blue">如果使用了索引下推技术，则MYSQL首先会返回符合zipcode='95054'的索引，然后根据lastname LIKE '%etrunia%'和address LIKE '%Main Street%'来判断索引是否符合条件。如果符合条件，则根据该索引来定位对应的数据，如果不符合，则直接reject掉。有了索引下推优化，可以在有like条件查询的情况下，减少回表次数。</font> 

### 1.4.3. ★★★示例二  
&emsp; 基于组合索引idx_name_age，以下这个SQL执行几次树搜索呢？  

```sql
select * from employee where name like '小%' and age=28 and sex='0';
```

&emsp; 「解析：」 这里考察索引下推的知识点，如果是「Mysql5.6之前」，在idx_name_age索引树，找出所有名字第一个字是“小”的人，拿到它们的主键id，然后回表找出数据行，再去对比年龄和性别等其他字段。如图：  
![image](http://182.92.69.8:8081/img/SQL/sql-152.png)  
&emsp; 有些朋友可能觉得奇怪，(name,age)不是联合索引嘛？为什么选出包含“小”字后，不再顺便看下年龄age再回表呢，不是更高效嘛？所以呀， **<font color = "clime">MySQL 5.6 引入了「索引下推优化」，可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。</font>**  

&emsp; 因此，MySQL5.6版本之后，选出包含“小”字后，顺表过滤age=28，所以就只需一次回表。  
![image](http://182.92.69.8:8081/img/SQL/sql-153.png)  


## 1.5. 索引维护
1. 冗余和重复索引：冗余索引是指在相同的列上按照相同的顺序创建的相同类型的索引，应当尽量避免这种索引，发现后立即删除。比如有一个索引(A,B)，再创建索引(A)就是冗余索引。冗余索引经常发生在为表添加新索引时，比如有人新建了索引(A,B)，但这个索引不是扩展已有的索引(A)。
2. 大多数情况下都应该尽量扩展已有的索引而不是创建新索引。但有极少情况下出现性能方面的考虑需要冗余索引，比如扩展已有索引而导致其变得过大，从而影响到其他使用该索引的查询。
3. 删除长期未使用的索引。

&emsp; MySql索引工具：1.mysqlidxchx 2.pt-index-usage 3.userstat 4.check-unused-keys  