
<!-- TOC -->

- [1. MySql存储引擎](#1-mysql存储引擎)
    - [1.1. 存储引擎操作](#11-存储引擎操作)
    - [1.2. InnoDB存储引擎](#12-innodb存储引擎)
        - [1.2.1. ***InnoDB体系结构](#121-innodb体系结构)
        - [1.2.2. Innodb后台线程](#122-innodb后台线程)
        - [1.2.3. InnoDB内存中的结构](#123-innodb内存中的结构)
        - [1.2.4. InnoDB磁盘上的结构](#124-innodb磁盘上的结构)
            - [1.2.4.1. 逻辑存储结构](#1241-逻辑存储结构)
                - [1.2.4.1.1. 表空间详解](#12411-表空间详解)
                - [1.2.4.1.2. InnoDB数据页结构](#12412-innodb数据页结构)
                    - [1.2.4.1.2.1. InnoDB行格式](#124121-innodb行格式)
            - [1.2.4.2. InnoDB表数据文件](#1242-innodb表数据文件)
    - [1.3. MyISAM存储引擎](#13-myisam存储引擎)
        - [1.3.1. MyISAM的索引](#131-myisam的索引)
        - [1.3.2. MyISAM的特性](#132-myisam的特性)
    - [1.4. ~~InnoDB与MyISAM的区别总结~~](#14-innodb与myisam的区别总结)
    - [1.5. 选择合适的存储引擎](#15-选择合适的存储引擎)

<!-- /TOC -->

<!-- 
MySQL
https://www.cnblogs.com/geaozhang/category/1326927.html
-->

# 1. MySql存储引擎
1. MySQL常见的存储引擎有InnoDB、MyISAM、Memory、NDB。<font color = "red">InnoDB现在是MySQL默认的存储引擎，支持事务、行级锁定和外键。</font>  
2. MySQL的存储引擎是针对表的，不是针对库的。也就是说在一个数据库中可以使用不同的存储引擎。但是不建议这样做。 
3. MySQL是插件式的存储引擎，其中存储引擎分很多种。只要实现符合mysql存储引擎的接口，可以开发自己的存储引擎! 
4. 所有跨存储引擎的功能都是在服务层实现的。  

## 1.1. 存储引擎操作  
&emsp; ......
<!-- 
https://mp.weixin.qq.com/s/MCFHNOQnTtJ6MGVjM3DP4A 
https://mp.weixin.qq.com/s/IsZjLI7QAB6t7H7NyGscGg
https://mp.weixin.qq.com/s/StjX9bi-YDANrMX21Pn_Uw
-->

## 1.2. InnoDB存储引擎  
&emsp; MySQL5.5及之后版本默认的存储引擎：InnoDB。  

&emsp; InnoDB的特性：    

* 支持事务  
* 支持行锁，采用MVCC来支持高并发  
* 支持外键  
* 支持崩溃后的安全恢复  
* 不支持全文索引  
* InnoDB 不保存表的具体行数，执行select count(*) from table 时需要全表扫描。  

<!-- 
    支持事务操作，具有事务 ACID 隔离特性，默认的隔离级别是可重复读(repetable-read)、通过MVCC（并发版本控制）来实现的。能够解决脏读和不可重复读的问题。
    InnoDB 支持外键操作。
    InnoDB 默认的锁粒度行级锁，并发性能比较好，会发生死锁的情况。
    和 MyISAM 一样的是，InnoDB 存储引擎也有 .frm文件存储表结构 定义，但是不同的是，InnoDB 的表数据与索引数据是存储在一起的，都位于 B+ 数的叶子节点上，而 MyISAM 的表数据和索引数据是分开的。
    InnoDB 有安全的日志文件，这个日志文件用于恢复因数据库崩溃或其他情况导致的数据丢失问题，保证数据的一致性。
    InnoDB 和 MyISAM 支持的索引类型相同，但具体实现因为文件结构的不同有很大差异。
    增删改查性能方面，果执行大量的增删改操作，推荐使用 InnoDB 存储引擎，它在删除操作时是对行删除，不会重建表。
-->

### 1.2.1. ***InnoDB体系结构  
<!-- 
InnoDB 原理
https://mp.weixin.qq.com/s/nrb0OaiD_QRtPGREpUr0HA
-->
&emsp; Innodb体系结构图：  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/SQL/sql-131.png)  

InnoDB架构图二（来自官方文档https://dev.mysql.com/doc/refman/5.7/en/innodb-architecture.html）：
![image](https://gitee.com/wt1814/pic-host/raw/master/images/SQL/sql-132.png)  

&emsp; Innodb体系结构包含后台线程、内存池和磁盘上的结构。  

### 1.2.2. Innodb后台线程 
<!-- 
了解InnoDB的后台线程 
https://mp.weixin.qq.com/s/2dUIAot8OKHiWar44qRi-A
-->
&emsp; 后台线程主要分为4个部分  

* Master Thread 
&emsp; 主要负责将缓冲池中的数据异步刷新到磁盘，保证数据的一致性，包括脏页的刷新、合并插入缓冲（INSERT BUFFER）、UNDO页的回收等等。
* IO Thread
&emsp; InnoDB存储引擎中大量使用AIO（Async IO)来处理写IO的请求，而IO Thread的工作主要就是负责这些IO请求的回调。  
&emsp; InnoDB 1.0版本之前一共有4个IO Thread，分别是write、read、insert buffer和log IO thread。从1.0.x版本开始 ，read和write增加到4个，一共10个IO Thread，阿里云的RDS就是这10个IO Thread。  
* Purge Thread
&emsp; 事务被提交后，其所使用的undolog可能不再需要了，purge thread来回收已经使用并分配的undo 页。在InnoDB 1.1 版本之前undo页的回收也就是purge操作都是在master thread中进行的，InnoDB1.1版本之后，就分配到单独的线程中执行，也就是purge thread ， 尽管现阶段使用的阿里云的RDS是基于mysql 5.5版本的，5.5对应的InnoDB就是1.1.x版本，但是配置的purge thread是为0的，目测应该是master thread进行purge操作来回收已经分配并使用的undo页。  
* Page Cleaner Thread
&emsp; page cleaner thread 是在InnoDB1.2.x版本之后加入的，将原本放在master thread中进行的脏页刷新操作放到了单独的线程中来完成。  

### 1.2.3. InnoDB内存中的结构  
<!-- 
https://mp.weixin.qq.com/s/nrb0OaiD_QRtPGREpUr0HA
-->
&emsp; 内存中的结构主要包括 Buffer Pool，Change Buffer、Adaptive Hash Index以及 Log Buffer 四部分。  
&emsp; **如果从内存上来看，Change Buffer 和 Adaptive Hash Index占用的内存都属于 Buffer Pool，Log Buffer占用的内存与 Buffer Pool独立。**  

&emsp; [InnoDB关键特性](/docs/SQL/InnoDB.md)   
  
### 1.2.4. InnoDB磁盘上的结构  
&emsp; 官方文档：https://dev.mysql.com/doc/refman/5.7/en/innodb-on-disk-structures.html  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/SQL/sql-133.png)  

#### 1.2.4.1. 逻辑存储结构 
<!-- 
https://zhuanlan.zhihu.com/p/111958646
-->

&emsp; 从InnoDb存储引擎的逻辑存储结构看，所有数据都被逻辑地存放在一个空间中，称之为表空间（tablespace）。表空间又由段（segment），区（extent），页（page）组成。页在一些文档中有时候也称为块（block）。InnoDb逻辑存储结构图如下：  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/SQL/sql-41.png)  

* 表空间（tablespace）：  
&emsp; 表空间是Innodb存储引擎逻辑的最高层，所有的数据都存放在表空间中。  
&emsp; 默认情况下，Innodb存储引擎有一个共享表空间ibdata1，即所有数据都存放在这个表空间中内。  
&emsp; 如果启用了innodbfileper_table参数，需要注意的是每张表的表空间内存放的只是数据、索引、和插入缓冲Bitmap，其他类的数据，比如回滚(undo)信息、插入缓冲检索页、系统事物信息，二次写缓冲等还是放在原来的共享表内的。  
* 段（segment）：  
&emsp; 表空间由段组成，常见的段有数据段、索引段、回滚段等。  
&emsp; InnoDB存储引擎表是索引组织的，因此数据即索引，索引即数据。数据段即为B+树的叶子结点，索引段即为B+树的非索引结点。  
&emsp; 在InnoDB存储引擎中对段的管理都是由引擎自身所完成，DBA不能也没必要对其进行控制。  
* 区（extent）：  
&emsp; 区是由连续页组成的空间，在任何情况下每个区的大小都为1MB。  
&emsp; 为了保证区中页的连续性，InnoDB存储引擎一次从磁盘申请4~5个区。  
&emsp; 默认情况下，InnoDB存储引擎页的大小为16KB，一个区中一共64个连续的区。  
* 页（page）：  
&emsp; 页是InnoDB磁盘管理的最小单位。在InnoDB存储引擎中，默认每个页的大小为16KB。  
&emsp; 从InnoDB1.2.x版本开始，可以通过参数innodbpagesize将页的大小设置为4K，8K，16K。  
&emsp; **InnoDB存储引擎中，常见的页类型有：数据页，undo页，系统页，事务数据页，插入缓冲位图页，插入缓冲空闲列表页等。** 
![image](https://gitee.com/wt1814/pic-host/raw/master/images/SQL/sql-78.png)  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/SQL/sql-79.png)  

##### 1.2.4.1.1. 表空间详解  

<!-- 
https://www.cnblogs.com/tongxiaoda/p/7874535.html
-->
<!--
&emsp; **.ibd文件或.ibdata文件详解：**  
1. 表空间  
&emsp; Innodb存储引擎可将所有数据存放于ibdata*的共享表空间，也可将每张表存放于独立的.ibd文件的独立表空间。  
&emsp; 共享表空间以及独立表空间都是针对数据的存储方式而言的。

* 共享表空间: 某一个数据库的所有的表数据，索引文件全部放在一个文件中，默认这个共享表空间的文件路径在data目录下。 默认的文件名为:ibdata1 初始化为10M。
* 独立表空间: 每一个表都将会生成以独立的文件方式来进行存储，每一个表都有一个.frm表描述文件，还有一个.ibd文件。 其中这个文件包括了单独一个表的数据内容以及索引内容，默认情况下它的存储位置也是在表的位置之中。  

    ```sql
    [root@localhost data]# ls
    a1  a2  a3  auto.cnf  ib_buffer_pool  ibdata1  ib_logfile0  ib_logfile1  ibtmp1  localhost.localdomain.err  localhost.localdomain.pid  mysql  performance_schema  sys
    ```

    &emsp; ibdata1就是InnoDB表的共享存储空间，默认innodb所有表的数据都在一个ibdata1里。  

2. 优缺点  
（1）共享表空间：
优点：
可以将表空间分成多个文件存放到各个磁盘上（表空间文件大小不受表大小的限制，如一个表可以分布在不同的文件上）。数据和文件放在一起方便管理。
缺点：
所有的数据和索引存放到一个文件中，虽然可以把一个大文件分成多个小文件，但是多个表及索引在表空间中混合存储，这样对于一个表做了大量删除操作后表空间中将会有大量的空隙，特别是对于统计分析，日值系统这类应用最不适合用共享表空间。

（2）独立表空间：
在配置文件（my.cnf）中设置： innodb_file_per_table
优点：
1）每个表都有自已独立的表空间。
2）每个表的数据和索引都会存在自已的表空间中。
3）可以实现单表在不同的数据库中移动。
4）空间可以回收（除drop table操作处，表空不能自已回收）

    Drop table操作自动回收表空间，如果对于统计分析或是日值表，删除大量数据后可以通过:alter table TableName engine=innodb;回缩不用的空间。
    对于使innodb-plugin的Innodb使用turncate table也会使空间收缩。
    对于使用独立表空间的表，不管怎么删除，表空间的碎片不会太严重的影响性能，而且还有机会处理。

缺点：
单表增加过大，如超过100个G。
相比较之下，使用独占表空间的效率以及性能会更高一点。
-->

##### 1.2.4.1.2. InnoDB数据页结构  
&emsp; 页是InnoDB磁盘管理的最小单位，每次读取数据都会读取一个页大小的数据。在InnoDB存储引擎中，默认每个页的大小为16KB。 (在操作系统中默认页大小是4KB。) 可以使用命令SHOW GLOBAL STATUS LIKE 'Innodb_page_size' 查看。  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/SQL/sql-99.png)  

&emsp; 页结构如下：  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/SQL/sql-79.png)  


###### 1.2.4.1.2.1. InnoDB行格式
<!-- 
https://www.cnblogs.com/bdsir/p/8745553.html
https://juejin.cn/post/6844904190477598733#heading-14
-->


#### 1.2.4.2. InnoDB表数据文件  
&emsp; <font color = "red">在InnoDB中，数据和索引文件是合起来储存的，如图所示，InnoDB 的存储文件有两个，后缀名分别是 .frm 和 .idb，其中 .frm 是表的定义文件，</font> **<font color = "lime">而idb是数据文件/索引文件。</font>**   
![image](https://gitee.com/wt1814/pic-host/raw/master/images/SQL/sql-33.png)  

* .frm文件：与表相关的元数据信息都存放在frm文件，包括表结构的定义信息等。  
* .ibd文件或.ibdata文件：这两种文件都是存放InnoDB数据的文件，之所以有两种文件形式存放 InnoDB 的数据，是因为InnoDB的数据存储方式能够通过配置来决定是使用共享表空间存放存储数据，还是用独享表空间存放存储数据。  
&emsp; 独享表空间存储方式使用.ibd文件，并且每个表一个.ibd文件 共享表空间存储方式使用.ibdata文件，所有表共同使用一个.ibdata文件（或多个，可自己配置）。  


## 1.3. MyISAM存储引擎  
### 1.3.1. MyISAM的索引  
&emsp; 查看[索引](/docs/SQL/7.index.md)  

### 1.3.2. MyISAM的特性  
&emsp; MyISAM引擎是MySQL 5.1及之前版本的默认引擎，它的特性是：  

* 不支持事务  
* 不支持行锁，读取时对需要读到的所有表加锁，写入时则对表加排它锁  
* 不支持外键  
* 不支持崩溃后的安全恢复  
* 在表有读取查询的同时，支持往表中插入新纪录  
* 支持BLOB和TEXT的前500个字符索引，支持全文索引  
* 支持延迟更新索引，极大提升写入性能  
* 对于不会进行修改的表，支持压缩表，极大减少磁盘空间占用  
* MyISAM 用一个变量保存了整个表的行数，执行select count(*) from table时只需要读出该变量即可，速度很快；  

&emsp; <font color = "red">一张表，里面有ID自增主键，当insert了17条记录之后，删除了第15,16,17条记录，再把Mysql重启，再insert一条记录，这条记录的ID是18还是15 ？</font>  
&emsp; 如果表的类型是MyISAM，那么是18。因为MyISAM表会把自增主键的最大ID 记录到数据文件中，重启MySQL自增主键的最大ID也不会丢失；  
&emsp; 如果表的类型是InnoDB，那么是15。因为InnoDB 表只是把自增主键的最大ID记录到内存中，所以重启数据库或对表进行OPTION操作，都会导致最大ID丢失。  

&emsp; <font color = "red">哪个存储引擎执行 select count(*) 更快，为什么? </font>   
&emsp; MyISAM更快，因为MyISAM内部维护了一个计数器，可以直接调取。  

* 在 MyISAM 存储引擎中，把表的总行数存储在磁盘上，当执行 select count(*) from t 时，直接返回总数据。  
* 在 InnoDB 存储引擎中，跟 MyISAM 不一样，没有将总行数存储在磁盘上，当执行 select count(*) from t 时，会先把数据读出来，一行一行的累加，最后返回总数量。  

&emsp; InnoDB 中 count(*) 语句是在执行的时候，全表扫描统计总数量，所以当数据越来越大时，语句就越来越耗时了，为什么 InnoDB 引擎不像 MyISAM 引擎一样，将总行数存储到磁盘上？这跟 InnoDB 的事务特性有关，由于多版本并发控制（MVCC）的原因，InnoDB 表“应该返回多少行”也是不确定的。  

## 1.4. ~~InnoDB与MyISAM的区别总结~~  
<!-- 
https://mp.weixin.qq.com/s/StjX9bi-YDANrMX21Pn_Uw
-->
1. InnoDB支持事务，MyISAM不支持，对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务；  
2. InnoDB支持外键，而MyISAM不支持。对一个包含外键的InnoDB表转为MYISAM会失败；  
3. InnoDB是聚集索引，数据文件是和索引绑在一起的，必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。而MyISAM是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。  
4. InnoDB不保存表的具体行数，执行select count(*) from table时需要全表扫描。而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；  
5. Innodb不支持全文索引，而MyISAM支持全文索引，查询效率上MyISAM要高；  

## 1.5. 选择合适的存储引擎  

* 如果对数据一致性要求比较高，需要事务支持，可以选择 InnoDB。比如OA自动化办公系统。  
* 如果数据查询多更新少，对查询性能要求比较高，可以选择 MyISAM。比如博客系统、新闻门户网站。  

![image](https://gitee.com/wt1814/pic-host/raw/master/images/SQL/sql-50.png)  

<!-- 
选择合适的存储引擎

在实际开发过程中，我们往往会根据应用特点选择合适的存储引擎。

    MyISAM：如果应用程序通常以检索为主，只有少量的插入、更新和删除操作，并且对事物的完整性、并发程度不是很高的话，通常建议选择 MyISAM 存储引擎。
    InnoDB：如果使用到外键、需要并发程度较高，数据一致性要求较高，那么通常选择 InnoDB 引擎，一般互联网大厂对并发和数据完整性要求较高，所以一般都使用 InnoDB 存储引擎。
    MEMORY：MEMORY 存储引擎将所有数据保存在内存中，在需要快速定位下能够提供及其迅速的访问。MEMORY 通常用于更新不太频繁的小表，用于快速访问取得结果。
    MERGE：MERGE 的内部是使用 MyISAM 表，MERGE 表的优点在于可以突破对单个 MyISAM 表大小的限制，并且通过将不同的表分布在多个磁盘上， 可以有效地改善 MERGE 表的访问效率。
-->
