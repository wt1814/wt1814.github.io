
<!-- TOC -->

- [1. 主从复制](#1-主从复制)
    - [1.1. MySql主从复制原理](#11-mysql主从复制原理)
        - [1.1.1. 复制流程](#111-复制流程)
        - [1.1.2. 同步方式](#112-同步方式)
        - [1.1.3. 复制方式](#113-复制方式)
            - [1.1.3.1. 基于语句的复制](#1131-基于语句的复制)
            - [1.1.3.2. 基于行的复制](#1132-基于行的复制)
            - [1.1.3.3. 混合模式复制](#1133-混合模式复制)
    - [1.2. 主从复制拓扑结构](#12-主从复制拓扑结构)
    - [1.3. 复制的问题和解决方案](#13-复制的问题和解决方案)
        - [1.3.1. 复制延迟过大](#131-复制延迟过大)
            - [1.3.1.1. 并行复制](#1311-并行复制)
        - [1.3.2. 数据损坏或丢失](#132-数据损坏或丢失)
            - [1.3.2.1. 主库意外关闭](#1321-主库意外关闭)
            - [1.3.2.2. 备库意外关闭](#1322-备库意外关闭)
            - [1.3.2.3. 主库二进制日志损坏](#1323-主库二进制日志损坏)
            - [1.3.2.4. 备库中继日志损坏](#1324-备库中继日志损坏)
            - [1.3.2.5. 二进制日志与 InnoDB 事务日志不同步](#1325-二进制日志与-innodb-事务日志不同步)
        - [1.3.3. 未定义的服务器ID](#133-未定义的服务器id)
        - [1.3.4. 对未复制数据的依赖性](#134-对未复制数据的依赖性)
        - [1.3.5. 丢失的临时表](#135-丢失的临时表)
        - [1.3.6. InnoDB加锁读导致主备数据不一致](#136-innodb加锁读导致主备数据不一致)
        - [1.3.7. 总结](#137-总结)
- [2. 读写分离](#2-读写分离)
    - [2.1. 读写分离带来的问题](#21-读写分离带来的问题)

<!-- /TOC -->

![image](https://gitee.com/wt1814/pic-host/raw/master/images/SQL/sql-64.png)  

&emsp; **<font color = "red">部分参考《高性能MySql》</font>**

# 1. 主从复制  
## 1.1. MySql主从复制原理  
<!-- https://mp.weixin.qq.com/s?__biz=MzU4NzYwNDAwMg==&mid=2247486953&idx=3&sn=8ce915a119d7a1d2bf32d82a1ece24ba&chksm=fde8c4a4ca9f4db2e9c40e65efcaefb9318dedb36411865b269b7b8026a80d250f45652f49a1&mpshare=1&scene=1&srcid=&sharer_sharetime=1587486135950&sharer_shareid=b256218ead787d58e0b58614a973d00d&key=79150dbf571fbc4896e24bfaa10bc51f375d54f7b7955b16d5d149611cc4488bc9bb38846d3564a0c365d73f8ebb056576cdee8f51847f3cd52bf867f4313410b386328262394bab8dd1a1d65bf80df6&ascene=1&uin=MTE1MTYxNzY2MQ%3D%3D&devicetype=Windows+10&version=62080079&lang=zh_CN&exportkey=ASnTeJ9F3S7ijOQUsEABecA%3D&pass_ticket=t7WrYQgRWkv7fomJ9tKSvYV9vbBBrtBhylesb1eYH1AGZ3bs%2FIfhN20euL1DBMbi -->
### 1.1.1. 复制流程  
&emsp; replication的工作流程分为以下3个步骤：  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/SQL/sql-27.png)  
1. 主服务器（master）把数据更改记录到二进制日志（binlog）中。  
2. 从服务器（slave）把主服务器的二进制日志复制到自己的中继日志（relay log）中。  
3. 从服务器重做日志中的日志，把更改应用到自己的数据库上，以达到数据的最终一致性。  


### 1.1.2. 同步方式
&emsp; 同步方式可以划分为：异步、半同步和同步。  

* 同步复制：指当主库执行完一个事务，所有的从库都执行了该事务才返回给客户端。因为需要等待所有从库执行完该事务才能返回，所以全同步复制的性能必然会收到严重的影响。需要有超时时间。  
* 异步复制：<font color = "red">MySQL默认的复制即是异步的，</font>主库在执行完客户端提交的事务后会立即将结果返给给客户端，并不关心从库是否已经接收并处理，<font color = "lime">这样就会有一个问题，主如果crash掉了，此时主上已经提交的事务可能并没有传到从上，如果此时，强行将从提升为主，可能导致新主上的数据不完整。</font>  
* 半同步复制：介于异步复制和全同步复制之间，主库在执行完客户端提交的事务后不是立刻返回给客户端，而是等待至少一个从库接收到并写到relay log中才返回给客户端。相对于异步复制，半同步复制提高了数据的安全性，同时它也造成了一定程度的延迟，这个延迟最少是一个TCP/IP往返的时间。所以，半同步复制最好在低延时的网络中使用。  

### 1.1.3. 复制方式  
<!-- https://www.jianshu.com/p/047185a672f6 -->
&emsp; 复制方式有三种：基于行的复制、基于语句的复制、混合模式复制。  

#### 1.1.3.1. 基于语句的复制  
&emsp; 基于SQL语句的复制(statement-based replication, SBR)，每一条会修改数据的sql语句会记录到binlog中。  
&emsp; **优点：** 不需要记录每一条SQL语句与每行的数据变化（不记录select操作），这样子binlog的日志也会比较少，减少了磁盘IO，提高性能。  
&emsp; **缺点：** <font color = "red">并非所有修改数据的语句都可以使用基于语句的复制进行复制。使用基于语句的复制时，任何非确定性行为都难以复制。</font>此类数据修改语言（DML）语句的示例包括以下内容：  
        
    依赖于UDF或不确定的存储程序的语句，因为这样的UDF或存储程序返回的值取决于提供给它的参数以外的因素。  
    不带ORDER BY的LIMIT子句的DELETE和UPDATE语句是不确定的。 
 
#### 1.1.3.2. 基于行的复制  
&emsp; 不记录每一条SQL语句的上下文信息，仅需记录哪条数据被修改了，修改成了什么样子了。  
&emsp; **优点：** 没有基于行的复制模式无法处理的场景。  
&emsp; **缺点：** 会产生大量的日志。  

#### 1.1.3.3. 混合模式复制  
&emsp; 混合模式复制(mixed-based replication, MBR)：MySQL5.1及其以后的版本推荐使用混合模式的复制，它是<font color = "lime">根据事件的类型实时的改变binlog的格式。当设置为混合模式时，默认为基于语句的格式，但在特定的情况下它会自动转变为基于行的模式。</font>  
&emsp; <font color = "red">当出现如下情况时，混合模式需要切换到基于行的复制：</font>  

* 该语句调用了：UUID函数；用户自定义函数(UDFs);CURRENT_USER或USER函数；LOAD_FILE函数。
* 同一个语句更改了两张或更多包含AUTO_INCREMENT列的表。
* 语句中使用了服务器变量。
* 存储引擎不允许使用基于语句复制，如：MySQL Cluster引擎。

## 1.2. 主从复制拓扑结构  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/SQL/sql-11.png)  

* 一主一从：  
&emsp; 主备架构。只有主库提供读写服务；备库冗余作故障转移，即主库挂了，keepalive（一种工具）会自动切换到备库。  
* 一主多从：  
&emsp; 一台Slave承受不住读请求压力时，可以添加多台，进行负载均衡，分散读压力。还可以对多台Slave进行分工，服务于不同的系统，例如一部分Slave负责网站前台的读请求，另一部分Slave负责后台统计系统的请求。因为不同系统的查询需求不同，对Slave分工后，可以创建不同的索引，使其更好的服务于目标系统。  
&emsp; 主库单点，从库高可用。一旦主库挂了，写服务也就无法提供。  
&emsp; 存在问题：存在数据一致性问题。请看，一致性解决方案。  
* 双主复制：  
&emsp; 一主多从，Master存在下线的可能，例如故障或者维护，需要把Slave切换为Master。在原来的Master恢复可用后，由于其数据已经不是最新的了，不能再做主，需要作为Slave添加进来。那么就需要对其重新搭建复制环境，需要耗费一定的工作量。  
&emsp; 双主架构，两个主库同时提供服务，负载均衡。高可用，一个主库挂了，不影响另一台主库提供服务。这个过程对业务层是透明的，无需修改代码或配置。  
&emsp; 存在问题：第一，数据一致性问题，一致性解决方案可解决问题。第二，主键冲突问题，ID统一地由分布式ID生成服务来生成可解决问题。  

* 从库级联复制  
&emsp; 当直接从属于Master的Slave过多时，连到Master的Slave IO线程就比较多，对Master的压力是很大的。  
&emsp; 级联结构就是通过减少直接从属于Master的Slave数量，减轻Master的压力，分散复制请求，从而提高整体的复制效率。  
* 双主+主从架构  
&emsp; 存在问题：数据一致性问题、主键冲突问题。数据同步又多了一层，数据延迟更严重。  
* 双主+级联  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/SQL/sql-12.png)  

## 1.3. 复制的问题和解决方案  
<!-- https://segmentfault.com/a/1190000018785903 -->
&emsp; **<font color = "red">《高性能MySql》第10章</font>**
![image](https://gitee.com/wt1814/pic-host/raw/master/images/SQL/sql-61.png)  

&emsp; 中断MySQL的复制并不是件难事。因为实现简单，配置相当容易，但也意味着有很多 方式会导致复制停止，陷入混乱并中断。  

### 1.3.1. 复制延迟过大  
&emsp; 产生延迟的两种方式：  

* 突然产生延迟，然后再跟上；  
* 稳定的延迟增大  

&emsp; 前者通常是由于一条执行时间过长的 SQL 导致，而后者即使在没有慢语句也会出现。  
&emsp; 对于前者，可以通过备库上的慢查询日志来进行优化。在备库上开启 log_slow_slave_statement 选项，可以在慢查询日志中记录复制线程执行的语句。  

&emsp; 而对于后者，没有针对性的解决方案，只能通过各种方式提高备库的复制效率。而想去对备库做优化时，会发现，除了购买更快的磁盘和 CPU，并没有太多的调优空间。只能通过 MySQL 选项禁止某些额外的工作以减少备库的复制。可以通过下面几种方式：   
1. 使用 InnoDB 引擎时，设置 innodb_flush_log_at_trx_commit 值为 2，来使备库不要频繁的刷新磁盘，以提高事务提交效率。  
2. 禁止二进制日志记录。把 innodb_locks_unsafe_for_binlog 设置为 1，并把 MyISAM 的 delay_key_write 设置为 ALL。要注意的是，这些设置是以安全换取速度，在将备库提升为主库时，记得把这些选项设置回安全的值。  
3. 拆分效率较低的复制 SQL，分离复杂语句中的 SELECT 和 UPDATE 语句，降低复制消耗，提高效率。 

#### 1.3.1.1. 并行复制  
&emsp; 可以使用并行复制（并行是指从库多个SQL线程并行执行 relay log），解决从库复制延迟的问题。  
&emsp; MySQL 5.7 中引入基于组提交的并行复制，其核心思想：一个组提交的事务都是可以并行回放，因为这些事务都已进入到事务的 prepare 阶段，则说明事务之间没有任何冲突（否则就不可能提交）。  
&emsp; 判断事务是否处于一个组是通过 last_committed 变量，last_committed 表示事务提交的时候，上次事务提交的编号，如果事务具有相同的 last_committed，则表示这些事务都在一组内，可以进行并行的回放。  

### 1.3.2. 数据损坏或丢失
&emsp; 问题描述：服务器崩溃、断电、磁盘损坏、内存或网络错误等问题，导致数据损坏或丢失。  
&emsp; 问题原因：非正常关机导致没有把数据及时的写入硬盘。  

&emsp; 这种问题，一般可以分为几种情况导致：  

#### 1.3.2.1. 主库意外关闭
&emsp; 问题未发生，避免方案：设置主库的 sync_binlog 选项为 1。此选项表示 MySQL 是否控制 binlog 的刷新。当设置为 1 时，表示每次事务提交，MySQL 都会把 binlog 刷下去，是最安全，性能损耗也最大的设置。  
&emsp; 问题已发生，解决方案：指定备库从下一个二进制日志的开头重新读日志。但是一些日志事件将永久性丢失。可以使用Percona Toolkit中的 pt-table-checksum工具来检查主备一致性，以便于修复。  

#### 1.3.2.2. 备库意外关闭
&emsp; 备库意外关闭重启时，会去读 master.info 文件以找到上次停止复制的位置。但是在意外关闭的情况下，这个文件存储的信息可能是错误的。此外，备库也可能会尝试重新执行一些二进制文件，这可能会导致唯一索引错误。可以通过Percona Toolkit 中的 pt-slave-restart 工具，帮助备库重新执行日志文件。  
&emsp; 如果使用的是InnoDB表，可以在重启后观察 MySQL 的错误日志。InnoDB 在恢复过程中会打印出恢复点的二进制日志坐标，可以使用这个值来决定备库指向主库的偏移量。  

#### 1.3.2.3. 主库二进制日志损坏
&emsp; 如果主库上的二进制日志损坏，除了忽略损坏的位置外，别无选择。在忽略存储位置后，可以通过 FLUSH LOGS 命令在主库开始一个新的日志文件，然后将备库指向该文件的开始位置。  

#### 1.3.2.4. 备库中继日志损坏  
&emsp; 如果主库上的日志是完好的，有两种解决方案：  
1. 手工处理。找到 master binlog 日志的 pos 点，然后重新同步。  
2. 自动处理。mysql5.5 考虑到 slave 宕机中继日志损坏这一问题，只要在 slave 的的配置文件 my.cnf 里增加一个参数 relay_log_recovery=1 即可。  

#### 1.3.2.5. 二进制日志与 InnoDB 事务日志不同步  
&emsp; 由于各种各样的原因，MySQL 的复制碰到服务器崩溃、断电、磁盘损坏、内存或网络错误时，很难恢复当时丢失的数据。几乎都需要从某个点开始重启复制。  




### 1.3.3. 未定义的服务器ID  
&emsp; 如果没有再 my.cnf 里定义服务器 ID，虽然可以通过 CHANGE MASTER TO 来设置备库，但在启动复制时会遇到：

    mysql> START SLAVE;
    ERROR 1200 (HY000): The server us bit configured as slave; fix in config file or with CHANGE MASTER TO

&emsp; 这个报错可能会让人困惑。因为可能已经通过 CHANGE MASTER TO 设置了备库，并且通过 SHOW MASTER STATUS 也确认了，为什么还会有这样的报错呢？通过 SELECT @@server_id 可以获得一个值，要注意的是，这个值只是默认值，必须为备库显式地设置服务器 ID。也就是在 my.cnf 里显示的设置服务器 ID。  

### 1.3.4. 对未复制数据的依赖性  
&emsp; 如果在主库上有备库上不存在的数据库或数据表，复制就很容易中断，反之亦然。  

* 对于前者，假设在主库上有一个 single_master 表，备库没有。在主库上对此表进行操作后，备库在尝试回放这些操作时就会出现问题，导致复制中断。
* 对于后者，假设备库上有一个 single_slave 表，主库没有。在主库上执行创建 single_slave 表的语句时，备库在回放该建表语句时就会出现问题。  

&emsp; 对于此问题，能做的就是做好预防：  
1. 主备切换时，尽量在切换后对比数据，查清楚是否有不一致的表或库。
2. 一定不要在备库执行写操作。

### 1.3.5. 丢失的临时表  
&emsp; 临时表和基于语句的复制方式不相容。如果备库崩溃或者正常关闭，任何复制线程拥有的临时表都会丢失。重启备库后，所有依赖于该临时表的语句都会失败。  
&emsp; 复制时出现找不到临时表的异常时，可以做：  
1. 直接跳过错误，或者手动地创建一个名字和结构相同的表来代替消失的的临时表。  

&emsp; 临时表的特性：  
1. 只对创建临时表的连接可见。不会和其他拥有相同名字的临时表的连接起冲突；
2. 随着连接关闭而消失，无须显式的移除它们。

&emsp; **<font color = "red">更好使用临时表的方式：</font>**  
&emsp; 保留一个专用的数据库，在其中创建持久表，把它们作为伪临时表，以模拟临时表特性。只需要通过 CONNETCTION_ID() 的返回值，给临时表创建唯一的名字。  

&emsp; 伪临时表的优劣势：  

* 优势：更容易调试应用程序。可以通过别的连接来查看应用正在维护的数据；  
* 劣势：比临时表多一些开销。创建较慢伪临时表会较慢，因为表的 .frm 文件需要刷新到磁盘。  

### 1.3.6. InnoDB加锁读导致主备数据不一致  
&emsp; 使用共享锁，串行化更新，保证备库复制时数据一致。  
&emsp; 某些情况下，加锁读可以防止混乱。假设有两张表：tab1 没有数据，tab2 只有一行数据，值为 99。此时，有两个事务更新数据。事务 1 将 tab2 的数据插入到 tab1，事务 2 更新 tab2。  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/SQL/sql-62.png)  
1. 事务 1 使用获取 tab2 数据时，加入共享锁，并插入 tab1；  
2. 同时，事务 2 更新 tab2 数据时，由于写操作的排它锁机制，无法获取 tab2 的锁，等待；  
3. 事务 1 插入数据后，删除共享锁，提交事务，写入 binlog（此时 tab1 和 tab2 的记录值 都是 99）；  
4. 事务 2 获取到锁，更新数据，提交事务，写入 binlog（此时 tab1 的记录值为 99，tab2 的记录值为 100）。  

&emsp; 上述过程中，第二步非常重要。事务 2 尝试去更新 tab2 表，这需要在更新的行上加排他锁（写锁）。排他锁与其他锁不相容，包括事务 1 在行记录上加的共享锁。因此事务 2 需要等待事务 1 完成。备库在根据 binlog 进行复制时，会按同样的顺序先执行事务 1，再执行事务 2。主备数据一致。  

&emsp; 同样的过程，如果事务 1 在第一步时没有加共享锁，流程就变成：  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/SQL/sql-63.png)  
1. 事务 1 无锁读取 tab2 数据，并插入 tab1（此时 tab1 和 tab2 的记录值 都是 99）；  
2. 同时，事务 2 更新 tab2 数据，先与事务 1 提交事务，写入 binlog（此时 tab1 的记录值为 99，tab2 的记录值为 100）；  
3. 事务 1 提交事务，写入 binlog（此时记录值无变化）；  

&emsp; mysqldump --single-transaction --all-databases --master-data=1 --host=server1 | mysql --host=server2  
&emsp; 要注意的是，上述过程中，事务 2 先提交，先写入 binlog。在备库复制时，同样先执行事务 2，将 tab2 的记录值更新为 100。然后执行事务 1，读取 tab2 数据，插入 tab1，所以最终的结果是，tab1 的记录值和 tab2 的记录值都是 100。很明显，数据和主库有差异。  

&emsp; 建议在大多数情况下将 innodb_unsafe_for_binlog 的值设置为 0。基于行的复制由于记录了数据的变化而非语句，因此不会存在这个问题。    
 

### 1.3.7. 总结  
&emsp; <font color = "red">复制问题要分清楚是 master 的问题，还是 slave 的问题。master 问题找 binlog，slave 问题找 relaylog。</font>  

----
# 2. 读写分离  
&emsp; 读写分离在数据库主从复制技术基础上实现（主从复制针对写入数据，读写分离主要针对读取数据）。  

## 2.1. 读写分离带来的问题  
* 数据不一致问题（主从数据同步延迟问题）：当主库的TPS并发较高时，由于主库上面是多线程写入的，而从库的SQL线程是单线程的，导致从库SQL可能会跟不上主库的处理速度。因此有可能出现在master节点中已经插入了数据，但是从slave节点却读取不到的问题。**<font color = "red">对于一些强一致性的业务场景，要求插入后必须能读取到，对于这种情况，需要提供一种方式，让读请求也可以走主库。</font>**  
&emsp; 延迟的解决：    
    1. 网络方面：将从库分布在相同局域网内或网络延迟较小的环境中。  
    2. 硬件方面：从库配置更好的硬件，提升随机写的性能。  
    3. 配置方面：从库配置sync_binlog=0，innodb_flush_log_at_trx_commit=2，logs-slave-updates=0，增大innodb_buffer_pool_size，让更多操作在Mysql内存中完成，减少磁盘操作。或者升级Mysql5.7版本使用并行复制。  
    4. 架构方面：比如在事务当中尽量对主库读写，其他非事务中的读在从库。消除一部分延迟带来的数据库不一致。增加缓存降低一些从库的负载。  
* 事务问题：读写分离属于分布式事务的范畴。但是对于读写分离，目前主流的做法是，事务中的所有sql统一都走主库，由于只涉及到一个库，本地事务就可以搞定。  
* 感知集群信息变更：如果访问的数据库集群信息变更了，例如主从切换了，写流量就要到新的主库上；又例如增加了从库数量，流量需要可以打到新的从库上；又或者某个从库延迟或者失败率比较高，应该将这个从库进行隔离，读流量尽量打到正常的从库上。  
* 运维：例如集群搭建、主从切换、从库扩容、缩容等。例如master配置了多个slave节点，如果其中某个slave节点挂了，那么之后的读请求，应用将其转发到正常工作的slave节点上。另外，如果新增了slave节点，应用也应该感知到，可以将读请求转发到新的slave节点上。  


