


<!-- TOC -->

- [1. SQL优化](#1-sql优化)
    - [1.1. MySql性能，最大数据量、最大并发数、查询耗时](#11-mysql性能最大数据量最大并发数查询耗时)
    - [1.2. ※※※SQL优化维度](#12-※※※sql优化维度)
    - [1.3. 慢查询（监控）](#13-慢查询监控)
        - [1.3.1. 慢查询简介](#131-慢查询简介)
        - [1.3.2. 慢查询使用](#132-慢查询使用)
        - [1.3.3. 慢查询工具](#133-慢查询工具)
    - [1.4. EXPLAIN、PROCEDURE ANALYSE(分析)](#14-explainprocedure-analyse分析)
        - [1.4.1. explain与explain extended](#141-explain与explain-extended)
                - [Extra分析](#extra分析)
            - [1.4.1.1. explain extended](#1411-explain-extended)
        - [1.4.2. show warnings](#142-show-warnings)
        - [1.4.3. ~~proceduer analyse()取得建议~~](#143-proceduer-analyse取得建议)
        - [1.4.4. profiling](#144-profiling)
            - [1.4.4.1. 查看profile开启情况](#1441-查看profile开启情况)
            - [1.4.4.2. 启用profile](#1442-启用profile)
            - [1.4.4.3. 查看执行的SQL列表](#1443-查看执行的sql列表)
            - [1.4.4.4. 查询指定ID的执行详细信息](#1444-查询指定id的执行详细信息)
            - [1.4.4.5. 获取CPU、Block IO等信息](#1445-获取cpublock-io等信息)
    - [1.5. Sql语句优化](#15-sql语句优化)
        - [1.5.1. 基本查询优化](#151-基本查询优化)
        - [1.5.2. 子查询优化](#152-子查询优化)
        - [1.5.3. 关联查询优化](#153-关联查询优化)
        - [1.5.4. 组合查询优化](#154-组合查询优化)
        - [1.5.5. INSERT的优化](#155-insert的优化)
    - [1.6. 数据库表结构设计](#16-数据库表结构设计)
        - [1.6.1. 选择合适的数据类型](#161-选择合适的数据类型)
        - [1.6.2. 表的拆分](#162-表的拆分)
        - [1.6.3. 读写分离](#163-读写分离)
    - [1.7. 系统调优](#17-系统调优)
        - [1.7.1. 查看MySQL服务器运行的状态值](#171-查看mysql服务器运行的状态值)
        - [1.7.2. 服务器参数调优](#172-服务器参数调优)
            - [1.7.2.1. 内存相关](#1721-内存相关)
            - [1.7.2.2. IO 相关](#1722-io-相关)
            - [1.7.2.3. 安全相关](#1723-安全相关)
            - [1.7.2.4. 其他](#1724-其他)

<!-- /TOC -->

# 1. SQL优化  
<!--
你知道这 8 种 SQL 错误用法吗？ 
https://mp.weixin.qq.com/s/Ur-SWCwm-6yVF9vV2eLlHA
男朋友连模糊匹配like %%怎么优化都不知道 
https://mp.weixin.qq.com/s/ygvuP35B_sJAlBHuuEJhfg

-->
&emsp; **<font color = "lime">explain：type单表查询类型要达到range级别（只检索给定范围的行，使用一个索引来选择行，非全表扫描），extra包含不在其他属性显示，但是又非常重要的信息，常见的不太友好的值，如下：Using filesort，Using temporary。其他重要字段：key、key_len</font>**

![image](https://gitee.com/wt1814/pic-host/raw/master/images/SQL/sql-52.png)  

## 1.1. MySql性能，最大数据量、最大并发数、查询耗时

* 最大并发数：  
&emsp; 并发数是指同一时刻数据库能处理多少个请求，由max_connections和max_user_connections决定。max_connections是指MySQL实例的最大连接数，上限值是16384，max_user_connections是指每个数据库用户的最大连接数。  
&emsp; MySQL会为每个连接提供缓冲区，意味着消耗更多的内存。如果连接数设置太高硬件吃不消，太低又不能充分利用硬件。一般要求两者比值超过10%，计算方法如下：  
        
        max_used_connections / max_connections * 100% = 3/100 *100% ≈ 3%
 
    &emsp; 查看最大连接数与响应最大连接数：  

    ```sql
    show variables like '%max_connections%';
    show variables like '%max_user_connections%';
    ```

    &emsp; 在配置文件my.cnf中修改最大连接数  

        [mysqld]
        max_connections = 100
        max_used_connections = 20

* 查询耗时0.5秒：  
&emsp; 建议将单次查询耗时控制在0.5秒以内，0.5秒是个经验值，源于用户体验的3秒原则。如果用户的操作3秒内没有响应，将会厌烦甚至退出。响应时间=客户端UI渲染耗时+网络请求耗时+应用程序处理耗时+查询数据库耗时，0.5秒就是留给数据库1/6的处理时间。 

* 最大数据量：  
&emsp; MySQL没有限制单表最大记录数，它取决于操作系统对文件大小的限制。  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/SQL/sql-28.png)  
&emsp; <font color = "red">《阿里巴巴Java开发手册》提出单表行数超过500万行或者单表容量超过2GB，才推荐分库分表。</font>500万仅供参考，并非铁律。  

## 1.2. ※※※SQL优化维度  

1. 服务器的优化。  
2. 表结构设计： **<font color = "red">单库单表无法满足时，可以拆分表结构（主从复制、分库分表），或者使用ES搜索引擎。</font>**  
3. SQL语句的优化。  
    &emsp; 对查询语句的监控、分析、优化是SQL优化的一般步骤。常规调优思路：  
    1. 查看slowlog，分析slowlog，分析出查询慢的语句。  
    2. 按照一定优先级，进行一个一个的排查所有慢语句。  
    3. 分析top sql，进行explain调试，查看语句执行时间。  
    4. 调整[索引](/docs/SQL/7.index.md)或语句本身。 

&emsp; <font color = "red">MySql性能由综合因素决定，抛开业务复杂度，影响程度依次是硬件配置、MySQL配置、数据表设计、索引优化。</font>  

 
----
----
----

## 1.3. 慢查询（监控）  

<!-- 
https://mp.weixin.qq.com/s/KG8xGeu1Sq_RhcCwl3AW5Q
-->

### 1.3.1. 慢查询简介  
&emsp; MySQL慢查询日志是MySQL提供的一种日志记录，用来记录在MySQL中响应时间超过阈值的语句，具体指运行时间超过long_query_time值（默认值为10，即10秒，通常设置为1秒）的SQL，则会被记录到慢查询日志中（日志可以写入文件或者数据库表，如果对性能要求高的话，建议写文件）。默认情况下，MySQL数据库是不开启慢查询日志的，如果不是调优需要的话，不建议启动该参数。  
&emsp; 一般来说，慢查询发生在大表（比如：一个表的数据量有几百万），且查询条件的字段没有建立索引，此时，要匹配查询条件的字段会进行全表扫描，耗时超过long_query_time，则为慢查询语句。  

### 1.3.2. 慢查询使用  
1. 参数说明：  
    
        slow_query_log，慢查询开启状态。
        slow_query_log_file，慢查询日志存放的位置。
        long_query_time，查询超过多少秒才记录。
2. 设置步骤：  
    1. 查看慢查询相关参数。  

            #查看是否开启慢查询
            #slowquerylog = off，表示没有开启慢查询
            #slowquerylog_file 表示慢查询日志存放的目录
            show variables like 'slow_query%';
            show variables like 'long_query_time'; 
 
    2. 设置方法。
        方法一：全局变量设置。（即时性的，重启mysql之后失效，常用的）  

            --将 slow_query_log 全局变量设置为“ON”状态
            set global slow_query_log='ON';
            --设置慢查询日志存放的位置
            set global slow_query_log_file='/usr/local/mysql/data/slow.log';
            --查询超过1秒就记录
            set global long_query_time=1;  

        方法二：配置文件设置。修改配置文件my.cnf，在[mysqld]下的下方加入。  

            [mysqld]
            slow_query_log = ON
            slow_query_log_file = /usr/local/mysql/data/slow.log
            long_query_time = 1

    3. 重启MySQL服务。  

            service mysqld restart

    4. 查看设置后的参数。  

            show variables like 'slow_query%';
            show variables like 'long_query_time';  

### 1.3.3. 慢查询工具  
<!-- 
如何定位 MySQL 慢查询？ 
https://mp.weixin.qq.com/s/_SWewX-8nFam20Wcg6No1Q


-->

......

----
## 1.4. EXPLAIN、PROCEDURE ANALYSE(分析)  

```meimaid
graph LR
A[SQL分析] --> B(explain)
A --> C(proceduer analyse)
A --> D(profiling)
```

&emsp; **<font color = "lime">SQL分析语句有EXPLAIN与explain extended、show warnings、proceduer analyse、profiling。</font>**  

### 1.4.1. explain与explain extended
<!-- 
https://mp.weixin.qq.com/s?__biz=MzAxODcyNjEzNQ==&mid=2247487641&idx=1&sn=3551d8f82bf8b503041e079b6ce704ce&chksm=9bd0bd01aca734172fff2cda5c4a46bce8f1dabc1b0d44334794510b34b665e3cf8b1f1abced&mpshare=1&scene=1&srcid=&key=00a8e91eefd868fcd64be6325594939523bc619318b02b06053cd6a26de9a9f6490cd967c97a822819178ab39d2507e2b41ba0694bcac89b80ab27e7518e7df3f17aa0d224992a132b90164c45e889c2&ascene=1&uin=MTE1MTYxNzY2MQ%3D%3D&devicetype=Windows+10&version=62060833&lang=zh_CN&pass_ticket=A8TVciY05jxe73%2ByAqBufT%2F39WMw2DS5UIeWy9gagHorTGRPzk0IoQC5RsOCwRL0

https://mp.weixin.qq.com/s/eJ_ConoGHP6az3IKNe6L2g
--> 

```sql
EXPLAIN SELECT column_name FROM table_name;  
```
![image](https://gitee.com/wt1814/pic-host/raw/master/images/SQL/sql-29.png)  
&emsp; expain出来的信息列分别是id、select_type、table、partitions、 **<font color = "red">type</font>** 、possible_keys、 **<font color = "red">key</font>** 、**<font color = "red">key_len</font>** 、ref、rows、filtered、**<font color = "red">Extra</font>** 。  

&emsp; 标注(1,2,3,4,5)是要重点关注的数据  

* type列，连接类型。一个好的sql语句至少要达到range级别。杜绝出现all级别  
* key列，使用到的索引名。如果没有选择索引，值是NULL。可以采取强制索引方式  
* key_len列，索引长度  
* rows列，扫描行数。该值是个预估值  
* extra列，详细说明。注意常见的不太友好的值有：Using filesort, Using temporary  


|列名|用途|
|---|---|
|id	|每一个SELECT关键字查询语句都对应一个唯一id|
|select_type|SELECT关键字对应的查询类型|
|table|表名|
|partitions	|匹配的分区信息|
|type|单表的访问方法|
|possible_keys|可能用到的索引|
|key|实际使用到的索引|
|key_len|实际使用到的索引长度|
|ref|当使用索引列等值查询时，与索引列进行等值匹配的对象信息|
|rows|预估需要读取的记录条数|
|filtered|某个表经过条件过滤后剩余的记录条数百分比|
|Extra|额外的一些信息|

<!--
id相同，执行顺序从上往下
id全不同，如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行
id部分相同，执行顺序是先按照数字大的先执行，然后数字相同的按照从上往下的顺序执行
-->

* id：SELECT识别符。这是SELECT的查询序列号。  
    * id值相同  
    &emsp; id值相同一般出现在多表关联的场景，访问表的顺序是从上到下。  
    ![image](https://gitee.com/wt1814/pic-host/raw/master/images/SQL/sql-30.png)  
    &emsp; 两个id 都为1，先访问b表然后访问a表。  
    * id值不同  
    &emsp; id 值不同的情况，从大到小执行，值越大越先开始执行或者被访问。  
    ![image](https://gitee.com/wt1814/pic-host/raw/master/images/SQL/sql-31.png)  
    &emsp; 从结果来看，id为2那一行的子查询先被执行。然后再去访问id=1中a表。  
    * id包含了相同和不同的情况。  
    &emsp; 该情况一般是先有2个表或者子查询和表join，然后再和第三个表关联查询。比如  
    
        ```sql
        EXPLAIN SELECT t2.* FROM(SELECT t3.id FROM t3 WHERE t3.other_column = '') s1,t2 WHERE s1.id = t2.id;
        ```
        ![image](https://gitee.com/wt1814/pic-host/raw/master/images/SQL/sql-32.png)  
        &emsp; 分析结果可看出，先走id最大的2，也就是先走括号里面的查t3表的语句。走完查t3后，顺序执行，有一个，derived是衍生的意思，意思是在执行完t3查询后的s1虚表基础上，结果中的2，就是id为2的。最后执行的查t2表。  

* select_type：常见的有如下6种SIMPLE、PRIMARY、SUBQUERY、DERIVED、UNION、UNION RESULT，指出查询的类型：普通查询、联合查询、子查询等复杂的查询。  
    * SIMPLE：最简单的查询，查询中不包含子查询或者UNION。  
    * PRIMARY：查询中若包含任何复杂的子查询，最外层查询则被标记为PRIMARY，也就是最后被执行的语句。  
    * SUBQUERY：在SELECT from或者WHERE列表中包含了子查询  
    * DERIVED：导出表的SELECT(FROM子句的子查询)；在FROM列表中包含的子查询被标记为DERIVED（衍生）MySQL会递归执行这些子查询，把结果放在临时表里。  
    * UNION：UNION中的第二个或后面的SELECT语句；若第二个SELECT出现在UNION之后，则被标记为UNION；若UNION包含在FROM子句的子查询中，外层SELECT将被标记为DERIVED  
    * UNION RESULT：UNION的结果；  
    * DEPENDENT SUBQUERY：子查询中的第一个 SELECT, 取决于外面的查询. 即子查询依赖于外层查询的结果. 出现该值的时候一定要特别注意，可能需要使用join的方式优化子查询。  
    * DEPENDENT UNION：UNION中的第二个或后面的SELECT语句,取决于外面的查询；  

* table：（查询涉及的表或衍生表）  
&emsp; 其值为表名或者表的别名，表示访问哪一个表。  
&emsp; 当from中有子查询的时候，表名是derivedN的形式，其中N指向子查询，也就是explain结果中的下一列  
&emsp; 当有union result的时候，表名是union 1,2等的形式，1,2表示参与union的query id  
&emsp; 注意MySQL对待这些表和普通表一样，但是这些临时表是没有任何索引的。数据量大的情况下可能会有性能问题。  

* **<font color = "red">type：联接类型，表示访问表的方式。</font>**  
&emsp; 从最好到最差的结果依次如下:system > const > eq_ref > ref > range > index > ALL。<font color = "red">一个好的SQL语句至少要达到range级别。杜绝出现all级别。</font>下面给出各种联接类型，按照从最佳类型到最坏类型进行排序：  
    * System：表仅有一行(=系统表)。这是const联接类型的一个特例。  
    * Const：表最多有一个匹配行,它将在查询开始时被读取。因为仅有一行,在这行的列值可被优化器剩余部分认为是常数。const表很快,因为它们只读取一次!  
    * eq_ref：对于每个来自于前面的表的行组合,从该表中读取一行。这可能是最好的联接类型,除了const类型。  
    * Ref：对于每个来自于前面的表的行组合,所有有匹配索引值的行将从这张表中读取。  
    * ref_or_null：该联接类型如同ref,但是添加了MySQL可以专门搜索包含NULL值的行。  
    * index_merge：该联接类型表示使用了索引合并优化方法。  
    * unique_subquery：该类型替换了下面形式的IN子查询的ref: value IN (SELECT primary_key FROM single_table WHERE some_expr) unique_subquery是一个索引查找函数,可以完全替换子查询,效率更高。  
    * index_subquery：该联接类型类似于unique_subquery。可以替换IN子查询,但只适合下列形式的子查询中的非唯一索引: value IN (SELECT key_column FROM single_table WHERE some_expr)  
    * <font color = "red">Range：只检索给定范围的行,使用一个索引来选择行。</font>  
    * Index：该联接类型与ALL相同,除了只有索引树被扫描。这通常比ALL快,因为索引文件通常比数据文件小。  
    * ALL：对于每个来自于先前的表的行组合,进行完整的表扫描。  
* possible_keys：指出MySQL能使用哪个索引在该表中找到行。  
* **<font color = "red">key：显示MySQL实际决定使用的键(索引)。如果没有选择索引,键是NULL。</font><font color = "lime">很少的情况下，MYSQL会选择优化不足的索引。这种情况下，可以在SELECT语句中使用USE INDEX（indexname）来强制使用一个索引或者用IGNORE INDEX（indexname）来强制MYSQL忽略索引。</font>**  
* **<font color = "red">key_len：索引长度，显示MySQL决定使用的键长度。如果键是NULL,则长度为NULL。</font>**  
* ref：显示使用哪个列或常数与key一起从表中选择行。  
* rows：扫描行数。该值是个预估值。显示MySQL认为它执行查询时必须检查的行数。多行之间的数据相乘可以估算要处理的行数。  
* filtered：显示了通过条件过滤出的行数的百分比估计值。  
* **<font color = "red">extra：该列包含MySQL解决查询的详细信息。注意，常见的不太友好的值，如下：Using filesort，Using temporary，意思MYSQL根本不能使用索引，常出现在使用order by。</font>**  
    * Distinct：MySQL发现第1个匹配行后,停止为当前的行组合搜索更多的行。  
    * Not exists：MySQL能够对查询进行LEFT JOIN优化,发现1个匹配LEFT JOIN标准的行后,不再为前面的的行组合在该表内检查更多的行。  
    * range checked for each record (index map: #):MySQL没有发现好的可以使用的索引,但发现如果来自前面的表的列值已知,可能部分索引可以使用。  
    * Using filesort：额外排序。MySQL需要额外的一次传递,以找出如何按排序顺序检索行。  
    * Using index:从只使用索引树中的信息而不需要进一步搜索读取实际的行来检索表中的列信息。  
    * Using temporary：使用了临时表。为了解决查询,MySQL需要创建一个临时表来容纳结果。这通常发生在对不同的列集进行ORDER BY上，而不是GROUP BY上。  
    * Using where:WHERE 子句用于限制哪一个行匹配下一个表或发送到客户。  
    * Using sort_union(...), Using union(...), Using intersect(...):这些函数说明如何为index_merge联接类型合并索引扫描。  
    * Using index for group-by:类似于访问表的Using index方式，Using index for group-by表示MySQL发现了一个索引,可以用来查询GROUP BY或DISTINCT查询的所有列,而不要额外搜索硬盘访问实际的表。  

##### Extra分析  


#### 1.4.1.1. explain extended
&emsp; <font color = "red">用explain extended查看执行计划会比explain多一列 filtered。filtered列给出了一个百分比的值，这个百分比值和rows列的值一起使用，可以估计出那些将要和explain中的前一个表进行连接的行的数目。前一个表就是指explain 的 id列的值比当前表的id小的表。</font>  

### 1.4.2. show warnings

&emsp; SHOW WARNINGS显示有关由于当前会话中执行最新的非诊断性语句而导致的条件的信息。  
&emsp; 使用mysql show warnings 避免一些隐式转换。  

<!-- 
explain extended + show warnings
阿里的程序员也不过如此，竟被一个简单的SQL查询难住 
https://mp.weixin.qq.com/s/6jjLv2SIBmh2kjHunxJVYA
-->

### 1.4.3. ~~proceduer analyse()取得建议~~  
&emsp; PROCEDURE ANALYSE() ，在优化表结构时可以辅助参考分析语句。  
&emsp; 使用proceduer analyse()对当前已有应用的表类型的判断，该函数可以对数据表中的列的数据类型（字段类型）提出优化建议（Optimal_fieldtype）。  

```sql
SELECT column_name FROM table_name PROCEDURE ANALYSE();
```

### 1.4.4. profiling  
&emsp; 使用 profiling 命令可以了解 SQL 语句消耗资源的详细信息（每个执行步骤的开销）。  

#### 1.4.4.1. 查看profile开启情况  
```
select @@profiling;
```
&emsp; 返回结果：  

```
mysql> select @@profiling;
+-------------+
| @@profiling |
+-------------+
|           0 |
+-------------+
1 row in set, 1 warning (0.00 sec)
```
&emsp; 0 表示关闭状态，1表示开启  

#### 1.4.4.2. 启用profile  
```
set profiling = 1;  
```
&emsp; 返回结果：  

```
mysql> set profiling = 1;  
Query OK, 0 rows affected, 1 warning (0.00 sec)

mysql> select @@profiling;
+-------------+
| @@profiling |
+-------------+
|           1 |
+-------------+
1 row in set, 1 warning (0.00 sec)
```
&emsp; 在连接关闭后，profiling 状态自动设置为关闭状态。  

#### 1.4.4.3. 查看执行的SQL列表  
```
show profiles;  
```
&emsp; 返回结果：  
```
mysql> show profiles;
+----------+------------+------------------------------+
| Query_ID | Duration   | Query                        |
+----------+------------+------------------------------+
|        1 | 0.00062925 | select @@profiling           |
|        2 | 0.00094150 | show tables                  |
|        3 | 0.00119125 | show databases               |
|        4 | 0.00029750 | SELECT DATABASE()            |
|        5 | 0.00025975 | show databases               |
|        6 | 0.00023050 | show tables                  |
|        7 | 0.00042000 | show tables                  |
|        8 | 0.00260675 | desc role                    |
|        9 | 0.00074900 | select name,is_key from role |
+----------+------------+------------------------------+
9 rows in set, 1 warning (0.00 sec)
```
&emsp; 该命令执行之前，需要执行其他 SQL 语句才有记录。  

#### 1.4.4.4. 查询指定ID的执行详细信息  

```sql
show profile for query Query_ID;
```
&emsp; 返回结果：  

```
mysql> show profile for query 9;
+----------------------+----------+
| Status               | Duration |
+----------------------+----------+
| starting             | 0.000207 |
| checking permissions | 0.000010 |
| Opening tables       | 0.000042 |
| init                 | 0.000050 |
| System lock          | 0.000012 |
| optimizing           | 0.000003 |
| statistics           | 0.000011 |
| preparing            | 0.000011 |
| executing            | 0.000002 |
| Sending data         | 0.000362 |
| end                  | 0.000006 |
| query end            | 0.000006 |
| closing tables       | 0.000006 |
| freeing items        | 0.000011 |
| cleaning up          | 0.000013 |
+----------------------+----------+
15 rows in set, 1 warning (0.00 sec)
```
&emsp; 每行都是状态变化的过程以及它们持续的时间。Status 这一列和 show processlist 的 State 是一致的。因此，需要优化的注意点与上文描述的一样。  

#### 1.4.4.5. 获取CPU、Block IO等信息  

```sql
show profile block io,cpu for query Query_ID;
show profile cpu,block io,memory,swaps,context switches,source for query Query_ID;
show profile all for query Query_ID;
```

---
## 1.5. Sql语句优化  
&emsp; MySql官网提供的优化方案：https://dev.mysql.com/doc/refman/5.7/en/optimization.html  

### 1.5.1. 基本查询优化  
&emsp; **查询结果集优化**  
&emsp; 避免使用select \*。count(1)或count(列)代替count(*)。  

    count(*) 和 count(1)和count(列名)区别：  
    1. 执行效果上： 
        count(*)包括了所有的列，相当于行数，在统计结果的时候，不会忽略列值为NULL  
        count(1)忽略所有列，用1代表代码行，在统计结果的时候，不会忽略列值为NULL  
        count(列名)只包括列名那一列，在统计结果的时候，会忽略列值为空（这里的空不是只空字符串或者0，而是表示null）的计数，即某个字段值为NULL时，不统计。
    
    2. 执行效率上：  
        列名为主键，count(列名)会比count(1)快  
        列名不为主键，count(1)会比count(列名)快  
        如果表多个列并且没有主键，则 count（1） 的执行效率优于 count（*）  
        如果有主键，则 select count（主键）的执行效率是最优的  
        如果表只有一个字段，则 select count（*）最优。

&emsp; **group by优化**  
1. 优化GROUP BY: 提高GROUP BY语句的效率，<font color = "red">可以通过将不需要的记录在GROUP BY之前过滤掉。即联合使用where子句和having子句。</font>  
2. 在默认情况下，MySQL中的GROUP BY语句会对其后出现的字段进行默认排序（非主键情况），就好比使用ORDER BY col1,col2,col3…所以在后面跟上具有相同列（与GROUP BY后出现的col1,col2,col3…相同）ORDER BY子句并没有影响该SQL的实际执行性能。  

&emsp; 那么就会有这样的情况出现，对查询到的结果是否已经排序不在乎时，可以使用ORDER BY NULL禁止排序达到优化目的。下面使用EXPLAIN命令分析SQL。  
&emsp; 在user_1中执行select id, sum(money) form user_1 group by name时，会默认排序（注意group by后的column是非index才会体现group by的排序，如果是primary key，那之前说过了InnoDB默认是按照主键index排好序的）  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/SQL/sql-53.png)  
&emsp; 不禁止排序，即不使用ORDER BY NULL时：有明显的Using filesort。  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/SQL/sql-54.png)  
&emsp; 当使用ORDER BY NULL禁止排序后，Using filesort不存在  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/SQL/sql-55.png)  

&emsp; **Order by优化：**  
<!-- 
MySQL中order by语句的实现原理以及优化手段 
https://mp.weixin.qq.com/s/FykC_mfqJH5oics3wIzBQA
-->
&emsp; MySQL可以使用一个索引来满足ORDER BY子句的排序，而不需要额外的排序，但是需要满足以下几个条件：  
1. WHERE 条件和OREDR BY使用相同的索引：即key_part1与key_part2是复合索引，where中使用复合索引中的key_part1  

    SELECT*FROM user WHERE key_part1=1 ORDER BY key_part1 DESC, key_part2 DESC;
2. 而且ORDER BY顺序和索引顺序相同：  

    SELECT*FROM user ORDER BY key_part1, key_part2;
3. 并且要么都是升序要么都是降序：  

    SELECT*FROM user ORDER BY key_part1 DESC, key_part2 DESC;

&emsp; 但<font color = "lime">以下几种情况则不使用索引</font>：  
1. ORDER BY中混合ASC和DESC：  

    SELECT*FROM user ORDER BY key_part1 DESC, key_part2 ASC;
2. 查询行的关键字与ORDER BY所使用的不相同，即WHERE 后的字段与ORDER BY 后的字段是不一样的  

    SELECT*FROM user WHERE key2 = ‘xxx’ ORDER BY key1;
3. ORDER BY对不同的关键字使用，即ORDER BY后的关键字不相同  
    
    SELECT*FROM user ORDER BY key1, key2;

### 1.5.2. 子查询优化  
&emsp; <font color = "red">使用子查询有时候可以使用更有效的JOIN连接代替，这是因为MySQL中不需要在内存中创建临时表完成SELECT子查询与主查询两部分查询工作。但是并不是所有的时候都成立，最好是在on关键字后面的列有索引的话，效果会更好！</font>  
&emsp; 比如在表major中major_id是有索引的：  

```sql
select * from student u left join major m on u.major_id=m.major_id where m.major_id is null;
```

&emsp; 而通过子查询时，在内存中创建临时表完成SELECT子查询与主查询两部分查询工作，会有一定的消耗  

```sql
select * from student u where major_id not in (select major_id from major);
```

### 1.5.3. 关联查询优化  
1. 在进行多表关联时，多用Where语句把单个表的结果集最小化，多用聚合函数汇总结果集后再与其它表做关联，以使结果集数据量最小化  
......

### 1.5.4. 组合查询优化  
1. MySQL处理UNION的策略是先创建临时表，然后再把各个查询结果插入到临时表中，最后再来做查询。因此很多优化策略在UNION查询中都没有办法很好的时候。经常需要手动将WHERE、LIMIT、ORDER BY等字句“下推”到各个子查询中，以便优化器可以充分利用这些条件先优化。  
2. 如果结果集允许重复的话,使用UNION ALL代替UNION。  

### 1.5.5. INSERT的优化  
1. 尽量使用多个值表的 INSERT 语句，这种方式将大大缩减客户端与数据库之间的连接、关闭等消耗。（同一客户的情况下），即：  

    INSERT INTO tablename values(1,2),(1,3),(1,4)  
2. 如果在不同客户端插入很多行，可使用INSERT DELAYED语句得到更高的速度，DELLAYED含义是让INSERT语句马上执行，其实数据都被放在内存的队列中。并没有真正写入磁盘。LOW_PRIORITY刚好相反。  
3. 将索引文件和数据文件分在不同的磁盘上存放（InnoDB引擎是在同一个表空间的）。  
4. 如果批量插入，则可以增加bluk_insert_buffer_size变量值提供速度（只对MyISAM有用）  
5. 当从一个文本文件装载一个表时，使用LOAD DATA INFILE，通常比INSERT语句快20倍。  

## 1.6. 数据库表结构设计  
### 1.6.1. 选择合适的数据类型  
<!-- 
https://mp.weixin.qq.com/s/IsZjLI7QAB6t7H7NyGscGg
-->
1. 使用可以存下数据最小的数据类型  
2. 使用简单的数据类型。int 要比 varchar 类型在mysql处理简单   
3. 尽量使用 tinyint、smallint、mediumint 作为整数类型而非 int  
4. 尽可能使用 not null 定义字段，因为 null 占用4字节空间  
5. 尽量少用 text 类型，非用不可时最好考虑分表  
6. 尽量使用 timestamp 而非 datetime  
7. 单表不要有太多字段，建议在 20 以内  

### 1.6.2. 表的拆分 
&emsp; 当数据库中的数据非常大时，查询优化方案也不能解决查询速度慢的问题时，可以考虑拆分表，让每张表的数据量变小，从而提高查询效率。  
1. 垂直拆分：将表中多个列分开放到不同的表中。例如用户表中一些字段经常被访问，将这些字段放在一张表中，另外一些不常用的字段放在另一张表中。插入数据时，使用事务确保两张表的数据一致性。  
2. 水平拆分：按照行进行拆分。例如用户表中，使用用户ID，对用户ID取10的余数，将用户数据均匀的分配到0~9的10个用户表中。查找时也按照这个规则查询数据。  

### 1.6.3. 读写分离  
&emsp; 一般情况下对数据库而言都是“读多写少”。换言之，数据库的压力多数是因为大量的读取数据的操作造成的。可以采用数据库集群的方案，使用一个库作为主库，负责写入数据；其他库为从库，负责读取数据。这样可以缓解对数据库的访问压力。  

## 1.7. 系统调优  

<!-- https://mp.weixin.qq.com/s/taJSS2QgLRWXgNnAW5WcsQ-->

### 1.7.1. 查看MySQL服务器运行的状态值  
&emsp; 执行命令：  

```
show status
```
&emsp; 由于返回结果太多，此处不贴出结果。其中，在返回的结果中，主要关注 “Queries”、“Threadsconnected” 和 “Threadsrunning” 的值，即查询次数、线程连接数和线程运行数。

&emsp; 可以通过执行如下脚本监控 MySQL 服务器运行的状态值  

```
#!/bin/bash
while true
do
mysqladmin -uroot -p"密码" ext | awk '/Queries/{q=$4}/Threads_connected/{c=$4}/Threads_running/{r=$4}END{printf("%d %d %d\n",q,c,r)}' >> status.txt
sleep 1
done
```
&emsp; 执行该脚本 24 小时，获取 status.txt 里的内容，再次通过 awk 计算==每秒请求 MySQL 服务的次数==  

```
awk '{q=$1-last;last=$1}{printf("%d %d %d\n",q,$2,$3)}' status.txt
```
&emsp; 复制计算好的内容到 Excel 中生成图表观察数据周期性。  
&emsp; 如果观察的数据有周期性的变化，如上图的解释，需要修改缓存失效策略。  
&emsp; 例如：  
&emsp; 通过随机数在[3,6,9] 区间获取其中一个值作为缓存失效时间，这样分散了缓存失效时间，从而节省了一部分内存的消耗。  
&emsp; 当访问高峰期时，一部分请求分流到未失效的缓存，另一部分则访问 MySQL 数据库，这样减少了 MySQL 服务器的压力。  

### 1.7.2. 服务器参数调优  

#### 1.7.2.1. 内存相关
&emsp; sortbuffersize 排序缓冲区内存大小  
&emsp; joinbuffersize 使用连接缓冲区大小  
&emsp; readbuffersize 全表扫描时分配的缓冲区大小  

#### 1.7.2.2. IO 相关
&emsp; Innodblogfile_size 事务日志大小  
&emsp; Innodblogfilesingroup 事务日志个数  
&emsp; Innodblogbuffer_size 事务日志缓冲区大小  
&emsp; Innodbflushlogattrx_commit 事务日志刷新策略 ，其值如下：  

    0：每秒进行一次 log 写入 cache，并 flush log 到磁盘
    1：在每次事务提交执行 log 写入 cache，并 flush log 到磁盘
    2：每次事务提交，执行 log 数据写到 cache，每秒执行一次 flush log 到磁盘

#### 1.7.2.3. 安全相关
&emsp; expirelogsdays 指定自动清理 binlog 的天数  
&emsp; maxallowedpacket 控制 MySQL 可以接收的包的大小  
&emsp; skipnameresolve 禁用 DNS 查找  
&emsp; read_only 禁止非 super 权限用户写权限  

#### 1.7.2.4. 其他
&emsp; max_connections 控制允许的最大连接数  
&emsp; tmptablesize 临时表大小  
&emsp; maxheaptable_size 最大内存表大小  




