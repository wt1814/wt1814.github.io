<!-- TOC -->

- [1. 递归与动态规划](#1-递归与动态规划)
    - [1.1. 递归](#11-递归)
        - [1.1.1. 什么是递归](#111-什么是递归)
        - [1.1.2. ★★★递归的特点(满足递归的题型)](#112-★★★递归的特点满足递归的题型)
        - [1.1.3. ★★★递归算法通用解决思路](#113-★★★递归算法通用解决思路)
        - [1.1.4. 递归题型](#114-递归题型)
    - [1.2. 动态规划](#12-动态规划)
        - [1.2.1. 动态规划题型](#121-动态规划题型)

<!-- /TOC -->


# 1. 递归与动态规划
## 1.1. 递归  
### 1.1.1. 什么是递归  
&emsp; 递归就是指函数直接或间接的调用自己。递归函数也可以使用栈加循环来实现。  
&emsp; 以阶乘函数为例，如下， 在 factorial 函数中存在着factorial(n - 1) 的调用，所以此函数是递归函数。  

```java
public int factorial(int n) {
    if (n < =1) {
        return 1;
    }
    return n * factorial(n - 1)
}
```
&emsp; 进一步剖析「递归」，先有「递」再有「归」，「递」的意思是将问题拆解成子问题来解决， 子问题再拆解成子子问题，...，直到被拆解的子问题无需再拆分成更细的子问题(即可以求解)，「归」是说最小的子问题解决了，那么它的上一层子问题也就解决了，上一层的子问题解决了，上上层子问题自然也就解决了，....，直到最开始的问题解决，文字说可能有点抽象，那就以阶层 f(6) 为例来看下它的「递」和「归」。  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/function/function-43.png)  
&emsp; 求解问题 f(6)， 由于 f(6) = n * f(5)， 所以 f(6) 需要拆解成 f(5) 子问题进行求解，同理 f(5) = n * f(4) ，也需要进一步拆分，... ，直到 f(1)， 这是「递」，f(1) 解决了，由于 f(2) =  2 f(1) = 2 也解决了，.... f(n)到最后也解决了，这是「归」，所以递归的本质是能把问题拆分成具有相同解决思路的子问题，...直到最后被拆解的子问题再也不能拆分，解决了最小粒度可求解的子问题后，在「归」的过程中自然顺其自然地解决了最开始的问题。  

### 1.1.2. ★★★递归的特点(满足递归的题型)
&emsp; 在上一节仔细剖析了什么是递归， **<font color = "clime">可以发现递归有以下两个特点：</font>**  

1. 一个问题可以分解成具有相同解决思路的子问题，子子问题，换句话说这些问题都能调用同一个函数  
2. 经过层层分解的子问题最后一定是有一个不能再分解的固定值的(即终止条件)，如果没有的话，就无穷无尽地分解子问题了，问题显然是无解的。  

&emsp; 所以解递归题的关键在于首先需要根据以上递归的两个特点判断题目是否可以用递归来解。  

-------------

&emsp; **递归的特点(满足递归的条件、递归解题的关键)：**  
1. 一个问题的解可以分解为几个子问题的解；
2. 这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样；
3. 存在递归终止条件，即必须有一个明确的递归结束条件，称之为递归出口。

### 1.1.3. ★★★递归算法通用解决思路
&emsp; 经过判断可以用递归后，接下来我们就来看看用递归解题的基本套路(四步曲)：  

1. 先定义一个函数，明确这个函数的功能，由于递归的特点是问题和子问题都会调用函数自身，所以这个函数的功能一旦确定了， 之后只要找寻问题与子问题的递归关系即可
2. 接下来寻找问题与子问题间的关系(即递推公式)，这样由于问题与子问题具有相同解决思路，只要子问题调用步骤 1 定义好的函数，问题即可解决。所谓的关系最好能用一个公式表示出来，比如 f(n) = n * f(n-) 这样，如果暂时无法得出明确的公式，用伪代码表示也是可以的， 发现递推关系后，要寻找最终不可再分解的子问题的解，即(临界条件)，确保子问题不会无限分解下去。由于第一步我们已经定义了这个函数的功能，所以当问题拆分成子问题时，子问题可以调用步骤 1 定义的函数，符合递归的条件(函数里调用自身)
3. 将第二步的递推公式用代码表示出来补充到步骤 1 定义的函数中
4. 最后也是很关键的一步，根据问题与子问题的关系，推导出时间复杂度，如果发现递归时间复杂度不可接受，则需转换思路对其进行改造，看下是否有更靠谱的解法


&emsp; **如何写递归代码？**  
1. 找到如何将大问题分解为小问题的规律
2. 通过规律写出递推公式
3. 通过递归公式的临界点推敲出终止条件
4. 将递推公式和终止条件翻译成代码

### 1.1.4. 递归题型  
<!-- 
Java递归实现字符串的排列和组合
https://mp.weixin.qq.com/s?__biz=MzA5NDIwNTk2Mw==&mid=2247484636&amp;idx=1&amp;sn=9ea705d330e7955c83dcfc3d6a7f90d0&source=41#wechat_redirect
一文学会递归解题
https://mp.weixin.qq.com/s/LQRrZbWW_UJQrxMLOj-s8w
为什么你学不会递归？告别递归，谈谈我的一些经验
https://mp.weixin.qq.com/s/RkYTtHYghiK8LNUnlWUrlg
数据结构与算法之递归系列
https://mp.weixin.qq.com/s/2gL7s8T6vjYQwwz_4UDy4g
一文学会排列组合 
https://mp.weixin.qq.com/s?__biz=MzI5MTU1MzM3MQ==&mid=2247483857&idx=1&sn=c4fbb9d55a656aac55c4976c48879c45&scene=21#wechat_redirect
-->
&emsp; 输入一个正整数n，输出n!的值。其中n!=123*…*n，即求阶乘  
&emsp; 套用上一节说的递归四步解题套路来看看怎么解  

1. 定义这个函数，明确这个函数的功能，我们知道这个函数的功能是求 n 的阶乘， 之后求 n-1， n-2 的阶乘就可以调用此函数了

```java
/**
 * 求 n 的阶乘
 */
public int factorial(int n) {
}
```
2. 寻找问题与子问题的关系 阶乘的关系比较简单， 以 f(n) 来表示 n 的阶乘， 显然 f(n) = n * f(n - 1)，  同时临界条件是 f(1) = 1，即
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/function/function-44.png)  
3. 将第二步的递推公式用代码表示出来补充到步骤 1 定义的函数中

```java
/**
 * 求 n 的阶乘
 */
public int factorial(int n) {
    // 第二步的临界条件
    if (n < =1) {
        return 1;
    }

    // 第二步的递推公式
    return n * factorial(n-1)
}
```
4. 求时间复杂度 由于  f(n) = n * f(n-1) = n * (n-1) * .... * f(1)，总共作了 n 次乘法，所以时间复杂度为 n。  


## 1.2. 动态规划  
<!-- 
不会动态规划，如何做出这道动态规划题？ 
https://mp.weixin.qq.com/s/2SWKifZJ3Gf1s5L2xBDJtg
这才是真正的状态压缩动态规划好不好！！！ 
https://mp.weixin.qq.com/s/H2V3D0DMPbT8hQW9Cq6LjQ
一文学会动态规划解题技巧
https://mp.weixin.qq.com/s?__biz=MzI5MTU1MzM3MQ==&mid=2247483932&idx=1&sn=d9cd9d5a5ebf5f31e23f11c82b6465f1&scene=21#wechat_redirect

动态规划题型：


爬台阶问题：

国王和金矿问题：

KMP算法，字符串匹配：
动态规划之 KMP 算法详解(配代码版) 
https://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&mid=2247486490&idx=3&sn=35ba410818207a1bef83d6578f4b332c&chksm=fa0e639bcd79ea8dff1141a8729cf4b1243d23ac276652a58fc23d7b6b2ce01ca2666feab293&mpshare=1&scene=1&srcid=&sharer_sharetime=1569055567478&sharer_shareid=b256218ead787d58e0b58614a973d00d&key=20f7b87cb3d4d9a8e94f75ad1bbd1fe8ed4af91513a424bebd0c4df328ea367a462e742f0885a4dbf9693a65560f764378ab2da5e0d620daa8cd627756a8d79b7b364eb9ccf4a8629e46dad4de38545d&ascene=1&uin=MTE1MTYxNzY2MQ%3D%3D&devicetype=Windows+10&version=62060844&lang=zh_CN&pass_ticket=l152qY7UDy13%2FQ8lMQftZpzwON66UoS8zNnRNqU0gQ1B38kfpkeCoh6I%2F0Cu%2FOwX

字符串匹配的KMP算法 
https://mp.weixin.qq.com/s?__biz=MzIwNTc4NTEwOQ==&mid=2247486950&idx=1&sn=61185c72b270891a0e1aa0db1f9a627f&chksm=972adc9ca05d558a3d5e8a505b29937768e6f47b6c318bc6cc478803d9634e2f4555c26179f9&mpshare=1&scene=1&srcid=&key=00a8e91eefd868fc0218770ad47efc19a0eb1837e26a2fde21a4e6ae367993f51dcfd216c2397954d6a4de33fa5f65dd63b8b620d6e981902b0f9ace3bbbf335784449a15c08450df602e9229d6857de&ascene=1&uin=MTE1MTYxNzY2MQ%3D%3D&devicetype=Windows+10&version=62060833&lang=zh_CN&pass_ticket=eg5OolRG8y0%2Bw9bavl09Uyc6GPxVmhjvDrWe622XQSg9XG10VZWa9GR31nV6T9cV
-->

&emsp; **动态规划与分治：**  
&emsp; 分治策略：将原问题分解为若干个规模较小但类似于原问题的子问题(Divide)，递归的求解这些子问题(Conquer)，然后再合并这些子问题的解来建立原问题的解。  
&emsp; 因为在求解大问题时，需要递归的求小问题，因此一般用递归的方法实现，即自顶向下。  
&emsp; 动态规划：动态规划其实和分治策略是类似的，也是将一个原问题分解为若干个规模较小的子问题，递归的求解这些子问题，然后合并子问题的解得到原问题的解。  
&emsp; <font color = "red">动态规划和分治策略的区别在于这些子问题会有重叠，一个子问题在求解后，可能会再次求解，可以将这些子问题的解存储起来，当下次再次求解这个子问题时，直接取过来用。</font>  

&emsp; **从递归到动态规划：**  
&emsp; 递归采用自顶向下的运算，比如：f(n) 是f(n-1)与f(n-2)相加，f(n-1) 是f(n-2)与f(n-3)相加。  
&emsp; 如果反过来，采取自底向上，用迭代的方式进行推导，则是动态规划。  

&emsp; **详解动态规划：**  
&emsp; 动态规划求解最值问题。动态规划实质是求最优解，不过很多题目是简化版，只要求返回最大值/最小值。最优解问题是指问题通常有多个可行解，需要从这些可行解中找到一个最优的可行解。  
&emsp; 动态规划中包含三个重要的概念：最优子结构( f(10) =f(9)+f(8) )、边界( f(1) 与 f(2) )、状态转移公式( f(n) =f(n-1)+f(n-2) )。  

### 1.2.1. 动态规划题型  
<!-- 
最长公共子串
https://mp.weixin.qq.com/s/0Mhe1NAZJIewbVy6A0HE4Q

-->

