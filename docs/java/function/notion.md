
<!-- TOC -->

- [1. 算法基本概念](#1-算法基本概念)
    - [1.1. 数据结构](#11-数据结构)
        - [1.1.1. 逻辑结构和物理结构](#111-逻辑结构和物理结构)
        - [1.1.2. 常用结构](#112-常用结构)
    - [1.2. 算法的好坏，时间复杂度和空间复杂度](#12-算法的好坏时间复杂度和空间复杂度)
        - [1.2.1. 时间复杂度](#121-时间复杂度)
        - [1.2.2. 空间复杂度](#122-空间复杂度)
    - [1.3. 算法分类](#13-算法分类)

<!-- /TOC -->

# 1. 算法基本概念

## 1.1. 数据结构  
&emsp; 不同的算法会选用不同的数据结构。例如排序算法中的堆排序，利用的是二叉堆这样一种数据结构；再如缓存淘汰算法LRU(最近最少使用)，利用的是哈希链表。 

    算法就是对数据结构的增删改查。学习数据结构时，它本身的一些增删改查运算；增删改查归根结底是对数据的查找、排序。

### 1.1.1. 逻辑结构和物理结构  
&emsp; <font color = "lime">数据结构分为逻辑结构和物理结构。</font>  
1. 逻辑结构：指反映数据元素之间的逻辑关系的数据结构，其中的逻辑关系是指数据元素之间的前后件关系，而与它们在计算机中的存储位置无关。<font color = "red">逻辑结构包括集合、线性结构、树形结构、图形结构。</font>  

    * 集合：数据结构中的元素之间除了“同属一个集合”的相互关系外，无其他关系；  
    * 线性结构：数据结构中的元素存在一对一的相互关系；  
    * 树形结构：数据结构中的元素存在一对多的相互关系；  
    * 图形结构：数据结构中的元素存在多对多的相互关系。  

2. 物理结构：又叫存储结构，指数据的逻辑结构在计算机存储空间的存放形式。  
&emsp; 通俗的讲，物理结构研究的是数据在存储器中存放的形式。存储器主要针对于内存而言，像硬盘、软盘、光盘等外部存储器的数据组织通常用文件结构来描述。  
&emsp; <font color = "red">物理结构有顺序、链接、索引、散列等多种。同一种逻辑结构可采用不同的存储方法(顺序存储结构与链式存储结构之一或组合)，这主要考虑的是运算方便及算法的时空要求。</font>  

    * 顺序存储：该方法把逻辑上相邻的结点存储在物理位置上相邻的存储单元中，结点之间的逻辑关系由存储单元的邻接关系来体现。数组是顺序存储结构的典型代表。  
    * 链式存储：该方法不要求逻辑上相邻的结点在物理位置上也相邻，结点间的逻辑关系是由附加的指针字段表示的。由此得到的存储结构表示称为链式存储结构。  
    * 索引存储：该方法在存储结点信息时建立除了建立存储结点信息外，还建立附加的索引表来标识结点的地址。索引项的一般形式为<关键字，地址>。关键字标识唯一一个结点，地址作为指向结点的指针。  
    * 散列存储：该方法根据结点的关键字通过散列函数直接计算出该节点的存储地址。这种方法本质上是对顺序存储方法的扩展。  

### 1.1.2. 常用结构  
&emsp; 在Java编程语言中，最基本的结构就是两种，一种是数组，一种是模拟指针(引用/链表)，所有的数据结构都可以用这两个基本结构构造。<font color = "lime">数组与链表属于物理结构；</font><font color = "red">栈、队列、树等属于逻辑结构，实现方式有数组和链表两种方式。</font>  

* 数组：在程序设计中，为了处理方便，把具有相同类型的若干变量按有序的形式组织起来。这些按序排列的同类数据元素的集合称为数组。  
* 链表：链表是一种物理存储单元上非连续、非顺序的存储结构，它既可以表示线性结构，也可以用于表示非线性结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列结点(链表中每一个元素称为结点)组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。  
* 栈：栈是只能在某一端插入和删除的特殊线性表。它按照先进后出的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据(最后一个数据被第一个读出来)。  
* 队列：一种特殊的线性表，它只允许在表的前端(front)进行删除操作，而在表的后端(rear)进行插入操作。进行插入操作的端称为队尾，进行删除操作的端称为队头。队列是按照“先进先出”或“后进后出”的原则组织数据的。队列中没有元素时，称为空队列。  
* 树：树是包含n(n>0)个结点的有穷集合K，且在K中定义了一个关系N，N满足以下条件：  
    1. 有且仅有一个结点K0，它对于关系N来说没有前驱，称K0为树的根结点。简称为根(root)。
    2. 除K0外，K中的每个结点，对于关系N来说有且仅有一个前驱。  
    3. K中各结点，对关系N来说可以有m个后继(m>=0)。  
* 图：图是由结点的有穷集合V和边的集合E组成。其中，为了与树形结构加以区别，在图结构中常常将结点称为顶点，边是顶点的有序偶对，若两个顶点之间存在一条边，就表示这两个顶点具有相邻关系。  
* 堆：在计算机科学中，**堆是一种特殊的树形数据结构，**每个结点都有一个值。通常所说的堆的数据结构，是指二叉堆。堆的特点是根结点的值最小(或最大)，且根结点的两个子树也是一个堆。  
* 散列表：若结构中存在关键字和K相等的记录，则必定在f(K)的存储位置上。由此，不需比较便可直接取得所查记录。称这个对应关系f为散列函数(Hash function)，按这个思想建立的表为散列表。  

<!-- 

数组(Array)
数组是一种聚合数据类型，它是将具有相同类型的若干变量有序地组织在一起的集合。数组可以说是最基本的数据结构，在各种编程语言中都有对应。一个数组可以分解为多个数组元素，按照数据元素的类型，数组可以分为整型数组、字符型数组、浮点型数组、指针数组和结构数组等。数组还可以有一维、二维以及多维等表现形式。 
栈( Stack)
栈是一种特殊的线性表，它只能在一个表的一个固定端进行数据结点的插入和删除操作。栈按照后进先出的原则来存储数据，也就是说，先插入的数据将被压入栈底，最后插入的数据在栈顶，读出数据时，从栈顶开始逐个读出。栈在汇编语言程序中，经常用于重要数据的现场保护。栈中没有数据时，称为空栈。 [5] 
队列(Queue)
队列和栈类似，也是一种特殊的线性表。和栈不同的是，队列只允许在表的一端进行插入操作，而在另一端进行删除操作。一般来说，进行插入操作的一端称为队尾，进行删除操作的一端称为队头。队列中没有元素时，称为空队列。 [5] 
链表( Linked List)
链表是一种数据元素按照链式存储结构进行存储的数据结构，这种存储结构具有在物理上存在非连续的特点。链表由一系列数据结点构成，每个数据结点包括数据域和指针域两部分。其中，指针域保存了数据结构中下一个元素存放的地址。链表结构中数据元素的逻辑顺序是通过链表中的指针链接次序来实现的。 [5] 
树( Tree)
树是典型的非线性结构，它是包括，2个结点的有穷集合K。在树结构中，有且仅有一个根结点，该结点没有前驱结点。在树结构中的其他结点都有且仅有一个前驱结点，而且可以有两个后继结点，m≥0。 [5] 
图(Graph)
图是另一种非线性数据结构。在图结构中，数据结点一般称为顶点，而边是顶点的有序偶对。如果两个顶点之间存在一条边，那么就表示这两个顶点具有相邻关系。

堆(Heap)
堆是一种特殊的树形数据结构，一般讨论的堆都是二叉堆。堆的特点是根结点的值是所有结点中最小的或者最大的，并且根结点的两个子树也是一个堆结构。 

散列表(Hash)
散列表源自于散列函数(Hash function)，其思想是如果在结构中存在关键字和T相等的记录，那么必定在F(T)的存储位置可以找到该记录，这样就可以不用进行比较操作而直接取得所查记录。
-->

## 1.2. 算法的好坏，时间复杂度和空间复杂度  
<!-- 
算法复杂度：
时间复杂度：算法的时间复杂度是指执行算法所需要的计算工作量。一般来说，计算机算法是问题规模n的函数f(n)，算法的时间复杂度也因此记做。T(n)=
Ο(f(n))。因此，问题的规模n越大，算法执行的时间的增长率与f(n) 的增长率正相关，称作渐进时间复杂度(Asymptotic Time Complexity)。
空间复杂度：算法的空间复杂度是指算法需要消耗的内存空间。其计算和表示方法与时间复杂度类似，一般都用复杂度的渐近性来表示。同时间复杂度相比，空间复杂度的分析要简单得多。
-->
&emsp; 运行时间的长短和占用内存空间的大小，是衡量程序好坏的重要因素。时间复杂度是执行算法的时间成本，空间复杂度是执行算法的空间成本。  

### 1.2.1. 时间复杂度  
&emsp; 一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为语句频度或时间频度。记为T(n)。  
&emsp; 在刚才提到的时间频度中，n称为问题的规模，当n不断变化时，时间频度T(n)也会不断变化。但有时想知道它变化时呈现什么规律。为此，引入时间复杂度概念。  
&emsp; 一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n)，使得当n趋近于无穷大时，T(n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=O(f(n))，称O(f(n))为算法的渐进时间复杂度，简称时间复杂度。  
&emsp; 有时候，算法中基本操作重复执行的次数还随问题的输入数据集不同而不同，如在冒泡排序中，输入数据有序而无序，其结果是不一样的。此时，计算平均值。  
&emsp; 常见的算法的时间 复杂度之间的关系为：  
&emsp; O(1)<O(logn)<O(n)<O(nlog n)<O(n2)<O(2n)<O(n!)<O(nn)   
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/function/function-25.png)  
&emsp; 对于罗列的复杂度量级，可以粗略地分为两类，多项式量级和非多项式量级。其中，非多项式量级只有两个：O(2n)和O(n!)。  
&emsp; 实例1  

```java
sum=0;                  //(1)
for(i=1;i<=n;i++)      //(2)
    for(j=1;j<=n;j++)   //(3)
        sum++;         //(4)
```
&emsp; 语句(1)执行1次，语句(2)执行n次，语句(3)执行n^2次，语句(4)执行n^2次。T(n) = 1+n+2*n^2= O(n^2)   
&emsp; 实例2    
```java
a=0; b=1;             //(1)
for (i=1;i<=n;i++){   //(2)
    s=a+b;　　　　    //(3)
    b=a;　　　　　    //(4) 
    a=s;　　　　　    //(5)
}  
```
&emsp; 语句(1)的频度是1，设语句2的频度是f(n)，则：2f(n)<=n;f(n)<=log2n。
&emsp; 取最大值f(n)= log2n，T(n)=O(log2n)。 

### 1.2.2. 空间复杂度  
&emsp; 在运行一段程序时，不仅要执行各种运算指令，同时也会根据需要，存储一些临时的中间数据，以便后续指令可以更方便的执行。  
<!--
空间复杂度：算法所需存储空间的度量，记作：S(n)=O( f(n) )，其中n为问题的规模。
一个算法在计算机存储器上所占用的存储空间，包括存储算法本身所占用的存储空间，算法的输入输出数据所占用的存储空间和算法在运行过程中临时占用的存储空间这三个方面。如果额外空间相对于输入数据量来说是个常数，则称此算法是原地工作。
算法的输入输出数据所占用的存储空间是由要解决的问题决定的，是通过参数表由调用函数传递而来的，它不随本算法的不同而改变。存储算法本身所占用的存储空间与算法书写的长短成正比，要压缩这方面的存储空间，就必须编写出较短的算法。
-->

## 1.3. 算法分类  
&emsp; 算法可以应用在很多不同的领域中，应用场景更是多种多样。大致可以分为数据结构的算法、排序算法、查找算法、动态规划算法(最优决策)......  
&emsp; 算法可以宏泛的分为三类：  
&emsp; 1).有限的，确定性算法。这类算法在有限的一段时间内终止。可能要花很长时间来执行指定的任务，但仍将在一定的时间内终止。这类算法得出的结果常取决于输入值。  
&emsp; 2).有限的，非确定算法。这类算法在有限的时间内终止。然而，对于一个(或一些)给定的数值，算法的结果并不是唯一的或确定的。  
&emsp; 3).无限的算法。是那些由于没有定义终止定义条件，或定义的条件无法由输入的数据满足而不终止运行的算法。通常，无限算法的产生是由于未能确定的定义终止条件。  
