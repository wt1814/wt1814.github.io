

<!-- TOC -->

- [1. 排序算法](#1-排序算法)
    - [1.1. 排序算法分类](#11-排序算法分类)
    - [1.2. 排序算法总结](#12-排序算法总结)

<!-- /TOC -->

# 1. 排序算法

<!-- 
~~
10 大经典排序算法
https://mp.weixin.qq.com/s/02fgxkMYZl7jdg9NGAP5YA
-->

## 1.1. 排序算法分类  
&emsp; 排序算法分类：  
* 根据待排序的数据量规模分类：  
    * 内部排序：在排序过程中，待排序的数据能够被全部加载进内存中。常见的内部排序算法有：冒泡排序、快速排序；选择排序、堆排序；插入排序、希尔排序；归并排序；基数排序等。
    * [外部排序](/docs/java/function/sort/externalSort.md)：待排序的数据太大，不能全部同时放入内存，排序过程中需要内存与外部存储交换数据。  

    内部排序是数据记录在内存中进行排序。而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。  

* <font color = "red">是否采用比较思想</font>：  
    * [比较排序](/docs/java/function/sort/compare.md)：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序。    
    * [非比较排序](/docs/java/function/sort/noCompare.md)：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。   

    &emsp; **比较和非比较的区别：**  


* <font color = "red">基于算法思想分类</font>：
    * 基于交换：冒泡排序、快速排序  
    * 基于选择：选择排序、堆排序  
    * 基于插入：插入排序、希尔排序  
    * 基于分治：快速排序、归并排序  

* 根据排序时间复杂度分类：  
    * O(N)：桶排序、计数排序、基数排序  
    * O(NlogN)：快速排序、希尔排序、归并排序、堆排序  
    * O(N*N)：冒泡排序、插入排序、选择排序  

* 根据排序的稳定性进行分类：  

        稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。
        不稳定：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。
    
    * 稳定性排序：冒泡排序、插入排序、归并排序  
    * 不稳定排序：快速排序、选择排序、希尔排序、堆排序  


## 1.2. 排序算法总结  

|排序算法|	平均时间复杂度|	最好|	最坏|	空间复杂度|	稳定性|
|---|---|---|---|---|---|
|冒泡排序|	|O(n^2)	|O(n)|	|O(n^2)	|O(1)	|稳定|
|快速排序|	O(nlogn)|	O(nlogn)|	O(n^2)	|O(logn)|	不稳定|
|插入排序|	O(n^2)|	O(n)|	O(n^2)	|O(1)	|稳定|
|希尔排序|	O(n^1.3)|	O(n)|	O(nlog2n)	|O(1)	|不稳定|
|选择排序|	O(n^2)|	O(n^2)	|O(n^2)	|O(1)	|不稳定|
|堆排序	|O(nlogn)|	O(nlogn)	|O(nlogn)|	O(1)|	不稳定|
|归并排序|	O(nlogn)|	O(nlogn)|	O(nlogn)	|O(n)	|稳定|
|桶排序	|O(n+k)	|O(n+k)	|O(n+k)	|O(n+k)	|稳定|
|计数排序|	O(n+k)|	O(n+k)|	O(n+k)	|O(k)	|稳定|
|基数排序|	O(n*k)|	O(n*k)|	O(n*k)	|O(n+k)|	稳定|