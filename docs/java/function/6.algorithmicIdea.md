

<!-- TOC -->

- [1. 算法](#1-算法)
    - [1.1. 递归](#11-递归)
        - [1.1.1. 递归题型](#111-递归题型)
    - [1.2. 动态规划](#12-动态规划)
        - [1.2.1. 动态规划题型](#121-动态规划题型)
    - [1.3. 缓存LRU算法](#13-缓存lru算法)
        - [1.3.1. 基于哈希链表的LRU实现](#131-基于哈希链表的lru实现)

<!-- /TOC -->

# 1. 算法  


## 1.1. 递归  

![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/function/function-5.png)  

&emsp; 递归就是指函数直接或间接的调用自己。递归函数也可以使用栈加循环来实现。  

&emsp; **递归的特点（满足递归的条件、递归解题的关键）：**  
1. 一个问题的解可以分解为几个子问题的解；
2. 这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样；
3. 存在递归终止条件，即必须有一个明确的递归结束条件，称之为递归出口。

&emsp; **如何写递归代码？**  
1. 找到如何将大问题分解为小问题的规律
2. 通过规律写出递推公式
3. 通过递归公式的临界点推敲出终止条件
4. 将递推公式和终止条件翻译成代码

### 1.1.1. 递归题型  
......

## 1.2. 动态规划  
&emsp; **动态规划与分治：**  
&emsp; 分治策略：  
&emsp;将原问题分解为若干个规模较小但类似于原问题的子问题（Divide），递归的求解这些子问题（Conquer），然后再合并这些子问题的解来建立原问题的解。  
&emsp; 因为在求解大问题时，需要递归的求小问题，因此一般用递归的方法实现，即自顶向下。  

&emsp; 动态规划：  
&emsp; 动态规划其实和分治策略是类似的，也是将一个原问题分解为若干个规模较小的子问题，递归的求解这些子问题，然后合并子问题的解得到原问题的解。  
&emsp; <font color = "red">动态规划和分治策略的区别在于这些子问题会有重叠，一个子问题在求解后，可能会再次求解，可以将这些子问题的解存储起来，当下次再次求解这个子问题时，直接取过来用。</font>  

&emsp; **从递归到动态规划：**  
&emsp; 递归采用自顶向下的运算，比如：f(n) 是f(n-1)与f(n-2)相加，f(n-1) 是f(n-2)与f(n-3)相加。  
&emsp; 如果反过来，采取自底向上，用迭代的方式进行推导，则是动态规划。  

&emsp; **详解动态规划：**  
&emsp; 动态规划求解最值问题。动态规划实质是求最优解，不过很多题目是简化版，只要求返回最大值/最小值。最优解问题是指问题通常有多个可行解，需要从这些可行解中找到一个最优的可行解。  
&emsp; 动态规划中包含三个重要的概念：最优子结构（ f(10) =f(9)+f(8) ）、边界（ f(1) 与 f(2) ）、状态转移公式（ f(n) =f(n-1)+f(n-2) ）。  

### 1.2.1. 动态规划题型  



---


## 1.3. 缓存LRU算法  
&emsp; LRU是Least Recently Used的缩写，即最近最少使用。选择最近最久未使用的数据删除。  
&emsp; LRU Cache具备的操作：  
1. put(key, val) 方法插入新的或更新已有键值对，如果缓存已满的话，要删除那个最久没用过的键值对以腾出位置插入。  
2. get(key) 方法获取 key 对应的 val，如果 key 不存在则返回 -1。  

### 1.3.1. 基于哈希链表的LRU实现    
&emsp; **<font color = "red">LRU缓存算法的核心数据结构就是哈希链表，双向链表和哈希表的结合体。哈希表查找快，但是数据无固定顺序；链表有顺序之分，插入删除快，但是查找慢。</font>**  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/function/function-4.png)  

&emsp; LRU算法实现：  
&emsp; 方式一：  

```java
import java.util.LinkedHashMap;
import java.util.Map;

public class LRUCache3<K, V> {
    /**
     * 最大缓存大小
     */
    private int cacheSize;
    private LinkedHashMap<K, V> cacheMap;

    public LRUCache3(int cacheSize) {
        this.cacheSize = cacheSize;
        cacheMap = new LinkedHashMap(16, 0.75F, true) {
            @Override
            protected boolean removeEldestEntry(Map.Entry eldest) {
                if (cacheSize + 1 == cacheMap.size()) {
                    return true;
                } else {
                    return false;
                }
            }
        };
    }

    public void put(K key, V value) {
        cacheMap.put(key, value);
    }

    public V get(K key) {
        return cacheMap.get(key);
    }
}
```  


&emsp; 手写LRU算法    
&emsp; 基于LinkedHashMap实现一个简单版本的LRU算法。  

```java
class LRUCache<K, V> extends LinkedHashMap<K, V> {
    private final int CACHE_SIZE;
    /**
     * @param cacheSize 缓存大小
     */
    // true表示让linkedHashMap按照访问顺序来进行排序，最近访问的放在头部，最老访问的放在尾部。
    public LRUCache(int cacheSize) {
        super((int) Math.ceil(cacheSize / 0.75) + 1, 0.75f, true);
        CACHE_SIZE = cacheSize;
    }

    @Override
    // 当map中的数据量大于指定的缓存个数的时候，就自动删除最老的数据。
    protected boolean removeEldestEntry(Map.Entry<K, V> eldest) {
        return size() > CACHE_SIZE;
    }
}
```

```java
public class LRUCache<k, v> {
    //容量
    private int capacity;
    //当前有多少节点的统计
    private int count;
    //缓存节点
    private Map<k, node> nodeMap;
    private Node head;
    private Node tail;

    public LRUCache(int capacity) {
        if (capacity < 1) {
            throw new IllegalArgumentException(String.valueOf(capacity));
        }
        this.capacity = capacity;
        this.nodeMap = new HashMap<>();
        //初始化头节点和尾节点，利用哨兵模式减少判断头结点和尾节点为空的代码
        Node headNode = new Node(null, null);
        Node tailNode = new Node(null, null);
        headNode.next = tailNode;
        tailNode.pre = headNode;
        this.head = headNode;
        this.tail = tailNode;
    }

    public void put(k key, v value) {
        Node node = nodeMap.get(key);
        if (node == null) {
            if (count >= capacity) {
                //先移除一个节点
                removeNode();
            }
            node = new Node<>(key, value);
            //添加节点
            addNode(node);
        } else {
            //移动节点到头节点
            moveNodeToHead(node);
        }
    }

    public Node get(k key) {
        Node node = nodeMap.get(key);
        if (node != null) {
            moveNodeToHead(node);
        }
        return node;
    }

    private void removeNode() {
        Node node = tail.pre;
        //从链表里面移除
        removeFromList(node);
        nodeMap.remove(node.key);
        count--;
    }

    private void removeFromList(Node node) {
        Node pre = node.pre;
        Node next = node.next;

        pre.next = next;
        next.pre = pre;

        node.next = null;
        node.pre = null;
    }

    private void addNode(Node node) {
        //添加节点到头部
        addToHead(node);
        nodeMap.put(node.key, node);
        count++
    }

    private void addToHead(Node node) {
        Node next = head.next;
        next.pre = node;
        node.next = next;
        node.pre = head;
        head.next = node;
    }

    public void moveNodeToHead(Node node) {
        //从链表里面移除
        removeFromList(node);
        //添加节点到头部
        addToHead(node);
    }

    class Node<k, v> {
        k key;
        v value;
        Node pre;
        Node next;

        public Node(k key, v value) {
            this.key = key;
            this.value = value;
        }
    }
}
```



