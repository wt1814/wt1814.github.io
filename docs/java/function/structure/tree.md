

<!-- TOC -->

- [1. 树](#1-树)
    - [1.1. 二叉树](#11-二叉树)
    - [1.2. 红黑树](#12-红黑树)
    - [1.3. B-树、B+树](#13-b-树b树)

<!-- /TOC -->

<!--
AVL树
https://mp.weixin.qq.com/s/7MJWagl_L-ZFlLtKdJwbFQ

-->

# 1. 树  
## 1.1. 二叉树  
&emsp; 二叉树有两种特殊形式，一个叫满二叉树，一个叫完全二叉树。  

&emsp; **二叉树的实现：**  
&emsp; 二叉树即可以用数组实现，也可以用链表实现。  
&emsp; 二叉树一般使用链表实现；二叉堆，一种特殊的完全二叉树，使用数组来操作。  

&emsp; **二叉树的遍历：**  
&emsp; 二叉树的遍历方式有深度优先遍历、广度优先遍历。  

&emsp; **二叉树的应用：**  
&emsp; 二叉树包含许多特殊的形式，每一种形式都有自己的应用。但是其最主要的应用还在于进行查找操作和维持相对顺序这两个方面。有一种特殊的二叉树叫做**二叉查找树或二叉排序树**。  
&emsp; 二叉查找树有可能退化成一个链表，可以采用自平衡方式优化结构。<font color = "red">二叉树自平衡的方式有多种，如红黑树、平衡二叉树（AVL）。</font>  

## 1.2. 红黑树  
&emsp; 红黑树是一种近似平衡的二叉查找树。在每个节点增加一个存储位表示节点的颜色，可以是红或黑（非红即黑）。其主要的优点就是“平衡“，即左右子树高度几乎一致，以此来防止树退化为链表，通过这种方式来保障查找的时间复杂度为 log(n)。  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/function/function-6.png)  

&emsp; **红黑树主要有以下几个特性：**  
1. 每个节点要么是红色，要么是黑色，但根节点永远是黑色的；  
2. 每个红色节点的两个子节点一定都是黑色；  
3. 红色节点不能连续（也即是，红色节点的孩子和父亲都不能是红色）；  
4. 从任一节点到其子树中每个叶子节点的路径都包含相同数量的黑色节点；  
5. 所有的叶节点都是是黑色的（注意这里说叶子节点其实是上图中的 NIL 节点）；  

&emsp; 在树的结构发生改变时（插入或者删除操作），往往会破坏上述条件3或条件 4，需要通过调整使得查找树重新满足红黑树的条件。  

&emsp; **红黑树与平衡二叉树的区别：**
1. 红黑树放弃了追求完全平衡，<font color = "red">追求大致平衡</font>，在与平衡二叉树的时间复杂度相差不大的情况下，<font color = "lime">保证每次插入最多只需要三次旋转就能达到平衡</font>，实现起来也更为简单。  
2. 平衡二叉树追求绝对平衡，条件比较苛刻，实现起来比较麻烦，每次插入新节点之后需要旋转的次数不能预知。  
3. 红黑树和AVL树的区别在于它使用颜色来标识结点的高度，它所追求的是局部平衡而不是AVL树中的非常严格的平衡。  
4. 红黑树是牺牲了严格的高度平衡的优越条件为代价，红黑树能够以O(log2 n)的时间复杂度进行搜索、插入、删除操作。  
5. 红黑树的算法时间复杂度和AVL相同，但统计性能比AVL树更高。  

## 1.3. B-树、B+树   






