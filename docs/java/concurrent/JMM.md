

<!-- TOC -->

- [1. JMM](#1-jmm)
    - [1.1. 计算机内存模型介绍](#11-计算机内存模型介绍)
    - [1.2. JMM中内存划分](#12-jmm中内存划分)
    - [1.3. 线程间的通信过程](#13-线程间的通信过程)
    - [1.4. JMM内存间的交互操作](#14-jmm内存间的交互操作)

<!-- /TOC -->

![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/concurrent/multi-10.png)  

# 1. JMM  

<!--
CPU缓存一致性协议
https://mp.weixin.qq.com/s/yWifJmirZNnBrAIZrpJwyg
https://blog.csdn.net/w1453114339/article/details/107563613
https://mp.weixin.qq.com/s/0_TDPDx8q2HmKCMyupWuNA
看懂这篇，才能说了解并发底层技术！ 
https://mp.weixin.qq.com/s/SZl2E5NAhpYM4kKv9gyQOQ
-->

&emsp; JMM是指Java内存模型(Java Memory Model)，本身是一种抽象的概念，实际上并不存在，它描述的是一组规则或规范，通过这组规范定义了程序中各个变量(包括实例字段，静态字段和构成数组对象的元素)的访问方式。  

1. 定义程序中各种变量的访问规则
2. 把变量值存储到内存的底层细节
3. 从内存中取出变量值的底层细节

 
## 1.1. 计算机内存模型介绍
...

## 1.2. JMM中内存划分  
<!-- 
&emsp; Java内存模型（Java Memory Model，JMM）是一种符合顺序一致内存模型规范的，屏蔽了各种硬件和操作系统的访问差异的，保证了Java程序在各种平台下对内存的访问都能保证效果一致的机制及规范。  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/concurrent/multi-6.png)  
-->
&emsp; Java线程内存模型跟cpu缓存模型类似，是基于cpu缓存模型来建立的，Java线程内存模型是标准化的，屏蔽掉了底层不同计算机的区别。  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/concurrent/multi-7.png)   
&emsp; Java内存模型划分： 

* 主内存：Java内存模型规定了所有变量都存储在主内存(Main Memory)中（此处的主内存与物理硬件的主内存RAM 名字一样，两者可以互相类比，但此处仅是虚拟机内存的一部分）。  
    * Java堆中对象实例数据部分
    * 对应于物理硬件的内存
* 工作内存：每条线程都有自己的工作内存(Working Memory，又称本地内存，可与CPU高速缓存类比)，线程的工作内存中保存了该线程使用到的主内存中的共享变量的副本拷贝。线程对变量的所有操作都必须在工作内存进行，而不能直接读写主内存中的变量。工作内存是JMM的一个抽象概念，并不真实存在。  
    * Java栈中的部分区域
    * 优先存储于寄存器和高速缓存

&emsp; Java内存模型的几个规范：  
1. 所有变量存储在主内存  
2. 主内存是虚拟机内存的一部分  
3. 每条线程有自己的工作内存  
4. 线程的工作内存保存变量的主内存副本  
5. 线程对变量的操作必须在工作内存中进行  
6. 不同线程之间无法直接访问对方工作内存中的变量  
7. 线程间变量值的传递均需要通过主内存来完成  

## 1.3. 线程间的通信过程  
&emsp; **JMM定义了Java虚拟机（JVM）在计算机内存（RAM）中的工作方式。JMM主要规定了以下两点：**  

* 规定了一个线程如何以及何时可以看到其他线程修改过后的共享变量的值，即线程之间共享变量的可见性。  
* 如何在需要的时候对共享变量进行同步。  

&emsp; **<font color = "lime">在并发编程需要处理的两个关键问题是：线程之间如何通信和线程之间如何同步，即以上两条标准的体现。</font>** **<font color = "red">线程通信是一种手段，而线程同步是一种目的，即线程通信的主要目的是用于线程同步。线程同步是为了解决线程安全问题。</font>**

* 线程通信  

        通信是指线程之间以何种机制来交换信息。在命令式编程中，线程之间的通信机制有两种：共享内存和消息传递。
        在共享内存的并发模型里，线程之间共享程序的公共状态，线程之间通过写-读内存中的公共状态来隐式进行通信。
        在消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过明确的发送消息来显式进行通信。

* 线程同步  

        同步是指程序用于控制不同线程之间操作发生相对顺序的机制。
        在共享内存的并发模型里，同步是显式进行的。程序员必须显式指定某个方法或某段代码需要在线程之间互斥执行。
        在消息传递的并发模型里，由于消息的发送必须在消息的接收之前，因此同步是隐式进行的。    

&emsp; **<font color = "red">Java的并发采用的是共享内存模型</font>，**Java线程之间的通信总是隐式进行，整个通信过程对程序员完全透明。  

&emsp; **线程间的通信过程：**  
&emsp; 由于JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存（有些地方称为栈空间），工作内存是每个线程的私有数据区域，而Java内存模型中规定所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问，<font color = "red">但线程对变量的操作（读取赋值等）必须在工作内存中进行，首先要将变量从主内存拷贝到自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量，</font>各个线程中的工作内存中存储着主内存中的变量副本拷贝，<font color = "lime">因此不同的线程间无法访问对方的工作内存，线程间的通信（传值）必须通过主内存来完成，</font>其简要访问过程：  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/concurrent/multi-42.png)   

## 1.4. JMM内存间的交互操作  
&emsp; Java内存模型为主内存和工作内存间的变量拷贝及同步定义8种原子性操作指令。  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/concurrent/multi-8.png)   

* read（读取）：从主内存读取数据。  
* load（载入）：将主内存读取到的数据。  
* use（使用）：从工作内存读取数据来计算。  
* assign(赋值)：将计算好的值重新赋值到工作内存中。
* store（存储）：将工作内存数据写入主内存。 
* write（写入）：将store过去的变量值赋值给主内存中的变量。 
* lock（锁定）：将主内存变量加锁，标识为线程独占状态。  
* unlock（解锁）：将主内存变量解锁，解锁后其他线程可以锁定该变量。  

&emsp; 要把一个变量从主内存中复制到工作内存，就需要按顺寻地执行read和load操作，如果把变量从工作内存中同步回主内存中，就要按顺序地执行store和write操作。  
&emsp; Java内存模型只要求上述两个操作必须按顺序执行，而没有保证必须是连续执行。也就是read和load之间，store和write之间是可以插入其他指令的。  

&emsp; Java内存模型还规定了在执行上述八种基本操作时，必须满足如下规则：  

* 不允许read和load、store和write操作之一单独出现。  
* 不允许一个线程丢弃它的最近assign的操作，即变量在工作内存中改变了之后必须同步到主内存中。  
* 不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步回主内存中。  
* 一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量。即就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作。  
* 一个变量在同一时刻只允许一条线程对其进行lock操作，lock和unlock必须成对出现  
* 如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值  
* 如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去unlock一个被其他线程锁定的变量。  
* 对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）。

