

# 多线程活跃性
<!-- 
Java并发编程实战，第10章   

死锁的原因

1、是多个线程涉及到多个锁，这些锁存在着交叉，所以可能会导致了一个锁依赖 的闭环。例如： 线程在获得了锁 A 并且没有释放的情况下去申请锁 B， 这时， 另一个线程已经获得了锁 B，在释放锁 B 之前又要先获得锁 A，因此闭环发生，陷入死锁循环。2、默认的锁申请操作是阻塞的。
所以要避免死锁， 就要在一遇到多个对象锁交叉的情况， 就要仔细审查这几个对象的类中的所有方法，    是否存在着导致锁依赖的环路的可能性。总之是尽量避免在一个同步方法中调用其它对象的延时方法和同步方法。

Java线程死锁是一个经典的多线程问题，因为不同的线程都在等待根本不可能被释放的 锁，从而导致所有的任务都无法继续完成。在多线程技术中，“死锁”是必须避免的，因为 这会造成线程的“假死”。
-->
&emsp; 死锁、饥饿和活锁都属于多线程的活跃性问题，如果发现这几种情况，那么相关线程可能就不再活跃，也就说它可能很难再继续往下执行了。  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/concurrent/multi-1.png)  

* 死锁：死锁应该是最糟糕的一种情况了。指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。  

* 饥饿：指某一个或者多个线程因为种种原因无法获得所需要的资源，导致一直无法执行。比如：  
    * 它的线程优先级可能太低，而高优先级的线程不断抢占它需要的资源，导致低优先级的线程无法工作。  
    * 另外一种可能是，某一个线程一直占着关键资源不放，导致其他需要这个资源的线程无法正常执行，这种情况也是饥饿的一种。   

&emsp; 与死锁相比，饥饿还是有可能在未来一段时间内解决的(比如高优先级的线程已经完成任务，不再疯狂的执行)  

* 活锁：指任务或者执行者没有被阻塞，由于某些条件没有满足，导致一直重复尝试，失败，尝试，失败。活锁可以认为是一种特殊的饥饿。线程都秉承着"谦让"的原则，主动将资源释放给他人使用，那么就会出现资源不断在两个线程之间跳动，而没有一个线程可以同时拿到所有资源而正常执行。  

&emsp; 在安全性与活跃性之间通常存在着某种制衡。使用加锁机制来确保线程安全，但如果过度地使用加锁，则可能导致锁顺序死锁(Lock-Ordering Deadlock)。同样，使用线程池和信号量来限制对资源的使用，但这些被限制的行为可能会导致资源死锁(Resource Deadlock)。Java应用程序无法从死锁中恢复过来，因此在设计时一定要排除那些可能导致死锁 出现的条件。  
