

# 线程安全解决方案
<!-- 
“非线程安全”其实会在多个线程对同一个对象中的实例 变量进行并发访问时发生，产生的后果就是“脏读”，也就是取到的数据其实是被更改过的。 而“线程安全”就是以获得的实例变量的值是经过同步处理的，不会出现脏读的现象。

因为线程的封闭阿粉错失了一份非常不错的工作 
https://mp.weixin.qq.com/s/3PfvkKKtH48XbMEtab2Z_g
-->
&emsp; 线程安全包含原子性和可见性两个方面，Java的同步机制都是围绕这两个方面来确保线程安全的。  
&emsp; 若多个线程同时对资源执行写操作，一般都需要考虑线程同步，否则的话就可能影响线程安全。线程安全问题有“丢失修改”、“不可重复读”、“读‘脏’数据”等。  

&emsp; **<font color = "red">线程安全的解决方案如下：</font>**  
1. **<font color = "clime">阻塞/互斥同步（悲观锁）</font>**   
&emsp; synchronized。互斥同步最主要的问题就是线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步。互斥同步属于一种悲观的并发策略。  
2. **<font color = "clime">非阻塞同步（乐观锁，CAS）</font>** 
3. **<font color = "clime">无同步方案（线程封闭）</font>**   
&emsp; **<font color = "red">要保证线程安全，并不是一定就要进行同步。如果一个方法本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性。</font>**  
    * **<font color = "clime">栈封闭（类变量变局部变量）</font>**  
    &emsp; 多个线程访问同一个方法的局部变量时，不会出现线程安全问题。因为局部变量存储在虚拟机栈中，属于线程私有的。  
    ![image](http://www.wt1814.com/static/view/images/java/concurrent/multi-9.png)   
    * **<font color = "clime">线程本地存储（Thread Local Storage）</font>**  
    &emsp; 如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行。如果能保证，就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。  
    &emsp; 符合这种特点的应用并不少见，大部分使用消费队列的架构模式（如“生产者-消费者”模式）都会将产品的消费过程尽量在一个线程中消费完。其中最重要的一个应用实例就是经典Web交互模型中的“一个请求对应一个服务器线程”（Thread-per-Request）的处理方式，这种处理方式的广泛应用使得很多Web服务端应用都可以使用线程本地存储来解决线程安全问题。  
    &emsp; 可以使用java.lang.ThreadLocal类来实现线程本地存储功能。  
4. **<font color = "clime">不可变对象</font>**   
&emsp; 不可变(Immutable)的对象一定是线程安全的，不需要再采取任何的线程安全保障措施。只要一个不可变的对象被正确地构建出来，永远也不会看到它在多个线程之中处于不一致的状态。多线程环境下，应当尽量使对象成为不可变，来满足线程安全。  
&emsp; <font color = "red">不可变的类型：final关键字修饰的基本数据类型、String、枚举类型</font>、Number 部分子类，如Long和Double等数值包装类型，BigInteger和BigDecimal等大数据类型。但同为Number的原子类AtomicInteger和AtomicLong则是可变的。    


&emsp; **java并发原语：**  
&emsp; Java内存模型，除了定义了一套规范，还提供了一系列原语，封装了底层实现后，供开发者直接使用。  

* 原子性可以通过synchronized和Lock来实现。  
* 可见性可以通过Volatile、synchronized、final来实现。  
* 有序性可以通过synchronized或者Lock、volatile来实现。  

<!-- 

当访问共享的可变数据时，通常需要使用同步。一种避免使用同步的方式就是不共 享数据。如果仅在单线程内访问数据，就不需要同步。这种技术被称为线程封闭(Thread Confinement)，它是实现线程安全性的最简单方式之一。当某个对象封闭在一个线程中时，这 种用法将自动实现线程安全性，即使被封闭的对象本身不是线程安全的。


Java语言及其核心库提供了一些机制来帮助维持线程封闭性，例如局部变量和ThreadLocal类  
栈封闭是线程封闭的一种特例，在栈封闭中，只能通过局部变量才能访问对象。正如封 装能使得代码更容易维持不变性条件那样，同步变量也能使对象更易于封闭在线程中。局部变 量的固有属性之一就是封闭在执行线程中。它们位于执行线程的栈中，其他线程无法访问这个 栈。栈封闭(也被称为线程内部使用或者线程局部使用，不要与核心类库中的ThreadLocal混 淆)比Ad-hoc线程封闭更易于维护，也更加健壮。  
维持线程封闭性的一种更规范方法是使用ThreadLocal,这个类能使线程中的某个值与保存值 的对象关联起来。
-->

