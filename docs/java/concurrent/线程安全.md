

# 线程安全
<!-- 
“非线程安全”其实会在多个线程对同一个对象中的实例 变量进行并发访问时发生，产生的后果就是“脏读”，也就是取到的数据其实是被更改过的。 而“线程安全”就是以获得的实例变量的值是经过同步处理的，不会出现脏读的现象。
-->

&emsp; 线程安全包含原子性和可见性两个方面，Java的同步机制都是围绕这两个方面来确保线程安全的。  
&emsp; 若多个线程同时对资源执行写操作，一般都需要考虑线程同步，否则的话就可能影响线程安全。线程安全问题有“丢失修改”、“不可重复读”、“读‘脏’数据”等。  

&emsp; **<font color = "red">线程安全的解决方案如下：</font>**  
1. **<font color = "lime">阻塞/互斥同步（悲观锁）</font>**   
&emsp; synchronized。互斥同步最主要的问题就是线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步。互斥同步属于一种悲观的并发策略。  
2. **<font color = "lime">非阻塞同步（乐观锁，CAS）</font>** 
3. **<font color = "lime">无同步方案</font>**   
&emsp; 要保证线程安全，并不是一定就要进行同步。如果一个方法本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性。  
    * **<font color = "lime">栈封闭(类变量变局部变量)</font>**  
    &emsp; 多个线程访问同一个方法的局部变量时，不会出现线程安全问题。因为局部变量存储在虚拟机栈中，属于线程私有的。  
    ![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/concurrent/multi-9.png)   
    * **<font color = "lime">线程本地存储（Thread Local Storage）</font>**  
    &emsp; 如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行。如果能保证，就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。  
    &emsp; 符合这种特点的应用并不少见，大部分使用消费队列的架构模式（如“生产者-消费者”模式）都会将产品的消费过程尽量在一个线程中消费完。其中最重要的一个应用实例就是经典Web交互模型中的“一个请求对应一个服务器线程”（Thread-per-Request）的处理方式，这种处理方式的广泛应用使得很多Web服务端应用都可以使用线程本地存储来解决线程安全问题。  
    &emsp; 可以使用java.lang.ThreadLocal类来实现线程本地存储功能。  
    * **<font color = "lime">可重入代码（Reentrant Code）</font>**  
    &emsp; 这种代码也叫做纯代码（Pure Code），可以在代码执行的任何时刻中断它，转而去执行另外一段代码（包括递归调用它本身），而在控制权返回后，原来的程序不会出现任何错误。  
    &emsp; 可重入代码有一些共同的特征，例如不依赖存储在堆上的数据和公用的系统资源、用到的状态量都由参数中传入、不调用非可重入的方法等。
4. **<font color = "lime">不可变对象</font>**   
&emsp; 不可变（Immutable）的对象一定是线程安全的，不需要再采取任何的线程安全保障措施。只要一个不可变的对象被正确地构建出来，永远也不会看到它在多个线程之中处于不一致的状态。多线程环境下，应当尽量使对象成为不可变，来满足线程安全。  
&emsp; <font color = "red">不可变的类型：final关键字修饰的基本数据类型、String、枚举类型</font>、Number 部分子类，如Long和Double等数值包装类型，BigInteger和BigDecimal等大数据类型。但同为Number的原子类AtomicInteger和AtomicLong则是可变的。    

