

<!-- TOC -->

- [1. 线程](#1-线程)
    - [1.1. 线程简介](#11-线程简介)
        - [1.1.1. 线程](#111-线程)
        - [1.1.2. 多线程](#112-多线程)
        - [1.1.3. ※※※多线程带来的风险](#113-※※※多线程带来的风险)
    - [1.2. 创建并运行java线程](#12-创建并运行java线程)
        - [1.2.1. 继承Thread父类](#121-继承thread父类)
        - [1.2.2. Runnable接口](#122-runnable接口)
        - [1.2.3. Callable接口](#123-callable接口)
        - [1.2.4. Future接口](#124-future接口)
        - [1.2.5. FutureTask](#125-futuretask)
        - [1.2.6. 三种创建线程的不同](#126-三种创建线程的不同)
    - [1.3. Thread.java的构造函数](#13-threadjava的构造函数)
    - [1.4. Thread.java的方法](#14-threadjava的方法)
        - [1.4.1. 线程的start方法和run方法的区别](#141-线程的start方法和run方法的区别)
        - [1.4.2. ※※※线程状态介绍(线程生命周期)](#142-※※※线程状态介绍线程生命周期)
            - [1.4.2.1. 线程有哪几种状态？](#1421-线程有哪几种状态)
            - [1.4.2.2. 线程阻塞BLOCKED和等待WAITING的区别](#1422-线程阻塞blocked和等待waiting的区别)
            - [1.4.2.3. 线程状态切换图示](#1423-线程状态切换图示)
            - [1.4.2.4. 代码演示](#1424-代码演示)
        - [1.4.3. 相关方法详解](#143-相关方法详解)
            - [1.4.3.1. Thread.sleep()与Object.wait()](#1431-threadsleep与objectwait)
            - [1.4.3.2. yield()，线程让步](#1432-yield线程让步)
            - [1.4.3.3. Join()方法](#1433-join方法)
            - [1.4.3.4. interrupt()与stop()，中断线程](#1434-interrupt与stop中断线程)
                - [1.4.3.4.1. Java中对线程中断所提供的API支持](#14341-java中对线程中断所提供的api支持)
                - [1.4.3.4.2. 线程在不同状态下对于中断所产生的反应](#14342-线程在不同状态下对于中断所产生的反应)
            - [1.4.3.5. 守护线程](#1435-守护线程)
            - [1.4.3.6. 线程优先级](#1436-线程优先级)
    - [1.5. 线程传参](#15-线程传参)
        - [1.5.1. 构造方法](#151-构造方法)
        - [1.5.2. 变量和方法](#152-变量和方法)
        - [1.5.3. 回调函数](#153-回调函数)

<!-- /TOC -->

<!-- 
***
阿里面试官问我Java线程和操作系统线程什么关系 
https://mp.weixin.qq.com/s/1DBqevIIZAzynUzBAeyPXQ

详细分析 Java 中实现多线程的方法有几种?(从本质上出发) 
https://mp.weixin.qq.com/s/IKU56LMVZeVFVqRf-0N0tw

线程基本知识
https://mp.weixin.qq.com/s/bpg0GyaqeLZyTk_UA0Ngcg
-->
&emsp; **<font color = "lime">总结：</font>**  
1. 多线程带来的风险：安全性问题、活跃性问题、性能问题。
2. **<font color = "lime">线程生命周期(6种状态)：新建、就绪、阻塞()、等待、计时等待、终止。阻塞和等待的区别：进入waiting状态是线程主动的，而进入blocked状态是被动的。更进一步的说，进入blocked状态是在同步(synchronized代码之外)，而进入waiting状态是在同步代码之内。</font>**  

&emsp; 线程中断。  

# 1. 线程  
## 1.1. 线程简介   
### 1.1.1. 线程
&emsp; **1. 线程的一些基本概念：**    
&emsp; 进程是一个“执行中的程序”，是系统进行资源分配和调度的一个独立单位；  
&emsp; 线程是进程的一个实体，一个进程中拥有多个线程，线程之间共享地址空间和其它资源(所以通信和同步等操作线程比进程更加容易)；  

<!-- 
进程与线程的区别：
进程是资源分配的最小单位，线程是CPU调度的最小单位。所有与进程相关的资源，均被记录在PCB中。
线程隶属于某一个进程，共享所属进程的资源。线程只由堆栈寄存器、程序计数器和TCB构成。
进程可以看作独立的应用，线程不能看作独立的应用。
进程有独立的地址空间，相互不影响，而线程只是进程的不同执行路径，如果线程挂了，进程也就挂了。所以多进程的程序比多线程程序健壮，但是切换消耗资源多。
Java中进程与线程的关系：
运行一个程序会产生一个进程，进程至少包含一个线程。
每个进程对应一个JVM实例，多个线程共享JVM中的堆。

Java采用单线程编程模型，程序会自动创建主线程 。

主线程可以创建子线程，原则上要后于子线程完成执行。
-->

&emsp; 线程上下文的切换比进程上下文切换要快很多。  

* 进程切换时，涉及到当前进程的CPU环境的保存和新被调度运行进程的CPU环境的设置。  
* 线程切换仅需要保存和设置少量的寄存器内容，不涉及存储管理方面的操作。  

&emsp; 线程调度：CPU在某一个时刻只能执行一条指令，线程只有得到CPU时间片，也就是使用权，才可以执行指令。线程的两种调度模型(Java使用的是抢占式调度模型)：  
1. 分时调度模型，所有线程轮流使用CPU的使用权，平均分配每个线程占用CPU的时间片。  
2. 抢占式调度模型，优先让优先级高的线程使用CPU，如果线程的优先级相同，那么会随机选择一个，优先级高的线程获取的CPU时间片相对多一些。   

### 1.1.2. 多线程

&emsp; **2. 多线程的一些基本概念：**    
<!--
https://mp.weixin.qq.com/s/CvVgjixJxiyEoxJN5UfMSg

什么是多线程中的上下文切换？  
多线程会共同使用一组计算机上的 CPU， 而线程数大于给程序分配的 CPU 数量时， 为了让各个线程都有执行的机会，就需要轮转使用 CPU。不同的线程切换使用 CPU 发生的切换数据等就是上下文切换。  

什么是多线程中的上下文切换？
在上下文切换过程中， CPU 会停止处理当前运行的程序， 并保存当前程序运行的具体位置以便之后继续运行。从这个角度来看， 上下文切换有点像我们同时阅读几本书， 在来回切换书本的同时我们需要记住每本书当前读到的页码。在程序中， 上下文切换过程中的“ 页
码” 信息是保存在进程控制块( PCB) 中的。PCB 还经常被称作“ 切换桢”
( switchframe)。“ 页码” 信息会一直保存到 CPU 的内存中， 直到他们被再次使用。上下文切换是存储和恢复 CPU 状态的过程， 它使得线程执行能够从中断点恢复执行。上下文切换是多任务操作系统和多线程环境的基本特征。


多线程同步和互斥有几种实现方法，都是什么？
线程同步是指线程之间所具有的一种制约关系， 一个线程的执行依赖另一个线程的消息， 当它没有得到另一个线程的消息时应等待，   直到消息到达时才被唤醒。线程互斥是指对于共享的进程系统资源， 在各单个线程访问时的排它性。当有若干个线程都要使用某一共享资源时， 任何时刻最多只允许一个线程去使用， 其它要使用该资源的线程必须等待， 直到占用资源者释放该资源。线程互斥可以看成是一种特殊的线程同步。
线程间的同步方法大体可分为两类： 用户模式和内核模式。顾名思义， 内核模式就是指利用系统内核对象的单一性来进行同步，  使用时需要切换内核态与用户态，  而用户模式就是不需要切换到内核态， 只在用户态完成操作。
用户模式下的方法有： 原子操作( 例如一个单一的全局变量)， 临界区。内核模式下的方法有： 事件， 信号量， 互斥量。
-->
&emsp; **父子线程：**某线程a中启动另外一个线程t，那么称线程t是线程a的一个子线程，而线程a是线程t的父线程。最典型的是在main方法中启动一个线程去执行。其中main方法隐含的main线程为父线程。  
&emsp; **与进程相比，创建的子线程从主线程那继承了什么？**  
&emsp; 对于线程而言，并没有继承数据段和代码段，包括栈，而线程最大的优势是，多线程是共享地址空间的，从一个线程切换到同一个进程下的另一个线程运行，页表、数据区等很多都已经在内存或缓存里，而从一个进程切换到另一个进程，由于进程的空间都是独立的，所以切换就涉及到开销。这一点其实对于现在的硬件来讲，尤其是程序员来说，整体速度上影响不大，只是不方便同步。所以线程并不会继承那些看得见的东西(比如变量、代码等)。 

### 1.1.3. ※※※多线程带来的风险  
&emsp; **<font color = "lime">多线程带来的风险：</font>**  
1. 安全性问题  
&emsp; 线程安全性可能是非常复杂的，在没有充足同步的情况下，多个线程中的操作执行顺序是不可预测的，甚至会产生奇怪的结果。  
2. 活跃性问题  
&emsp; 安全性的含义是“永远不发生糟糕的事情”，而活跃性则关注于另一个目标，即“某件正确的事情最终会发生”。当某个操作充法继续执行下去时，就会发生活跃性问题。在串行程序中，活跃性问题的形式之一就是无意中造成的无限循环，从而使循环之后的代码无法得到执行。线程将带来其他一些活跃性问题。  
3. 性能问题  
&emsp; 与活跃性问题密切相关的是性能问题。活跃性意味着某件正确的事情最终会发生，但却不够好，因为通常希望正确的事情尽快发生。性能问题包括多个方面，例如服务时间过长，响应不灵敏，吞吐率过低，资源消耗过高，或者可伸缩性较低等。与安全性和活跃性一样，在 多线程程序中不仅存在与单线程程序相同的性能问题，而且还存在由于使用线程而引入的其他性能问题。  
&emsp; 在设计良好的并发应用程序中，线程能提升程序的性能，但无论如何，线程总会带来某种程度的运行时开销。在多线程程序中，当线程调度器临时挂起活跃线程并转而运行另一个线程时，就会频繁地出现上下文切换操作(Context Switch)，这种操作将带来极大的开销：保存和 恢复执行上下文，丢失局部性，并且CPU时间将更多地花在线程调度而不是线程运行上。当线程共享数据时，必须使用同步机制，而这些机制往往会抑制某些编译器优化，使内存缓存区中的数据无效，以及增加共享内存总线的同步流量。所有这些因素都将带来额外的性能开销。  


