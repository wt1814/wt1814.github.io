

<!-- TOC -->

- [1. 线程基本概念](#1-线程基本概念)
    - [1.1. 线程](#11-线程)
    - [1.2. 多线程](#12-多线程)

<!-- /TOC -->

<!-- 
***
阿里面试官问我Java线程和操作系统线程什么关系 
https://mp.weixin.qq.com/s/1DBqevIIZAzynUzBAeyPXQ

详细分析 Java 中实现多线程的方法有几种?(从本质上出发) 
https://mp.weixin.qq.com/s/IKU56LMVZeVFVqRf-0N0tw

线程基本知识
https://mp.weixin.qq.com/s/bpg0GyaqeLZyTk_UA0Ngcg
-->
&emsp; **<font color = "lime">总结：</font>**  
1. 多线程带来的风险：安全性问题、活跃性问题、性能问题。
2. **<font color = "lime">线程生命周期(6种状态)：新建、就绪、阻塞()、等待、计时等待、终止。阻塞和等待的区别：进入waiting状态是线程主动的，而进入blocked状态是被动的。更进一步的说，进入blocked状态是在同步(synchronized代码之外)，而进入waiting状态是在同步代码之内。</font>**  

&emsp; 线程中断。  

# 1. 线程基本概念  
## 1.1. 线程
&emsp; **1. 线程的一些基本概念：**    
&emsp; 进程是一个“执行中的程序”，是系统进行资源分配和调度的一个独立单位；  
&emsp; 线程是进程的一个实体，一个进程中拥有多个线程，线程之间共享地址空间和其它资源(所以通信和同步等操作线程比进程更加容易)；  

<!-- 
进程与线程的区别：
进程是资源分配的最小单位，线程是CPU调度的最小单位。所有与进程相关的资源，均被记录在PCB中。
线程隶属于某一个进程，共享所属进程的资源。线程只由堆栈寄存器、程序计数器和TCB构成。
进程可以看作独立的应用，线程不能看作独立的应用。
进程有独立的地址空间，相互不影响，而线程只是进程的不同执行路径，如果线程挂了，进程也就挂了。所以多进程的程序比多线程程序健壮，但是切换消耗资源多。
Java中进程与线程的关系：
运行一个程序会产生一个进程，进程至少包含一个线程。
每个进程对应一个JVM实例，多个线程共享JVM中的堆。

Java采用单线程编程模型，程序会自动创建主线程 。

主线程可以创建子线程，原则上要后于子线程完成执行。
-->

&emsp; 线程上下文的切换比进程上下文切换要快很多。  

* 进程切换时，涉及到当前进程的CPU环境的保存和新被调度运行进程的CPU环境的设置。  
* 线程切换仅需要保存和设置少量的寄存器内容，不涉及存储管理方面的操作。  

&emsp; 线程调度：CPU在某一个时刻只能执行一条指令，线程只有得到CPU时间片，也就是使用权，才可以执行指令。线程的两种调度模型(Java使用的是抢占式调度模型)：  
1. 分时调度模型，所有线程轮流使用CPU的使用权，平均分配每个线程占用CPU的时间片。  
2. 抢占式调度模型，优先让优先级高的线程使用CPU，如果线程的优先级相同，那么会随机选择一个，优先级高的线程获取的CPU时间片相对多一些。   

## 1.2. 多线程

&emsp; **2. 多线程的一些基本概念：**    
<!--
https://mp.weixin.qq.com/s/CvVgjixJxiyEoxJN5UfMSg

什么是多线程中的上下文切换？  
多线程会共同使用一组计算机上的 CPU， 而线程数大于给程序分配的 CPU 数量时， 为了让各个线程都有执行的机会，就需要轮转使用 CPU。不同的线程切换使用 CPU 发生的切换数据等就是上下文切换。  

什么是多线程中的上下文切换？
在上下文切换过程中， CPU 会停止处理当前运行的程序， 并保存当前程序运行的具体位置以便之后继续运行。从这个角度来看， 上下文切换有点像我们同时阅读几本书， 在来回切换书本的同时我们需要记住每本书当前读到的页码。在程序中， 上下文切换过程中的“ 页
码” 信息是保存在进程控制块( PCB) 中的。PCB 还经常被称作“ 切换桢”
( switchframe)。“ 页码” 信息会一直保存到 CPU 的内存中， 直到他们被再次使用。上下文切换是存储和恢复 CPU 状态的过程， 它使得线程执行能够从中断点恢复执行。上下文切换是多任务操作系统和多线程环境的基本特征。


多线程同步和互斥有几种实现方法，都是什么？
线程同步是指线程之间所具有的一种制约关系， 一个线程的执行依赖另一个线程的消息， 当它没有得到另一个线程的消息时应等待，   直到消息到达时才被唤醒。线程互斥是指对于共享的进程系统资源， 在各单个线程访问时的排它性。当有若干个线程都要使用某一共享资源时， 任何时刻最多只允许一个线程去使用， 其它要使用该资源的线程必须等待， 直到占用资源者释放该资源。线程互斥可以看成是一种特殊的线程同步。
线程间的同步方法大体可分为两类： 用户模式和内核模式。顾名思义， 内核模式就是指利用系统内核对象的单一性来进行同步，  使用时需要切换内核态与用户态，  而用户模式就是不需要切换到内核态， 只在用户态完成操作。
用户模式下的方法有： 原子操作( 例如一个单一的全局变量)， 临界区。内核模式下的方法有： 事件， 信号量， 互斥量。
-->
&emsp; **父子线程：**某线程a中启动另外一个线程t，那么称线程t是线程a的一个子线程，而线程a是线程t的父线程。最典型的是在main方法中启动一个线程去执行。其中main方法隐含的main线程为父线程。  
&emsp; **与进程相比，创建的子线程从主线程那继承了什么？**  
&emsp; 对于线程而言，并没有继承数据段和代码段，包括栈，而线程最大的优势是，多线程是共享地址空间的，从一个线程切换到同一个进程下的另一个线程运行，页表、数据区等很多都已经在内存或缓存里，而从一个进程切换到另一个进程，由于进程的空间都是独立的，所以切换就涉及到开销。这一点其实对于现在的硬件来讲，尤其是程序员来说，整体速度上影响不大，只是不方便同步。所以线程并不会继承那些看得见的东西(比如变量、代码等)。 
