
<!-- TOC -->

- [1. 并发安全问题](#1-并发安全问题)
    - [1.1. 并发安全问题](#11-并发安全问题)
        - [1.1.1. 并发安全问题及含义](#111-并发安全问题及含义)
        - [1.1.2. 线程切换带来的原子性问题](#112-线程切换带来的原子性问题)
        - [1.1.3. 缓存导致了可见性问题](#113-缓存导致了可见性问题)
    - [1.2. 重排序简介](#12-重排序简介)
        - [1.2.1. 重排序简介](#121-重排序简介)
        - [1.2.2. 重排序分类](#122-重排序分类)
        - [1.2.3. 重排序规则](#123-重排序规则)
            - [1.2.3.1. 重排序遵守数据依赖性](#1231-重排序遵守数据依赖性)
            - [1.2.3.2. 重排序遵守as-if-serial语义](#1232-重排序遵守as-if-serial语义)
        - [1.2.4. 重排序对多线程的影响](#124-重排序对多线程的影响)

<!-- /TOC -->

&emsp; **<font color = "red">总结：</font>**  
1. **并发安全的3个问题：**  

    * 原子性：线程切换带来的原子性问题；（[Volatile](/docs/java/concurrent/Volatile.md)不保证原子性）
    * 可见性：缓存不能及时刷新导致的可见性问题；
    * 有序性：编译优化带来的有序性问题  

    &emsp; **<font color = "clime">【编译器优化】和“缓存不能及时刷新”(【内存系统重排序】)都是重排序的一种。</font>**   

2. **重排序：**  
    * **<font color = "blue">重排序分类：1). 编译器优化；2). 指令重排序(CPU优化行为)；3). 内存系统重排序：内存系统没有重排序，但是由于有缓存的存在，使得程序整体上会表现出乱序的行为。</font>**     
        * 对于编译器，JMM的编译器重排序规则会禁止特定类型的编译器重排序（不是所有的编译器重排序都要禁止）。  
        * 对于处理器重排序，JMM的处理器重排序规则会要求Java编译器在生成指令序列时，插入特定类型的内存屏障指令， **<font color = "clime">通过内存屏障指令来禁止特定类型的处理器重排序</font>** (不是所有的处理器重排序都要禁止)。 

    * 重排序遵守的规则：重排序遵守数据依赖性、重排序遵守as-if-serial语义。  
    * 重排序对多线程的影响



# 1. 并发安全问题
<!-- 
【Java 并发003】原理层面：Java并发三特性全解析
https://www.cnblogs.com/maoqizhi/p/13909179.html
-->
<!--
~~ 
https://mp.weixin.qq.com/s/DaCTrm8y9vWeaJyHfbRoTw
-->

## 1.1. 并发安全问题
### 1.1.1. 并发安全问题及含义  
&emsp; 在计算机中cpu、缓存、I/O设备这个三者之间速度的差异一直存在问题，cpu > 缓存 > I/O设备。按照串行的逻辑，程序的整体速度取决速度最慢的I/O设备。  

&emsp; 为了提高程序的整体性能，做了如下的升级  

* 增加cpu缓存，平衡cpu和内存的速度差异
* 操作系统增加多进程、多线程；通过分时复用平衡CPU和I/O设备间的速度差异
* 编译器指令优化，可以充分利用缓存，提高执行效率

&emsp; 但是凡事有利必有弊，性能提高的同时，也会引发一些问题。并发编程中的问题源头就是因为这个导致的。  

------

&emsp; 并发编程存在原子性、可见性、有序性问题。  

* **<font color = "red">原子性，即一系列操作要么都执行，要么都不执行。</font>**  
&emsp;  线程切换会导致原子性问题。  
* **<font color = "red">可见性，当一个线程修改了共享变量的值时，其他线程能够立即得知这个修改。</font>**  
&emsp; **由于多核CPU，每个CPU核都有高速缓存，会缓存共享变量，** 某个线程对共享变量的修改会改变高速缓存中的值，但却不会马上写入内存。另一个线程读到的是另一个核缓存的共享变量的值，**出现缓存不一致问题。**  
* **<font color = "red">有序性，即程序执行的顺序按照代码的先后顺序执行。</font>**    
&emsp; **<font color = "clime">编译器和处理器会对指令进行重排，以优化指令执行性能，</font>** 重排不会改变单线程执行结果，但在多线程中可能会引起各种各样的问题，包括有序性。  
&emsp; 关于有序性：如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的。前半句是指“线程内似表现为串行的语义”(Within-Thread As-If-Serial Semantics)，后半句是指“指令重排序”现象和“工作内存与主内存同步延迟”现象。  


&emsp; **<font color = "clime">注：【编译器优化】和“缓存不能及时刷新”(【内存系统重排序】)都是重排序的一种。</font>**   

### 1.1.2. 线程切换带来的原子性问题  
&emsp; [Volatile](/docs/java/concurrent/Volatile.md)不保证原子性。  
&emsp; 现代操作系统都是基于线程调度的，java并发程序出现的多线程，会涉及到线程切换，在一条语句可能需要多个cpu指令完成。例如代码count+=1大概需要三条指令。  

* 把变量 count 从内存加载到CPU的寄存器中
* 在寄存器中把变量 count + 1
* 把变量 count 写入到内存(缓存机制导致可能写入的是CPU缓存而不是内存)

&emsp; 操作系统做任务切换，可以发生在任何一条CPU指令执行完，所以并不是高级语言中的一条语句，不要被count += 1这个操作蒙蔽了双眼。假设count = 0，线程A执行完指令1 后，做任务切换到线程B执行了指令1、指令2、指令3后，再做任务切换回线程A。会发现虽然两个线程都执行了count += 1 操作。但是得到的结果并不是2，而是1。  

![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/concurrent/multi-77.png)  
&emsp; 如果 count += 1 是一个不可分割的整体，线程的切换可以发生在 count += 1 之前或之后，但是不会发生在中间，就像个原子一样。**把一个或者多个操作在 CPU 执行的过程中不被中断的特性称为原子性。**

### 1.1.3. 缓存导致了可见性问题  
&emsp; 目前操作系统都是多核的，cpu都有自己的缓存，这个时候就需要考虑数据的一致性问题。某一个变量被多个线程操作；相互的操作是不可见的。这个时候就会出现问题了，这就是可见性问题。  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/concurrent/multi-78.png)  


## 1.2. 重排序简介    
### 1.2.1. 重排序简介  
&emsp; 在执行程序时，为了提供性能，处理器和编译器常常会对指令进行重排序，但是<font color = "clime">不能随意重排序，它需要满足以下两个条件：</font>  

* <font color = "red">在单线程环境下不能改变程序运行的结果；</font>  
* <font color = "red">存在数据依赖关系的不允许重排序。</font>  

&emsp; 需要注意的是：重排序不会影响单线程环境的执行结果，但是会破坏多线程的执行语义。  

### 1.2.2. 重排序分类  
&emsp; 从Java源代码到最终实际执行的指令序列，会分别经历下面三种重排序：  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/concurrent/multi-2.png)  

<!-- 
1. 编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。  
2. 指令级并行的重排序。现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。  
3. 内存系统的重排序。由于处理器使用缓存和读／写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。  
-->

1. 编译器优化：对于没有数据依赖关系的操作，编译器在编译的过程中会进行一定程度的重排。  
2. **<font color = "clime">指令重排序：CPU优化行为，</font>** 也是会对不存在数据依赖关系的指令进行一定程度的重排。  
3. **<font color = "clime">内存系统重排序：内存系统没有重排序，但是由于有缓存的存在，使得程序整体上会表现出乱序的行为。</font>**  


&emsp; 上面的这些重排序都可能导致多线程程序出现内存可见性问题。  
* 对于编译器，JMM的编译器重排序规则会禁止特定类型的编译器重排序(不是所有的编译器重排序都要禁止)。  
* 对于处理器重排序，JMM的处理器重排序规则会要求Java编译器在生成指令序列时，插入特定类型的内存屏障指令， **<font color = "clime">通过内存屏障指令来禁止特定类型的处理器重排序</font>** (不是所有的处理器重排序都要禁止)。  


&emsp; JMM属于语言级的内存模型，它确保在不同的编译器和不同的处理器平台之上，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证。  

### 1.2.3. 重排序规则  
#### 1.2.3.1. 重排序遵守数据依赖性  
&emsp; 如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性。数据依赖分下列三种类型：  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/concurrent/multi-3.png)  
&emsp; 上面三种情况，只要重排序两个操作的执行顺序，程序的执行结果将会被改变。  

&emsp; 编译器和处理器可能会对操作做重排序。编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序。  
&emsp; 注意，这里所说的数据依赖性仅针对单个处理器中执行的指令序列和单个线程中执行的操作，不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑。  

#### 1.2.3.2. 重排序遵守as-if-serial语义  
&emsp; **<font color = "red">as-if-serial语义的意思指：不管怎么重排序(编译器和处理器为了提高并行度)，(单线程)程序的执行结果不能被改变。编译器，runtime和处理器都必须遵守as-if-serial语义。</font>**  

### 1.2.4. 重排序对多线程的影响  
&emsp; 示例代码：  

```java
class Demo {
    int a = 0;
    boolean flag = false;

    public void write() {
        a = 1;            //1
        flag = true;    //2
    }

    public void read() {
        if(flag) {            //3
            int i = a * a;    //4
        }
    }
}
```
&emsp; 由于操作1和2没有数据依赖关系，编译器和处理器可以对这两个操作重排序；操作3和操作4没有数据依赖关系，编译器和处理器也可以对这两个操作重排序。  

1. 当操作1和操作2重排序时，可能会产生什么效果？  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/concurrent/multi-4.png)  
&emsp; 如上图所示，操作1和操作2做了重排序。程序执行时，线程A首先写标记变量flag，随后线程B读这个变量。由于条件判断为真，线程B将读取变量a。此时，变量a还根本没有被线程A写入，在这里多线程程序的语义被重排序破坏了！  
2. 当操作3和操作4重排序时会产生什么效果(借助这个重排序，可以顺便说明控制依赖性)。  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/concurrent/multi-5.png)  
&emsp; 在程序中，操作3和操作4存在控制依赖关系。当代码中存在控制依赖性时，会影响指令序列执行的并行度。为此，编译器和处理器会采用猜测(Speculation)执行来克服控制相关性对并行度的影响。以处理器的猜测执行为例，执行线程B 的处理器可以提前读取并计算a * a，然后把计算结果临时保存到一个名为重排序缓冲(reorder buffer ROB)的硬件缓存中。当接下来操作3的条件判断为真时，就把该计算结果写入变量i中。  

&emsp; 从图中可以看出，猜测执行实质上对操作3和4做了重排序。重排序在这里破坏了多线程程序的语义！  
&emsp; 在单线程程序中，对存在控制依赖的操作重排序，不会改变执行结果(这也是as-if-serial语义允许对存在控制依赖的操作做重排序的原因)；但在多线程程序中，对存在控制依赖的操作重排序，可能会改变程序的执行结果。  

