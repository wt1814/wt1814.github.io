
<!-- TOC -->

- [1. 并发安全问题](#1-并发安全问题)
    - [1.1. 并发操作](#11-并发操作)
    - [1.2. 计算机CPU缓存模型](#12-计算机cpu缓存模型)
        - [1.2.1. 三级缓存](#121-三级缓存)
        - [1.2.2. CPU缓存行](#122-cpu缓存行)
    - [1.3. 重排序简介](#13-重排序简介)
        - [1.3.1. 重排序简介](#131-重排序简介)
        - [1.3.2. 重排序分类](#132-重排序分类)
        - [1.3.3. 重排序规则](#133-重排序规则)
            - [1.3.3.1. 重排序遵守数据依赖性](#1331-重排序遵守数据依赖性)
            - [1.3.3.2. 重排序遵守as-if-serial语义](#1332-重排序遵守as-if-serial语义)
        - [1.3.4. 重排序对多线程的影响](#134-重排序对多线程的影响)
    - [1.4. 并发安全问题](#14-并发安全问题)
        - [1.4.1. 并发安全问题及含义](#141-并发安全问题及含义)
        - [1.4.2. 线程切换带来的原子性问题](#142-线程切换带来的原子性问题)
        - [1.4.3. 缓存导致了可见性问题/CPU的缓存一致性问题](#143-缓存导致了可见性问题cpu的缓存一致性问题)

<!-- /TOC -->

&emsp; **<font color = "red">总结：</font>**  
&emsp; `⚠⚠⚠声明：并发安全并不是java独有的，其他语言，不同操作系统都存在并发安全。究其原因是因为cpu多级缓存架构。`  
&emsp; 并发操作是指同一时间可能有多个用户对同一数据进行读写操作。  
&emsp; `并发问题并不是Java独有的，也不是只在linux系统才会有，究其原因是计算机CPU优化带来的一些问题。`  

1. **并发安全的3个问题：**  

    * 原子性：线程切换带来的原子性问题；（[Volatile](/docs/java/concurrent/Volatile.md)不保证原子性）
    * 可见性：缓存不能及时刷新导致的可见性问题；
    * 有序性：编译优化带来的有序性问题  

    &emsp; **<font color = "clime">`【缓存不能及时刷新】/可见性 (【内存系统重排序】)` 和`【编译器优化】/有序性` 都是`重排序`的一种。</font>**   
2. **重排序：**  
    * **<font color = "blue">重排序分类：1). 编译器优化；2). 指令重排序(CPU优化行为)；3). 内存系统重排序：内存系统没有重排序，但是由于有缓存的存在，使得程序整体上会表现出乱序的行为。</font>**     
        * 对于编译器，JMM的编译器重排序规则会禁止特定类型的编译器重排序（不是所有的编译器重排序都要禁止）。  
        * 对于处理器重排序，JMM的处理器重排序规则会要求Java编译器在生成指令序列时，插入特定类型的内存屏障指令， **<font color = "clime">通过内存屏障指令来禁止特定类型的处理器重排序</font>** （不是所有的处理器重排序都要禁止）。 

    * 重排序遵守的规则：重排序遵守数据依赖性、重排序遵守as-if-serial语义。  
    * 重排序对多线程的影响



# 1. 并发安全问题
<!-- 

*** http://blog.itpub.net/69940567/viewspace-2684318/

http://blog.itpub.net/69940567/viewspace-2684318/
缓存一致性
**** https://www.jianshu.com/p/06717ac8312c

并发问题是怎样造成的
https://zhuanlan.zhihu.com/p/67150793

★★★并发问题产生的三大根源
https://zhuanlan.zhihu.com/p/64988344

CPU缓存一致性协议
https://blog.csdn.net/w1453114339/article/details/107563613
-->

<!--


https://mp.weixin.qq.com/s/yWifJmirZNnBrAIZrpJwyg
-->



<!-- 
~~
https://mp.weixin.qq.com/s/0_TDPDx8q2HmKCMyupWuNA
https://mp.weixin.qq.com/s?__biz=MzAwNDA2OTM1Ng==&mid=2453142004&idx=1&sn=81ccddb6c8b37114c022c4ad50368ecf&scene=21#wechat_redirect
-->


<!-- 

【Java 并发003】原理层面：Java并发三特性全解析
https://www.cnblogs.com/maoqizhi/p/13909179.html
-->
<!--
~~ 
https://mp.weixin.qq.com/s/DaCTrm8y9vWeaJyHfbRoTw
-->
&emsp; `⚠⚠⚠声明：并发安全并不是java独有的，其他语言，不同操作系统都存在并发安全。究其原因是因为cpu多级缓存架构。`  

## 1.1. 并发操作  


## 1.2. 计算机CPU缓存模型  
&emsp; `并发问题并不是Java独有的，也不是只在linux系统才会有，究其原因是计算机CPU优化带来的一些问题。`  


### 1.2.1. 三级缓存
&emsp; CPU是计算机的心脏，所有运算和程序最终都要由它来执行。  
&emsp; 主内存(RAM)是数据存放的地方，CPU 和主内存之间有好几级缓存，因为即使直接访问主内存也是非常慢的。  
&emsp; 如果对一块数据做相同的运算多次，那么在执行运算的时候把它加载到离 CPU 很近的地方就有意义了，比如一个循环计数，不想每次循环都跑到主内存去取这个数据来增长它。  
![image](http://182.92.69.8:8081/img/java/concurrent/multi-50.png)  
&emsp; <font color = "red">越靠近CPU的缓存越快也越小。</font>所以L1缓存很小但很快，并且紧靠着在使用它的 CPU 内核。L2大一些，也慢一些，并且仍然只能被一个单独的 CPU 核使用。L3 在现代多核机器中更普遍，仍然更大，更慢，并且被单个插槽上的所有 CPU 核共享。最后，主存保存着程序运行的所有数据，它更大，更慢，由全部插槽上的所有 CPU 核共享。  
&emsp; 当 CPU 执行运算的时候，它先去 L1 查找所需的数据，再去 L2，然后是 L3，最后如果这些缓存中都没有，所需的数据就要去主内存拿。走得越远，运算耗费的时间就越长。所以如果进行一些很频繁的运算，要确保数据在 L1 缓存中。  

### 1.2.2. CPU缓存行  
&emsp; 缓存是由缓存行组成的，通常是64字节（常用处理器的缓存行是64字节的，比较旧的处理器缓存行是 32 字节），并且它有效地引用主内存中的一块地址。  
&emsp; <font color = "red">一个Java的long类型是8字节，因此在一个缓存行中可以存8个long类型的变量。</font>  
![image](http://182.92.69.8:8081/img/java/concurrent/multi-51.png)  



## 1.3. 重排序简介    
### 1.3.1. 重排序简介  
&emsp; 在执行程序时，为了提供性能，处理器和编译器常常会对指令进行重排序，但是<font color = "clime">不能随意重排序，它需要满足以下两个条件：</font>  

* <font color = "red">在单线程环境下不能改变程序运行的结果；</font>  
* <font color = "red">存在数据依赖关系的不允许重排序。</font>  

&emsp; 需要注意的是：重排序不会影响单线程环境的执行结果，但是会破坏多线程的执行语义。  

### 1.3.2. 重排序分类  
&emsp; 从Java源代码到最终实际执行的指令序列，会分别经历下面三种重排序：  
![image](http://182.92.69.8:8081/img/java/concurrent/multi-2.png)  

<!-- 
1. 编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。  
2. 指令级并行的重排序。现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。  
3. 内存系统的重排序。由于处理器使用缓存和读／写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。  
-->

1. 编译器优化：对于没有数据依赖关系的操作，编译器在编译的过程中会进行一定程度的重排。  
2. **<font color = "clime">指令重排序：CPU优化行为，</font>** 也是会对不存在数据依赖关系的指令进行一定程度的重排。  
3. **<font color = "clime">内存系统重排序：内存系统没有重排序，但是由于有缓存的存在，使得程序整体上会表现出乱序的行为。</font>**  


&emsp; 上面的这些重排序都可能导致多线程程序出现内存可见性问题。  
* 对于编译器，JMM的编译器重排序规则会禁止特定类型的编译器重排序(不是所有的编译器重排序都要禁止)。  
* 对于处理器重排序，JMM的处理器重排序规则会要求Java编译器在生成指令序列时，插入特定类型的内存屏障指令， **<font color = "clime">通过内存屏障指令来禁止特定类型的处理器重排序</font>** (不是所有的处理器重排序都要禁止)。  


&emsp; JMM属于语言级的内存模型，它确保在不同的编译器和不同的处理器平台之上，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证。  

### 1.3.3. 重排序规则  
#### 1.3.3.1. 重排序遵守数据依赖性  
&emsp; 如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性。数据依赖分下列三种类型：  
![image](http://182.92.69.8:8081/img/java/concurrent/multi-3.png)  
&emsp; 上面三种情况，只要重排序两个操作的执行顺序，程序的执行结果将会被改变。  

&emsp; 编译器和处理器可能会对操作做重排序。编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序。  
&emsp; 注意，这里所说的数据依赖性仅针对单个处理器中执行的指令序列和单个线程中执行的操作，不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑。  

#### 1.3.3.2. 重排序遵守as-if-serial语义  
&emsp; **<font color = "red">as-if-serial语义的意思指：不管怎么重排序(编译器和处理器为了提高并行度)，(单线程)程序的执行结果不能被改变。编译器，runtime和处理器都必须遵守as-if-serial语义。</font>**  

### 1.3.4. 重排序对多线程的影响  
&emsp; 示例代码：  

```java
class Demo {
    int a = 0;
    boolean flag = false;

    public void write() {
        a = 1;            //1
        flag = true;    //2
    }

    public void read() {
        if(flag) {            //3
            int i = a * a;    //4
        }
    }
}
```
&emsp; 由于操作1和2没有数据依赖关系，编译器和处理器可以对这两个操作重排序；操作3和操作4没有数据依赖关系，编译器和处理器也可以对这两个操作重排序。  

1. 当操作1和操作2重排序时，可能会产生什么效果？  
![image](http://182.92.69.8:8081/img/java/concurrent/multi-4.png)  
&emsp; 如上图所示，操作1和操作2做了重排序。程序执行时，线程A首先写标记变量flag，随后线程B读这个变量。由于条件判断为真，线程B将读取变量a。此时，变量a还根本没有被线程A写入，在这里多线程程序的语义被重排序破坏了！  
2. 当操作3和操作4重排序时会产生什么效果(借助这个重排序，可以顺便说明控制依赖性)。  
![image](http://182.92.69.8:8081/img/java/concurrent/multi-5.png)  
&emsp; 在程序中，操作3和操作4存在控制依赖关系。当代码中存在控制依赖性时，会影响指令序列执行的并行度。为此，编译器和处理器会采用猜测(Speculation)执行来克服控制相关性对并行度的影响。以处理器的猜测执行为例，执行线程B 的处理器可以提前读取并计算a * a，然后把计算结果临时保存到一个名为重排序缓冲(reorder buffer ROB)的硬件缓存中。当接下来操作3的条件判断为真时，就把该计算结果写入变量i中。  

&emsp; 从图中可以看出，猜测执行实质上对操作3和4做了重排序。重排序在这里破坏了多线程程序的语义！  
&emsp; 在单线程程序中，对存在控制依赖的操作重排序，不会改变执行结果(这也是as-if-serial语义允许对存在控制依赖的操作做重排序的原因)；但在多线程程序中，对存在控制依赖的操作重排序，可能会改变程序的执行结果。  




## 1.4. 并发安全问题
### 1.4.1. 并发安全问题及含义  
&emsp; 在计算机中cpu、缓存、I/O设备这个三者之间速度的差异一直存在问题，cpu > 缓存 > I/O设备。按照串行的逻辑，程序的整体速度取决速度最慢的I/O设备。  

&emsp; 为了提高程序的整体性能，做了如下的升级  

* 增加cpu缓存，平衡cpu和内存的速度差异
* 操作系统增加多进程、多线程；通过分时复用平衡CPU和I/O设备间的速度差异
* 编译器指令优化，可以充分利用缓存，提高执行效率

&emsp; 但是凡事有利必有弊，性能提高的同时，也会引发一些问题。并发编程中的问题源头就是因为这个导致的。  

------

&emsp; 并发编程存在原子性、可见性、有序性问题。  

* **<font color = "red">原子性，即一系列操作要么都执行，要么都不执行。</font>**  
&emsp;  线程切换会导致原子性问题。  
* **<font color = "red">可见性，当一个线程修改了共享变量的值时，其他线程能够立即得知这个修改。</font>**  
&emsp; **由于多核CPU，每个CPU核都有高速缓存，会缓存共享变量，** 某个线程对共享变量的修改会改变高速缓存中的值，但却不会马上写入内存。另一个线程读到的是另一个核缓存的共享变量的值，**出现缓存不一致问题。**  
* **<font color = "red">有序性，即程序执行的顺序按照代码的先后顺序执行。</font>**    
&emsp; **<font color = "clime">编译器和处理器会对指令进行重排，以优化指令执行性能，</font>** 重排不会改变单线程执行结果，但在多线程中可能会引起各种各样的问题，包括有序性。  
&emsp; 关于有序性：如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的。前半句是指“线程内似表现为串行的语义”(Within-Thread As-If-Serial Semantics)，后半句是指“指令重排序”现象和“工作内存与主内存同步延迟”现象。  


&emsp; **<font color = "clime">注：【编译器优化】和“缓存不能及时刷新”(【内存系统重排序】)都是重排序的一种。</font>**   

### 1.4.2. 线程切换带来的原子性问题  
&emsp; [Volatile](/docs/java/concurrent/Volatile.md)不保证原子性。  
&emsp; 现代操作系统都是基于线程调度的，java并发程序出现的多线程，会涉及到线程切换，在一条语句可能需要多个cpu指令完成。例如代码count+=1大概需要三条指令。  

* 把变量 count 从内存加载到CPU的寄存器中
* 在寄存器中把变量 count + 1
* 把变量 count 写入到内存(缓存机制导致可能写入的是CPU缓存而不是内存)

&emsp; 操作系统做任务切换，可以发生在任何一条CPU指令执行完，所以并不是高级语言中的一条语句，不要被count += 1这个操作蒙蔽了双眼。假设count = 0，线程A执行完指令1 后，做任务切换到线程B执行了指令1、指令2、指令3后，再做任务切换回线程A。会发现虽然两个线程都执行了count += 1 操作。但是得到的结果并不是2，而是1。  

![image](http://182.92.69.8:8081/img/java/concurrent/multi-77.png)  
&emsp; 如果 count += 1 是一个不可分割的整体，线程的切换可以发生在 count += 1 之前或之后，但是不会发生在中间，就像个原子一样。**把一个或者多个操作在 CPU 执行的过程中不被中断的特性称为原子性。**

### 1.4.3. 缓存导致了可见性问题/CPU的缓存一致性问题  
&emsp; 目前操作系统都是多核的，cpu都有自己的缓存，这个时候就需要考虑数据的一致性问题。某一个变量被多个线程操作；相互的操作是不可见的。这个时候就会出现问题了，这就是可见性问题。  
![image](http://182.92.69.8:8081/img/java/concurrent/multi-78.png)  


----------

&emsp; 当多个CPU持有的缓存都来自同一个主内存的拷贝，当有某个CPU修改了这个主内存数据后，而其他CPU并不知道，那拷贝的内存将会和主内存不一致，这就是缓存不一致。那如何来保证缓存一致呢？这里就需要操作系统来共同制定一个同步规则来保证。 

&emsp; **缓存失效/缓存不一致/缓存可见性**  
&emsp; 当CPU写数据时，如果发现操作的变量是共享变量，即在其它CPU中也存在该变量的副本，系统会发出信号通知其它CPU将该内存变量的缓存行设置为无效。如下图所示，CPU1和CPU3 中num=1已经失效了。  
![image](http://182.92.69.8:8081/img/java/concurrent/multi-44.png)  
&emsp; 当其它CPU读取这个变量的时，发现自己缓存该变量的缓存行是无效的，那么它就会从内存中重新读取。  

<!-- 
&emsp; 如下图所示，CPU1和CPU3发现缓存的num值失效了，就重新从内存读取，num值更新为2。  
![image](http://182.92.69.8:8081/img/java/concurrent/multi-45.png)  
-->
