


<!-- TOC -->

- [1. JVM类的加载](#1-jvm类的加载)
    - [1.1. 类加载的时机](#11-类加载的时机)
    - [1.2. 类加载的过程](#12-类加载的过程)
        - [1.2.1. 加载](#121-加载)
            - [1.2.1.1. 延伸知识点](#1211-延伸知识点)
        - [1.2.2. 链接](#122-链接)
            - [1.2.2.1. 验证](#1221-验证)
            - [1.2.2.2. 准备](#1222-准备)
            - [1.2.2.3. 解析](#1223-解析)
        - [1.2.3. 初始化](#123-初始化)
            - [1.2.3.1. 类初始化时机](#1231-类初始化时机)
            - [1.2.3.2. 类初始化流程xxxxx](#1232-类初始化流程xxxxx)
            - [1.2.3.3. 延伸知识点](#1233-延伸知识点)
        - [1.2.4. 使用：](#124-使用)
        - [1.2.5. 卸载](#125-卸载)
    - [1.3. 类加载的方式：类加载器](#13-类加载的方式类加载器)
        - [1.3.1. 类加载器的分类](#131-类加载器的分类)
        - [1.3.2. 类加载器的加载机制](#132-类加载器的加载机制)
            - [1.3.2.1. 双亲委派模型](#1321-双亲委派模型)
            - [1.3.2.2. 破坏双亲委派模型](#1322-破坏双亲委派模型)
        - [1.3.3. 类加载器应用](#133-类加载器应用)
            - [1.3.3.1. 自定义类加载器](#1331-自定义类加载器)
            - [1.3.3.2. 查看Boostrap ClassLoader 加载的类库](#1332-查看boostrap-classloader-加载的类库)
            - [1.3.3.3. 如何在启动时观察加载了哪个jar包中的哪个类？](#1333-如何在启动时观察加载了哪个jar包中的哪个类)
            - [1.3.3.4. 观察特定类的加载上下文](#1334-观察特定类的加载上下文)

<!-- /TOC -->

![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/JVM/JVM-50.png)  

&emsp; **<font color = "red">部分参考《深入理解java虚拟机 第3版》第7章 虚拟机类加载机制</font>**  

# 1. JVM类的加载  

## 1.1. 类加载的时机  
&emsp; 什么情况下虚拟机需要开始加载一个类呢？虚拟机规范中并没有对此进行强制约束，这点可以交给虚拟机的具体实现来自由把握。  

## 1.2. 类加载的过程  
&emsp; 类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载（Loading)、验证（Verification)、准备（Preparation)、解析（Resolution)、初始化(Initialization)、使用(Using)和卸载（Unloading) 7个阶段。<font color = "red">类的加载包括前5个阶段，其屮验证、准备、解析3个部分统称为连接（Linking)。</font>这7个阶段的发生顺序如图所示。    
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/JVM/JVM-5.png)  
&emsp; 加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始，而**解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定（也称为动态绑定或晚期绑定）**。  

### 1.2.1. 加载  
&emsp; 加载：查找并加载类的二进制数据。加载主要做三件事： 
 
* 找到类文件（首先通过类的全限定名来获取定义此类的二进制字节流）  
* 放入方法区（其次将这个字节流所代表的静态存储结构转化为方法区(1.8开始是堆)的运行时数据结构）  
* 开个入口（最后生成一个代表此类的java.lang.Class对象，作为访问方法区这些数据结构的入口）  

&emsp; **<font color = "red">一句话概括：把代码数据加载到内存中，加载完成后，在方法区实例化一个对应的Class对象。</font>**  

&emsp; 类的加载的最终产品是位于堆区中的Class对象，Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。  
&emsp; 其中加载的类有以下几种：  

* 从本地系统直接加载  
* 通过网络下载.class文件  
* 从zip，jar等归档文件中加载.class文件  
* 从专有数据库中提取.class文件  
* 将Java源文件动态编译为.class文件（服务器）  
* 命令行启动应用时候由JVM初始化加载  
* 通过Class.forName()方法动态加载  

#### 1.2.1.1. 延伸知识点  
&emsp; 相对于类加载过程的其他阶段，一个非数组类的加载阶段（准确地说，是加载阶段中获取类的二进制字节流的动作）是开发人员可控性最强的，因为加载阶段既可以使用系统提供的引导类加载器来完成，也可以由用户自定义的类加载器去完成，开发人员可以通过定义自己的类加载器去控制字节流的获取方式（即重写一个类加载器的loadClass()方法）。  
&emsp; 对于数组类而言，情况就有所不同，数组类本身不通过类加载器创建，它是由Java虚拟机直接创建的。但是数组类的元素类型（Element Type，指的是数组去掉所有维度的类型）最终是要靠类加载器去创建，如果数组的组件类型不是引用类型（例如int[]数组），Java虚拟机将会把数组C标记为与引导类加载器关联。  
&emsp; 数组类的可见性与它的组件类型的可见性一致，如果组件类型不是引用类型，那数组类的可见性将默认为public。  

### 1.2.2. 链接  
#### 1.2.2.1. 验证  
&emsp; **<font color = "red">验证：确保被加载的类的正确性</font>**  
&emsp; 确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致会完成4个阶段的检验动作：  
1. 文件格式验证：验证字节流是否符合Class文件格式的规范；例如：是否以0xCAFEBABE开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。  
2. 元数据验证：对字节码描述的信息进行语义分析（注意：对比javac编译阶段的语义分析），以保证其描述的信息符合Java语言规范的要求，例如：这个类是否有父类（除了java.lang.Object之外所有类都是父类）、这个类是否被继承类不允许继承的类（被final修饰的类）等。  
3. 字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。  
4. 符号引用验证：确保解析动作能正确执行。  



&emsp; 验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用-Xverifynone参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。  

#### 1.2.2.2. 准备  
&emsp; **<font color = "red">准备：为类的静态变量分配内存，并将其初始化为默认值</font>**<font color = "red">，这些内存都将在方法区中分配。</font>对于该阶段有以下几点需要注意：  
1. <font color = "red">这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在 Java 堆中。</font>  
2. <font color = "red">这里所设置的初始值"通常情况"下是数据类型默认的零值（如0、0L、null、false等），比如定义了public static int value=111 ，那么 value 变量在准备阶段的初始值就是 0 而不是111（初始化阶段才会复制）。</font>  
* <font color = "red">特殊情况：比如给 value 变量加上了 fianl 关键字public static final int value=111 ，那么准备阶段 value 的值就被赋值为 111。</font>  

&emsp; **<font color = "red">为什么 static final 会直接被赋值？</font>**  
&emsp; final 关键字在 Java 中代表不可改变的意思，意思就是说 value 的值一旦赋值就不会再改变了。既然一旦赋值就不会再改变，那么就必须一开始就给其赋予用户想要的值，因此被 final 修饰的类变量在准备阶段就会被赋予想要的值。而没有被 final 修饰的类变量，其可能在初始化阶段或者运行阶段发生变化，所以就没有必要在准备阶段对它赋予用户想要的值。  

<!-- 
&emsp; 当完成字节码文件的校验之后，JVM 便会开始为类变量分配内存并设置类变量初始值。  
&emsp; 类变量是被 static 修饰的变量，准备阶段为类变量分配内存并设置初始值，使用的是方法区的内存。  
&emsp; 实例变量不会在这阶段分配内存，它会在对象实例化时随着对象一起被分配在堆中。应该注意到，实例化不是类加载的一个过程，类加载发生在所有实例化操作之前，并且类加载只进行一次，实例化可以进行多次。  
&emsp; 注意：这里的初始化指的是为变量赋予 Java 语言中该数据类型的零值，而不是用户代码里初始化的值。  

 https://juejin.im/post/5e0aa97451882549757e5e56#heading-19 
--> 

#### 1.2.2.3. 解析  
&emsp; **<font color = "red">解析：将常量池内的符号引用转换为直接引用</font>** ，得到类或者字段、方法在内存中的指针或者偏移量，确保类与类之间相互引用正确性，完成内存结构布局，以便直接调用该方法。</font>解析主要有四种：类或接口的解析、字段解析、类方法解析、接口方法解析。  

* 符号引用：以一组符号来描述所引用的目标。符号引用与虚拟机实现的布局无关，引用的目标并不一定要已经加载到内存中。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须是一致的，因为符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中。符号引用是class文件中CONSTANT_Class_info、CONSTANT_Field_info、CONSTANT_Method_info等类型的常量。使用符号引用来描述所引用的目标。  
* 直接引用，通过对符号引用进行解析，找到引用的实际内存地址。可以是指向目标的指针，相对偏移量或是一个能间接定位到目标的句柄。如果有了直接引用，那引用的目标必定已经在内存中存在。  

&emsp; **<font color = "red">为什么要使用符号引用？</font>**  
&emsp; 符号引用要转换成直接引用才有效，这也说明直接引用的效率要比符号引用高。那为什么要用符号引用呢？这是因为类加载之前，javac会将源代码编译成.class文件，这个时候javac是不知道被编译的类中所引用的类、方法或者变量它们的引用地址在哪里，所以只能用符号引用来表示。当然，符号引用是要遵循java虚拟机规范的。  

&emsp; **<font color = "red">解析过程在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 的动态绑定。</font>**   

### 1.2.3. 初始化  
&emsp; 类初始化阶段是类加载过程的最后一步，前面的类加载过程中，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的Java程序代码（或者说是字节码）。   
&emsp; 在准备阶段，类变量已经被赋过默认初始值，而<font color = "red">在初始化阶段，类变量将被赋值为代码期望赋的值。初始化过程即执行类中的静态初始化代码（static代码块）、构造器代码以及静态变量的初始化。</font>  

<!-- 
&emsp; 在Java中对类变量进行初始值设定有两种方式：  
1. 声明类变量是指定初始值  
2. 使用静态代码块为类变量指定初始值
-->

#### 1.2.3.1. 类初始化时机  

1. **<font color = "red">主动引用执行初始化。</font>**<font color = "red">对于初始化阶段，虚拟机规范则是严格规定了有且只有5种情况必须立即对类进行“初始化”。</font>  
  
    * 显式字节码指令集：遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。显式字节码指令集(new/getstatic/putstatic/invokestatic)：对应的场景就是创建对象或者调用到类文件的静态变量/静态方法/静态代码块。  
    * 反射：使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没存进行过初始化，则需要先触发其初始化。  
    * 继承：当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。  
    * 入口：当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。  
    * 当使用JDK 1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。  

            对于这5种会触发类进行初始化的场景，虚拟机规范中使用了一个很强烈的限定语：“有且只有”，这5种场景中的行为称为对一个类进行主动引用。
  
2. **<font color = "red">被动引用不执行初始化。</font>** 以上5种场景中的行为称为对一个类进行主动引用。除此之外，所有引用类的方式都不会触发初始化，称为被动引用。被动引用的常见例子包括：  

    * 通过子类引用父类的静态字段，不会导致子类初始化。  

        ```java
        System.out.println(SubClass.value);  // value字段在SuperClass中定义
        ```
    * 通过数组定义来引用类，不会触发此类的初始化。该过程会对数组类进行初始化，数组类是一个由虚拟机自动生成的、直接继承自Object 的子类，其中包含了数组的属性和方法。  

        ```java
        SuperClass[] sca = new SuperClass[10];
        ```
    * 常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。  

        ```java
        System.out.println(ConstClass.HELLOWORLD);
        ```

#### 1.2.3.2. 类初始化流程xxxxx  
&emsp; 初始化阶段是执行类构造器client方法的过程。client方法并不是由程序员在Java代码中直接编写的方法，是由编译器自动生成的。  

* client方法是由编译器自动收集类中的类变量的赋值操作和静态语句块static{}中的语句合并而成的。  
* 编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问。  
* 虚拟机会保证子client方法执行之前，父类的client方法已经执行完毕， 如果一个类中没有对静态变量赋值也没有静态语句块，那么编译器可以不为这个类生client()方法。  

        JVM初始化步骤：  
        1. 假如这个类还没有被加载和连接，则程序先加载并连接该类
        2. 假如该类的直接父类还没有被初始化，则先初始化其直接父类
        3. 假如类中有初始化语句，则系统依次执行这些初始化语句

&emsp; **<font color = "red">一句话概括：初始化阶段，执行类构造器＜clinit>() 方法（类变量赋值、静态语句块），如果赋值运算是通过其他类的静态方法来完成的，那么会马上解析另外一个类，在虚拟机栈中执行完毕后通过返回值进行赋值。</font>**  

&emsp; clinit方法和init方法：  
&emsp; <font color = "red">在编译生成class文件时，会自动产生两个方法，clinit是类的初始化方法，init是实例的初始化方法。</font>clinit：在jvm第一次加载class文件时调用，包括静态变量初始化语句和静态块的执行。init: 在实例创建出来的时候调用，包括调用new操作符；调用Class或 Java.lang.reflect.Constructor对象的newInstance()方法；调用任何现有对象的clone()方法；通过 java.io.ObjectInputStream 类的getObject()方法反序列化。  

#### 1.2.3.3. 延伸知识点  
<!-- https://juejin.im/post/5e0aa97451882549757e5e56#heading-19--> 
......

### 1.2.4. 使用：  
&emsp; 类的使用包括主动引用和被动引用。参考类初始化时机。  

### 1.2.5. 卸载  
&emsp; 参考[GC](/docs/java/JVM/5.GC垃圾回收.md)方法区回收。  

## 1.3. 类加载的方式：类加载器  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/JVM/JVM-6.png)  

### 1.3.1. 类加载器的分类  
&emsp; 类加载子系统也可以称之为类加载器，JVM默认提供三个类加载器：启动类加载器、扩展类加载器、应用类加载器。  
1. 启动类加载器（BootStrap ClassLoader），是最顶层的类加载器，加载 jre/lib包下面的jar文件（JDK中的核心类库，⽆法被java程序直接引⽤），如rt.jar、resources.jar、charsets.jar等、被-Xbootclasspath参数所指定的路径中，并且是虚拟机会识别的jar类库加载到内存中。  
2. 扩展类加载器（Extension ClassLoader），加载jre/lib/ext包下面的jar文件、或者被java.ext.dirs系统变量指定的路径中的所有类库。  
3. 应用类加载器（Application ClassLoader），负责加载应用程序classpath目录下所有jar和class文件。  

&emsp; 三个类加载器的联系：除了BootStrap ClassLoader之外的另外两个默认加载器都是继承自java.lang.ClassLoader。BootStrap ClassLoader不是一个普通的Java类，它底层由C++编写，已嵌入到了JVM的内核当中，当JVM启动后，BootStrap ClassLoader也随之启动，负责加载完核心类库后，并构造Extension ClassLoader和App ClassLoader类加载器。  

### 1.3.2. 类加载器的加载机制  
&emsp; 类加载器之间的层级关系如上图所示。这种层次关系被称作为双亲委派模型。  

#### 1.3.2.1. 双亲委派模型  
&emsp; 如果一个类加载器收到了加载类的请求，它会先把请求委托给上层加载器去完成，上层加载器又会委托上上层加载器，一直到最顶层的类加载器；如果上层加载器无法完成类的加载工作时，当前类加载器才会尝试自己去加载这个类。如果都没加载到，则会抛出ClassNotFoundException异常。例子：父加载器已经加载了JDK中的 String.class 文件，所以不能定义同名的 String.java文件。  
&emsp; **<font color = "red">一句话概述：一个类加载器首先将类加载请求转发到父类加载器，只有当父类加载器无法完成时才尝试自己加载。</font>**  
&emsp; ClassLoader源码分析：  

```java
public Class<?> loadClass(String name)throws ClassNotFoundException {
    return loadClass(name, false);
}

protected synchronized Class<?> loadClass(String name, boolean resolve)throws ClassNotFoundException {
    // 首先判断该类型是否已经被加载
    Class c = findLoadedClass(name);
    if (c == null) {
        //如果没有被加载，就委托给父类加载或者委派给启动类加载器加载
        try {
            if (parent != null) {
                //如果存在父类加载器，就委派给父类加载器加载
                c = parent.loadClass(name, false);
            } else {
                //如果不存在父类加载器，就检查是否是由启动类加载器加载的类，通过调用本地方法native Class findBootstrapClass(String name)
                c = findBootstrapClass0(name);
            }
        } catch (ClassNotFoundException e) {
            // 如果父类加载器和启动类加载器都不能完成加载任务，才调用自身的加载功能
            c = findClass(name);
        }
    }
    if (resolve) {
        resolveClass(c);
    }
    return c;
}
```
&emsp; <font color = "red">双亲委派模型的好处：</font>  

* 避免类的重复加载，JVM中区分不同类，不仅仅是根据类名，相同的class文件被不同的ClassLoader加载就属于两个不同的类（比如，Java中的Object类，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，如果不采用双亲委派模型，由各个类加载器自己去加载的话，系统中会存在多种不同的Object类）。  
* 防止核心API被随意篡改，避免用户自己编写的类动态替换 Java的一些核心类，比如自定义类：java.lang.String。  

#### 1.3.2.2. 破坏双亲委派模型  
&emsp; 双亲委派模型并不是一个强制性的约束模型，而是Java设计者推荐给开发者的类加载器实现方式，可以“被破坏”。  

&emsp; **<font color = "red">破坏双亲委派模型的案例：</font>**  

* 双亲委派模型有一个问题：顶层ClassLoader，无法加载底层ClassLoader的类。典型例子JNDI、JDBC，所以加入了线程上下文类加载器（Thread Context ClassLoader）,可以通过Thread.setContextClassLoaser()设置该类加载器，然后顶层ClassLoader再使用Thread.getContextClassLoader()获得底层的ClassLoader进行加载。  
* Tomcat中使用了自定义ClassLoader，并且也破坏了双亲委托机制。每个应用使用WebAppClassloader进行单独加载，它首先使用WebAppClassloader进行类加载，如果加载不了再委托父加载器去加载，这样可以保证每个应用中的类不冲突。每个tomcat中可以部署多个项目，每个项目中存在很多相同的class文件（很多相同的jar包），加载到jvm中可以做到互不干扰。  
* 利用破坏双亲委派来实现代码热替换（每次修改类文件，不需要重启服务）。因为一个Class只能被一个ClassLoader加载一次，否则会报java.lang.LinkageError。当要实现代码热部署时，可以每次都new一个自定义的ClassLoader来加载新的Class文件。JSP的实现动态修改就是使用此特性实现。  

### 1.3.3. 类加载器应用  
#### 1.3.3.1. 自定义类加载器  

&emsp; <font color = "red">什么情况下需要自定义类加载器？</font>  
1. **隔离加载类。** 在某些框架内进行中间件与应用的模块隔离，把类加载到不同的环境。
2. **修改类加载方式。** 类的加载模型并非强制，除了Bootstrap以外，其他的加载并非一定要引入，或者根据实际情况在某个时间点进行按需进行动态加载。
3. **扩展加载源。** 比如从数据库、网络，甚至电视机机顶盒进行加载。
4. **防止源码泄露。** Java代码容易被编译和篡改，可以进行编译加密。那么类加载器也需要自定义，还原加密的字节码。

&emsp; java.lang.ClassLoader 的 loadClass() 实现了双亲委派模型的逻辑，自定义类加载器一般不去重写它，但是需要重写 findClass() 方法。  

```java
public class CustomClassLoader extends ClassLoader {

    @Override
    protected Class<?> findClass(String name) throws ClassNotFoundException {
        try {
            byte[] result = getClassFromCustomPath(name);
            if (result == null) {
                throw new FileNotFoundException();
            } else {
                return defineClass(name, result, 0, result.length);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        throw new ClassNotFoundException(name);
    }

    private byte[] getClassFromCustomPath(String name) {
        // TODO 从自定义路径中加载指定类
        return null;
    }
}
```

#### 1.3.3.2. 查看Boostrap ClassLoader 加载的类库  

```java
public static void main(String[] args) {
    URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();
    for (URL url : urls) {
        System.out.println(url.toExternalForm());
    }
}
```
&emsp; 执行结果：  

```java
file:/C:/Program%20Files/Java/jdk1.8.0_131/jre/lib/resources.jar
file:/C:/Program%20Files/Java/jdk1.8.0_131/jre/lib/rt.jar
file:/C:/Program%20Files/Java/jdk1.8.0_131/jre/lib/sunrsasign.jar
file:/C:/Program%20Files/Java/jdk1.8.0_131/jre/lib/jsse.jar
file:/C:/Program%20Files/Java/jdk1.8.0_131/jre/lib/jce.jar
file:/C:/Program%20Files/Java/jdk1.8.0_131/jre/lib/charsets.jar
file:/C:/Program%20Files/Java/jdk1.8.0_131/jre/lib/jfr.jar
file:/C:/Program%20Files/Java/jdk1.8.0_131/jre/classes
```

#### 1.3.3.3. 如何在启动时观察加载了哪个jar包中的哪个类？  
&emsp; 使用-XX:+TraceClassLoading参数，可以在启动时观察加载了哪个jar包中的哪个类。此参数在解决类冲突时特别实用。因为不同JVM环境对于加载类的顺序并非是一致的。  
&emsp; 部分示例：  

```java
[Opened C:\Program Files\Java\jdk1.8.0_131\jre\lib\rt.jar]
[Loaded java.lang.Object from C:\Program Files\Java\jdk1.8.0_131\jre\lib\rt.jar]
[Loaded java.io.Serializable from C:\Program Files\Java\jdk1.8.0_131\jre\lib\rt.jar]
[Loaded java.lang.Comparable from C:\Program Files\Java\jdk1.8.0_131\jre\lib\rt.jar]
[Loaded java.lang.CharSequence from C:\Program Files\Java\jdk1.8.0_131\jre\lib\rt.jar]
[Loaded java.lang.String from C:\Program Files\Java\jdk1.8.0_131\jre\lib\rt.jar]
[Loaded java.lang.reflect.AnnotatedElement from C:\Program Files\Java\jdk1.8.0_131\jre\lib\rt.jar]
[Loaded java.lang.reflect.GenericDeclaration from C:\Program Files\Java\jdk1.8.0_131\jre\lib\rt.jar]
[Loaded java.lang.reflect.Type from C:\Program Files\Java\jdk1.8.0_131\jre\lib\rt.jar]
[Loaded java.lang.Class from C:\Program Files\Java\jdk1.8.0_131\jre\lib\rt.jar]
[Loaded java.lang.Cloneable from C:\Program Files\Java\jdk1.8.0_131\jre\lib\rt.jar]
[Loaded java.lang.ClassLoader from C:\Program Files\Java\jdk1.8.0_131\jre\lib\rt.jar]
[Loaded java.lang.System from C:\Program Files\Java\jdk1.8.0_131\jre\lib\rt.jar]
[Loaded java.lang.Throwable from C:\Program Files\Java\jdk1.8.0_131\jre\lib\rt.jar]
......
```

#### 1.3.3.4. 观察特定类的加载上下文  
&emsp; 由于加载的类数量众多，调试时很难捕捉到指定类的加载过程，这时可以使用条件断点功能。拿HashMap的加载过程为例，在ClassLoader#loadClass()处打个条件断点，效果如下：  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/JVM/JVM-48.png)  

