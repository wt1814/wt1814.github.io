
<!-- TOC -->

- [1. 内存中对象](#1-内存中对象)
    - [1.1. 对象的创建过程](#11-对象的创建过程)
        - [1.1.1. TLAB](#111-tlab)
    - [1.2. 对象的内存布局](#12-对象的内存布局)
    - [1.3. 对象的访问定位](#13-对象的访问定位)
    - [1.4. 堆内存分配策略](#14-堆内存分配策略)
        - [1.4.1. 对象优先在Eden分配](#141-对象优先在eden分配)
        - [1.4.2. 大对象直接进入老年代](#142-大对象直接进入老年代)
        - [1.4.3. 长期存活的对象将进入老年代](#143-长期存活的对象将进入老年代)
        - [1.4.4. 动态对象年龄判定](#144-动态对象年龄判定)
        - [1.4.5. 空间分配担保](#145-空间分配担保)

<!-- /TOC -->

# 1. 内存中对象  
<!--
https://mp.weixin.qq.com/s/wsgxJSpEbY3yrmL9mDC2sw
-->

## 1.1. 对象的创建过程  
&emsp; 简述一下Java中创建一个对象的过程？  
&emsp; 解析：回答这个问题首先就要清楚类的生命周期  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/JVM/JVM-5.png)  
&emsp; Java中对象的创建就是在堆上分配内存空间的过程，此处说的对象创建仅限于new关键字创建的普通Java对象，不包括数组对象的创建。  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/JVM/JVM-61.png)  
1. <font color = "red">检测类是否被加载</font>  
&emsp; 当虚拟机执行到new时，会先去常量池中查找这个类的符号引用。如果能找到符号引用，说明此类已经被加载到方法区（方法区存储虚拟机已经加载的类的信息），可以继续执行；如果找不到符号引用，就会使用类加载器执行类的加载过程，类加载完成后继续执行。  
2. <font color = "lime">为对象分配内存</font>  
&emsp; 类加载完成以后，虚拟机就开始为对象分配内存，此时所需内存的大小就已经确定了。只需要在堆上分配所需要的内存即可。  
    &emsp; 具体的分配内存有两种情况：第一种情况是内存空间绝对规整，第二种情况是内存空间是不连续的。  

    * 对于内存绝对规整的情况相对简单一些，虚拟机只需要在被占用的内存和可用空间之间移动指针即可，这种方式被称为指针碰撞。  
    * 对于内存不规整的情况稍微复杂一点，这时候虚拟机需要维护一个列表，来记录哪些内存是可用的。分配内存的时候需要找到一个可用的内存空间，然后在列表上记录下已被分配，这种方式称为空闲列表。  
        
    &emsp; <font color = "red">分配内存的时候也需要考虑线程安全问题，有两种解决方案：</font>  

    * 第一种是采用同步的办法，使用CAS来保证操作的原子性。
    * 另一种是每个线程分配内存都在自己的空间内进行，即是每个线程都在堆中预先分配一小块内存，称为本地线程分配缓冲（TLAB），分配内存的时候再TLAB上分配，互不干扰。
3. <font color = "red">为分配的内存空间初始化零值</font>  
&emsp; 对象的内存分配完成后，还需要将对象的内存空间都初始化为零值，这样能保证对象即使没有赋初值，也可以直接使用。  
4. <font color = "red">对对象进行其他设置</font>  
&emsp; 分配完内存空间，初始化零值之后，虚拟机还需要对对象进行其他必要的设置，设置的地方都在对象头中，包括这个对象所属的类，类的元数据信息，对象的hashcode，GC分代年龄等信息。  
5. <font color = "red">执行init方法</font>  
&emsp; 执行完上面的步骤之后，在虚拟机里这个对象就算创建成功了，但是对于Java程序来说还需要执行init方法才算真正的创建完成，因为这个时候对象只是被初始化零值了，还没有真正的去根据程序中的代码分配初始值，调用了init方法之后，这个对象才真正能使用。  

&emsp; 到此为止一个对象就产生了，这就是new关键字创建对象的过程。过程如下：  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/JVM/JVM-60.png)  

### 1.1.1. TLAB  
&emsp; ......
<!-- 
https://mp.weixin.qq.com/s/jPIHNsQwiYNCRUQt1qXR6Q
https://mp.weixin.qq.com/s/fyorrpT5-hFpIS5aEDNjZA
-->

## 1.2. 对象的内存布局  
&emsp; 对象的内存布局包括三个部分：对象头，实例数据和对齐填充。

* 对象头：对象头包括两部分信息，第一部分是存储对象自身的运行时数据，如哈希码，GC分代年龄，锁状态标志，线程持有的锁等等。第二部分是类型指针，即对象指向类元数据的指针。  
* 实例数据：就是数据  
* 对齐填充：不是必然的存在，就是为了对齐  

## 1.3. 对象的访问定位  
&emsp; <font color = "red">对象的访问定位有两种：句柄定位和直接指针。</font>  

* 句柄定位：Java 堆会画出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/JVM/JVM-58.png)  
* 直接指针访问：java堆对象的不居中就必须考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象地址。  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/JVM/JVM-59.png)  

## 1.4. 堆内存分配策略  
&emsp; JVM分配内存机制有三大原则和担保机制。具体如下所示：  

* 优先分配到eden区
* 大对象直接进入到老年代
* 长期存活的对象分配到老年代
* 空间分配担保  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/JVM/JVM-79.png)  

### 1.4.1. 对象优先在Eden分配  
&emsp; 在JVM内存模型中，JVM年轻代堆内存可以划分为一块Eden区和两块Survivor区。在大多数情况下, 对象在新生代Eden区中分配, 当Eden区没有足够空间分配时，JVM发起一次Minor GC，将Eden区和其中一块Survivor区内尚存活的对象放入另一块Survivor区域，如果在Minor GC期间发现新生代存活对象无法放入空闲的Survivor区，则会通过空间分配担保机制使对象提前进入老年代。  

### 1.4.2. 大对象直接进入老年代  
&emsp; Serial和ParNew两款收集器提供了-XX:PretenureSizeThreshold的参数，令大于该值的大对象直接在老年代分配, 这样做的目的是避免在Eden区和Survivor区之间产生大量的内存复制(大对象一般指需要大量连续内存的Java对象，如很长的字符串和数组), 因此大对象容易导致还有不少空闲内存就提前触发GC以获取足够的连续空间。  

### 1.4.3. 长期存活的对象将进入老年代  
&emsp; 虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别哪些对象应放在新生代，哪些对象应放在老年代中。为此，虚拟机为每个对象定义了一个对象年龄(Age)计数器，对象在Eden出生如果经第一次Minor GC后仍然存活，且能被Survivor容纳的话，将被移动到Survivor空间中，并将年龄设为1。以后对象在Survivor区中每经历一次Minor GC，年龄就+1。当增加到一定程度(-XX:MaxTenuringThreshold，默认15)，将会被晋升到老年代。对象晋升老年代的年龄阈值，可以通过参数-XX:MaxTenuringThreshold设置。  

### 1.4.4. 动态对象年龄判定  
&emsp; 为了更好地适应不同程序的内存情况，JVM并不总是要求对象的年龄必须达到MaxTenuringThreshold才能晋升老年代: 如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，而无须等到晋升年龄。  

### 1.4.5. 空间分配担保  
&emsp; JVM在发生Minor GC之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间，如果大于，则此次Minor GC是安全的如果小于，则虚拟机会查看HandlePromotionFailure设置项的值是否允许担保失败。如果HandlePromotionFailure=true，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小，如果大于则尝试进行一次Minor GC，但这次Minor GC依然是有风险的；如果小于或者HandlePromotionFailure=false，则改为进行一次Full GC。  

<!-- 
2.2. 内存分配方式  
&emsp; 分配方式有“指针碰撞”和“空闲列表”两种，选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定，即取决于GC收集器的算法是"标记-清除"，还是"标记-整理"（也称作"标记-压缩"），值得注意的是，复制算法内存也是规整的。  

2.2.1. 指针碰撞  
&emsp; 假设Java堆中内存是绝对规整的，所有用过的内存都放一边，空闲的内存放另一边，中间放着一个指针作为分界点的指示器，所分配内存就仅仅是把哪个指针向空闲空间那边挪动一段与对象大小相等的举例，这种分配方案就叫指针碰撞。  

2.2.2. 空闲列表  
&emsp; 有一个列表，其中记录中哪些内存块可用，在分配的时候从列表中找到一块足够大的空间划分给对象实例，然后更新列表中的记录。这就叫做空闲列表。  

2.3. ※※※内存分配并发问题  
&emsp; 问题产生：空闲列表中一块内存被分配后，还未更新空闲列表时，另一对象请求分配该地址。线程不安全。虚拟机采用两种方式来保证线程安全：  
&emsp; CAS（乐观锁）+失败重试：虚拟机采用CAS配上失败重试的方式保证更新操作的原子性。  
&emsp; TLAB：为每一个线程预先在Eden区分配一块儿内存，JVM在给线程中的对象分配内存时，首先在TLAB分配，当对象大于TLAB中的剩余内存或TLAB的内存已用尽时，再采用上述的CAS进行内存分配。  
-->