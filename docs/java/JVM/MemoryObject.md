
<!-- TOC -->

- [1. 内存中的对象](#1-内存中的对象)
    - [1.1. 对象的创建过程](#11-对象的创建过程)
    - [1.2. ★★★步骤二：对象分配内存流程详解](#12-★★★步骤二对象分配内存流程详解)
        - [1.2.1. 内存分配两种方式](#121-内存分配两种方式)
        - [1.2.2. 内存分配并发问题](#122-内存分配并发问题)
        - [1.2.3. ~~★★★并发解决之TLAB详解~~](#123-★★★并发解决之tlab详解)
            - [1.2.3.1. ~~TLAB介绍~~](#1231-tlab介绍)
            - [1.2.3.2. ~~TLAB的缺点~~](#1232-tlab的缺点)
        - [1.2.4. ~~内存分配全流程~~](#124-内存分配全流程)
        - [1.2.5. 堆内存分配策略](#125-堆内存分配策略)
            - [1.2.5.1. 对象优先在Eden分配](#1251-对象优先在eden分配)
            - [1.2.5.2. 大对象直接进入老年代](#1252-大对象直接进入老年代)
            - [1.2.5.3. 长期存活的对象将进入老年代](#1253-长期存活的对象将进入老年代)
            - [1.2.5.4. 动态对象年龄判定](#1254-动态对象年龄判定)
            - [1.2.5.5. 空间分配担保](#1255-空间分配担保)
            - [1.2.5.6. ~~小结：对象何时进入老年代？~~](#1256-小结对象何时进入老年代)
    - [1.3. 对象的内存布局](#13-对象的内存布局)
    - [1.4. 对象的访问定位](#14-对象的访问定位)

<!-- /TOC -->

&emsp; **<font color = "red">总结：</font>**  
1. **<font color = "clime">对象创建过程：1. 检测类是否被加载；2. 为对象分配内存；3. 将分配内存空间的对象初始化零值；4. 对对象进行其他设置；5.执行init方法。</font>**   

    当类加载完成之后，紧接着就是对象分配内存空间和初始化的过程
        首先为对象分配合适大小的内存空间
        接着为实例变量赋默认值
        设置对象的头信息，对象hash码、GC分代年龄、元数据信息等
        执行构造函数(init)初始化

2. 步骤二：对象分配内存流程详解：
    * 分配内存两种方式：指针碰撞（内存空间绝对规整）；空闲列表（内存空间是不连续的）。
        * 标记-整理或复制 ---> 空间规整 ---> 指针碰撞； 
        * 标记-清除 ---> 空间不规整 ---> 空闲列表。       
    * 线程安全问题：1).采用CAS； **<font color = "clime">2).线程本地分配缓冲（TLAB）。</font>**  
    * **<font color = "blue">TLAB详解：</font>**  
        * 线程本地分配缓存，这是一个线程专用的内存分配区域。可以加速对象的分配。TLAB是在堆中开辟的内存区域。默认情况下，TLAB空间的内存非常小，仅占有整个Eden空间的1%。  
        * **<font color = "blue">TLAB通常很小，所以放不下大对象。`JVM设置了最大浪费空间`。</font>**  
        &emsp; 当大对象申请内存时，当剩余的空间小于最大浪费空间，那该TLAB属于的线程在重新向Eden区申请一个TLAB空间。进行对象创建，还是空间不够，那这个对象太大了，去Eden区直接创建吧！  
        &emsp; 当剩余的空间大于最大浪费空间，那这个大对象直接去Eden区创建。剩余空间还需要使用。
    * **<font color = "blue">`内存分配全流程：`逃逸分析 ---> 没有逃逸，尝试栈上分配 ---> 是否满足直接进入老年代的条件 ---> `尝试TLAB分配` ---> `新生代Eden区分配`。</font>**  
3. 堆内存分配策略：  
&emsp; 分配策略有：对象优先在Eden分配、大对象直接进入老年代、长期存活的对象将进入老年代、动态对象年龄判定、空间分配担保。  
&emsp; `空间分配担保：` **<font color = "clime">JVM在发生Minor GC之前，虚拟机会检查老年代最大可用的`连续空间`是否大于新生代所有对象的总空间。</font>**   


# 1. 内存中的对象  
<!-- 

-->

## 1.1. 对象的创建过程  
&emsp; 简述一下Java中创建一个对象的过程？  
&emsp; 解析：回答这个问题首先就要清楚类的生命周期  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/JVM/JVM-5.png)  
&emsp; Java中对象的创建就是在堆上分配内存空间的过程，此处说的对象创建仅限于new关键字创建的普通Java对象，不包括数组对象的创建。  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/JVM/JVM-61.png)  
1. <font color = "red">检测类是否被加载</font>  
&emsp; 当虚拟机执行到new时，会先去常量池中查找这个类的符号引用。如果能找到符号引用，说明此类已经被加载到方法区(方法区存储虚拟机已经加载的类的信息)，可以继续执行；如果找不到符号引用，就会使用类加载器执行类的加载过程，类加载完成后继续执行。  
2. <font color = "clime">类加载完成以后，虚拟机就开始为对象分配内存，此时所需内存的大小就已经确定了。只需要在堆上分配所需要的内存即可。  </font>  
3. <font color = "red">为分配的内存空间初始化零值</font>  
&emsp; 对象的内存分配完成后，还需要将对象的内存空间都初始化为零值，这样能保证对象即使没有赋初值，也可以直接使用。  
4. <font color = "red">对对象进行其他设置</font>  
&emsp; 分配完内存空间，初始化零值之后，虚拟机还需要对对象进行其他必要的设置，设置的地方都在对象头中，包括这个对象所属的类，类的元数据信息，对象的hashcode，GC分代年龄等信息。  
5. <font color = "red">执行init方法</font>  
&emsp; 执行完上面的步骤之后，在虚拟机里这个对象就算创建成功了，但是对于Java程序来说还需要执行init方法才算真正的创建完成，因为这个时候对象只是被初始化零值了，还没有真正的去根据程序中的代码分配初始值，调用了init方法之后，这个对象才真正能使用。  

## 1.2. ★★★步骤二：对象分配内存流程详解  
<!-- 
https://www.jianshu.com/p/8be816cbb5ed
https://mp.weixin.qq.com/s/WVGZIBXsIVYPMfhkqToh_Q
-->
<!-- 
~~
https://mp.weixin.qq.com/s/jPIHNsQwiYNCRUQt1qXR6Q
-->
### 1.2.1. 内存分配两种方式  
&emsp; 分配方式有“指针碰撞”和“空闲列表”两种：  

* 指针碰撞(Serial、ParNew等带Compact过程的收集器)：  
&emsp; 对于内存绝对规整的情况相对简单一些，虚拟机只需要在被占用的内存和可用空间之间移动指针即可，这种方式被称为指针碰撞。  
* **空闲列表(CMS这种基于Mark-Sweep算法的收集器)**   
&emsp; **<font color = "red">对于内存不规整的情况稍微复杂一点，这时候虚拟机需要维护一个列表，来记录哪些内存是可用的。分配内存的时候需要找到一个可用的内存空间，然后在列表上记录下已被分配，这种方式称为空闲列表。</font>**  


&emsp; **选择策略：**  
&emsp; **<font color = "red">选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定，即取决于GC收集器的算法是"标记-清除"，还是"标记-整理"(也称作"标记-压缩")，值得注意的是，复制算法内存也是规整的。</font>**  
&emsp; **<font color = "clime">小结：</font>**  
* 标记-整理或复制 ---> 空间规整 ---> 指针碰撞；
* 标记-清除 ---> 空间不规整 ---> 空闲列表。  


### 1.2.2. 内存分配并发问题  
&emsp; 由于对象一般会分配在堆上，而堆是全局共享的。因此在同一时间，可能会有多个线程在堆上申请空间。因此，每次对象分配都必须要进行同步。 **内存分配并发问题有两种方式：CAS和TLAB。**    
&emsp; 虚拟机采用CAS配上失败重试的方式保证更新操作的原子性，而在竞争激烈的场合分配的效率又会进一步下降。JVM使用TLAB来避免多线程冲突，在给对象分配内存时，每个线程使用自己的TLAB，这样可以避免线程同步，提高了对象分配的效率。  
<!-- 
&emsp; 空闲列表中一块内存被分配后，还未更新空闲列表时，另一对象请求分配该地址。线程不安全。虚拟机采用两种方式来保证线程安全：  
&emsp; CAS(乐观锁)+失败重试：虚拟机采用CAS配上失败重试的方式保证更新操作的原子性。  
&emsp; TLAB：为每一个线程预先在Eden区分配一块儿内存，JVM在给线程中的对象分配内存时，首先在TLAB分配，当对象大于TLAB中的剩余内存或TLAB的内存已用尽时，再采用上述的CAS进行内存分配。  
2. <font color = "red">分配内存的时候也需要考虑线程安全问题，有两种解决方案：</font>  

    * 第一种是采用同步的办法，使用CAS来保证操作的原子性。
    * **<font color = "lime">另一种是每个线程分配内存都在自己的空间内进行，即是每个线程都在堆中预先分配一小块内存，称为本地线程分配缓冲(TLAB)，分配内存的时候在TLAB上分配，互不干扰。</font>**
-->



<!-- 
https://www.jianshu.com/p/8be816cbb5ed
-->
### 1.2.3. ~~★★★并发解决之TLAB详解~~  
#### 1.2.3.1. ~~TLAB介绍~~
&emsp; **<font color = "clime">TLAB，全称Thread Local Allocation Buffer，线程本地分配缓存，这是一个线程专用的内存分配区域。可以加速对象的分配。</font>**  
&emsp; **TLAB是在堆中开辟的内存区域。** 默认情况下，TLAB 空间的内存非常小，仅占有整个 Eden 空间的 1%，可以通过 -XX:TLABWasteTargetPercent 设置 TLAB 空间所占用 Eden 空间的百分比大小。  

|参数|描述|
|---|---|
|-Xx:+UseTLAB|使用TLAB|
|-XX:+TLABSize|设置TLAB大小|
|-XX:TLABRefillWasteFraction|设置维护进入TLAB空间的单个对象大小，它是一个比例值，默认为64，即如果对象大于整个空间的1/64，则在堆创建|
|-XX:+PrintTLAB|查看TLAB信息|
|-Xx:ResizeTLAB|自调整TLABRefillWasteFraction阀值。|


&emsp; TLAB的本质其实是三个指针管理的区域：start，top 和 end，每个线程都会从Eden分配一块空间，例如说100KB，作为自己的TLAB，其中 start 和 end 是占位用的，标识出 eden 里被这个 TLAB 所管理的区域，卡住eden里的一块空间不让其它线程来这里分配。  
&emsp; TLAB只是让每个线程有私有的分配指针，但存对象的内存空间还是给所有线程访问的，只是其它线程无法在这个区域分配而已。从这一点看，它被翻译为 线程私有分配区 更为合理一点。  
&emsp; 当一个TLAB用满(分配指针top撞上分配极限end了)，就新申请一个TLAB，而在老TLAB里的对象还留在原地什么都不用管——它们无法感知自己是否是曾经从TLAB分配出来的，而只关心自己是在eden里分配的。  

&emsp; 分配策略：  
&emsp; 一个100KB的TLAB区域，如果已经使用了80KB，当需要分配一个30KB的对象时，TLAB是如何分配的呢？  
&emsp; 此时，虚拟机有两种选择：第一，废弃当前的TLAB(会浪费20KB的空3.4 间)；第二，将这个30KB的对象直接分配到堆上，保留当前TLAB(当有小于20KB的对象请求TLAB分配时可以直接使用该TLAB区域)。  
&emsp; JVM选择的策略是：在虚拟机内部维护一个叫refill_waste的值，当请求对象大于refill_waste时，会选择在堆中分配，反之，则会废弃当前TLAB，新建TLAB来分配新对象。  
&emsp; 【默认情况下，TLAB和refill_waste都是会在运行时不断调整的，使系统的运行状态达到最优。】  

<!-- 
TLAB本身占用eEden区空间，在开启TLAB的情况下，虚拟机会为每个Java线程分配一块TLAB空间。参数-XX:+UseTLAB开启TLAB，默认是开启的。TLAB空间的内存非常小，缺省情况下仅占有整个Eden空间的1%，当然可以通过选项-XX:TLABWasteTargetPercent设置TLAB空间所占用Eden空间的百分比大小。 

&emsp; 这是为了加速对象的分配。由于对象一般分配在堆上，而堆是线程共用的，因此可能会有多个线程在堆上申请空间，而每一次的对象分配都必须线程同步，会使分配的效率下降。考虑到对象分配几乎是Java中最常用的操作，因此JVM使用了TLAB这样的线程专有区域来避免多线程冲突，提高对象分配的效率。  


&emsp; 一般而言生成对象需要向堆中的新生代申请内存空间，而堆又是全局共享的，像新生代内存又是规整的，是通过一个指针来划分的。  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/JVM/JVM-105.png)  
&emsp; 内存是紧凑的，新对象创建指针就右移对象大小 size 即可，这叫指针加法(bump [up] the pointer)。  
&emsp; 可想而知如果多个线程都在分配对象，那么这个指针就会成为热点资源，需要互斥，那分配的效率就低了。  
&emsp; 为了降低规整内存的分配指针碰撞问题，引入了TLAB(线程本地存储)。  
-->

#### 1.2.3.2. ~~TLAB的缺点~~  
&emsp; 事务总不是完美的，TLAB也有自己的缺点。因为TLAB通常很小，所以放不下大对象。
1. TLAB空间大小是固定的，但是这时候一个大对象，TLAB剩余的空间已经容不下它了。(比如100kb的TLAB，来了个110KB的对象)
2. TLAB空间还剩一点点没有用到，有点舍不得。(比如100kb的TLAB，装了80KB，又来了个30KB的对象)  
&emsp;所以JVM开发人员做了以下处理，设置了最大浪费空间。  
&emsp; 当剩余的空间小于最大浪费空间，那该TLAB属于的线程在重新向Eden区申请一个TLAB空间。进行对象创建，还是空间不够，那这个对象太大了，去Eden区直接创建吧！  
&emsp; 当剩余的空间大于最大浪费空间，那这个大对象直接去Eden区创建，TLAB放不下没有使用完的空间。  
&emsp;当然，又会造成新的病垢。  
3. Eden空间够的时候，再次申请TLAB没问题，我不够了，Heap的Eden区要开始GC，
4. TLAB允许浪费空间，导致Eden区空间不连续，积少成多。以后还要人帮忙打理。


### 1.2.4. ~~内存分配全流程~~  
<!-- 
好看视频
https://www.bilibili.com/video/BV15U4y1p75L?from=search&seid=15758145935432254065
-->
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/JVM/JVM-106.png)  
&emsp; ~~对象分配的大致流程如下：如果JVM开启了栈上分配和标量替换，且经过JIT逃逸分析判定该对象的引用不会逃逸到线程外，则该对象为栈分配候选；如果不满足栈上分配的条件，则尝试TLAB分配；如果TLAB分配不成功，则尝试堆上分配，如果满足进入老年代的条件，则对象直接分配到老年代，否则对象分配在新生代的eden区域。~~  


### 1.2.5. 堆内存分配策略  
&emsp; JVM分配内存机制有三大原则和担保机制。具体如下所示：  

* 优先分配到eden区
* 大对象直接进入到老年代
* 长期存活的对象分配到老年代
* 空间分配担保  

#### 1.2.5.1. 对象优先在Eden分配  
&emsp; 在JVM内存模型中，JVM年轻代堆内存可以划分为一块Eden区和两块Survivor区。在大多数情况下，对象在新生代Eden区中分配， 当Eden区没有足够空间分配时，JVM发起一次Minor GC，将Eden区和其中一块Survivor区内尚存活的对象放入另一块Survivor区域，如果在Minor GC期间发现新生代存活对象无法放入空闲的Survivor区，则会通过空间分配担保机制使对象提前进入老年代。  

#### 1.2.5.2. 大对象直接进入老年代  
&emsp; **Serial和ParNew两款收集器提供了-XX:PretenureSizeThreshold的参数，令大于该值的大对象直接在老年代分配，** 这样做的目的是避免在Eden区和Survivor区之间产生大量的内存复制(大对象一般指需要大量连续内存的Java对象，如很长的字符串和数组)，因此大对象容易导致还有不少空闲内存就提前触发GC以获取足够的连续空间。  

#### 1.2.5.3. 长期存活的对象将进入老年代  
&emsp; 虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别哪些对象应放在新生代，哪些对象应放在老年代中。为此，虚拟机为每个对象定义了一个对象年龄(Age)计数器，对象在Eden出生如果经第一次Minor GC后仍然存活，且能被Survivor容纳的话，将被移动到Survivor空间中，并将年龄设为1。以后对象在Survivor区中每经历一次Minor GC，年龄就+1。当增加到一定程度(-XX:MaxTenuringThreshold，默认15)，将会被晋升到老年代。对象晋升老年代的年龄阈值，可以通过参数-XX:MaxTenuringThreshold设置。  

#### 1.2.5.4. 动态对象年龄判定  
&emsp; 为了更好地适应不同程序的内存情况，JVM并不总是要求对象的年龄必须达到MaxTenuringThreshold才能晋升老年代：如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，而无须等到晋升年龄。  

#### 1.2.5.5. 空间分配担保  
&emsp; **<font color = "clime">JVM在发生Minor GC之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间，</font>** 如果大于，则此次Minor GC是安全的；如果小于，则虚拟机会查看HandlePromotionFailure设置项的值是否允许担保失败。如果HandlePromotionFailure=true，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小，如果大于则尝试进行一次Minor GC，但这次Minor GC依然是有风险的；如果小于或者HandlePromotionFailure=false，则改为进行一次Full GC。  

#### 1.2.5.6. ~~小结：对象何时进入老年代？~~  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/JVM/JVM-79.png)  



## 1.3. 对象的内存布局  
&emsp; 对象的内存布局包括三个部分：对象头，实例数据和对齐填充。 请参考[Synchronized原理](/docs/java/concurrent/SynPrinciple.md)  

## 1.4. 对象的访问定位  
&emsp; <font color = "red">对象的访问定位有两种：句柄定位和直接指针。</font>  

* 句柄定位：Java 堆会画出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/JVM/JVM-58.png)  
* 直接指针访问：java堆对象的不居中就必须考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象地址。  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/JVM/JVM-59.png)  


