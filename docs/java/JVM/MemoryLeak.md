
<!-- TOC -->

- [1. 内存泄漏、内存溢出](#1-内存泄漏内存溢出)
    - [1.1. 内存泄漏与内存溢出](#11-内存泄漏与内存溢出)
    - [1.2. 内存溢出影响](#12-内存溢出影响)
    - [1.3. 内存泄漏的分类（按发生方式来分类）](#13-内存泄漏的分类按发生方式来分类)
    - [1.4. 内存溢出演示和泄漏场景](#14-内存溢出演示和泄漏场景)
    - [1.5. 内存溢出的原因及解决方法小结](#15-内存溢出的原因及解决方法小结)
    - [1.6. 堆外内存泄漏](#16-堆外内存泄漏)

<!-- /TOC -->


# 1. 内存泄漏、内存溢出  
<!-- 

https://mp.weixin.qq.com/s/Cz3fXRRT1B8iAd36fNTdPA

Java 常见的几种内存溢出异常的原因及解决
https://www.yht7.com/news/141549


-->

## 1.1. 内存泄漏与内存溢出 

&emsp; **<font color = "red">内存溢出out of memory</font>** ，是指<font color = "red">程序在申请内存时，`没有足够的内存空间供其使用`</font>，出现out of memory。  
&emsp; **<font color = "blue">内存泄露memory leak</font>** ，是指<font color = "red">程序在申请内存后，`无法释放已申请的内存空间`</font>。一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存，迟早会被占光。内存泄露，会导致频繁的Full GC。  
&emsp; 所以内存泄漏可能会导致内存溢出，但内存溢出并不完全都是因为内存泄漏，也有可能使用了太多的大对象导致。  


-------

1、内存泄漏memory leak :

    是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄漏似乎不会有大的影响，但内存泄漏堆积后的后果就是内存溢出。

2、内存溢出 out of memory :

    指程序申请内存时，没有足够的内存供申请者使用，或者说，给了你一块存储int类型数据的存储空间，但是你却存储long类型的数据，那么结果就是内存不够用，此时就会报错OOM,即所谓的内存溢出。

3、二者的关系：

        内存泄漏的堆积最终会导致内存溢出

        内存溢出就是你要的内存空间超过了系统实际分配给你的空间，此时系统相当于没法满足你的需求，就会报内存溢出的错误。

        内存泄漏是指你向系统申请分配内存进行使用(new)，可是使用完了以后却不归还(delete)，结果你申请到的那块内存你自己也不能再访问（也许你把它的地址给弄丢了），而系统也不能再次将它分配给需要的程序。就相当于你租了个带钥匙的柜子，你存完东西之后把柜子锁上之后，把钥匙丢了或者没有将钥匙还回去，那么结果就是这个柜子将无法供给任何人使用，也无法被垃圾回收器回收，因为找不到他的任何信息。

        内存溢出：一个盘子用尽各种方法只能装4个果子，你装了5个，结果掉倒地上不能吃了。这就是溢出。比方说栈，栈满时再做进栈必定产生空间溢出，叫上溢，栈空时再做退栈也产生空间溢出，称为下溢。就是分配的内存不足以放下数据项序列,称为内存溢出。说白了就是我承受不了那么多，那我就报错。

## 1.2. 内存溢出影响  
&emsp; **<font color = "clime">问题：`JVM堆内存溢出后，其他线程是否可继续工作？`</font>**  
&emsp; 当一个线程抛出OOM异常后，它所占据的内存资源会全部被释放掉，从而不会影响其他线程的运行！  
&emsp; **<font color = "red">其实发生OOM的线程一般情况下会死亡，也就是会被终结掉，该线程持有的对象占用的heap都会被gc了，释放内存。</font><font color = "clime">因为发生OOM之前要进行gc，就算其他线程能够正常工作，也会因为频繁gc产生较大的影响。</font>**  



## 1.3. 内存泄漏的分类（按发生方式来分类）
&emsp; 常发性内存泄漏。发生内存泄漏的代码会被多次执行到，每次被执行的时候都会导致一块内存泄漏。  
&emsp; 偶发性内存泄漏。发生内存泄漏的代码只有在某些特定环境或操作过程下才会发生。常发性和偶发性是相对的。对于特定的环境，偶发性的也许就变成了常发性的。所以测试环境和测试方法对检测内存泄漏至关重要。  
&emsp; 一次性内存泄漏。发生内存泄漏的代码只会被执行一次，或者由于算法上的缺陷，导致总会有一块仅且一块内存发生泄漏。比如，在类的构造函数中分配内存，在析构函数中却没有释放该内存，所以内存泄漏只会发生一次。 
&emsp; 隐式内存泄漏。程序在运行过程中不停的分配内存，但是直到结束的时候才释放内存。严格的说这里并没有发生内存泄漏，因为最终程序释放了所有申请的内存。但是对于一个服务器程序，需要运行几天，几周甚至几个月，不及时释放内存也可能导致最终耗尽系统的所有内存。所以，我们称这类内存泄漏为隐式内存泄漏。  

## 1.4. 内存溢出演示和泄漏场景  
<!--
Java中七个潜在的内存泄露风险，你知道几个？ 
https://mp.weixin.qq.com/s/rJ-YSpHy9SVnJQ6UHUKZvQ
https://mp.weixin.qq.com/s?__biz=Mzg3NzU5NTIwNg==&mid=2247488067&idx=1&sn=0a274ef171c7845d53ae625a1507ca38&source=41#wechat_redirect
～～
(内存溢出演示)几种典型的内存溢出案例，都在这儿了！
https://mp.weixin.qq.com/s/4SenzIeX9FqsnXAaV6IgLg
 教你写Bug，常见的 OOM 异常分析 
https://mp.weixin.qq.com/s/gIJvtd8rrZz6ttaoGLddLg

面试官：哪些场景会产生OOM？怎么解决？ 
https://mp.weixin.qq.com/s/j8_6QW_WLqlZDUjbDUbyZw

https://mp.weixin.qq.com/s/XJhtBYGMJps4B5wzNTsSVA
-->

<!-- 
～～
java内存泄漏与内存溢出
https://www.cnblogs.com/panxuejun/p/5883044.html
-->



## 1.5. 内存溢出的原因及解决方法小结
（1） 内存溢出原因：  

        内存中加载的数据量过于庞大，如一次从数据库取出过多数据；
        集合类中有对对象的引用，使用完后未清空，使得JVM不能回收；
        代码中存在死循环或循环产生过多重复的对象实体；
        使用的第三方软件中的BUG；
        启动参数内存值设定的过小

（2）内存溢出的解决方案：

    第一步，修改JVM启动参数，直接增加内存。(-Xms，-Xmx参数一定不要忘记加。)
    第二步，检查错误日志，查看“OutOfMemory”错误前是否有其 它异常或错误。
    第三步，对代码进行走查和分析，找出可能发生内存溢出的位置。 
        重点排查以下几点： 
        1.检查对数据库查询中，是否有一次获得全部数据的查询。一般来说，如果一次取十万条记录到内存，就可能引起内存溢出。这个问题比较隐蔽，在上线前，数据库中数据较少，不容易出问题，上线后，数据库中数据多了，一次查询就有可能引起内存溢出。因此对于数据库查询尽量采用分页的方式查询。
        2.检查代码中是否有死循环或递归调用。
        3.检查是否有大循环重复产生新对象实体。
        4.检查对数据库查询中，是否有一次获得全部数据的查询。一般来说，如果一次取十万条记录到内存，就可能引起内存溢出。这个问题比较隐蔽，在上线前，数据库中数据较少，不容易出问题，上线后，数据库中数据多了，一次查询就有可能引起内存溢出。因此对于数据库查询尽量采用分页的方式查询。
        5.检查List、MAP等集合对象是否有使用完后，未清除的问题。List、MAP等集合对象会始终存有对对象的引用，使得这些对象不能被GC回收。
    第四步，使用内存查看工具动态查看内存使用情况

## 1.6. 堆外内存泄漏
<!-- 
JVM 堆外内存泄露
https://cloud.tencent.com/developer/article/1129904
-->

