
<!-- TOC -->

- [1. ~~编译执行~~](#1-编译执行)
    - [1.1. 字节码、汇编代码](#11-字节码汇编代码)
    - [1.2. JVM编译执行的两种方式](#12-jvm编译执行的两种方式)
        - [1.2.1. 字节码解释执行](#121-字节码解释执行)
        - [1.2.2. 编译执行](#122-编译执行)
    - [1.3. 解释器与编译器混合使用](#13-解释器与编译器混合使用)
    - [1.4. 热点代码判断](#14-热点代码判断)

<!-- /TOC -->

&emsp; **<font color = "red">总结：</font>**  
&emsp; ~~HopSpot虚拟机采用混合模式，综合了解释执行与即时编译的优点。它会先执行解释执行字节码，而后将其中反复执行的热点代码，以此方法为单位进行即时编译。~~  
&emsp; “热点代码”包括： 1. 被多次调用的方法；2. 被多次执行的循环体。  

# 1. ~~编译执行~~  
<!-- 

https://blog.csdn.net/xiaotai1234/article/details/108290474
查看java文件汇编代码与字节码
https://blog.csdn.net/J080624/article/details/85318895

-->

<!-- 



虚拟机字节码执行引擎，JVM的马达图，是爱情呀 
https://mp.weixin.qq.com/s/d_AqDygFgKbdHTfz--Dy-A
解释执行？编译执行？即时编译？轻松让你分清前期编译与后期编译 
https://mp.weixin.qq.com/s/LedQX2H4Uqoqt76pld16Zg

https://blog.csdn.net/zhu_ya_nan/article/details/86472206
https://blog.csdn.net/qq_41701956/article/details/85014038
-->

## 1.1. 字节码、汇编代码  


## 1.2. JVM编译执行的两种方式
&emsp; 类加载器加载的类文件字节码数据流由基于JVM指令集架构的执行引擎来执行。执行引擎以指令为单位读取Java字节码。字节码可以通过字节码解释执行、编译执行两种方式之一转化为合适的语言。 

![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/JVM/JVM-107.png)  


### 1.2.1. 字节码解释执行  
&emsp; 解释器，逐个读取，解释和执行字节码指令。当它逐个解释和执行指令时，它可以快速解释一个字节码，但是同时也只能相对缓慢的地执行解释结果，这是解释语言的缺点。  


&emsp; 解释执行得放在编译执行之前。因为不出意外，大部分情况下都是解释执行处理程序。  
&emsp; 那么一段java代码走解释执行路线被计算机执行将会经历多少步骤呢？步骤如下：  
&emsp; 步骤：java代码->class代码(javac)-> 字节码解释器->C++代码(解释执行)-->硬编码(机器码)。  
&emsp; 通过解释器，在代码执行时逐条翻译成机器码，不做保存。也就是解释执行的代码每次都要经过上述整个步骤。因此解释器的方式是非常低效的，需要先把字节码翻译成机器码，才能往下执行。（一边解释，一边执行）。然而除了程序中有提前编译的程序外，代码一开始都是从解释执行开始的。  

### 1.2.2. 编译执行 
&emsp; JIT（实时）编译器弥补解释器的缺点。执行引擎首先作为解释器运行，并在适当的时候，JIT编译器编译整个字节码以将其更改为本机代码。之后，执行引擎不再解释该方法，而是直接使用本机代码执行（当JIT编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用）。本地代码中的执行比逐个解释指令要快得多。由于本机代码存储在高速缓存中，因此可以快速执行编译的代码。  
&emsp; 但是，JIT编译器编译代码需要花费更多的时间，而不是解释器逐个解释代码。因此，如果代码只执行一次，最好是选择解释而不是编译。因此，使用JIT编译器的JVM在内部检查方法执行的频率，并仅在频率高于某个级别时编译方法。  
&emsp; JVM规范中未定义执行引擎的运行方式。因此，JVM厂商使用各种技术改进其执行引擎，并引入各种类型的JIT编译器。大多数JIT编译器运行如上图所示。  
&emsp; JIT编译器将字节码转换为中间级表达式IR，以执行优化，然后将表达式转换为本机代码。Oracle Hotspot VM使用名为Hotspot Compiler的JIT编译器。它被称为Hotspot，因为Hotspot Compiler通过分析搜索需要以最高优先级进行编译的“Hotspot”，然后将热点编译为本机代码。如果不再频繁调用编译了字节码的方法，换句话说，如果该方法不再是热点，则Hotspot VM将从缓存中删除本机代码并以解释器模式运行。Hotspot VM分为服务器VM和客户端VM，两个VM使用不同的JIT编译器。  
&emsp; 大多数Java性能改进都是通过改进执行引擎来实现的。除了JIT编译器之外，还引入了各种优化技术，因此可以不断改进JVM性能。初始JVM和最新JVM之间的最大区别是执行引擎。  


## 1.3. 解释器与编译器混合使用  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/JVM/JVM-108.png)  
&emsp; HopSpot虚拟机采用混合模式，综合了解释执行与即时编译的优点。它会先执行解释执行字节码，而后将其中反复执行的热点代码，以此方法为代为单位进行即时编译。  
即时编译建立在程序符合二八定律的假设上，也就是百分之20的代码占据了百分之80的计算机资源。  
&emsp; 对于大部分不常用的代码，我们无需耗费时间将其编译成机器码，而是采用解释执行的方式运行；另一方面，对于仅占据小部分的热点代码，我们则可以将其编译成机器码，已达到理想的运行速度。  
&emsp; 理论上讲，即时编译后的Java程序的执行效率，是可能超过C++程序的。这是因为与静态编译（一开始全部翻译成机器码）相比，即时编译拥有程序运行时的信息（程序在运行时能根据运行过程中再次进行优化编译），并且能够根据这个信息作出相应的优化，峰值性能更好。  

&emsp; 解释器与编译器直接各有优势：  
1. 当程序需要迅速启动时，解释器可以首先发挥作用，省去编译的时间，立即运行。（虽然二者都是翻译成机器码，但是由于编译器要对代码进行优化以及保存等操作必然更加耗时）  
2. 当程序运行了一段时间后，编译器逐渐发挥作用。把越来越多的热点代码翻译成机器码。这样可以减少许多解释器的时间消耗，提供效率。（也有点空间换时间内味儿）  
3. 当程序运行环境中内存资源限制较大，可以使用解释执行节约内存。反之可以用编译器提升效率。  
4. 同时，解释器还可以作为编译器激进优化后的后备”逃生门”(如果情况运行，HotSpot虚拟机中也会采用不进行激进优化的客户端编译器充当”逃生门”角色)。为什么会需要逃生门呢？因为在运行过程中，编译器可能识别一些场景，根据经验进行提速优化。然而这些场景并不不能保证一定正确。此时激进优化的假设就会不成立。例如如果加载了新类，类的继承结构就会变化，出现”罕见陷阱”。此时可以通过逆优化，让编译执行的代码重新进行解释执行。这也就告诉我们，为什么HotSpot虚拟机是解释器编译器并存的虚拟机。  


## 1.4. 热点代码判断
&emsp; 在运行过程中，会被即时编译器编译的目标是”热点代码”。这里的“热点代码”包括：  
1. 被多次调用的方法  
2. 被多次执行的循环体  

&emsp; 要知道某段代码是不是热点代码，是不是需要触发即时编译，这个行为被称为“热点探测”（Hot Spot Code Detection），目前主流的有两种方式：  

* 基于采样的热点探测（Sample Based Hot Spot Code Detection）：周期性地检查各个线程的调用栈顶，如果发现某个（或者某些）方法经常出现在栈顶（栈顶的方法是正在被执行的方法），那这个方法就是“热点方法”。好处是高效，而且很容易获取方法调用的关系（将调用栈展开即可）。缺点是不够精确，容易受到线程阻塞和外部因素影响。  
* 基于计数器的热点探测（Counter Based Hot Spot Code Detection）：为每个方法（甚至代码块）建立计数器，统计方法的执行次数，如果执行次数超过一定的阙值就认为是“热点方法”。缺点是比较麻烦，需要为每个方法维护计数器，而且不能直接获得调用关系。优点是更加严谨准确。  

