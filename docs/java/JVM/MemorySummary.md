

<!-- TOC -->

- [1. 内存区域小结](#1-内存区域小结)
    - [1.1. 变量](#11-变量)
    - [1.2. 静态方法和实例方法](#12-静态方法和实例方法)

<!-- /TOC -->

# 1. 内存区域小结
## 1.1. 变量
1. 常量final static
2. 静态变量static
3. 全局变量
4. 局部变量


## 1.2. 静态方法和实例方法
<!-- 
https://segmentfault.com/a/1190000016655589?sort=newest

https://www.cnblogs.com/chenxizhang/archive/2008/09/03/1282924.html
-->
&emsp; 静态方法会在程序运行的时候直接装载进入方法区。而实例方法会在new的时候以对象的方法装载进入堆中。  
&emsp; 最大的区别在于内存的区别，由于main函数为static静态方法，会直接在运行的时候装载进入内存区，实例方法必须new，在堆中创建内存区域。再进行引用。  

-------------  

&emsp; 一、 静态方法常驻内存，实例方法不是，所以静态方法效率高但占内存。  
&emsp; 事实上，方法都是一样的，在加载时机和占用内存上，静态方法和实例方法是一样的，在类型第一次被使用时加载。调用的速度基本上没有差别。  

&emsp; 二、 静态方法在堆上分配内存，实例方法在堆栈上。   
&emsp; 事实上所有的方法都不可能在堆或者堆栈上分配内存，方法作为代码是被加载到特殊的代码内存区域，这个内存区域是不可写的。  

&emsp; 三、 实例方法需要先创建实例才可以调用，比较麻烦，静态方法不用，比较简单。  
&emsp; 事实上如果一个方法与他所在类型的实例无关，那么它就应该是静态的，决不会有人把它写成实例方法。所以所有的实例方法都与实例有关，既然与实例有关，那么创建实例就是必然的步骤，没有麻烦简单一说。实际上上你可以把所有的实例方法都写成静态的，将实例作为参数传入即可。  
&emsp; 有些方法看似与所在的实例无关，如IComparer.Compare方法，但实际上每一个实现这个接口的类都只会负责自己类型实例的比较，这是C#1.x规范中没有泛型所带来的历史遗留问题。  
&emsp; 大部分静态方法是与类的实例有关的，如各种Parse方法，他做成静态的原因是他没有实例作为参数。其他的大多是出于语义或者其他目的的考虑。  



