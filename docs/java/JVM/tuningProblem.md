
<!-- TOC -->

- [1. JVM调优](#1-jvm调优)
    - [1.1. 内存设置](#11-内存设置)
    - [1.2. GC调优](#12-gc调优)
        - [1.2.1. GC调优基础](#121-gc调优基础)
        - [1.2.2. GC耗时和频率判断](#122-gc耗时和频率判断)
        - [1.2.3. ★★★YGC、FGC优化](#123-★★★ygcfgc优化)
        - [1.2.4. GC策略调整](#124-gc策略调整)

<!-- /TOC -->

&emsp; **<font color = "red">总结：</font>**  
1. 根据实际情况选择合适垃圾收集器  
&emsp; 堆内存4G以下可以用parallel，4-8G可以用ParNew + CMS，8G以上可以用G1，几百G以上用ZGC。
2. 内存设置  
&emsp; 如何将各分区调整到合适的大小，分析活跃数据的大小是很好的切入点。**活跃数据的大小是指，应用程序稳定运行时长期存活对象在堆中占用的空间大小，也就是Full GC后堆中老年代占用空间的大小。** 活跃数据和各分区之间的比例关系如下：  

|空间	|倍数|
|---|---|
|总大小	|3--4倍活跃数据的大小|
|新生代	|1--1.5倍活跃数据的大小|
|老年代	|2--3倍活跃数据的大小|
|永久代	|1.2--1.5倍Full GC后的永久代空间占用|

3. GC调优
    1. <font color = "clime">`GC的优化主要有2个维度，一是频率，二是时长。`</font> **<font color = "clime">如果满足下面的指标，则一般不需要进行GC调优：</font>**    
        * Minor GC执行时间不到50ms;
        * Minor GC执行不频繁，约10秒一次；
        * Full GC执行时间不到1s;
        * Full GC执行频率不算频繁，不低于10分钟1次。
    2. Young GC、Full GC优化策略 参考 1.2.3节。



--------
JVM 调优目标：使用较小的内存占用来获得较高的吞吐量或者较低的延迟。  

程序在上线前的测试或运行中有时会出现一些大大小小的 JVM 问题，比如 cpu load 过高、请求延迟、tps 降低等，甚至出现内存泄漏（每次垃圾收集使用的时间越来越长，垃圾收集频率越来越高，每次垃圾收集清理掉的垃圾数据越来越少）、内存溢出导致系统崩溃，因此需要对 JVM 进行调优，使得程序在正常运行的前提下，获得更高的用户体验和运行效率。  

这里有几个比较重要的指标：  

    内存占用：程序正常运行需要的内存大小。
    延迟：由于垃圾收集而引起的程序停顿时间。
    吞吐量：用户程序运行时间占用户程序和垃圾收集占用总时间的比值。

当然，和 CAP 原则一样，同时满足一个程序内存占用小、延迟低、高吞吐量是不可能的，程序的目标不同，调优时所考虑的方向也不同，在调优之前，必须要结合实际场景，有明确的的优化目标，找到性能瓶颈，对瓶颈有针对性的优化，最后进行测试，通过各种监控工具确认调优后的结果是否符合目标。  


<!-- 
JVM调优汇总（JDK1.8）
https://blog.csdn.net/qq_36080515/article/details/120502104

-->


# 1. JVM调优 
&emsp; JVM的调优主要有两个方面：内存调优、垃圾回收策略调优。  

    获取堆内存日志，调整内存比例或者gc回收策略； 

## 1.1. 内存设置
&emsp; Jvm调优Oracle官网有一份指导说明：https://docs.oracle.com/middleware/11119/wls/PERFM/jvm_tuning.htm#i1146060  

&emsp; 各分区的大小对GC的性能影响很大。如何将各分区调整到合适的大小，分析活跃数据的大小是很好的切入点。  
&emsp; **活跃数据的大小是指，应用程序稳定运行时长期存活对象在堆中占用的空间大小，也就是Full GC后堆中老年代占用空间的大小。** 可以通过GC日志中Full GC之后老年代数据大小得出，比较准确的方法是在程序稳定后，多次获取GC数据，通过取平均值的方式计算活跃数据的大小。活跃数据和各分区之间的比例关系如下：  

|空间	|倍数|
|---|---|
|总大小	|3--4倍活跃数据的大小|
|新生代	|1--1.5倍活跃数据的大小|
|老年代	|2--3倍活跃数据的大小|
|永久代	|1.2--1.5倍Full GC后的永久代空间占用|

&emsp; 例如，根据GC日志获得老年代的活跃数据大小为300MB，那么各分区大小可以设为：  

```
总堆：1200MB = 300MB × 4
新生代：450MB = 300MB × 1.5
老年代：750MB = 1200MB - 450MB
```
&emsp; 这部分设置仅仅是堆大小的初始值，后面的优化中，可能会调整这些值，具体情况取决于应用程序的特性和需求。

## 1.2. GC调优  
### 1.2.1. GC调优基础  
&emsp; <font color = "red">GC性能指标有吞吐量、GC开销、时长、频率、堆空间、对象生命周期。</font><font color = "clime">GC的优化主要有2个维度，一是频率，二是时长。</font>  

&emsp; 如果各项参数设置合理，系统没有超时日志出现，GC频率不高，GC耗时不高，那么没有必要进行GC优化；如果GC时间超过1〜3 秒，或者频繁GC，则必须优化。**<font color = "clime">如果满足下面的指标，则一般不需要进行GC：</font>**    

* Minor GC执行时间不到50ms;
* Minor GC执行不频繁，约10秒一次；
* Full GC执行时间不到1s;
* Full GC执行频率不算频繁，不低于10分钟1次。


### 1.2.2. GC耗时和频率判断  
<!-- 
https://my.oschina.net/qzhli/blog/1859132
-->

### 1.2.3. ★★★YGC、FGC优化
* YGC  
&emsp; YGC，首先看频率，如果YGC超过10秒一次，甚至更长，说明系统内存过大，应该缩小容量，如果频率很高，说明Eden区过小，可以将Eden区增大，但整个新生代的容量应该在堆的30% - 40%之间，eden、from 和to的比例应该在8 :1 :1左右，这个比例可根据对象晋升的大小进行调整。  
&emsp; 如果YGC时间过长呢？YGC有2个过程，一个是扫描，一个是复制，通常扫描速度很快，复制速度相比而言要慢一些，如果每次都有大量对象要复制，就会将STW时间延长，还有一个情况就是StringTable，这个数据结构中存储着String.intern方法返回的常连池的引用，YGC每次都会扫描这个数据结构(HashTable)，如果这个数据结构很大，且没有经过FGC，那么也会拉长STW时长，还有一种情况就是操作系统的虚拟内存，当GC时正巧操作系统正在交换内存，也会拉长STW时长。  

* FGC  
&emsp; 实际上，FGC只能优化频率，无法优化时长，因为这个时长无法控制。  
&emsp; <font color = "red">对于Full GC较多的情况，其主要有如下两个特征： </font> 

    * <font color = "red">线上多个线程的CPU都超过了100%，通过jstack命令可以看到这些线程主要是垃圾回收线程。</font>  
    * 通过jstat命令监控GC情况，可以看到Full GC次数非常多，并且次数在不断增加。  


&emsp; ⚠️注：FGC过高问题，请查看[JVM问题排查](/docs/java/JVM/TroubleShooting.md)  

### 1.2.4. GC策略调整  
&emsp; 当Java程序性能达不到既定目标，且其他优化手段都已经穷尽时，通常需要调整垃圾回收器来进一步提高性能，选择一款合适的垃圾回收器。  

<!--
&emsp; Java虚拟机的垃圾回收策略一般分为：串行收集器、并行收集器和并发收集器。  

* 串行收集器：  
1. -XX:+UseSerialGC：代表垃圾回收策略为串行收集器，即在整个扫描和复制过程采用单线程的方式来进行，适用于单CPU、新生代空间较小及对暂停时间要求不是非常高的应用上，是client级别默认的GC方式，主要在JDK1.5之前的垃圾回收方式。  

* 并发收集器：
1. -XX:+UseParallelGC：代表垃圾回收策略为并行收集器(吞吐量优先)，即在整个扫描和复制过程采用多线程的方式来进行，适用于多CPU、对暂停时间要求较短的应用上，是server级别默认采用的GC方式。此配置仅对年轻代有效。该配置只能让年轻代使用并发收集，而年老代仍旧使用串行收集。  
2. -XX:ParallelGCThreads=4：配置并行收集器的线程数，即：同时多少个线程一起进行垃圾回收。此值最好配置与处理器数目相等。  
3. -XX:+UseParallelOldGC：配置年老代垃圾收集方式为并行收集。JDK6.0支持对年老代并行收集。  
4. -XX:MaxGCPauseMillis=100：设置每次年轻代垃圾回收的最长时间，如果无法满足此时间，JVM会自动调整年轻代大小，以满足此值。  
5. -XX:+UseAdaptiveSizePolicy：设置此选项后，并行收集器会自动选择年轻代区大小和相应的Survivor区比例，以达到目标系统规定的最低相应时间或者收集频率等，此值建议使用并行收集器时，一直打开。  

* 并发收集器：  
1. -XX:+UseConcMarkSweepGC:代表垃圾回收策略为并发收集器。  
-->