

<!-- TOC -->

- [1. JVM类的加载](#1-jvm类的加载)
    - [1.1. 类加载的时机](#11-类加载的时机)
    - [1.2. 类加载的过程](#12-类加载的过程)
        - [1.2.1. 加载](#121-加载)
            - [1.2.1.1. 延伸知识点](#1211-延伸知识点)
        - [1.2.2. 连接](#122-连接)
            - [1.2.2.1. 验证](#1221-验证)
            - [1.2.2.2. 准备](#1222-准备)
            - [1.2.2.3. 解析](#1223-解析)
        - [1.2.3. 初始化](#123-初始化)
            - [1.2.3.1. ~~类初始化时机~~](#1231-类初始化时机)
            - [1.2.3.2. ~~类初始化流程~~](#1232-类初始化流程)
            - [1.2.3.3. 延伸知识点](#1233-延伸知识点)
        - [1.2.4. 使用：](#124-使用)
        - [1.2.5. 卸载](#125-卸载)

<!-- /TOC -->

![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/JVM/JVM-50.png)  

&emsp; **<font color = "red">总结：</font>**  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/JVM/JVM-5.png)  
* 准备(Preparation)  
&emsp; 为类的静态变量分配内存，并将其初始化为默认值</font>**<font color = "red">，这些内存都将在方法区中分配。</font>对于该阶段有以下几点需要注意：  
    1. <font color = "red">这时候进行内存分配的仅包括类变量(static)，而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在 Java 堆中。</font>  
    2. <font color = "red">这里所设置的初始值"通常情况"下是数据类型默认的零值(如0、0L、null、false等)，比如定义了public static int value=111 ，那么 value 变量在准备阶段的初始值就是 0 而不是111(初始化阶段才会复制)。</font>  
    * <font color = "red">特殊情况：比如给 value 变量加上了 fianl 关键字public static final int value=111 ，那么准备阶段 value 的值就被赋值为 111。</font>  
* 解析(Resolution)  
&emsp; **<font color = "clime">解析过程在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 的动态绑定。</font>**   

# 1. JVM类的加载  
&emsp; **<font color = "red">部分参考《深入理解java虚拟机 第3版》第7章 虚拟机类加载机制</font>**  

## 1.1. 类加载的时机  
&emsp; 什么情况下虚拟机需要开始加载一个类呢？虚拟机规范中并没有对此进行强制约束，这点可以交给虚拟机的具体实现来自由把握。  

## 1.2. 类加载的过程  
&emsp; 类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载(Loading)、验证(Verification)、准备(Preparation)、解析(Resolution)、初始化(Initialization)、使用(Using)和卸载(Unloading) 7个阶段。<font color = "red">类的加载包括前5个阶段，其屮验证、准备、解析3个部分统称为连接(Linking)。</font>这7个阶段的发生顺序如图所示。    
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/JVM/JVM-5.png)  
&emsp; 加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始，**而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定(也称为动态绑定或晚期绑定)。**  

### 1.2.1. 加载  
&emsp; 加载：查找并加载类的二进制数据。加载主要做三件事： 
 
* 找到类文件（首先通过类的全限定名来获取定义此类的二进制字节流）  
* 放入方法区（其次将这个字节流所代表的静态存储结构转化为方法区（1.8开始是堆）的运行时数据结构）  
* 开个入口（最后生成一个代表此类的java.lang.Class对象，作为访问方法区这些数据结构的入口）  

&emsp; **<font color = "red">一句话概括：把代码数据加载到内存中，加载完成后，在方法区实例化一个对应的Class对象。</font>**  

&emsp; 类的加载的最终产品是位于堆区中的Class对象，Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。  
&emsp; 其中加载的类有以下几种：  

* 从本地系统直接加载  
* 通过网络下载.class文件  
* 从zip，jar等归档文件中加载.class文件  
* 从专有数据库中提取.class文件  
* 将Java源文件动态编译为.class文件(服务器)  
* 命令行启动应用时候由JVM初始化加载  
* 通过Class.forName()方法动态加载  

#### 1.2.1.1. 延伸知识点  
&emsp; 相对于类加载过程的其他阶段，一个非数组类的加载阶段（准确地说，是加载阶段中获取类的二进制字节流的动作）是开发人员可控性最强的，因为加载阶段既可以使用系统提供的引导类加载器来完成，也可以由用户自定义的类加载器去完成，开发人员可以通过定义自己的类加载器去控制字节流的获取方式（即重写一个类加载器的loadClass()方法）。  
&emsp; 对于数组类而言，情况就有所不同，数组类本身不通过类加载器创建，它是由Java虚拟机直接创建的。但是数组类的元素类型（Element Type，指的是数组去掉所有维度的类型）最终是要靠类加载器去创建，如果数组的组件类型不是引用类型（例如int[]数组），Java虚拟机将会把数组C标记为与引导类加载器关联。  
&emsp; 数组类的可见性与它的组件类型的可见性一致，如果组件类型不是引用类型，那数组类的可见性将默认为public。  

### 1.2.2. 连接  
#### 1.2.2.1. 验证  
&emsp; **<font color = "red">验证：确保被加载的类的正确性</font>** 确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致会完成4个阶段的检验动作：  
1. 文件格式验证：验证字节流是否符合Class文件格式的规范；例如：是否以0xCAFEBABE开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。  
2. 元数据验证：对字节码描述的信息进行语义分析(注意：对比javac编译阶段的语义分析)，以保证其描述的信息符合Java语言规范的要求，例如：这个类是否有父类(除了java.lang.Object之外所有类都是父类)、这个类是否被继承类不允许继承的类(被final修饰的类)等。  
3. 字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。  
4. 符号引用验证：确保解析动作能正确执行。  

&emsp; 验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用-Xverifynone参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。  

#### 1.2.2.2. 准备  
&emsp; **<font color = "red">准备：为类的静态变量分配内存，并将其初始化为默认值</font>**<font color = "red">，这些内存都将在方法区中分配。</font>对于该阶段有以下几点需要注意：  
1. <font color = "red">这时候进行内存分配的仅包括类变量(static)，而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在 Java 堆中。</font>  
2. <font color = "red">这里所设置的初始值"通常情况"下是数据类型默认的零值(如0、0L、null、false等)，比如定义了public static int value=111 ，那么 value 变量在准备阶段的初始值就是 0 而不是111(初始化阶段才会复制)。</font>  
* <font color = "red">特殊情况：比如给 value 变量加上了 fianl 关键字public static final int value=111 ，那么准备阶段 value 的值就被赋值为 111。</font>  

&emsp; **<font color = "red">为什么 static final 会直接被赋值？</font>**  
&emsp; final 关键字在Java中代表不可改变的意思，意思就是说value的值一旦赋值就不会再改变了。既然一旦赋值就不会再改变，那么就必须一开始就给其赋予用户想要的值，因此被final修饰的类变量在准备阶段就会被赋予想要的值。而没有被final修饰的类变量，其可能在初始化阶段或者运行阶段发生变化，所以就没有必要在准备阶段对它赋予用户想要的值。  

<!-- 
&emsp; 当完成字节码文件的校验之后，JVM 便会开始为类变量分配内存并设置类变量初始值。  
&emsp; 类变量是被 static 修饰的变量，准备阶段为类变量分配内存并设置初始值，使用的是方法区的内存。  
&emsp; 实例变量不会在这阶段分配内存，它会在对象实例化时随着对象一起被分配在堆中。应该注意到，实例化不是类加载的一个过程，类加载发生在所有实例化操作之前，并且类加载只进行一次，实例化可以进行多次。  
&emsp; 注意：这里的初始化指的是为变量赋予 Java 语言中该数据类型的零值，而不是用户代码里初始化的值。  

 https://juejin.im/post/5e0aa97451882549757e5e56#heading-19 
--> 

#### 1.2.2.3. 解析  
&emsp; **<font color = "red">解析：将常量池内的符号引用转换为直接引用</font>** ，得到类或者字段、方法在内存中的指针或者偏移量，确保类与类之间相互引用正确性，完成内存结构布局，以便直接调用该方法。</font>  

* 符号引用：以一组符号来描述所引用的目标。 **符号引用与虚拟机实现的布局无关，引用的目标并不一定要已经加载到内存中。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须是一致的，** 因为符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中。符号引用是class文件中CONSTANT_Class_info、CONSTANT_Field_info、CONSTANT_Method_info等类型的常量。使用符号引用来描述所引用的目标。  
* 直接引用，通过对符号引用进行解析，找到引用的实际内存地址。可以是指向目标的指针，相对偏移量或是一个能间接定位到目标的句柄。如果有了直接引用，那引用的目标必定已经在内存中存在。


```text
为什么要使用符号引用？  
符号引用要转换成直接引用才有效，这也说明直接引用的效率要比符号引用高。那为什么要用符号引用呢？这是因为类加载之前，javac会将源代码编译成.class文件，这个时候javac是不知道被编译的类中所引用的类、方法或者变量它们的引用地址在哪里，所以只能用符号引用来表示。当然，符号引用是要遵循java虚拟机规范的。  
```

&emsp; 解析主要有四种：类或接口的解析、字段解析、类方法解析、接口方法解析。在解析的过程中可能会抛出以下异常：  

* java.lang.NoSuchFieldError：找不到字段  
* java.lang.IllegalAccessError：不具有访问权限  
* java.lang.NoSuchMethodError：找不到方法  



&emsp; **<font color = "clime">解析过程在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 的动态绑定。</font>**   

### 1.2.3. 初始化  
&emsp; 类初始化阶段是类加载过程的最后一步，前面的类加载过程中，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的Java程序代码(或者说是字节码)。   
&emsp; 在准备阶段，类变量已经被赋过默认初始值，而<font color = "red">在初始化阶段，类变量将被赋值为代码期望赋的值。初始化过程即执行类中的静态初始化代码(static代码块)、构造器代码以及静态变量的初始化。</font>  

<!-- 
&emsp; 在Java中对类变量进行初始值设定有两种方式：  
1. 声明类变量是指定初始值  
2. 使用静态代码块为类变量指定初始值
-->

#### 1.2.3.1. ~~类初始化时机~~  
1. **<font color = "red">主动引用执行初始化。</font>**<font color = "red">对于初始化阶段，虚拟机规范则是严格规定了有且只有5种情况必须立即对类进行“初始化”。</font>  
  
    * 显式字节码指令集：遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。显式字节码指令集(new/getstatic/putstatic/invokestatic)：对应的场景就是创建对象或者调用到类文件的静态变量/静态方法/静态代码块。  
    * 反射：使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没存进行过初始化，则需要先触发其初始化。  
    * 继承：当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。  
    * 入口：当虚拟机启动时，用户需要指定一个要执行的主类(包含main()方法的那个类)，虚拟机会先初始化这个主类。  
    * 当使用JDK 1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。  

            对于这5种会触发类进行初始化的场景，虚拟机规范中使用了一个很强烈的限定语：“有且只有”，这5种场景中的行为称为对一个类进行主动引用。
  
2. **<font color = "red">被动引用不执行初始化。</font>** 以上5种场景中的行为称为对一个类进行主动引用。除此之外，所有引用类的方式都不会触发初始化，称为被动引用。被动引用的常见例子包括：  

    * 通过子类引用父类的静态字段，不会导致子类初始化。  

        ```java
        System.out.println(SubClass.value);  // value字段在SuperClass中定义
        ```
    * 通过数组定义来引用类，不会触发此类的初始化。该过程会对数组类进行初始化，数组类是一个由虚拟机自动生成的、直接继承自Object 的子类，其中包含了数组的属性和方法。  

        ```java
        SuperClass[] sca = new SuperClass[10];
        ```
    * 常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。  

        ```java
        System.out.println(ConstClass.HELLOWORLD);
        ```

#### 1.2.3.2. ~~类初始化流程~~  
&emsp; 初始化阶段是执行类构造器client方法的过程。client方法并不是由程序员在Java代码中直接编写的方法，是由编译器自动生成的。  

* client方法是由编译器自动收集类中的类变量的赋值操作和静态语句块static{}中的语句合并而成的。  
* 编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问。  
* 虚拟机会保证子client方法执行之前，父类的client方法已经执行完毕， 如果一个类中没有对静态变量赋值也没有静态语句块，那么编译器可以不为这个类生client()方法。  

        JVM初始化步骤：  
        1. 假如这个类还没有被加载和连接，则程序先加载并连接该类
        2. 假如该类的直接父类还没有被初始化，则先初始化其直接父类
        3. 假如类中有初始化语句，则系统依次执行这些初始化语句

&emsp; **<font color = "red">一句话概括：初始化阶段，执行类构造器＜clinit>() 方法(类变量赋值、静态语句块)，如果赋值运算是通过其他类的静态方法来完成的，那么会马上解析另外一个类，在虚拟机栈中执行完毕后通过返回值进行赋值。</font>**  

&emsp; clinit方法和init方法：  
&emsp; <font color = "red">在编译生成class文件时，会自动产生两个方法，clinit是类的初始化方法，init是实例的初始化方法。</font>clinit：在jvm第一次加载class文件时调用，包括静态变量初始化语句和静态块的执行。init: 在实例创建出来的时候调用，包括调用new操作符；调用Class或 Java.lang.reflect.Constructor对象的newInstance()方法；调用任何现有对象的clone()方法；通过 java.io.ObjectInputStream 类的getObject()方法反序列化。  

#### 1.2.3.3. 延伸知识点  
<!-- https://juejin.im/post/5e0aa97451882549757e5e56#heading-19--> 
......

### 1.2.4. 使用：  
&emsp; 类的使用包括主动引用和被动引用。参考类初始化时机。  

### 1.2.5. 卸载  
&emsp; 参考[GC](/docs/java/JVM/GC.md)方法区回收。  
