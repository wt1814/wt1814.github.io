

<!-- TOC -->

- [1. 对象的存活](#1-对象的存活)
    - [1.1. GC的存活标准](#11-gc的存活标准)
        - [1.1.1. 引用计数法](#111-引用计数法)
        - [1.1.2. 可达性分析法](#112-可达性分析法)
        - [1.1.3. 对象的四种引用状态，强弱软虚](#113-对象的四种引用状态强弱软虚)
            - [1.1.3.1. 强引用](#1131-强引用)
            - [1.1.3.2. 软引用](#1132-软引用)
            - [1.1.3.3. 弱引用](#1133-弱引用)
            - [1.1.3.4. 虚引用](#1134-虚引用)
            - [1.1.3.5. 软引用和弱引用的使用](#1135-软引用和弱引用的使用)
    - [1.2. 生存还是死亡](#12-生存还是死亡)
- [2. GC算法](#2-gc算法)
    - [2.1. 标记-清除（Mark-Sweep）算法](#21-标记-清除mark-sweep算法)
    - [2.2. 标记-复制（Copying）算法](#22-标记-复制copying算法)
    - [2.3. 标记-整理（Mark-Compact）算法](#23-标记-整理mark-compact算法)
    - [2.4. 分代收集理论](#24-分代收集理论)
- [3. 垃圾回收器](#3-垃圾回收器)
    - [3.1. 收集器性能考虑因素](#31-收集器性能考虑因素)
    - [3.2. 收集器分类](#32-收集器分类)
    - [3.3. 收集器详解](#33-收集器详解)
        - [3.3.1. 新生代收集器](#331-新生代收集器)
            - [3.3.1.1. Serial收集器](#3311-serial收集器)
            - [3.3.1.2. ParNew收集器](#3312-parnew收集器)
            - [3.3.1.3. Parallel Scavenge收集器](#3313-parallel-scavenge收集器)
        - [3.3.2. 老年代收集器](#332-老年代收集器)
            - [3.3.2.1. Serial Old收集器](#3321-serial-old收集器)
            - [3.3.2.2. Parallel Old收集器](#3322-parallel-old收集器)
            - [3.3.2.3. CMS收集器](#3323-cms收集器)
        - [3.3.3. G1收集器](#333-g1收集器)
            - [3.3.3.1. G1的内存布局](#3331-g1的内存布局)
            - [3.3.3.2. G1运行流程](#3332-g1运行流程)
            - [3.3.3.3. G1优缺点](#3333-g1优缺点)
            - [3.3.3.4. 使用G1](#3334-使用g1)
        - [3.3.4. 常用的收集器组合](#334-常用的收集器组合)
    - [3.4. 选择合适的垃圾收集器](#34-选择合适的垃圾收集器)
    - [3.5. ~~垃圾收集器常用参数~~](#35-垃圾收集器常用参数)
- [4. GC类型：Minor GC和Full GC/Major GC](#4-gc类型minor-gc和full-gcmajor-gc)
    - [4.1. Minor GC](#41-minor-gc)
    - [4.2. Major GC / Full GC](#42-major-gc--full-gc)
    - [4.3. Stop the world](#43-stop-the-world)
- [5. 方法区(类和常量)回收(类的卸载阶段)](#5-方法区类和常量回收类的卸载阶段)

<!-- /TOC -->

![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/JVM/JVM-56.png)  

&emsp; GC主要解决下面的三个问题：  

* 哪些内存需要回收？  
* 什么时候回收？  
* 如何回收？  

<!-- 
哪些内存需要回收？即GC 发生的内存区域？


如何判断这个对象需要回收？即GC 的存活标准？
    这里又能够引出以下的知识概念：

    引用计数法
    可达性分析法
    引用的种类和特点、区别 （强引用、软引用、弱引用、虚引用） 
    延伸知识：(WeakHashMap) (引用队列)



有了对象的存活标准之后，我们就需要知道GC 的相关算法（思想）

    标记-清除（Mark-Sweep）算法
    复制（Copying）算法
    标记-整理（Mark-Compact）算法

在下一步学习之前，还需要知道一些GC的术语📖，防止对一些概念描述出现混淆


知道了算法之后，自然而然我们到了JVM中对这些算法的实现和应用，即各种垃圾收集器（Garbage Collector）

    串行收集器
    并行收集器
    ⭐CMS 收集器 
    ⭐G1 收集器
-->



# 1. 对象的存活
<!-- https://juejin.im/post/5e151b38f265da5d495c8025 --> 
&emsp; GC回收的主要区域是堆、方法区。

## 1.1. GC的存活标准  
&emsp; 对于如何判断对象是否可以回收，有两种比较经典的判断策略：引用计数算法、可达性分析算法。  

### 1.1.1. 引用计数法  
&emsp; 给每个对象添加一个计数器，当有地方引用该对象时计数器加1，当引用失效时计数器减1。用对象计数器是否为0来判断对象是否可被回收。  
&emsp; 缺点：**<font color = "red">无法解决循环引用的问题</font>**。如果出现A引用了B，B又引用了A，这时候就算它们都不再使用了，但因为相互引用，计算器=1，永远无法被回收。Java中没有使用这种算法。  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/JVM/JVM-16.png)  

### 1.1.2. 可达性分析法  
&emsp; 从GC Roots开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的，那么虚拟机就判断是可回收对象。可达性分析可以解决循环引用的问题。  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/JVM/JVM-17.png)  
&emsp; 可作为GC ROOTs的对象：  

* 虚拟机栈中引用的对象；  
* 方法区中，类静态属性引用的对象；  
* 方法区中，常量引用的对象；  
* 本地方法栈中，JNI（即Native方法）引用的对象；  

### 1.1.3. 对象的四种引用状态，强弱软虚    
&emsp; 无论是通过引用计数算法判断对象的引用数量，还是通过根搜索算法判断对象的引用链是否可达，判定对象是否存活都与“引用”有关。  
&emsp; 在JDK中提供了四个级别的引用：强引用，软引用，弱引用和虚引用。在这四个引用类型中，只有强引用Final Reference类是包内可见，其他三种引用类型均为public，可以在应用程序中直接使用。引用类型的类结构如图所示：  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/JVM/JVM-22.png)  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/JVM/JVM-18.png)  
&emsp; <font color = "lime">Java 中引入四种引用的目的是让程序自己决定对象的生命周期，JVM 是通过垃圾回收器对这四种引用做不同的处理，来实现对象生命周期的改变。</font>  

<!-- 
Java设计这四种引用的主要目的有两个：
    可以让程序员通过代码的方式来决定某个对象的生命周期；
    有利用垃圾回收。
-->

#### 1.1.3.1. 强引用  
&emsp; 代码中普遍存在的类似"Object obj = new Object()"这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。  
&emsp; 强引用的特点： 
 
* 强引用可以直接访问目标对象。  
* 强引用所指向的对象在任何时候都不会被系统回收。JVM宁愿抛出OOM异常，也不会回收强引用所指向的对象。  
* 强引用可能导致内存泄漏。  

#### 1.1.3.2. 软引用  
&emsp; 软引用是除了强引用外，最强的引用类型。可以通过java.lang.ref.SoftReference使用软引用。一个持有软引用的对象，不会被JVM很快回收，JVM会根据当前堆的使用情况来判断何时回收。**<font color = "red">当堆使用率临近阈值时，才会去回收软引用的对象</font>**。因此，软引用可以用于实现对内存敏感的高速缓存。  
&emsp; 软引用示例：  
&emsp; 在IDE设置参数-Xmx2m -Xms2m规定堆内存大小为2m。  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/JVM/JVM-19.png)  
&emsp; 运行结果：  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/JVM/JVM-20.png)  
&emsp; 打开被注释掉的new byte[1024*100]语句，这条语句请求一块大的堆空间，使堆内存使用紧张。并显式的再调用一次GC，结果如下：  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/JVM/JVM-21.png)说明在系统内存紧张的情况下，软引用被回收。  

#### 1.1.3.3. 弱引用  
&emsp; 弱引用是一种比软引用较弱的引用类型。在系统GC时，**<font color = "red">只要发现弱引用，不管系统堆空间是否足够，都会将对象进行回收</font>**。<font color = "lime">它可以作为简单的缓存表解决方案。</font>  
&emsp; 在java中，可以用java.lang.ref.WeakReference实例来保存对一个Java对象的弱引用。  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/JVM/JVM-23.png)  
&emsp; 运行结果：  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/JVM/JVM-24.png)  

#### 1.1.3.4. 虚引用  
&emsp; 虚引用是所有类型中最弱的一个。**<font color = "red">一个持有虚引用的对象，和没有引用几乎是一样的，随时可能被垃圾回收器回收</font>**。当试图通过虚引用的get()方法取得强引用时，总是会失败。并且，虚引用必须和引用队列一起使用，它的作用在于跟踪垃圾回收过程。  
&emsp; 当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在垃圾回收后，销毁这个对象，将这个虚引用加入引用队列。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/JVM/JVM-25.png)  
&emsp; 运行结果：  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/JVM/JVM-26.png)  
&emsp; 对虚引用的get()操作，总是返回null，因为sf.get()方法的实现如下：  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/JVM/JVM-27.png)  

#### 1.1.3.5. 软引用和弱引用的使用  
&emsp; **<font color>软引用，弱引用都非常适合来保存那些可有可无的缓存数据，如果这么做，当系统内存不足时，这些缓存数据会被回收，不会导致内存溢出。而当内存资源充足时，这些缓存数据又可以存在相当长的时间，从而起到加速系统的作用。</font>**  

&emsp; 假如⼀个应⽤需要读取⼤量的本地图⽚，如果每次读取图⽚都从硬盘读取会严重影响性能，如果⼀次性全部加载到内存⼜可能造成内存溢出，这时可以⽤软引⽤解决这个问题。  
&emsp; 设计思路：⽤⼀个HashMap来保存图⽚路径和相应图⽚对象关联的软引⽤之间的映射关系,在内存不⾜时,JVM会⾃动共回收这些缓存图⽚对象所占的空间,避免OOM。  

```java
Map<String, SoftReference<Bitmap>> imageCache = new HashMap<>();  
```  

-----
## 1.2. 生存还是死亡

<!-- 
&emsp; 即使在可达性分析算法中不可达的对象，也并非一定是“非死不可”的，这时候他们暂时处于“缓刑”阶段，真正宣告一个对象死亡至少要经历两次标记过程：  
&emsp; 1）如果对象在可达性分析算法中不可达，那么它会被第一次标记并进行一次刷选，刷选的条件是是否需要执行finalize()方法（当对象没有覆盖finalize()或者finalize()方法已经执行过了（对象的此方法只会执行一次）），虚拟机将这两种情况都会视为没有必要执行）。  
&emsp; 2）如果这个对象有必要执行finalize()方法会将其放入F-Queue队列中，稍后GC将对F-Queue队列进行第二次标记，如果在重写finalize()方法中将对象自己赋值给某个类变量或者对象的成员变量，那么第二次标记时候就会将它移出“即将回收”的集合。  
&emsp; finalize()能做的工作，使用try-finally或者其他方式都能做到更好，更及时，所以不建议使用此方法。  
-->

&emsp; <font color = "red">在可达性分析算法中，不可达的对象也不是一定会死亡的，它们暂时都处于“缓刑”阶段，要真正宣告一个对象“死亡”，至少要经历两次标记过程。</font>  

&emsp; 步骤1：判断有没有必要执行finalize()方法  
&emsp; 如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。  
&emsp; 另外，有两种情况都视为“没有必要执行”：对象没有覆盖finaliza()方法、finalize()方法已经被虚拟机调用过。  

&emsp; 步骤2：如何执行  
&emsp; 如果这个对象被判定为有必要执行finalize()方法，那么此对象将会放置在一个叫做 F-Queue 的队列中，并在稍后由一个虚拟机自动建立的、低优先级的Finalizer线程去执行它。  

&emsp; 步骤3：执行死亡还是逃脱死亡  
&emsp; 首先，需要知道，finalize()方法是对象逃脱死亡命运的最后一次机会，稍后GC将对F-Queue 队列中的对象进行第二次小规模的标记。  
&emsp; 逃脱死亡：对象想在finalize()方法中成功拯救自己，只要重新与引用链上的任何一个对象建立关联即可，例如把自己（this关键字）赋值给某个类变量或者对象的成员变量，这样在第二次标记时它将被移出“即将回收”的集合。  
&emsp; 执行死亡：对象没有执行逃脱死亡，那就是死亡了。  

    finalize()⽅法什么时候被调⽤？析构函数(finalization)的⽬的是什么？
    垃圾回收器(garbage colector)决定回收某对象时，就会运⾏该对象的finalize()⽅法 但是在Java中很不幸，如果内存总是充⾜的，那么垃圾回收可能永远不会进⾏，也就是说filalize() 可能永远
    不被执⾏，显然指望它做收尾⼯作是靠不住的。 那么finalize()究竟是做什么的呢？ 它最主要的⽤途是回收特殊渠道申请的内存。Java程序有垃圾回收器，所以⼀般情况下内存问题不⽤程序
    员操⼼。但有⼀种JNI(Java Native Interface)调⽤non-Java程序（C或C++）， finalize()的⼯作就是回收这部分的内存。

-----
# 2. GC算法  
&emsp; GC常用的算法：标记-清除（Mark-Sweep）、复制（Copying）、标记-整理（Mark-Compact）、分代收集（新生用复制，老年用标记-压缩）。  

## 2.1. 标记-清除（Mark-Sweep）算法  
<!-- 
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/JVM/JVM-14.png)  
&emsp; 这是最基础的算法，分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，标记完成后统一回收所有被标记的对象。  
&emsp; 适用场景：存活对象较多的情况下比较高效；适用于老年代。 
-->
&emsp; 标记-清除算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象，也可以反过来，标记存活的对象，统一回收所有未被标记的对象。  
&emsp; 标记-清除算法是最基础的收集算法，是因为后续的收集算法大多都是以标记-清除算法为基础，对其缺点进行改进而得到的。<font color = "red">它的主要缺点有两个：</font>
1. 执行效率不稳定，如果Java堆中包含大量对象，而且其中大部分是需要被回收的，这时必须进行大量标记和清除的动作，导致标记和清除两个过程的执行效率都随对象数量增长而降低；  
2. <font color = "lime">内存空间的碎片化问题，</font>清除后产生大量不连续的内存碎片。如果有大对象会出现空间不够的现象，从而不得不提前触发另一次垃圾收集动作。  

&emsp; 标记-清除算法的执行过程：  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/JVM/JVM-52.png)  

## 2.2. 标记-复制（Copying）算法 
<!-- 
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/JVM/JVM-13.png)  
-->
&emsp; 标记-复制算法常被简称为复制算法。<font color = "red">为了解决标记-清除算法面对大量可回收对象时执行效率低的问题。</font>  
&emsp; 将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。  
&emsp; <font color = "red">如果内存中多数对象都是存活的，这种算法将会产生大量的内存间复制的开销</font>，但对于多数对象都是可回收的情况，算法需要复制的就是占少数的存活对象，而且每次都是针对整个半区进行内存回收，分配内存时也就不用考虑有空间碎片的复杂情况，只要移动堆顶指针，按顺序分配即可。这样实现简单，运行高效，不过其缺陷也显而易见，这种复制回收算法的代价是<font color = "red">将可用内存缩小为了原来的一半</font>，空间浪费多了一点。 

    优点：解决了内存碎片问题。
    缺点：将原来的内存缩小为原来的一半，存活对象越多效率越低。
    
&emsp; 标记-复制算法的执行过程：  
 ![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/JVM/JVM-53.png)  

## 2.3. 标记-整理（Mark-Compact）算法  
<!-- 
&emsp; 标记-整理算法是一种老年代的回收算法。  
&emsp; 标记-整理算法的工作过程如图：  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/JVM/JVM-15.png)  
-->
&emsp; 标记-整理算法的执行过程：  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/JVM/JVM-54.png)  
&emsp; 标记-整理算法的标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存。  
&emsp; 标记-清除算法与标记-整理算法的本质差异在于前者是一种非移动式的回收算法，而后者是移动式的。  

## 2.4. 分代收集理论  
&emsp; 新生代采用复制算法、老年代采用标记-整理算法。  

# 3. 垃圾回收器  
&emsp; 垃圾收集算法是内存回收的理论基础，而垃圾收集器就是内存回收的具体实现。HotSpot虚拟机所包含的所有收集器如图：  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/JVM/JVM-55.png)  
&emsp; 上图展示了多种作用于不同分代的收集器。如果两个收集器之间存在连线，那说明它们可以搭配使用。虚拟机所处的区域说明它是属于新生代收集器还是老年代收集器。选择对具体应用最合适的收集器。  

## 3.1. 收集器性能考虑因素  

* 吞吐量：程序的运行时间（程序的运行时间＋内存回收的时间）。  
* 垃圾收集开销：吞吐量的补数，垃圾收集器所占时间与总时间的比例。  
* 暂停时间：执行垃圾收集时，程序的工作线程被暂停的时间。  
* 收集频率：相对于应用程序的执行，收集操作发生的频率。  
* 堆空间： Java 堆区所占的内存大小。  
* 快速： 一个对象从诞生到被回收所经历的时间。  

&emsp; <font color  = "red">衡量垃圾收集器的三项最重要的指标是：内存占用（Footprint）、吞吐量（Throughput）和延迟（Latency），三者共同构成了一个“不可能三角”。</font>    

&emsp; **吞吐量和停顿时间：**  
&emsp; 停顿时间->垃圾收集器进行垃圾回收终端应用执行响应的时间  
&emsp; 吞吐量->运行用户代码时间/(运行用户代码时间+垃圾收集时间)  

&emsp; 停顿时间越短就越适合需要和用户交互的程序，良好的响应速度能提升用户体验；  
&emsp; 高吞吐量则可以高效地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。  

## 3.2. 收集器分类  

* 串行收集器->Serial和Serial Old  
&emsp; **<font color = "red">只能有一个垃圾回收线程执行，用户线程暂停。</font>** 适用于内存比较小的嵌入式设备 。  
* 并行收集器[吞吐量优先]->Parallel Scanvenge、Parallel Old  
&emsp; **<font color = "red">多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。</font>** 适用于科学计算、后台处理等若交互场景 。  
* 并发收集器[停顿时间优先]->CMS、G1  
&emsp; **<font color = "red">用户线程和垃圾收集线程同时执行(但并不一定是并行的，可能是交替执行的)，垃圾收集线程在执行的时候不会停顿用户线程的运行。</font>** 适用于相对时间有要求的场景，比如Web 。  

## 3.3. 收集器详解
### 3.3.1. 新生代收集器  
#### 3.3.1.1. Serial收集器  
&emsp; 最基本、发展历史最久的收集器，这个收集器是一个采用复制算法的单线程的收集器。  
&emsp; 迄今为止，Serial收集器依然是虚拟机运行在Client模式下的默认新生代收集器，因为它简单而高效。用户桌面应用场景中，分配给虚拟机管理的内存一般来说不会很大，收集几十兆甚至一两百兆的新生代停顿时间在几十毫秒最多一百毫秒，只要不是频繁发生，这点停顿是完全可以接受的。  
&emsp; 参数控制：
  
    -XX:+UseSerialGC 串行收集器
    
&emsp; Serial收集器运行过程如下图所示：  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/JVM/JVM-29.png)  
<!-- &emsp; 说明：1.需要STW（Stop The World），停顿时间长。2.简单高效，对于单个CPU环境而言，Serial收集器由于没有线程交互开销，可以获取最高的单线程收集效率。  -->

&emsp; **<font color = "red">一句话概括：Serial收集器，采用复制算法的单线程的收集器，运行在Client模式下的默认新生代收集器，适用于用户桌面应用中。</font>**

#### 3.3.1.2. ParNew收集器  
&emsp; （相同）ParNew收集器是Serial收集器的多线程版本，除了使用多条线程进行垃圾收集外，其余行为和Serial收集器完全一样，包括使用的也是复制算法。  
&emsp; （不同）ParNew收集器除了多线程以外和Serial收集器并没有太多创新的地方，但是它却是JDK7之前Server模式下的虚拟机首选的新生代收集器，其中有一个很重要的和性能无关的原因是，除了Serial收集器外，目前只有它能与CMS收集器配合工作。  
&emsp; （对比）ParNew收集器在单CPU的环境中绝对不会有比Serial收集器更好的效果，甚至由于线程交互的开销，该收集器在两个CPU的环境中都不能百分之百保证可以超越Serial收集器。当然，随着可用CPU数量的增加，它对于GC时系统资源的有效利用还是很有好处的。它默认开启的收集线程数与CPU数量相同，在CPU数量非常多的情况下，可以使用-XX:ParallelGCThreads参数来限制垃圾收集的线程数。  
&emsp; 参数控制：  

    -XX:+UseParNewGC ParNew收集器
    -XX:ParallelGCThreads 限制线程数量
    
&emsp; ParNew收集器运行过程如下图所示：  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/JVM/JVM-30.png)  

&emsp; **<font color = "red">一句话概括：Serial收集器的多线程版本，降低停顿时间，JDK7之前Server模式下的虚拟机首选的新生代收集器，能与CMS收集器配合。</font>**

#### 3.3.1.3. Parallel Scavenge收集器  
&emsp; Parallel Scavenge收集器也是一个新生代收集器，也是用复制算法的收集器，也是并行的多线程收集器。Parallel Scavenge收集器是虚拟机运行在Server模式下的默认垃圾收集器。   
&emsp; 它的特点是它的关注点和其他收集器不同。<font color = "red">Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量（吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)））。</font> 高吞吐量可以最高效率地利用 CPU 时间，尽快地完成程序的运算任务，主要适用于在后台运算而不需要太多交互的任务。<font color = "red">自适应调节策略也是 ParallelScavenge 收集器与 ParNew 收集器的一个重要区别。</font> 
&emsp; 参数控制：  

    -XX:+UseParallelGC 使用Parallel收集器+ 老年代串行。  
    Parallel Scavenge收集器提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间的-XX：MaxGCPauseMillis参数以及直接设置吞吐量大小的-XX：GCTimeRatio参数。  
    Parallel Scavenge收集器还有一个参数-XX：+UseAdaptiveSizePolicy值得我们关注。这是一个开关参数，当这个参数被激活之后，就不需要人工指定新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX：SurvivorRatio）、晋升老年代对象大小（-XX：PretenureSizeThreshold）等细节参数 了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。这种调节方式称为垃圾收集的自适应的调节策略（GC Ergonomics）。  

&emsp; **<font color = "red"> Parallel Scavenge收集器，也是采用复制算法的并行的多线程收集器，Server模式下的默认垃圾收集器</font>，<font color = "lime">目标是达到一个可控制的吞吐量。</font>**

### 3.3.2. 老年代收集器  
#### 3.3.2.1. Serial Old收集器  
&emsp; Serial收集器的老年代版本，同样是一个单线程收集器，使用“标记-整理算法”，这个收集器的主要意义也是在于给Client模式下的虚拟机使用。 

#### 3.3.2.2. Parallel Old收集器  
&emsp; Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法。这个收集器在JDK 1.6之后的出现，“吞吐量优先收集器”终于有了比较名副其实的应用组合，在注重吞吐量以及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge收集器+Parallel Old收集器的组合。  
&emsp; 数控制：  

    -XX:+UseParallelOldGC 使用Parallel收集器+ 老年代并行

&emsp; 运行过程如下图所示：  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/JVM/JVM-31.png)  

#### 3.3.2.3. CMS收集器  
&emsp; CMS（Conrrurent Mark Sweep）收集器是以 **<font color = "lime">获取最短回收停顿时间为目标</font>** 的收集器。  
&emsp; 使用标记-清除算法，收集过程分为如下四步：  
1. 初始标记，标记GCRoots能直接关联到的对象，时间很短。  
2. 并发标记，进行GCRoots Tracing（可达性分析）过程，过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行。  
3. 重新标记，修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短。  
4. 并发清除，理删除掉标记阶段判断的已经死亡的对象，由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的。  

&emsp; **<font color = "red">由于在整个过程中耗时最长的并发标记和并发清除阶段中，垃圾收集器线程都可以与用户线程一起工作，所以从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。</font>**  

&emsp; CMS是一款优秀的收集器，**<font color = "red">它最主要的优点在名字上已经体现出来：并发收集、低停顿。</font>**但是也有以下**<font color = "red">三个明显的缺点</font>**：  

* 吞吐量低  
&emsp; 由于CMS在垃圾收集过程使用用户线程和GC线程并行执行，从而线程切换会有额外开销，因此CPU吞吐量就不如在GC过程中停止一切用户线程的方式来的高。
* <font color = "red">无法处理浮动垃圾，导致频繁Full GC</font>  
&emsp; 由于垃圾清除过程中,用户线程和GC线程并发执行，也就是用户线程仍在执行，那么在执行过程中会产生垃圾，这些垃圾称为"浮动垃圾"。  
&emsp; 如果CMS在垃圾清理过程中,用户线程需要在老年代中分配内存时发现空间不足，就需再次发起Full GC，而此时CMS正在进行清除工作，因此此时只能由Serial Old临时对老年代进行一次Full GC。  
* 使用"标记-清除"算法，产生碎片空间  
&emsp; 由于CMS使用了"标记-清除"算法, 因此清除之后会产生大量的碎片空间，不利于空间利用率。不过CMS提供了应对策略：开启-XX:+UseCMSCompactAtFullCollection，开启该参数后,每次FullGC完成后都会进行一次内存压缩整理，将零散在各处的对象整理到一块儿。但每次都整理效率不高，因此提供了另外一个参数，设置参数-XX:CMSFullGCsBeforeCompaction，本参数告诉CMS，经过了N次Full GC过后再进行一次内存整理。  

&emsp; 参数控制：  

    -XX:+UseConcMarkSweepGC 使用CMS收集器
    -XX:+ UseCMSCompactAtFullCollection Full GC后，进行一次碎片整理；整理过程是独占的，会引起停顿时间变长
    -XX:+CMSFullGCsBeforeCompaction 设置进行几次Full GC后，进行一次碎片整理-XX:ParallelCMSThreads 设定CMS的线程数量（一般情况约等于可用CPU数量）

<!-- 
1. **CMS收集器对处理器资源非常敏感。**在并发阶段，它虽然不会导致用户线程停顿，但却会因为占用了一部分线程（或者说处理器的计算能力）而导致应用程序变慢，降低总吞吐量。  
2. **由于CMS收集器无法处理“浮动垃圾”（Floating Garbage），有可能出现“Concurrent Mode Failure”失败进而导致另一次完全“Stop The World”的Full GC的产生。**  
&emsp; 在CMS的并发标记和并发清理阶段，用户线程是还在继续运行的，程序在运行自然就还会伴随有新的垃圾对象不断产生，但这一部分垃圾对象是出现在标记过程结束以后，CMS无法在当次收集中处理掉它们，只好留待下一次垃圾收集时再清理掉。这一部分垃圾就称为“浮动垃圾”。   
&emsp; 由于在垃圾收集阶段用户线程还需要持续运行，那就还需要预留足够内存空间提供给用户线程使用，因此CMS收集器不能像其他收集器那样等待到老年代几乎完全被填满了再进行收集，必须预留一部分空间供并发收集时的程序运作使用。  
&emsp; 到了JDK 6时，CMS收集器的启动阈值就已经默认提升至92%。但这又会更容易面临另一种风险：要是CMS运行期间预留的内存无法满足程序分配新对象的需要，就会出现一次“并发失败”（Concurrent Mode Failure），这时候虚拟机将不得不启动后备预案：冻结用户线程的执行，临时启用Serial Old收集器来重新进行老年代的垃圾收集， 但这样停顿时间就很长了。  
3. **CMS是一款基于“标记-清除”算法实现的收集器，收集结束时会有大量空间碎片产生。**  
-->

<!-- 
&emsp; 其中，并发标记与并发清除两个阶段耗时最长，但是可以与用户线程并发执行。运行过程如下图所示:  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/JVM/JVM-32.png)  
&emsp; 说明：1.对CPU资源非常敏感，可能会导致应用程序变慢，吞吐率下降。2.无法处理浮动垃圾，因为在并发清理阶段用户线程还在运行，自然就会产生新的垃圾，而在此次收集中无法收集他们，只能留到下次收集，这部分垃圾为浮动垃圾，同时，由于用户线程并发执行，所以需要预留一部分老年代空间提供并发收集时程序运行使用。3.由于采用的标记 - 清除算法，会产生大量的内存碎片，不利于大对象的分配，可能会提前触发一次Full GC。虚拟机提供了-XX:+UseCMSCompactAtFullCollection参数来进行碎片的合并整理过程，这样会使得停顿时间变长，虚拟机还提供了一个参数配置，-XX:+CMSFullGCsBeforeCompaction，用于设置执行多少次不压缩的Full GC后，接着来一次带压缩的GC。  
-->
### 3.3.3. G1收集器  

<!-- https://www.cnblogs.com/cuizhiquan/articles/10961354.html-->
&emsp; G1是目前技术发展的最前沿成果之一，HotSpot开发团队赋予它的使命是未来可以替换掉JDK1.5中发布的CMS收集器。  
&emsp; G1是一款而向服务端应用的垃圾收集器。G1回收器在jdk1.9后成为了JVM的默认垃圾回收器。  
&emsp; 通过把Java堆分成大小相等的多个独立区域，回收时计算出每个区域回收所获得的空间以及所需时间的经验值，根据记录两个值来判断哪个区域最具有回收价值，所以叫Garbage First（垃圾优先）。

#### 3.3.3.1. G1的内存布局  
<!-- 深入理解Java虚拟机 第3版 -->
&emsp; **<font color = "red">G1的内存布局：</font>** 在G1之前的垃圾收集器，收集的范围都是整个新生代或者老年代，而G1不再是这样。使用G1收集器时，Java堆的内存布局与其他收集器有很大差别，它<font color = "red">将整个Java堆划分为多个大小相等的独立区域（Region）</font>，虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分（可以不连续）Region的集合。  
&emsp; **<font color = "red">G1收集器能建立可预测的停顿时间模型</font>**，是因为它可以有计划地避免在整个Java堆中进行全区域的垃圾收集。G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region/这也就是Garbage-First名称的来由）。这种使用Region划分内存空间以及有优先级的区域回收方式，保证子G1收集器在有限的时间内可以获取尽可能高的收集效率。  

&emsp; Region不可能是孤立的。一个对象分配在某个Region中，它并非只能被本Region中的其他对象引用，而是可以与整个Java堆任意的对象发生引用关系。  
&emsp; 在G1收集器中，Region之间的对象引用以及其他收集器中的新生代与老年代之间的对象引用，<font color = "red">虚拟机是使用Remembered Set 来避免全堆扫描的</font>。G1中每个Region都有一个与之对应的Remembered Set，虚拟机发现程序在对Reference类型的数据进行写操作时，会产生一个Write Barrier暂时中断写操作，检查Reference引用的对象是否处于不同的Region之中（在分代的例子中就是检查是否老年代中的对象引用了新生代中的对象），如果是，便通过CardTable 把相关引用信息记录到被引用对象所属的Region的Remembered Set之中。当进行内存回收时，在GC根节点的枚举范围中加入Remembered Set即可保证不对全堆扫描也不会有遗漏。  

-----
G1 收集器避免全区域垃圾收集，它把堆内存划分为大小固定的几个独立区域，并且跟踪这些区域的垃圾收集进度，同时在后台维护一个优先级列表，每次根据所允许的收集时间，优先回收垃圾最多的区域。区域划分和优先级区域回收机制，确保 G1 收集器可以在有限时间获得最高的垃圾收集效率。  


#### 3.3.3.2. G1运行流程  
<!-- https://baijiahao.baidu.com/s?id=1663956888745443356&wfr=spider&for=pc-->
&emsp; 不去计算用户线程运行过程中的动作（如使用写屏障维护记忆集的操作），G1收集器的运作过程大致可划分为以下四个步骤：  

* 初始标记（Initial Marking）：仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS 指针的值，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象。这个阶段需要停顿线程，但耗时很短，而且是借用进行Minor GC的时候同步完成的，所以G1收集器在这个阶段实际并没有额外的停顿。    
* 并发标记（Concurrent Marking）：从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行。当对象图扫描完成以后，还要重新处理SATB记录下的在并发时有引用变动的对象。  
* 最终标记（Final Marking）：对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍遗留下来的最后那少量的SATB记录。   
* 筛选回收（Live Data Counting and Evacuation）：负责更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region 构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧Region的全部空间。这里的操作涉及存活对象的移动，是必须暂停用户线程，由多条收集器线程并行完成的。    

&emsp; G1收集器除了并发标记外，其余阶段也是要完全暂停用户线程的， 换言之，它并非纯粹地追求低延迟，**<font color = "red">官方给它设定的目标是在延迟可控的情况下获得尽可能高的吞吐量</font>**，所以才能担当起“全功能收集器”的重任与期望。

#### 3.3.3.3. G1优缺点  


&emsp; G1收集器有以下特点：  

* 并行和并发：使用多个CPU来缩短Stop The World停顿时间，与用户线程并发执行。  
* 分代收集：虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但是还是保留了分代的概念。它能够采用不同的方式去处理新创建的对象和已经存活了一段时间，熬过多次GC的旧对象以获取更好的收集效果。  
* **<font color = "lime">空间整合：</font>** 与CMS的“标记--清理”算法不同，<font color = "red">G1从整体来看是基于“标记整理”算法实现的收集器；从局部上来看是基于“复制”算法实现的。</font>这两种算法都意味着<font color = "red">G1运作期不会产生内存空间碎片</font>，收集后能提供规整的可用内存。这种特性有利于程序长时间运行，分配大对象吋不会因为无法找到连续内存空而提前触发下一次GC。  
* **<font color = "lime">可预测的停顿：</font>** 这是G1相对于CMS的另一个大优势，降低停顿时间是G1和CMS共同的关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。  

&emsp; 可以<font color = "red">由用户指定期望的停顿时间是G1收集器很强大的一个功能</font>，设置不同的期望停顿时间，可使得G1在不同应用场景中取得关注吞吐量和关注延迟之间的最佳平衡。不过，这里设置的“期望值”必须是符合实际的。  
&emsp; 相比CMS，G1的优点有很多，暂且不论可以指定最大停顿时间、分Region的内存布局、按收益动态确定回收集这些创新性设计带来的红利，单从最传统的算法理论上看，G1也更有发展潜力。与CMS 的“标记-清除”算法不同，G1从整体来看是基于“标记-整理”算法实现的收集器，但从局部（两个Region 之间）上看又是基于“标记-复制”算法实现，无论如何，这两种算法都意味着G1运作期间不会产生内存空间碎片，垃圾收集完成之后能提供规整的可用内存。这种特性有利于程序长时间运行，在程序为大对象分配内存时不容易因无法找到连续内存空间而提前触发下一次收集。  

&emsp; 比起CMS，G1的弱项也可以列举出不少，如在用户程序运行过程中，G1无论是为了垃圾收集产生的内存占用（Footprint）还是程序运行时的额外执行负载
（Overload）都要比CMS要高。 


---------
G1 收集器两个最突出的改进是：  
1. 基于标记-整理算法，不产生内存碎片。
2. 可以非常精确控制停顿时间，在不牺牲吞吐量前提下，实现低停顿垃圾回收。

#### 3.3.3.4. 使用G1  
&emsp; **开启G1：** 在JDK9之前，JDK7和JDK8默认都是ParallelGC垃圾回收。到了JDK9，G1才是默认的垃圾回收器。所以如果JDK7或者JDK8需要使用G1的话，需要通过参数（-XX:+UseG1GC）显示执行垃圾回收器。而JDK9以后的版本，不需要任何JVM参数，默认就是G1垃圾回收模式，显示指定G1运行一个Demo程序如下：  

```java
java -Xmx1g -Xms1g -XX:+UseG1GC -XX:MaxGCPauseMillis=200 -jar demo.jar
```
  
### 3.3.4. 常用的收集器组合  

| |新生代GC策略	|老年代GC策略	|说明|
|---|---|---|---|
|组合1|Serial	|Serial Old	|Serial和Serial Old都是单线程进行GC，特点就是GC时暂停所有应用线程。|
|组合2|Serial	|CMS+Serial Old	|CMS（Concurrent Mark Sweep）是并发GC，实现GC线程和应用线程并发工作，不需要暂停所有应用线程。另外，当CMS进行GC失败时，会自动使用Serial Old策略进行GC。|
|组合3|ParNew	|CMS	|使用-XX:+UseParNewGC选项来开启。ParNew是Serial的并行版本，可以指定GC线程数，默认GC线程数为CPU的数量。可以使用-XX:ParallelGCThreads选项指定GC的线程数。如果指定了选项-XX:+UseConcMarkSweepGC选项，则新生代默认使用ParNew GC策略。|
|组合4|ParNew	|Serial Old	|使用-XX:+UseParNewGC选项来开启。新生代使用ParNew GC策略，年老代默认使用Serial Old GC策略。|
|组合5|Parallel Scavenge	|Serial Old	|Parallel Scavenge策略主要是关注一个可控的吞吐量：应用程序运行时间 / (应用程序运行时间 + GC时间)，可见这会使得CPU的利用率尽可能的高，适用于后台持久运行的应用程序，而不适用于交互较多的应用程序。|
|组合6|Parallel Scavenge	|Parallel Old	|Parallel Old是Serial Old的并行版本|
|组合7|G1GC	|G1GC	| -XX:+UnlockExperimentalVMOptions -XX:+UseG1GC  <br/>#开启  <br/>-XX:MaxGCPauseMillis =50  #暂停时间目标  <br/>-XX:GCPauseIntervalMillis =200  #暂停间隔目标  <br/>-XX:+G1YoungGenSize=512m  #年轻代大小  <br/>-XX:SurvivorRatio=6  #幸存区比例|

## 3.4. 选择合适的垃圾收集器  
&emsp; 官网：https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/collectors.html#sthref28

* 优先调整堆的大小让服务器自己来选择  
* 如果内存小于100M，使用串行收集器  
* 如果是单核，并且没有停顿时间要求，使用串行或JVM自己选  
* 如果允许停顿时间超过1秒，选择并行或JVM自己选  
* 如果响应时间最重要，并且不能超过1秒，使用并发收集器  
* 对于G1收集  

## 3.5. ~~垃圾收集器常用参数~~  
&emsp; -XX:+UseSerialGC：在新生代和老年代使用串行收集器  
&emsp; -XX:+UseParNewGC：在新生代使用并行收集器  
&emsp; -XX:+UseParallelGC：新生代使用并行回收收集器，更加关注吞吐量  
&emsp; -XX:+UseParallelOldGC：老年代使用并行回收收集器  
&emsp; -XX:ParallelGCThreads：设置用于垃圾回收的线程数  
&emsp; -XX:+UseConcMarkSweepGC：新生代使用并行收集器，老年代使用CMS+串行收集器  
&emsp; -XX:ParallelCMSThreads：设定CMS的线程数量  
&emsp; -XX:+UseG1GC：启用G1垃圾回收器  

# 4. GC类型：Minor GC和Full GC/Major GC  
&emsp; GC经常发生的区域是堆区，堆区还可以细分为新生代、老年代，新生代还分为一个Eden区和两个Survivor区。  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/JVM/JVM-33.png)  

## 4.1. Minor GC  
&emsp; 新生成的对象优先放在年轻代。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。  
&emsp; 新生代内存按照8:1:1的比例分为一个eden区和两个survivor区。大部分对象在Eden区中生成。当Eden占用完时，垃圾回收器进行回收。回收时先将eden区存活对象复制到一个survivor0区，然后清空eden区，当这个survivor0区也存放满了时，则将eden区和survivor0区（使用的survivor中的对象也可能失去引用）存活对象复制到另一个survivor1区，然后清空eden和这个survivor0区，此时survivor0区是空的，然后将survivor0区和survivor1区交换，即保持survivor1区为空， 如此往复。    
&emsp; 新生代发生的GC也叫做Minor GC，MinorGC发生频率比较高(不一定等Eden区满了才触发)。  
&emsp; 对象每经历一次Minor GC，年龄加1，达到“晋升年龄阈值”后，被放到老年代，这个过程也称为“晋升”。显然，“晋升年龄阈值”的大小直接影响着对象在新生代中的停留时间，在Serial和ParNew GC两种回收器中，“晋升年龄阈值”通过参数MaxTenuringThreshold设定，默认值为15。    

&emsp; **Minor GC触发条件：** 当Eden空间满时，就将触发一次Minor GC。    

## 4.2. Major GC / Full GC  
<!-- 
    对象优先在Eden中分配，当Eden中没有足够空间时，虚拟机将发生一次Minor GC，因为Java大多数对象都是朝生夕灭，所以Minor GC非常频繁，而且速度也很快；

    Full GC，发生在老年代的GC，当老年代没有足够的空间时即发生Full GC，发生Full GC一般都会有一次Minor GC。大对象直接进入老年代，如很长的字符串数组，虚拟机提供一个-XX:PretenureSizeThreadhold参数，令大于这个参数值的对象直接在老年代中分配，避免在Eden区和两个Survivor区发生大量的内存拷贝；

    发生Minor GC时，虚拟机会检测之前每次晋升到老年代的平均大小是否大于老年代的剩余空间大小，如果大于，则进行一次Full GC，如果小于，则查看HandlePromotionFailure设置是否允许担保失败，如果允许，那只会进行一次Minor GC，如果不允许，则改为进行一次Full GC。
-->
&emsp; Major GC：老年代（Old Generation）：在新生代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代，该区域中对象存活率高。老年代的垃圾回收，又称Major GC，通常使用“标记-清理”或“标记-整理”算法。  
&emsp; Full GC：整堆包括新生代和老年代的垃圾回收称为Full GC（HotSpot VM里，除了CMS之外，其它能收集老年代的GC都会同时收集整个GC堆，包括新生代）。  

&emsp; 老年代对象其存活时间长，因此Full GC很少执行。老年代内存比新生代也大很多(大概比例是2:1)。Full GC执行速度会比Minor GC慢很多，Full GC一般会比Minor GC慢10倍以上。Major GC也会触发STW（Stop the World）。所以，对于响应性的应用程序，应该尽量避免Major GC。还要注意，Major GC的STW的时长受年老代垃圾回收器类型的影响。STW会造成系统A内部的工作线程大量的卡顿，不再工作。要等JVM FullGC结束之后，工作线程才会恢复运作。  

&emsp; **<font color = "red">Full GC的触发条件：</font>**  
1. 调用System.gc()  
&emsp; 只是建议虚拟机执行Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。  
2. 老年代空间不足  
&emsp; 老年代空间不足的常见场景为大对象直接进入老年代、长期存活的对象进入老年代等。  
&emsp; 为了避免以上原因引起的Full GC，应当尽量不要创建过大的对象以及数组。除此之外，可以通过-Xmn虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。还可以通过 -XX:MaxTenuringThreshold 调大对象进入老年代的年龄，让对象在新生代多存活一段时间。  
3. 空间分配担保失败  
&emsp; 使用复制算法的Minor GC需要老年代的内存空间作担保，如果担保失败会执行一次Full GC。  
4. JDK 1.7及以前的永久代空间不足  
&emsp; 为避免以上原因引起的Full GC，可采用的方法为增大永久代空间或转为使用 CMS GC。  
5. Concurrent Mode Failure  
&emsp; 执行CMS GC的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是GC过程中浮动垃圾过多导致暂时性的空间不足），便会报 Concurrent Mode Failure错误，并触发Full GC。  


    1. 旧生代空间不足 
    旧生代空间只有在新生代对象转入及创建为大对象、大数组时才会出现不足的现象，当执行Full GC后空间仍然不足，则抛出如下错误：java.lang.OutOfMemoryError: Java heap space 为避免以上两种状况引起的FullGC，调优时应尽量做到让对象在Minor GC阶段被回收、让对象在新生代多存活一段时间及不要创建过大的对象及数组。  
    2. Permanet Generation空间满  
    PermanetGeneration中存放的为一些class的信息等，当系统中要加载的类、反射的类和调用的方法较多时，Permanet Generation可能会被占满，在未配置为采用CMS GC的情况下会执行Full GC。如果经  
    过Full GC仍然回收不了，那么JVM会抛出如下错误信息：java.lang.OutOfMemoryError: PermGen space为避免Perm Gen占满造成Full GC现象，可采用的方法为增大Perm Gen空间或转为使用CMS GC。  
    3. CMS GC时出现promotion failed和concurrent mode failure  
    对于采用CMS进行旧生代GC的程序而言，尤其要注意GC日志中是否有promotion failed和concurrentmode failure两种状况，当这两种状况出现时可能会触发Full GC。promotionfailed是在进行Minor GC时，survivor space放不下、对象只能放入旧生代，而此时旧生代也放不下造成的；concurrent mode failure是在执行CMS GC的过程中同时有对象要放入旧生代，而此时旧生代空间不足造成的。  
    应对措施为：增大survivorspace、旧生代空间或调低触发并发GC的比率，但在JDK5.0+、6.0+的版本中有可能会由于JDK的bug29导致CMS在remark完毕后很久才触发sweeping动作。对于这种状况，可通过设置-XX:CMSMaxAbortablePrecleanTime=5（单位为ms）来避免。  
    4. 统计得到的Minor GC晋升到旧生代的平均大小大于旧生代的剩余空间  
    这是一个较为复杂的触发情况，Hotspot为了避免由于新生代对象晋升到旧生代导致旧生代空间不足的现象，在进行Minor GC时，做了一个判断，如果之前统计所得到的Minor GC晋升到旧生代的平均大小大于旧生代的剩余空间，那么就直接触发Full GC。  
    例如程序第一次触发MinorGC后，有6MB的对象晋升到旧生代，那么当下一次Minor GC发生时，首先检查旧生代的剩余空间是否大于6MB，如果小于6MB，则执行Full GC。  
    当新生代采用PSGC时，方式稍有不同，PS GC是在Minor GC后也会检查，例如上面的例子中第一次Minor GC后，PS GC会检查此时旧生代的剩余空间是否大于6MB，如小于，则触发对旧生代的回收。  

    除了以上4种状况外，对于使用RMI来进行RPC或管理的Sun JDK应用而言，默认情况下会一小时执行一次Full GC。可通过在启动时通过- java-Dsun.rmi.dgc.client.gcInterval=3600000来设置Full GC执行的间隔时间或通过-XX:+ DisableExplicitGC来禁止RMI调用System.gc。

## 4.3. Stop the world  
&emsp; Java中Stop-The-World机制简称STW，是在执行垃圾收集时，Java应用程序的其他所有线程都被挂起（除了垃圾收集帮助器之外）。Java中一种全局暂停现象，全局停顿，所有Java代码停止，native代码可以执行，但不能与JVM交互；这些现象多半是由于gc引起。  
&emsp; GC时的Stop the World(STW)是Java开发最大的敌人。但可能很多人还不清楚，除了GC，JVM下还会发生停顿现象。  
&emsp; JVM里有一条特殊的线程－－VM Threads，专门用来执行一些特殊的VM Operation，比如分派GC，thread dump等，这些任务都需要整个Heap，以及所有线程的状态是静止的，一致的才能进行。所以JVM引入了安全点(Safe Point)的概念，想办法在需要进行VM Operation时，通知所有的线程进入一个静止的安全点。  

&emsp; 除了GC，其他触发安全点的VM Operation包括：  
1. JIT相关，比如Code deoptimization, Flushing code cache ；  
2. Class redefinition (e.g. javaagent，AOP代码植入的产生的instrumentation) ；  
3. Biased lock revocation 取消偏向锁 ；  
4. Various debug operation (e.g. thread dump or deadlock check)；  


----
# 5. 方法区(类和常量)回收(类的卸载阶段)
&emsp; 永久代中回收的内容主要是两部分：废弃的常量和无用的类。  
&emsp; 类的卸载阶段，判断无用的类必须满足三个条件：  

* 该类所以的实例都已经被回收  
* 加载该类的ClassLoader被回收  
* 该类对应的java.lang.Class对象没有在任何地方引用，无法在任何地方通过反射访问该类的方法  

&emsp; 虚拟机可以对上述3个条件对无用类进行回收，这里说的仅仅是“可以”，而不是和对象一样不使用了就会必然回收。  

    如果以上三个条件全部满足，<font color = "lime">jvm会在方法区垃圾回收的时候对类进行卸载</font>，<font color = "red">类的卸载过程其实就是在方法区中清空类信息，java类的整个生命周期就结束了。</font>  


 &emsp; 如何判断⼀个常量是废弃常量?   

