

<!-- TOC -->

- [1. 行为型设计模式](#1-行为型设计模式)
    - [1.1. 策略（Strategy）模式](#11-策略strategy模式)
    - [1.2. 模板方法（Template Method）模式](#12-模板方法template-method模式)
    - [1.3. 观察者（Observer）模式](#13-观察者observer模式)
    - [1.4. 职责链（Chain of Responsibility）模式](#14-职责链chain-of-responsibility模式)
        - [1.4.1. 责任链模式和建造者模式](#141-责任链模式和建造者模式)
    - [1.5. 命令（Command）模式](#15-命令command模式)
    - [1.6. 备忘录（Memento）模式](#16-备忘录memento模式)
    - [1.7. 状态（State）模式](#17-状态state模式)
    - [1.8. 中介者（Mediator）模式](#18-中介者mediator模式)
    - [1.9. 访问者（Visitor）模式](#19-访问者visitor模式)
    - [1.10. 解释器（Interpreter）模式](#110-解释器interpreter模式)
    - [1.11. 迭代器（Iterator）模式](#111-迭代器iterator模式)

<!-- /TOC -->

# 1. 行为型设计模式
## 1.1. 策略（Strategy）模式  
&emsp; 策略模式，它是将定义的算法家族分别封装起来，让它们之间可以互相替换，从而让算法的变化不会影响到使用算法的用户。  
&emsp; <font color = "red">策略模式使用的是面向对象的继承和多态机制</font>，从而实现同一行为在不同场景下具备不同实现。 

&emsp; **使用场景：**策略模式可以解决在有多种算法相似的情况下，使用if...else或switch...case所带来的复杂性和臃肿性。在日常业务开发中，策略模式适用以下场景：  
1. 针对同一类型问题，有多种处理方式，每一种都能独立解决问题；  
2. 算法需要自由切换的场景；  
3. 需要屏蔽算法规则的场景。  

&emsp; 注意事项：如果一个系统的策略多于四个，就需要考虑使用混合模式，解决策略类膨胀的问题。  

&emsp; **<font color = "red">策略模式在框架中的使用：JDK中比较器Comparator 接口、Spring的Resource 类、Spring 的初始化也采用了策略模式，不同的类型的类采用不 同的初始化策略。</font>**  

&emsp; **优点：**  
1. 策略模式符合开闭原则。  
2. 避免使用多重条件转移语句，如if...else...语句、switch语句。  
3. 使用策略模式可以提高算法的保密性和安全性。  

&emsp; **缺点：**  
1. 客户端必须知道所有的策略，并且自行决定使用哪一个策略类。  
2. 代码中会产生非常多策略类，增加维护难度。  

&emsp; **模式角色组成：**  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/design/design-14.png)  

* Strategy：抽象策略类，定义所有支持的算法的公共接口。     
* ConcreteStrategy：具体策略类，包装了相关的算法或行为。  
* Context：环境类，用一个ConcreteStrategy对象来配置。维护一个对Strategy对象的引用。可定义一个接口来让Strategy访问它的数据。  

## 1.2. 模板方法（Template Method）模式  
&emsp; 模板方法模式定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。  
&emsp; 模版方法模式实际上是封装了一个固定流程，该流程由几个步骤组成，具体步骤可以由子类进行不同实现，从而让固定的流程产生不同的结果。它非常简单，其实就是类的继承机制，但它却是一个应用非常广泛但模式。模版方法模式的本质是抽象封装流程，具体进行实现。  

&emsp; **使用场景：**  
1. 一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现。  
2. 各子类中公共的行为被提取出来并集中到一个公共的父类中，从而避免代码重复。  

&emsp; **优点：**  
1. 利用模板方法将相同处理逻辑的代码放到抽象父类中，可以提高代码的复用性。 
2. 将不同的代码不同的子类中，通过对子类的扩展增加新的行为，提高代码的扩展性。 
3. 把不变的行为写在父类上，去除子类的重复代码，提供了一个很好的代码复用平台， 符合开闭原则。 

&emsp; **缺点：**  
1. 类数目的增加，每一个抽象类都需要一个子类来实现，这样导致类的个数增加。 
2. 类数量的增加，间接地增加了系统实现的复杂度。 
3. 继承关系自身缺点，如果父类添加新的抽象方法，所有子类都要改一遍。


&emsp; **模式角色组成：**  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/design/design-15.png)  

* Abstract：抽象模板角色，定义并实现了一个模板方法。这个模板方法一般是一个具体方法，它给出了一个顶级逻辑的骨架，而逻辑的组成步骤在相应的抽象操作中，推迟到子类实现。顶级逻辑也有可能调用一些具体方法。  

        模板方法中的方法可以分为两大类：模板方法和基本方法。
        模板方法：一个模板方法是定义在抽象类中的，把基本操作方法组合在一起形成一个总算法或一个总行为的方法。一个抽象类可以有任意多个模板方法，而不限于一个。每一个模板方法都可以调用任意多个具体方法。  
        基本方法：基本方法又可以分为三种：抽象方法(Abstract Method)、具体方法(Concrete Method)和钩子方法(Hook Method)。  
        　　●　抽象方法：一个抽象方法由抽象类声明，由具体子类实现。在Java语言里抽象方法以abstract关键字标示；  
        　　●　具体方法：一个具体方法由抽象类声明并实现，而子类并不实现或置换。  
        　　●　钩子方法：一个钩子方法由抽象类声明并实现，而子类会加以扩展。通常抽象类给出的实现是一个空实现，作为方法的默认实现。  
        　　默认钩子方法：一个钩子方法常常由抽象类给出一个空实现作为此方法的默认实现。这种空的钩子方法叫做“Do Nothing Hook”。显然，这种默认钩子方法在缺省适配模式里面已经见过了，一个缺省适配模式讲的是一个类为一个接口提供一个默认的空实现，从而使得缺省适配类的子类不必像实现接口那样必须给出所有方法的实现，因为通常一个具体类并不需要所有的方法。  
        　　命名规则：钩子方法的名字应当以do开始。  

* Concrete：每一个抽象模板角色都可以有任意多个具体模板角色与之对应，而每一个具体模板角色都可以给出这些抽象方法（也就是顶级逻辑的组成步骤）的不同实现，从而使得顶级逻辑的实现各不相同。  
 
## 1.3. 观察者（Observer）模式  
&emsp; 观察者模式（Observer Pattern） ，又叫发布-订阅模式。定义一种一对多的依赖关系，一个主题对象可被多个观察者对象同时监听，使得每当主题对象状态变化时，所有依赖于它的对象都会得到通知并被自动更新。  
&emsp; 观察者模式的核心是将观察者与被观察者接耦，以类似于消息/广播发送的机制联动两者，使被观察者的变动能通知到感兴趣的观察者们，从而做出相应的响应。  

&emsp; **使用场景：**  
1. 当一个抽象模型包含两个方面内容，其中一个方面依赖于另一个方面；  
2. 其他一个或多个对象的变化依赖于另一个对象的变化；  
3. 实现类似广播机制的功能，无需知道具体收听者，只需分发广播，系统中感兴趣的对象自动接收该广播；  
4. 多层级嵌套使用，形成一种链式触发机制，使得事件具备跨域（跨越两种观察者类型）通知。  

&emsp; **<font color = "red">Spring 中的 ContextLoaderListener 实现了 ServletContextListener 接口， ServletContextListener 接口又继承了 EventListener。EventListener就是典型的观察者模式接口。</font>**  

&emsp; **优点：**  
1. 观察者和被观察者之间建立了一个抽象的耦合。
2. 观察者模式支持广播通信。

&emsp; **缺点：**
1. 观察者之间有过多的细节依赖、提高时间消耗及程序的复杂度。
2. 使用要得当，要避免循环调用。

&emsp; **模式角色组成：**  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/design/design-16.png)  

* Subject：抽象被观察者角色，也就是一个抽象主题，它把所有对观察者对象的引用保存在一个集合中，每个主题都可以有任意数量的观察者。抽象主题提供一个接口，可以增加和删除观察者角色。一般用一个抽象类和接口来实现。
* ConcreteSubject：具体被观察者角色，也就是一个具体的主题，在集体主题的内部状态改变时，所有登记过的观察者发出通知。
* Observer：抽象观察者角色，为所有的具体观察者定义一个接口，在得到主题通知时更新自己。
* ConcreteObserver：具体观察者角色，实现抽象观察者角色所需要的更新接口，一边使本身的状态与制图的状态相协调。

## 1.4. 职责链（Chain of Responsibility）模式  
&emsp; 责任链模式是将链中每一个节点看作是一个对象，每个节点处理的请求均不同，且内部自动维护一个下一节点对象。当一个请求从链式的首端发出时，会沿着链的路径依次传递给每一个节点对象，直至有对象处理这个请求为止。  
&emsp; 责任链模式的本质是解耦请求于处理，让请求在处理链中能进行传递与被处理。责任链模式的独到之处是其将节点处理者组合成链链式结构，并允许节点自身决定是否进行请求处理或转发，相当于请求流动链起来。  

&emsp; **适用场景：**  
&emsp; 责任链模式主要是解耦了请求与处理，客户只需将请求发送到链上即可，无需关心请求的具体内容和处理细节，请求会自动进行传递直至有节点对象进行处理。适用于以下应用场景：  
1. 多个对象可以处理同一请求，但具体由哪个对象处理则在运行时动态决定；
2. 在不明确指定接收者但情况下，向多个对象中的一个提交一个请求；
3. 可动态指定一组对象处理请求。  

&emsp; **<font color = "red">servlet中的filter、mybatis中的plugin、dubbo中的filter都使用了责任链模式。</font>**  

&emsp; **优点：**  
1. 将请求与处理接耦；  
2. 请求处理者（节点对象）只需关注自己感兴趣的请求进行处理即可，对于不感兴趣的请求，直接转发给下一级节点对象；  
3. 具备链式传递处理请求功能，请求发送者无需知晓链路结构，只需等待请求处理结果；  
4. 链路结构灵活，可以通过改变链路结构动态地新增或删减责任；  
5. 易于扩展新地请求处理类（节点），符合开闭原则。  

&emsp; **缺点：**  
1. 责任链太长或者处理时间过长，会影响整体性能。  
2. 如果节点对象存在循环引用时，会造成死循环，导致系统崩溃。  

&emsp; **模式角色组成：**  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/design/design-17.png)  

* 抽象处理者(Handler)角色：定义出一个处理请求的接口。如果需要，接口可以定义 出一个方法以设定和返回对下家的引用。这个角色通常由一个Java抽象类或者Java接口实现。Handler类的聚合关系给出了具体子类对下家的引用，抽象方法handleRequest()规范了子类处理请求的操作。  
* 具体处理者(ConcreteHandler)角色：具体处理者接到请求后，可以选择将请求处理掉，或者将请求传给下家。由于具体处理者持有对下家的引用，因此，如果需要，具体处理者可以访问下家。  

### 1.4.1. 责任链模式和建造者模式  
&emsp; 链式结构组装复杂时，可以结合建造者模式。  


## 1.5. 命令（Command）模式  
......

## 1.6. 备忘录（Memento）模式  
......

## 1.7. 状态（State）模式  
......

## 1.8. 中介者（Mediator）模式  
......

## 1.9. 访问者（Visitor）模式  
......

## 1.10. 解释器（Interpreter）模式  
......

## 1.11. 迭代器（Iterator）模式  
......

