
<!-- TOC -->

- [1. 原型模式](#1-原型模式)
    - [1.1. 简介](#11-简介)
    - [1.2. 结构](#12-结构)
    - [1.3. Object#clone()方法实现浅克隆](#13-objectclone方法实现浅克隆)
    - [1.4. 使用序列化实现深克隆](#14-使用序列化实现深克隆)
    - [1.5. 克隆破坏单例模式](#15-克隆破坏单例模式)

<!-- /TOC -->


&emsp; 克隆的结果有2种，一种是浅复制，另一种是深复制。  

* 浅复制: 对值类型的成员变量进行值的复制，对引用类型的成员变量只复制引用，不复制引用的对象。  
* 深复制:  **<font color = "clime">对值类型的成员变量进行值的复制，对引用类型的成员变量也进行引用对象的复制。</font>**  


# 1. 原型模式 
## 1.1. 简介 
&emsp; 原型模式，通过克隆一个已经存在的实例来返回新的实例，而不是新建实例。被复制的实例就是所称的“原型”，这个原型是可定制的。  
&emsp; 原型模式的核心在于拷贝原型对象。以系统中已存在的一个对象为原型，直接基于内存二进制流进行拷贝，无需再经历耗时的对象初始化过程(不调用构造函数)，性能提升许多。当对象的构建过程比较耗时时，可以利用当前系统中已存在的对象作为原型，对其进行克隆(一般是基于二进制流的复制)，躲避初始化过程，使得新对象的创建时间大大减少。  
&emsp; 克隆的结果有2种，一种是浅复制，另一种是深复制。  

* 浅复制: 对值类型的成员变量进行值的复制，对引用类型的成员变量只复制引用，不复制引用的对象。  
* 深复制:  **<font color = "clime">对值类型的成员变量进行值的复制，对引用类型的成员变量也进行引用对象的复制。</font>**  

&emsp; **适用场景：**
1. 类初始化消耗资源较多。
2. new产生的一个对象需要非常繁琐的过程(数据准备、访问权限等)。
3. 构造函数比较复杂。
4. 循环体中生产大量对象时。

&emsp; **<font color = "clime">在Spring中，原型模式应用得非常广泛，例如 scope=“prototype”。JSON.parseObject()也是一种原型模式。</font>**  

&emsp; **原型模式的优点：**  
1. 性能优良，Java自带的原型模式是基于内存二进制流的拷贝，比直接new一个对象性能上提升了许多。  
2. 可以使用深克隆方式保存对象的状态，使用原型模式将对象复制一份并将其状态保存起来，简化了创建对象的过程，以便在需要的时候使用(例如恢复到历史某一状态)，可辅助实现撤销操作。  

&emsp; **原型模式的缺点：**  
1. 需要为每一个类配置一个克隆方法。  
2. 克隆方法位于类的内部，当对已有类进行改造的时候，需要修改代码，违反了开闭原则。  
3. 在实现深克隆时需要编写较为复杂的代码，而且当对象之间存在多重嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现起来会比较麻烦。因此，深拷贝、浅拷贝需要运用得当。  

## 1.2. 结构  
&emsp; **模式角色组成：**  
![image](http://www.wt1814.com/static/view/images/java/design/design-8.png)  

* Prototype：抽象原型类。声明克隆自身的接口。 
* ConcretePrototype：具体原型类。实现克隆的具体操作。它是可被复制的对象。 
* Client：客户类。让一个原型克隆自身，从而获得一个新的对象。

## 1.3. Object#clone()方法实现浅克隆  
&emsp; Java 中的 Object 类提供了浅克隆的 clone() 方法，具体原型类只要实现 Cloneable 接口就可实现对象的浅克隆，这里的 Cloneable 接口就是抽象原型类。  

## 1.4. 使用序列化实现深克隆


## 1.5. 克隆破坏单例模式  
&emsp; 如果克隆的目标的对象是单例对象，那意味着，深克隆就会破坏单例。实际上防止克隆破坏单例解决思路非常简单，禁止深克隆便可。要么单例类不实现Cloneable 接口；要么重写 clone()方法，在 clone 方法中返回单例对象即可，具体代码如下：

```java
@Override
protected Object clone() throws CloneNotSupportedException {
    return INSTANCE;
}
```
