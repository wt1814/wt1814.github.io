

&emsp; &emsp; [适配器模式](/docs/java/Design/adapter.md)   
&emsp; &emsp; [代理模式](/docs/java/Design/proxy.md)   
&emsp; &emsp; &emsp; [动态编程](/docs/java/Design/DynamicProgramming.md)  
&emsp; &emsp; &emsp; [JDK动态代理](/docs/java/Design/DynamicProxy.md)   
&emsp; &emsp; &emsp; [CGLIB代理](/docs/java/Design/CGLIB.md)   
&emsp; &emsp; [装饰器模式](/docs/java/Design/decorator.md)  
&emsp; &emsp; [桥接模式(if/else)](/docs/java/Design/Bridge.md)  
&emsp; &emsp; [外观模式/门面模式](/docs/java/Design/facade.md)   
&emsp; &emsp; [享元模式(池化技术)](/docs/java/Design/Enjoy.md)  

<!-- 
适配器模式和装饰器模式有什么区别？
虽然适配器模式和装饰器模式的结构类似，   但是每种模式的出现意图不同。适配器模式被用于桥接两个接口， 而装饰模式的目的是在不修改类的情况下给类增加新的功能。

适配器模式和代理模式之前有什么不同？
这个问题与前面的类似，   适配器模式和代理模式的区别在于他们的意图不同。由于适配器模式和代理模式都是封装真正执行动作的类， 因此结构是一致的， 但是适配器模式用于接口之间的转换， 而代理模式则是增加一个额外的中间层， 以便支持分配、控制或智能访问。
-->

