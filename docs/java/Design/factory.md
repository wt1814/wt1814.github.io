
<!-- TOC -->

- [1. 工厂模式](#1-工厂模式)
    - [1.1. 简单工厂模式](#11-简单工厂模式)
    - [1.2. 工厂方法模式](#12-工厂方法模式)
    - [1.3. 抽象工厂模式](#13-抽象工厂模式)

<!-- /TOC -->

# 1. 工厂模式
## 1.1. 简单工厂模式


## 1.2. 工厂方法模式  
<!-- 

理解多态与工厂模式
https://blog.csdn.net/yongwan5637/article/details/80459881
-->
&emsp; **定义：** 工厂方法模式，定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。  
&emsp; **适用场景：**  
1. 创建对象需要大量重复的代码。
2. 客户端（应用层）不依赖于产品类实例如何被创建、实现等细节。
3. 一个类通过其子类来指定创建哪个对象。

&emsp; **工厂方法的缺点：**  
1. 类的个数容易过多，增加复杂度。
2. 增加了系统的抽象性和理解难度。

&emsp; **模式角色组成：**  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/design/design-4.png)  

* AbstractFactory，抽象工厂角色，这是工厂方法模式的核心。  
* ConcreateFactory1，具体工厂角色，它含有和具体业务逻辑有关的代码。由应用程序调用以创建对应的具体产品的对象。   
* Product，抽象产品角色。  
* ConcreateProduct1，具体产品角色，具体工厂角色所创建的对象就是此角色的实例。  

## 1.3. 抽象工厂模式  
&emsp; **定义：** 为创建一组相关或相互依赖的对象提供一个接口，而且无须指定它们的具体类。客户端（应用层）不依赖于产品类实例如何被创建、实现等细节，强调的是一系列相关的产品对象（属于同一产品族）一起使用创建对象需要大量重复的代码。需要提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。  

&emsp; 详细讲解两个概念：**产品等级结构和产品族。**  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/design/design-5.png)  
&emsp; 从上图中看出有正方形，圆形和菱形三种图形，相同颜色深浅的就代表同一个产品族，相同形状的代表同一个产品等级结构。  

&emsp; 同样可以从生活中来举例，比如，美的电器生产多种家用电器。那么上图中，颜色最深的正方形就代表美的洗衣机、颜色最深的圆形代表美的空调、颜色最深的菱形代表美的热水器，颜色最深的一排都属于美的品牌，都是美的电器这个产品族。再看最右侧的菱形，颜色最深的指定了代表美的热水器，那么第二排颜色稍微浅一点的菱形，代表海信的热水器。同理，同一产品结构下还有格力热水器，格力空调，格力洗衣机。  
&emsp; 再看下面的这张图，最左侧的小房子就认为具体的工厂，有美的工厂，有海信工厂，有格力工厂。每个品牌的工厂都生产洗衣机、热水器和空调。  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/design/design-6.png)  

&emsp; **抽象工厂的缺点：**  
1. 规定了所有可能被创建的产品集合，产品族中扩展新的产品困难，需要修改抽象工厂的接口。
2. 增加了系统的抽象性和理解难度。

&emsp; **模式角色组成：**  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/design/design-7.png)  

* AbstractFactory，提供创建对象的接口。  
* ConcreteFactory，提供真正创建对象的实现类，组合并创建不同的对象，实现一个产品族。  
* AbstractProduct，提供对象的使用接口。  
* ConcreteProduct，提供真正的适用对象，隐藏该对象的创建过程，是工厂创建的对象。  
* Client，使用者，通过抽象工厂接口，使用不同的具体工厂方法创建对象组合，从而直接使用对象，无需关注对象的创建过程。  
