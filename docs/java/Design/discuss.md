
<!-- TOC -->

- [1. 设计模式讨论](#1-设计模式讨论)
    - [1.1. 创建型模式讨论](#11-创建型模式讨论)
        - [1.1.1. 工厂方法模式VS建造者模式](#111-工厂方法模式vs建造者模式)
    - [1.2. 结构型模式的讨论](#12-结构型模式的讨论)
        - [1.2.1. 代理模式VS装饰模式](#121-代理模式vs装饰模式)
        - [1.2.2. 装饰模式VS适配器模式](#122-装饰模式vs适配器模式)
    - [1.3. 行为型模式的讨论](#13-行为型模式的讨论)
        - [1.3.1. 命令模式VS策略模式](#131-命令模式vs策略模式)
        - [1.3.2. 状态模式与策略模式区别](#132-状态模式与策略模式区别)
    - [1.4. ~~跨战区PK~~](#14-跨战区pk)
        - [1.4.1. 多态、策略模式和简单工厂模式的理解](#141-多态策略模式和简单工厂模式的理解)
        - [1.4.2. 门面模式VS中介者模式](#142-门面模式vs中介者模式)

<!-- /TOC -->

&emsp; **<font color = "red">总结：</font>**  
1. 多态、策略模式和简单工厂模式：策略模式和简单工厂模式看起来非常相似，都是通过多态来实现不同子类的选取。策略模式使用前需要知道具体某一个对象，简单工厂则是通过条件创造对象，两者都是通过多态调用具体算法。  

# 1. 设计模式讨论
&emsp; **<font color = "red">参考《设计模式之蝉》</font>**  

<!-- 
 设计模式在工作中的实践 
 https://mp.weixin.qq.com/s/KOyqcPS2T-IR2kuManDPEw
-->

## 1.1. 创建型模式讨论  
### 1.1.1. 工厂方法模式VS建造者模式
&emsp; **<font color = "red">工厂方法模式注重的是整体对象的创建方法，而建造者模式注重的是部件构建的过程，旨在通过一步一步地精确构造创建出一个复杂的对象。</font>** 举个简单例子来说明两者的差异，如要制造一个超人，如果使用工厂方法模式，直接产生出来的就是一个力大无穷、能够 飞翔、内裤外穿的超人；而如果使用建造者模式，则需要组装手、头、脚、躯干等部分，然后再把内裤外穿，于是一个超人就诞生了。  

## 1.2. 结构型模式的讨论
### 1.2.1. 代理模式VS装饰模式  
&emsp; 对于两个模式，首先要说的是，装饰模式就是代理模式的一个特殊应用，两者的共同点是都具有相同的接口， **<font color = "red">不同点则是代理模式着重对代理过程的控制，而装饰模式则是对类的功能进行加强或减弱，它着重类的功能变化。</font>**   
&emsp; 代理模式和装饰模式有非常相似的地方，甚至代码实现都非常相似，特别是装饰模式中省略抽象装饰角色后，两者代码基本上相同，但是还是有细微的差别。  

* 代理模式是把当前的行为或功能委托给其他对象执行，<font color = "clime">代理类负责接口限定：是否可以调用真实角色，以及是否对发送到真实角色的消息进行变形处理，它不对被主题角色(也就是被代理类)的功能做任何处理，保证原汁原味的调用。</font>  
* 装饰模式是在要保证接口不变的情况下加强类的功能，它保证的是被修饰的对象功能比原始对象丰富(当然，也可以减弱)，但不做准入条件判断和准入参数过滤，如是否可以执行类的功能，过滤输入参数是否合规等，这不是装饰模式关心的。  

### 1.2.2. 装饰模式VS适配器模式  
&emsp; 装饰模式和适配器模式在通用类图上没有太多的相似点，差别比较大，但是它们的功能有相似的地方：都是包装作用，都是通过委托方式实现其功能。不同点是：<font color = "clime">装饰模式包装的是自己的兄弟类，隶属于同一个家族(相同接口或父类)，</font><font color = "red">适配器模式则修饰非血缘关系类，把一个非本家族的对象伪装成本家族的对象，注意是伪装，因此它的本质还是非相同接口的对象。</font>  

&emsp; 这两个模式有较多的不同点：  
* 意图不同  
&emsp; 装饰模式的意图是加强对象的功能，例子中就是把一个怯弱的小天鹅强化成了一个美丽、自信的白天鹅，它不改变类的行为和属性，只是增加(当然了，减弱类的功能也是可能存在的)功能，使美丽更加美丽，强壮更加强壮，安全更加安全；而适配器模式关注的则是转化，它的主要意图是两个不同对象之间的转化，它可以把一个天鹅转化为一个小鸭子看待，也可以把一只小鸭子看成是一只天鹅(那估计要在小鸭子的背上装个螺旋桨了)，它关注转换。
* 施与对象不同  
&emsp; 装饰模式装饰的对象必须是自己的同宗，也就是相同的接口或父类，只要在具有相同属性和行为的情况下，才能比较行为是增加还是减弱；适配器模式则必须是两个不同的对象，因为它着重于转换，只有两个不同的对象才有转换的必要，如果是相同对象还转换什么！
* 场景不同  
&emsp; 装饰模式在任何时候都可以使用，只要是想增强类的功能，而适配器模式则是一个补救模式，一般出现在系统成熟或已经构件完毕的项目中，作为一个紧急处理手段采用。
* 扩展性不同  
&emsp; 装饰模式很容易扩展！今天不用这个修饰，好，去掉；明天想再使用，好，加上。这都没有问题。而且装饰类可以继续扩展下去；但是适配器模式就不同了，它在两个不同对象之间架起了一座沟通的桥梁，建立容易，去掉就比较困难了，需要从系统整体考虑是否能够撤销。  

## 1.3. 行为型模式的讨论
### 1.3.1. 命令模式VS策略模式  
&emsp; 命令模式和策略模式的类图确实很相似，只是命令模式多了一个接收者(Receiver)角色。它们虽然同为行为类模式，但是两者的区别还是很明显的。策略模式的意图是封装算 法，它认为“算法”已经是一个完整的、不可拆分的原子业务(注意这里是原子业务，而不是原子对象)，即其意图是让这些算法独立，并且可以相互替换，让行为的变化独立于拥有行为的客户；而命令模式则是对动作的解耦，把一个动作的执行分为执行对象(接收者角色)、执行行为(命令角色)，让两者相互独立而不相互影响。  

### 1.3.2. 状态模式与策略模式区别  
&emsp; **策略模式结构图：** 
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/design/design-19.png)  
&emsp; **状态模式结构图：**  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/design/design-20.png)  

&emsp; 1、状态模式重点在各状态之间的切换从而做不同的事情，而策略模式更侧重于根据具体情况选择策略，并不涉及切换。  
&emsp; 2、状态模式不同状态下做的事情不同，而策略模式做的都是同一件事，例如聚合支付平台，有支付宝、微信支付、银联支付，虽然策略不同，但最终做的事情都是支付，也就是说它们之间是可替换的。反观状态模式，各个状态的同一方法做的是不同的事，不能互相替换。  
&emsp; 状态模式封装了对象的状态，而策略模式封装算法或策略。因为状态是跟对象密切相关的，它不能被重用；而通过从Context中分离出策略或算法，可以重用它们。  
&emsp; 在状态模式中，每个状态通过持有Context的引用，来实现状态转移；但是每个策略都不持有Context的引用，它们只是被Context使用。  

## 1.4. ~~跨战区PK~~  
&emsp; 创建类模式描述如何创建对象，行为类模式关注如何管理对象的行为，结构类模式则着 重于如何建立一个软件结构，虽然三种模式的着重点不同，但是在实际应用中还是有重叠 的，会出现一种模式适用、另外一种模式也适用的情况。  

### 1.4.1. 多态、策略模式和简单工厂模式的理解  
<!--
https://blog.csdn.net/Andy_93/article/details/54017349
-->
&emsp; 多态、策略模式和简单工厂模式：  

* 多态：C++的多态性用一句话概括就是，在基类的函数前加上virtual关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数。如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数。  
* 策略模式：定义了实现，用接口来封装起来，通过构造器的构造参数不同使得实现有所不同。  
* 简单工厂模式：定义了实现，用接口来封装起来，由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类（这些产品类继承自一个父类或接口）的实例。  


&emsp; 策略模式和简单工厂模式看起来非常相似，都是通过多态来实现不同子类的选取。如果从使用这两种模式的角度来看的话，会发现在简单工厂模式中我们只需要传递相应的条件就能得到想要的一个对象，然后通过这个对象实现算法的操作。而策略模式，使用时必须首先创建一个想使用的类对象，然后将该对象最为参数传递进去，通过该对象调用不同的算法。在简单工厂模式中实现了通过条件选取一个类去实例化对象，策略模式则将选取相应对象的工作交给模式的使用者，它本身不去做选取工作。简单理解为策略模式使用前需要知道具体某一个对象，简单工厂则是通过条件创造对象，两者都是通过多态调用具体算法。  


### 1.4.2. 门面模式VS中介者模式
&emsp; 门面模式为复杂的子系统提供一个统一的访问界面，它定义的是一个高层接口，该接口使得子系统更加容易使用，避免外部模块深入到子系统内部而产生与子系统内部细节耦合的 问题。中介者模式使用一个中介对象来封装一系列同事对象的交互行为，它使各对象之间不 再显式地引用，从而使其耦合松散，建立一个可扩展的应用架构。  
&emsp; 门面模式和中介者模式之间的区别还是比较明显的，门面模式是以封装和隔离为主要任 务，而中介者模式则是以调和同事类之间的关系为主，因为要调和，所以具有了部分的业务 逻辑控制。两者的主要区别如下：   
* 功能区别  
&emsp; 门面模式只是增加了一个门面，它对子系统来说没有增加任何的功能，子系统若脱离门 面模式是完全可以独立运行的。而中介者模式则增加了业务功能，它把各个同事类中的原有耦合关系移植到了中介者，同事类不可能脱离中介者而独立存在，除非是想增加系统的复杂 性和降低扩展性。  
* 知晓状态不同  
&emsp; 对门面模式来说，子系统不知道有门面存在，而对中介者来说，每个同事类都知道中介者存在，因为要依靠中介者调和同事之间的关系，它们对中介者非常了解。  
* 封装程度不同  
&emsp; 门面模式是一种简单的封装，所有的请求处理都委托给子系统完成，而中介者模式则需要有一个中心，由中心协调同事类完成，并且中心本身也完成部分业务，它属于更进一步的 业务功能封装。  

