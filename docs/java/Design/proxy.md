
<!-- TOC -->

- [1. 代理](#1-代理)
    - [1.1. 代理模式简介](#11-代理模式简介)
    - [1.2. 静态代理](#12-静态代理)
    - [1.3. 动态代理](#13-动态代理)

<!-- /TOC -->

# 1. 代理  
<!-- 
动态代理竟然如此简单
https://mp.weixin.qq.com/s/7YYcSkdhJMrvD9We9dsMNA
超全MyBatis动态代理详解！
https://mp.weixin.qq.com/s/RjRzacdmx3DMHlhjj1GM3g
-->

## 1.1. 代理模式简介  
&emsp; 代理模式，是指为其他对象提供一种代理，以控制对这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。使用代理模式主要有两个目的：一保护目标对象，二增强目标对象。  

&emsp; <font color = "red">代理设计模式，提供了对目标对象另外的访问方式；即通过代理访问目标对象。</font>代理好处：可以在目标对象实现的基础上，增强额外的功能操作(扩展目标对象的功能)。  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/SSM/AOP/AOP-1.png)  

## 1.2. 静态代理  

## 1.3. 动态代理 
<!-- 


&emsp; 动态代理技术：  
&emsp; 代理类在程序运行时创建的代理方式被认为动态代理。在了解动态代理之前, 先回顾一下JVM的类加载机制中的加载阶段要做的三件事情：  
1. 通过一个类的全名或其它途径来获取这个类的二进制字节流；  
2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构；  
3. 在内存中生成一个代表这个类的Class对象, 作为方法区中对这个类访问的入口。  

&emsp; **动态代理，主要就发生在第一个阶段, 这个阶段类的二进制字节流的来源可以有很多, 比如zip包、网络、运行时计算生成、其它文件生成 (JSP)、数据库获取。**其中运行时计算生成就是所说的动态代理技术，在Proxy类中, 就是运用了ProxyGenerator，generateProxyClass来为特定接口生成形式为 *$Proxy 的代理类的二进制字节流。所谓的动态代理就是想办法根据接口或者目标对象计算出代理类的字节码然后加载进JVM 中。实际计算的情况会很复杂，可以借助一些诸如JDK动态代理实现、CGLIB第三方库来完成的。 
-->
