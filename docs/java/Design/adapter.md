
<!-- TOC -->

- [1. 适配器(Adapter)模式](#1-适配器adapter模式)
    - [1.1. 简介](#11-简介)
    - [1.2. 结构](#12-结构)
    - [1.3. 类适配器模式与对象适配器模式](#13-类适配器模式与对象适配器模式)
        - [1.3.1. 对象适配器模式](#131-对象适配器模式)
        - [1.3.2. 类适配器模式](#132-类适配器模式)
        - [1.3.3. 类适配器模式和对象适配器模式区别](#133-类适配器模式和对象适配器模式区别)
    - [1.4. 接口适配器模式](#14-接口适配器模式)

<!-- /TOC -->


&emsp; **<font color = "red">总结：</font>**  
1. 平时开发中，面向接口编程，注入其他类，从而进行调用。  
&emsp; 适配器(Adapter)模式中，Adapter，适配器类，即实现目标接口Target，又继承Adaptee类。适配器模式的核心角色，其他两个角色都是已经存在的角色，而适配器角色是需要新建立的，它的职责非常简单：把源角色转换为目标角色。`转换的方式有：即能通过继承，又能通过类关联的方式。`  
2. **适配器模式有3种形式：类适配器、对象适配器、接口适配器。**  
    * `对象适配器（平时使用最多）`：不使用多继承或继承的方式，而是使用直接关联，或者称为委托的方式。  
    * 类适配器：Adapter类继承Adaptee（被适配类），同时实现Target接口（因为Java不支持多继承，所以只能通过接口的方法来实现多继承），在Client类中可以根据需要选择并创建任一种符合需求的子类，来实现具体功能。 
    * 接口适配器：通过抽象类来实现适配。即适配器类是一个抽象类。  
3. 适配的思想。  

# 1. 适配器(Adapter)模式  

## 1.1. 简介
&emsp; 适配器模式(Adapter Pattern)，将一个类的接口转换成客户端期望的另一种接口，从而使原本因接口不匹配而导致无法在一起工作的两个类能够一起工作。  

&emsp; **使用场景：**  
1. <font color = "clime">已经存在的类，它的方法和需求不匹配（方法结果相同或相似）的情况。</font>  
2. 适配器模式不是软件设计阶段考虑的设计模式，是随着软件维护，由于不同产品、不同厂家造成功能类似而接口不相同情况下的解决方案。  


&emsp; **比较形象的例子：**  
1. 用电器做例子，笔记本电脑的插头一般都是三相的，即除了阳极、阴极外，还有一个地极。而有些地方的电源插座却只有两极，没有地极。电源插座与笔记本电脑的电源插头不匹配使得笔记本电脑无法使用。这时候一个三相到两相的转换器（适配器）就能解决此问题，而这正像是本模式所做的事情。  
2. 有一个 MediaPlayer 接口和一个实现了 MediaPlayer 接口的实体类 AudioPlayer。默认情况下，AudioPlayer 可以播放 mp3 格式的音频文件。  
&emsp; 还有另一个接口 AdvancedMediaPlayer 和实现了 AdvancedMediaPlayer 接口的实体类。该类可以播放 vlc 和 mp4 格式的文件。  
&emsp; 想要让AudioPlayer播放其他格式的音频文件。为了实现这个功能，需要创建一个实现了MediaPlayer接口的适配器类MediaAdapter，并使用AdvancedMediaPlayer对象来播放所需的格式。  

&emsp; Mybatis日志的适配器，参考[MyBatis日志体系](/docs/SSM/MyBatis/MybatisLog.md)   

&emsp; **优点：**   
1. 能提高类的透明性和复用，现有的类复用但不需要改变。   
2. 目标类和适配器类解耦，提高程序的扩展性。   
3. 在很多业务场景中符合开闭原则。  

&emsp; **缺点：**   
1. 适配器编写过程需要全面考虑，可能会增加系统的复杂性。   
2. 增加代码阅读难度，降低代码可读性，过多使用适配器会使系统代码变得凌乱。  

## 1.2. 结构  
&emsp; **模式角色组成：**  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/design/design-13.png)  

* Target，目标接口，即期望转换成的接口。  
* Adaptee，现有类，源角色，它是已经存在的，运行良好的类或对象，经过适配器角色的包装，转换成目标接口。  
* Adapter，适配器类，即实现目标接口Target，又继承Adaptee类。适配器模式的核心角色，其他两个角色都是已经存在的角色，而适配器角色是需要新建立的，它的职责非常简单：把源角色转换为目标角色。`转换的方式有：即能通过继承，又能通过类关联的方式。`  

&emsp; **<font color = "clime">适配器模式有3种形式：类适配器、对象适配器、接口适配器。</font>**  


## 1.3. 类适配器模式与对象适配器模式  
<!-- 
https://blog.csdn.net/u012359453/article/details/79165080
https://blog.csdn.net/qq_36982160/article/details/79965027
-->

### 1.3.1. 对象适配器模式  
&emsp; 不使用多继承或继承的方式，而是使用直接关联，或者称为委托的方式。  

### 1.3.2. 类适配器模式
&emsp; Adapter类继承Adaptee（被适配类），同时实现Target接口（因为Java不支持多继承，所以只能通过接口的方法来实现多继承），在Client类中可以根据需要选择并创建任一种符合需求的子类，来实现具体功能。  

### 1.3.3. 类适配器模式和对象适配器模式区别
&emsp; 类适配器的重点在于类，是通过构造一个继承Adaptee类来实现适配器的功能；  
&emsp; 对象适配器的重点在于对象，是通过在直接包含Adaptee类来实现的，当需要调用特殊功能的时候直接使用Adapter中包含的那个Adaptee对象来调用特殊功能的方法即可。  

## 1.4. 接口适配器模式
<!-- 
https://blog.csdn.net/u012359453/article/details/79165080
https://www.cnblogs.com/mingmingcome/p/9810731.html

-->
&emsp; **<font color = "clime">原理：通过抽象类来实现适配。</font>**  
&emsp; 当存在这样一个接口，其中定义了N多的方法，而我们现在却只想使用其中的一个到几个方法，如果我们直接实现接口，那么我们要对所有的方法进行实现，哪怕我们仅仅是对不需要的方法进行置空（只写一对大括号，不做具体方法实现）也会导致这个类变得臃肿，调用也不方便，这时我们可以使用一个抽象类作为中间件，即适配器，用这个抽象类实现接口，而在抽象类中所有的方法都进行置空，那么我们在创建抽象类的继承类，而且重写我们需要使用的那几个方法即可。   

```java
package com.example.springboot.dto;

public interface A {
    void a0();
    void a1();
    void a2();
    void a3();
    void a4();
}
```

```java
/**
 * 接口适配器
 */
public abstract  class Adapter implements A {

    public void a0() {

    }

    public void a1() {

    }

    public void a2() {

    }

    public void a3() {

    }

    public void a4() {

    }
}
```

```java
public class B extends Adapter{

    public void a2() {
        super.a2();
    }
}
```
