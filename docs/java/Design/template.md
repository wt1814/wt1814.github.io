
<!-- TOC -->

- [1. 模板方法(Template Method)模式](#1-模板方法template-method模式)
    - [1.1. 简介](#11-简介)
    - [1.2. 结构](#12-结构)

<!-- /TOC -->

# 1. 模板方法(Template Method)模式  

## 1.1. 简介
&emsp; 模板方法模式定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。  
&emsp; 模版方法模式实际上是封装了一个固定流程，该流程由几个步骤组成，具体步骤可以由子类进行不同实现，从而让固定的流程产生不同的结果。它非常简单，其实就是类的继承机制，但它却是一个应用非常广泛的模式。模版方法模式的本质是抽象封装流程，具体进行实现。  

&emsp; **使用场景：**  
1. 一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现。  
2. 各子类中公共的行为被提取出来并集中到一个公共的父类中，从而避免代码重复。  

&emsp; **优点：**  
1. 利用模板方法将相同处理逻辑的代码放到抽象父类中，可以提高代码的复用性。 
2. 将不同的代码不同的子类中，通过对子类的扩展增加新的行为，提高代码的扩展性。 
3. 把不变的行为写在父类上，去除子类的重复代码，提供了一个很好的代码复用平台， 符合开闭原则。 

&emsp; **缺点：**  
1. 类数目的增加，每一个抽象类都需要一个子类来实现，这样导致类的个数增加。 
2. 类数量的增加，间接地增加了系统实现的复杂度。 
3. 继承关系自身缺点，如果父类添加新的抽象方法，所有子类都要改一遍。


## 1.2. 结构  
&emsp; **模式角色组成：**  
![image](http://www.wt1814.com/static/view/images/java/design/design-15.png)  

* Abstract：抽象模板角色，定义并实现了一个模板方法。这个模板方法一般是一个具体方法，它给出了一个顶级逻辑的骨架，而逻辑的组成步骤在相应的抽象操作中，推迟到子类实现。顶级逻辑也有可能调用一些具体方法。  

        模板方法中的方法可以分为两大类：模板方法和基本方法。
        模板方法：一个模板方法是定义在抽象类中的，把基本操作方法组合在一起形成一个总算法或一个总行为的方法。一个抽象类可以有任意多个模板方法，而不限于一个。每一个模板方法都可以调用任意多个具体方法。  
        基本方法：基本方法又可以分为三种：抽象方法(Abstract Method)、具体方法(Concrete Method)和钩子方法(Hook Method)。  
        　　●　抽象方法：一个抽象方法由抽象类声明，由具体子类实现。在Java语言里抽象方法以abstract关键字标示；  
        　　●　具体方法：一个具体方法由抽象类声明并实现，而子类并不实现或置换。  
        　　●　钩子方法：一个钩子方法由抽象类声明并实现，而子类会加以扩展。通常抽象类给出的实现是一个空实现，作为方法的默认实现。  
        　　默认钩子方法：一个钩子方法常常由抽象类给出一个空实现作为此方法的默认实现。这种空的钩子方法叫做“Do Nothing Hook”。显然，这种默认钩子方法在缺省适配模式里面已经见过了，一个缺省适配模式讲的是一个类为一个接口提供一个默认的空实现，从而使得缺省适配类的子类不必像实现接口那样必须给出所有方法的实现，因为通常一个具体类并不需要所有的方法。  
        　　命名规则：钩子方法的名字应当以do开始。  

* Concrete：每一个抽象模板角色都可以有任意多个具体模板角色与之对应，而每一个具体模板角色都可以给出这些抽象方法（也就是顶级逻辑的组成步骤）的不同实现，从而使得顶级逻辑的实现各不相同。  