
<!-- TOC -->

- [1. 策略(Strategy)模式](#1-策略strategy模式)
    - [1.1. 简介](#11-简介)
    - [1.2. 结构](#12-结构)

<!-- /TOC -->

# 1. 策略(Strategy)模式  
## 1.1. 简介
&emsp; 策略模式，它是将定义的算法家族分别封装起来，让它们之间可以互相替换，从而让算法的变化不会影响到使用算法的用户。  
&emsp; <font color = "red">策略模式使用的是面向对象的继承和多态机制</font>，从而实现同一行为在不同场景下具备不同实现。 

&emsp; **使用场景：**策略模式可以解决在有多种算法相似的情况下，使用if...else或switch...case所带来的复杂性和臃肿性。在日常业务开发中，策略模式适用以下场景：  
1. 针对同一类型问题，有多种处理方式，每一种都能独立解决问题；  
2. 算法需要自由切换的场景；  
3. 需要屏蔽算法规则的场景。  

&emsp; 注意事项：如果一个系统的策略多于四个，就需要考虑使用混合模式，解决策略类膨胀的问题。  

&emsp; **<font color = "red">策略模式在框架中的使用：JDK中比较器Comparator接口、Spring的Resource 类、Spring的初始化也采用了策略模式，不同的类型的类采用不同的初始化策略。</font>**  

&emsp; **优点：**  
1. 策略模式符合开闭原则。  
2. 避免使用多重条件转移语句，如if...else...语句、switch语句。  
3. 使用策略模式可以提高算法的保密性和安全性。  

&emsp; **缺点：**  
1. 客户端必须知道所有的策略，并且自行决定使用哪一个策略类。  
2. 代码中会产生非常多策略类，增加维护难度。  

## 1.2. 结构  
&emsp; **模式角色组成：**  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/design/design-14.png)  

* Strategy：抽象策略类，定义所有支持的算法的公共接口。     
* ConcreteStrategy：具体策略类，包装了相关的算法或行为。  
* Context：环境类，用一个ConcreteStrategy对象来配置。维护一个对Strategy对象的引用。可定义一个接口来让Strategy访问它的数据。  

