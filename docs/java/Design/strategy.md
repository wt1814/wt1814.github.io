
<!-- TOC -->

- [1. 策略(Strategy)模式，if/else，多用组合少用继承](#1-策略strategy模式ifelse多用组合少用继承)
    - [1.1. 简介](#11-简介)
    - [1.2. 结构](#12-结构)
    - [1.3. 小结](#13-小结)

<!-- /TOC -->

# 1. 策略(Strategy)模式，if/else，多用组合少用继承  
<!-- 
策略模式 + 反射工厂
https://mp.weixin.qq.com/s/6HqGa_inBHTxGOP12QXPnQ

https://www.runoob.com/design-pattern/strategy-pattern.html


https://blog.csdn.net/dengjili/article/details/79273928
https://cloud.tencent.com/developer/article/1385920?from=article.detail.1066412
https://my.oschina.net/u/1187187/blog/192706?p={{page}}
-->

## 1.1. 简介
&emsp; 策略模式，它是将定义的算法家族分别封装起来，让它们之间可以互相替换，从而让算法的变化不会影响到使用算法的用户。  
&emsp; <font color = "red">策略模式使用的是面向对象的继承和多态机制</font>，从而实现同一行为在不同场景下具备不同实现。 

&emsp; **使用场景：**策略模式可以解决在有多种算法相似的情况下，使用if...else或switch...case所带来的复杂性和臃肿性。在日常业务开发中，策略模式适用以下场景：  
1. 针对同一类型问题，有多种处理方式，每一种都能独立解决问题；  
2. 算法需要自由切换的场景；  
3. 需要屏蔽算法规则的场景。  

&emsp; 注意事项：如果一个系统的策略多于四个，就需要考虑使用混合模式，解决策略类膨胀的问题。  

&emsp; **<font color = "red">策略模式在框架中的使用：JDK中比较器Comparator接口、Spring的Resource 类、Spring的初始化也采用了策略模式，不同的类型的类采用不同的初始化策略。</font>**  

&emsp; **优点：**  
1. 策略模式符合开闭原则。  
2. 避免使用多重条件转移语句，如if...else...语句、switch语句。  
3. 使用策略模式可以提高算法的保密性和安全性。  

&emsp; **缺点：**  
1. 客户端必须知道所有的策略，并且自行决定使用哪一个策略类。  
2. 代码中会产生非常多策略类，增加维护难度。  

## 1.2. 结构  
&emsp; **模式角色组成：**  
![image](http://182.92.69.8:8081/img/java/design/design-14.png)  

* Strategy：抽象策略类，定义所有支持的算法的公共接口。     
* ConcreteStrategy：具体策略类，包装了相关的算法或行为。  
* Context：环境类，用一个ConcreteStrategy对象来配置。维护一个对Strategy对象的引用。可定义一个接口来让Strategy访问它的数据。  

&emsp; `环境类使用组合。`  

## 1.3. 小结
1. 让确定不变的东西放在基类中，实现更好的代码重用和逻辑上的继承关系。
2. 让变化的东西实现灵活性，可以对变化的东西进一步抽象为接口，采用组合的方式在基类中放入变化东西的接口。
3. 同时为了实现代码的重用性，对每一种变化的类型设计一个类，通过组合，这个类只需要写一份代码就可以使用在各个地方。
4. 可以在基类的子类中对接口进行赋值，可以直接在构造函数中对其赋以需要的实现接口的类，但为了不对实现编程，其实更好的做法是实现一些set方法，动态地设定那些变化的类，以及在今后还会学到工厂模式。  

&emsp; 继承，接口，组合的综合使用，使得能够获得更好的类体系结构。  
