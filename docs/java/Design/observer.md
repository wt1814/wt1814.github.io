



# 观察者（Observer）模式  
&emsp; 观察者模式（Observer Pattern） ，又叫发布-订阅模式。定义一种一对多的依赖关系，一个主题对象可被多个观察者对象同时监听，使得每当主题对象状态变化时，所有依赖于它的对象都会得到通知并被自动更新。  
&emsp; 观察者模式的核心是将观察者与被观察者接耦，以类似于消息/广播发送的机制联动两者，使被观察者的变动能通知到感兴趣的观察者们，从而做出相应的响应。  

&emsp; **使用场景：**  
1. 当一个抽象模型包含两个方面内容，其中一个方面依赖于另一个方面；  
2. 其他一个或多个对象的变化依赖于另一个对象的变化；  
3. 实现类似广播机制的功能，无需知道具体收听者，只需分发广播，系统中感兴趣的对象自动接收该广播；  
4. 多层级嵌套使用，形成一种链式触发机制，使得事件具备跨域（跨越两种观察者类型）通知。  

&emsp; **<font color = "red">Spring 中的 ContextLoaderListener 实现了 ServletContextListener 接口， ServletContextListener 接口又继承了 EventListener。EventListener就是典型的观察者模式接口。</font>**  

&emsp; **优点：**  
1. 观察者和被观察者之间建立了一个抽象的耦合。
2. 观察者模式支持广播通信。

&emsp; **缺点：**
1. 观察者之间有过多的细节依赖、提高时间消耗及程序的复杂度。
2. 使用要得当，要避免循环调用。

&emsp; **模式角色组成：**  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/design/design-16.png)  

* Subject：抽象被观察者角色，也就是一个抽象主题，它把所有对观察者对象的引用保存在一个集合中，每个主题都可以有任意数量的观察者。抽象主题提供一个接口，可以增加和删除观察者角色。一般用一个抽象类和接口来实现。
* ConcreteSubject：具体被观察者角色，也就是一个具体的主题，在集体主题的内部状态改变时，所有登记过的观察者发出通知。
* Observer：抽象观察者角色，为所有的具体观察者定义一个接口，在得到主题通知时更新自己。
* ConcreteObserver：具体观察者角色，实现抽象观察者角色所需要的更新接口，一边使本身的状态与制图的状态相协调。
