
<!-- TOC -->

- [1. ~~复用规则~~](#1-复用规则)
    - [1.1. 类之间的关系简述](#11-类之间的关系简述)
    - [1.2. 继承和组合](#12-继承和组合)
        - [1.2.1. 继承](#121-继承)
        - [1.2.2. 组合](#122-组合)
        - [1.2.3. 组合与继承的区别](#123-组合与继承的区别)
        - [1.2.4. ★★★两者的选择，组合优于继承](#124-★★★两者的选择组合优于继承)
    - [1.3. 委托](#13-委托)
    - [1.4. 继承和参数化类型的比较](#14-继承和参数化类型的比较)
    - [委托和组合的对比](#委托和组合的对比)
    - [理解继承、组合和委托的关系](#理解继承组合和委托的关系)

<!-- /TOC -->

&emsp; **<font color = "red">总结：</font>**  
1. 类和类之间的关系有三种：is-a（继承或泛化）、has-a（关联或聚合）和use-a（依赖）。  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/design/design-27.png)  
2. 组合的含义更像是一个对象(类)由各方面构成，这些方面并非来自于继承，但有时候却是必不可少的。`如果说继承是垂直结构，那么组合是横向结构。`  
3. 对于委托，类与类之间或对象与对象之间可以没有任何逻辑上的关系(比如继承关系和组合关系)，仅仅只是委托方和被委托方的关系。不过，继承而来的方法本就会自动查找，所以这些方法不需要委托。`而组合经常会结合委托一起使用，或者说组合的过程中本就依赖于委托，`比如对于房子.煮饭()这个方法调用请求，应该委托或转发给厨房.煮饭()。  
&emsp; ~~委托是将一部分功能分割出去完成，即委托者（delegator）将自己委托给受托者（delegatee），`受托者方法中参数为委托者对象`；然后委托者调用受托者类对象。~~  


# 1. ~~复用规则~~  

<!-- 
委托和组合的对比
https://www.jianshu.com/p/349bf04a9d4d
理解继承、组合和委托的关系
https://www.junmajinlong.com/coding/inherit_composition_delegate/


-->

<!-- 
可参考《设计模式 - 可复用面向对象软件的基础（高清版）》1.6.5 复用规则
理解对象、接口、类和继承之类的概念对大多数人来说并不难，问题的关键在于如何运用它们写出灵活的、可复用的软件。设计模式将告诉你怎样去做。  
1. 继承和组合的比较  
面向对象系统中功能复用的两种最常用技术是类继承和对象组合(object composition)。正如我们已解释过的，类继承允许你根据其他类的实现来定义一个类的实现。这种通过生成子类的复用通常被称为白箱复用(white-box reuse)。术语“白箱”是相对可视性而言：在继承方式中，父类的内部细节对子类可见。  
对象组合是类继承之外的另一种复用选择。新的更复杂的功能可以通过组装或组合对象来获得。对象组合要求被组合的对象具有良好定义的接口。这种复用风格被称为黑箱复用(black-box reuse)，因为对象的内部细节是不可见的。对象只以“黑箱”的形式出现。  

继承和组合各有优缺点。类继承是在编译时刻静态定义的，且可直接使用，因为程序设计语言直接支持类继承。类继承可以较方便地改变被复用的实现。当一个子类重定义一些而不是全部操作时，它也能影响它所继承的操作，只要在这些操作中调用了被重定义的操作。  
但是类继承也有一些不足之处。首先，因为继承在编译时刻就定义了，所以无法在运行时刻改变从父类继承的实现。更糟的是，父类通常至少定义了部分子类的具体表示。因为继承对子类揭示了其父类的实现细节，所以继承常被认为“破坏了封装性” 。子类中的实现与它的父类有如此紧密的依赖关系，以至于父类实现中的任何变化必然会导致子类发生变化。  

当你需要复用子类时，实现上的依赖性就会产生一些问题。如果继承下来的实现不适合解决新的问题，则父类必须重写或被其他更适合的类替换。这种依赖关系限制了灵活性并最终限制了复用性。一个可用的解决方法就是只继承抽象类，因为抽象类通常提供较少的实现。  
对象组合是通过获得对其他对象的引用而在运行时刻动态定义的。组合要求对象遵守彼此的接口约定，进而要求更仔细地定义接口，而这些接口并不妨碍你将一个对象和其他对象一起使用。这还会产生良好的结果：因为对象只能通过接口访问，所以我们并不破坏封装性；只要类型一致，运行时刻还可以用一个对象来替代另一个对象；更进一步，因为对象的实现是基于接口写的，所以实现上存在较少的依赖关系。  
对象组合对系统设计还有另一个作用，即优先使用对象组合有助于你保持每个类被封装，并被集中在单个任务上。这样类和类继承层次会保持较小规模，并且不太可能增长为不可控制的庞然大物。另一方面，基于对象组合的设计会有更多的对象 (而有较少的类)，且系统的行为将依赖于对象间的关系而不是被定义在某个类中。  

这导出了我们的面向对象设计的第二个原则：优先使用对象组合，而不是类继承。  
理想情况下，你不应为获得复用而去创建新的构件。你应该能够只使用对象组合技术，通过组装已有的构件就能获得你需要的功能。但是事实很少如此，因为可用构件的集合实际上并不足够丰富。使用继承的复用使得创建新的构件要比组装旧的构件来得容易。这样，继承和对象组合常一起使用。  
然而，我们的经验表明：设计者往往过度使用了继承这种复用技术。但依赖于对象组合技术的设计却有更好的复用性 (或更简单)。你将会看到设计模式中一再使用对象组合技术。  

2. 委托
委托(d e l e g a t i o n)是一种组合方法，它使组合具有与继承同样的复用能力 [ L i e 8 6 , J Z 9 1 ]。在委托方式下，有两个对象参与处理一个请求，接受请求的对象将操作委托给它的代理者
(d e l e g a t e)。这类似于子类将请求交给它的父类处理。使用继承时，被继承的操作总能引用接受请求的对象，C + +中通过t h i s成员变量，S m a l l t a l k中则通过s e l f。委托方式为了得到同样的
效果，接受请求的对象将自己传给被委托者（代理人），使被委托的操作可以引用接受请求的对象。  
举例来说，我们可以在窗口类中保存一个矩形类的实例变量来代理矩形类的特定操作，这样窗口类可以复用矩形类的操作，而不必像继承时那样定义成矩形类的子类。也就是说，一个窗口拥有一个矩形，而不是一个窗口就是一个矩形。窗口现在必须显式的将请求转发给它的矩形实例，而不是像以前它必须继承矩形的操作。
下面的图显示了窗口类将它的 A r e a操作委托给一个矩形实例。
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/design/design-23.png)  

箭头线表示一个类对另一个类实例的引用关系。引用名是可选的，本例为“ r e c t a n g l e”。
委托的主要优点在于它便于运行时刻组合对象操作以及改变这些操作的组合方式。假定
矩形对象和圆对象有相同的类型，我们只需简单的用圆对象替换矩形对象，则得到的窗口就
是圆形的。
委托与那些通过对象组合以取得软件灵活性的技术一样，具有如下不足之处：动态的、
高度参数化的软件比静态软件更难于理解。还有运行低效问题，不过从长远来看人的低效才
是更主要的。只有当委托使设计比较简单而不是更复杂时，它才是好的选择。要给出一个能
确切告诉你什么时候可以使用委托的规则是很困难的。因为委托可以得到的效率是与上下文
有关的，并且还依赖于你的经验。委托最适用于符合特定程式的情形，即标准模式的情形。
有一些模式使用了委托，如 S t a t e ( 5 . 8 )、S t r a t e g y ( 5 . 9 )和Vi s i t o r ( 5 . 11 )。在S t a t e模式中，一
个对象将请求委托给一个描述当前状态的 S t a t e对象来处理。在S t r a t e g y模式中，一个对象将一
个特定的请求委托给一个描述请求执行策略的对象，一个对象只会有一个状态，但它对不同
的请求可以有许多策略。这两个模式的目的都是通过改变受托对象来改变委托对象的行为。
在Vi s i t o r中，对象结构的每个元素上的操作总是被委托到 Vi s i t o r对象。
其他模式则没有这么多 地用到委托。M e d i a t o r ( 5 . 5 )引进了一个中介其他对象间通信的对
象。有时， M e d i a t o r对象只是简单地将请求转发给其他对象；有时，它沿着指向自己的引用
来传递请求，使用真正意义的委托。 Chain of Responsibility(5.1)通过将请求沿着对象链传递
来处理请求，有时，这个请求本身带有一个接受请求对象的引用，这时该模式就使用了委托。
B r i d g e ( 4 . 2 )将实现和抽象分离开，如果抽象和一个特定实现非常匹配，那么这个实现可以代
理抽象的操作。
委托是对象组合的特例。它告诉你对象组合作为一个代码复用机制可以替代继承。
3. 继承和参数化类型的比较
另一种功能复用技术 (并非严格的面向对象技术 )是参数化类型(parameterized type)，也就
是类属( g e n e r i c ) ( A d a、E i ff e l )或模板( t e m p l a t e s ) ( C + + )。它允许你在定义一个类型时并不指定该
类型所用到的其他所有类型。未经指定的类型在使用时以参数形式提供。例如，一个列表类
能够以它所包含元素的类型来进行参数化。如果你想声明一个 I n t e g e r列表，只需将 I n t e g e r类
型作为列表参数化类型的参数值；声明一个 S t r i n g列表，只需提供 S t r i n g类型作为参数值。语
言的实现将会为各种元素类型创建相应的列表类模板的定制版本。
参数化类型给我们提供除了类继承和对象组合外的第三种方法来组合面向对象系统中的
行为。许多设计可以使用这三种技术中的任何一种来实现。实现一个以元素比较操作为可变
元的排序例程，可有如下方法：
1) 通过子类实现该操作( Template Method(5.10)的一个应用)。
2 ) 实现为传给排序例程的对象的职责 ( S t r a t e g y ( 5 . 9 ) )。
3) 作为C + +模板或A d a类属的参数，以指定元素比较操作的名称。
这些技术存在着极大的不同之处。对象组合技术允许你在运行时刻改变被组合的行为，
但是它存在间接性，比较低效。继承允许你提供操作的缺省实现，并通过子类重定义这些操
作。参数化类型允许你改变类所用到的类型。但是继承和参数化类型都不能在运行时刻改变。
哪一种方法最佳，取决于你设计和实现的约束条件。

-->

## 1.1. 类之间的关系简述
&emsp; 简单地说，类和类之间的关系有三种：is-a(继承或泛化)、has-a(关联或聚合)和use-a(依赖)。  

* is-a 关系也叫继承或泛化，比如学生和人的关系、手机和电子产品的关系都属于继承关系；
* has-a 关系通常称之为关联，比如部门和员工的关系、汽车和引擎的关系都属于关联关系；关联关系如果是整体和部分的关联， **那么称之为聚合关系；** 如果整体进一步负责了部分的生命周期 (整体和部分是不可分割的，同时同在也同时消亡)，那么这种就是最强的关联关系，称之为 合成 关系。
* use-a 关系通常称之为依赖，比如司机有一个驾驶的行为(方法)，其中 (的参数) 使用到了汽车，那么司机和汽车的关系就是依赖关系。

&emsp; 利用类之间的这些关系，可以在已有类的基础上来完成某些操作，也可以在已有类的基础上创建新的类，这些都是实现代码复用的重要手段。复用现有的代码不仅可以减少开发的工作量，也有利于代码的管理和维护，这是开发在日常工作中都会使用到的技术手段。  

## 1.2. 继承和组合
<!-- 
https://mp.weixin.qq.com/s/KksIdVFsh2mr3kZvrNQHgg
https://time.geekbang.org/column/article/169593
https://www.jianshu.com/p/349bf04a9d4d
https://www.junmajinlong.com/coding/inherit_composition_delegate/
-->

### 1.2.1. 继承
&emsp; 继承是面向对象三大基本特征之一(继承，封装，多态)，继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。在java中通过关键字extends实现继承，java中所有类默认都是java.lang.Object的子类。继承强调的是is-a关系。  
&emsp; 直接通过例子来了解继承：  

```java
/**
 * 动物
 */
public class Animal {
    public void breathing() {
        System.out.println("呼气...吸气...");
    }
}
```

```java
/**
 * 飞行动物
 * 继承
 */
public class FlyingAnimals extends Animal{
    public void filying() {
        System.out.println("飞行...");
    }

    public static void main(String[] args) {
        FlyingAnimals flyingAnimals = new FlyingAnimals();
        flyingAnimals.breathing();
        flyingAnimals.filying();
    }
}
```

&emsp; 运行结果：  

```
呼气…吸气…
飞行…
```
&emsp; 继承是代码复用的一种方式。在继承中，父类的方法内部实现细节对子类可见，是‘白盒式’的代码复用。  


### 1.2.2. 组合
&emsp; 组合是通过对现有对象进行拼装即组合产生新的具有更复杂的功能。如：  

```java
/**
 * 动物
 */
public class Animal {
    public void breathing() {
        System.out.println("呼气...吸气...");
    }
}
```

```java
/**
 * 爬行动物
 * 组合
 */
public class Reptilia {

    private Animal animal;

    public Reptilia(Animal animal) {
        this.animal = animal;
    }

    public void crawling() {
        System.out.println("爬行...");
    }
    public void breathing() {
        animal.breathing();
    }


    public static void main(String[] args) {
        Animal animal = new Animal();
        Reptilia reptilia = new Reptilia(animal);
        reptilia.breathing();;
        reptilia.crawling();
    }
}
```

&emsp; 运行结果：  

```
呼气…吸气…
爬行…
```

&emsp; 组合体现的是整体和部分，强调的是has-a的关系。所以组合更多的用于下面这样的场景：  

```java
/**
 * 轮胎
 */
class Tire {
    public void run() {
        System.out.println("轮胎转动...");
    }
}
/**
 * 车灯
 */
class Light {
    public void light() {
        System.out.println("灯亮...");
    }
}
```

```java
/**
 * 交通工具
 * 组合
 */
public class Vehicle {
    private Tire tire;
    private Light light;

    public Vehicle(Tire tire,Light light) {
        this.tire = tire;
        this.light = light;
    }

    public void operation() {
        light.light();
        tire.run();
    }

    public static void main(String[] args) {
        Tire tire = new Tire();
        Light light = new Light();
        Vehicle vehicle = new Vehicle(tire,light);
        vehicle.operation();
    }
}
```


&emsp; 运行结果：  

```
灯亮…
轮胎转动…
```

### 1.2.3. 组合与继承的区别 
<!-- 
https://blog.csdn.net/zymx14/article/details/79605926
-->
&emsp; 继承与组合都是面向对象中代码复用的方式。父类的内部细节对子类可见，其代码属于白盒式的复用，而组合中，对象之间的内部细节不可见，其代码属于黑盒式复用。继承在编码过程中就要指定具体的父类，其关系在编译期就确定，而组合的关系一般在运行时确定。继承强调的是is-a的关系，而组合强调的是has-a的关系。  


### 1.2.4. ★★★两者的选择，组合优于继承  
&emsp; 除非两个类之间是“is-a”的关系，否则不要轻易的使用继承，不要单纯的为了实现代码的重用而使用继承，因为过多的使用继承会破坏代码的可维护性，当父类被修改时，会影响到所有继承自它的子类，从而增加程序的维护难度和成本。  
&emsp; 不要仅仅为了实现多态而使用继承，如果类之间没有“is-a”的关系，可以通过实现接口与组合的方式来达到相同的目的。设计模式中的策略模式可以很好的说明这一点，采用接口与组合的方式比采用继承的方式具有更好的可扩展性。  
&emsp; 在Java语言中，能使用组合就尽量不要使用继承。  

## 1.3. 委托  

## 1.4. 继承和参数化类型的比较


------------

## 委托和组合的对比  
委托是将一部分功能分割出去完成，即委托者（delegator）将自己委托给受托者（delegatee），受托者方法中参数为委托者对象；然后委托者调用受托者类对象。  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/design/design-26.png)  

委托与组合的对比：  

（1）组合：  

```java
delegateA {

delegateeB b;

void methodA(); { b.methodB();;}

}

delegateeB {

void methodB(); {}

}
```

（2）委托：   

```java
delegateA {

    delegateeB b;

    voidmethodA(); { b.methodB(this);; }voiddo(); {}

}

delegateeB {

    void methodB(delegateA a); { a.do();; }

}
```

&emsp; 委托相比于组合，是在受托者方法中加入了委托者对象。  

## 理解继承、组合和委托的关系
&emsp; 类与类之间的关系，除了继承关系，还有组合(Composition)关系和委托关系：  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/design/design-27.png)  

&emsp; 继承的含义自不必说，组合的含义更像是一个对象(类)由各方面构成，这些方面并非来自于继承，但有时候却是必不可少的。如果说继承是垂直结构，那么组合是横向结构。  

&emsp; 比如，房子是一个封闭的结构，有房顶，有四面墙，有大门，假设这些属性都来自于继承。但房子还有房间，有厨房，有卫生间，如果这些不是继承而来，那就需要通过组合来提供：对于房子来说，把一个或多个房间组合进来构成自己的一部分，再把一个厨房组合进来，还可以把一个卫生间也组合进来构成自己的一部分。也可以认为，房间、厨房和卫生间都是房子的一部分组件，而房子是组件的承载体。而且，房间、厨房和卫生间对象都依赖于房子对象而存在，房子对象消亡时这个房子对象中的组合对象也都将消亡。  

&emsp; 对于委托，类与类之间或对象与对象之间可以没有任何逻辑上的关系(比如继承关系和组合关系)，仅仅只是委托方和被委托方的关系。不过，继承而来的方法本就会自动查找，所以这些方法不需要委托。而组合经常会结合委托一起使用，或者说组合的过程中本就依赖于委托，比如对于房子.煮饭()这个方法调用请求，应该委托或转发给厨房.煮饭()。  

&emsp; 下面的伪代码实现了组合：  

```text
class Kitchen {
  func cooking(){
    print("cooking")
  }
}
class Bathroom {
  func wash(){
    print("washing")
  }
}
class House {
  # 构造方法
  # 在房子对象中，将一个厨房对象、一个卫生间对象组合进来
  func constructor(){
    @kitchen = Kitchen.new
    @bathroom = Bathroom.new
  }
}
```

&emsp; 上面的房子对象和厨房对象以及卫生间对象都是共存亡的，要创建房子对象，同时会创建出厨房对象和卫生间对象，销毁房子对象时，卫生间对象和厨房对象也会随之销毁。  

&emsp; 上面的组合虽然符合组合的逻辑，但在功能上还不完整。比如h=House.new();h.wash()会报错，因为房子对象h并没有定义wash()方法。  

&emsp; 所以，这里还需要加入方法委托：  

```text
class House {
  # 构造方法：@kitchen和@bathroom是实例变量
  # 在房子对象中，将一个厨房对象、一个卫生间对象组合进来
  func constructor(){
    @kitchen = Kitchen.new
    @bathroom = Bathroom.new
  }
  func cooking(){
    @kitchen.cooking()
  }
  func wash(){
    @bathroom.wash()
  }
}
```

&emsp; 这样功能就完善了，每次调用h.wash()都会转而调用@bathroom.wash()。  

&emsp; 如果语言有提供相关的库或模块，甚至可以自动完成方法转发。  
