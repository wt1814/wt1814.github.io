

<!-- TOC -->

- [1. 知识点概况](#1-知识点概况)
    - [1.1. Java](#11-java)
    - [1.2. 设计模式](#12-设计模式)
    - [1.3. JVM](#13-jvm)
        - [1.3.1. 类加载](#131-类加载)
        - [1.3.2. 运行时数据区/内存结构](#132-运行时数据区内存结构)
        - [1.3.3. GC](#133-gc)
            - [1.3.3.1. 安全点和安全区域](#1331-安全点和安全区域)
            - [1.3.3.2. 回收算法与分代回收](#1332-回收算法与分代回收)
            - [1.3.3.3. 回收对象](#1333-回收对象)
            - [1.3.3.4. 垃圾回收器](#1334-垃圾回收器)
            - [1.3.3.5. JVM调优](#1335-jvm调优)

<!-- /TOC -->


# 1. 知识点概况
## 1.1. Java
1. 集合
    1. 集合Collections
    2. HashMap
2. JDK 1.8
1. SPI
2. 泛型
    1. 为什么使用泛型？泛型的好处


## 1.2. 设计模式
1. 设计原则
2. 3种设计模式
3. 日常开发常用的设计模式
4. Spring中使用到的设计模式


## 1.3. JVM
### 1.3.1. 类加载
1. 类加载流程
2. 类加载器：双亲委派模型
3. 破坏双亲委派
    1. 为什么破坏？JDK、Tomcat、Spring
    2. `破坏双亲委派两种方式：`  
        1. 继承ClassLoader，重写loadClass()方法。  
        2. `使用线程上下文类加载器(Thread Context ClassLoader)`

### 1.3.2. 运行时数据区/内存结构
1. JVM内存结构
    1. 程序计数器
    2. JVM栈/【方法】【栈】
    3. 【GC】【堆】
    4. 方法区/永久代
    &emsp; jdk1.8及之后：无永久代。<font color = "clime">字符串常量池、静态变量（`值可变`）仍在堆，</font> 但类型信息、字段、`方法`、<font color = "red">常量（`值固定`）</font>保存在本地内存的元空间。  
    5. MetaSpace存储类的元数据信息
2. 类存储内存小结
    1. 变量
        1. 常量final static
        2. 静态变量static
        3. 全局变量
        4. 局部变量 
    2. ~~静态方法和实例方法~~  
    &emsp; `静态方法`会在程序运行的时候`直接装载进入方法区`。而实例方法会在new的时候以对象的方法装载进入堆中。  
    &emsp; 最大的区别在于内存的区别，由于main函数为static静态方法，会直接在运行的时候装载进入内存区，实例方法必须new，在堆中创建内存区域，再进行引用。  
3. 内存(堆栈)中的对象
    1. 创建对象
        1. **<font color = "clime">对象创建过程：1. 检测类是否被加载；2. 为对象分配内存；3. 将分配内存空间的对象初始化零值；4. 对对象进行其他设置；5.执行init方法。</font>**  
        2. ~~对象分配内存流程详解~~  
            1. 堆内存分配策略  
            2. 内存分配全流程  
            3. 分配内存两种方式  
            4. 线程安全问题
        3. 逃逸分析
4. 对象生命周期  
5. ~~对象大小~~  
6. 内存泄漏  

### 1.3.3. GC  
&emsp; ⚠️⚠️⚠️一句话小结：`垃圾回收器` 在 `安全点/安全区域` 采用`回收算法` `分代/整堆` 回收 `(堆)根不可达的对象 或 (方法区)类/常量`。  

#### 1.3.3.1. 安全点和安全区域  
&emsp; `在安全点上中断的是活跃运行的用户线程，对于已经挂起的线程该怎么处理呢？`**<font color = "blue">`已经挂起的线程`会被认定为处在`安全区域`内，中断的时候不需要考虑安全区域中的线程。</font>**  
&emsp; 当前安全区域的线程要被唤醒离开安全区域时，先检查能否离开，如果GC完成了，那么线程可以离开，否则它必须等待，直到收到安全离开的信号为止。  

#### 1.3.3.2. 回收算法与分代回收
1. GC算法  
2. 分代回收  
3. 跨代引用假说  
4. 各种GC：局部GC和整堆回收  

#### 1.3.3.3. 回收对象  
1. 堆中对象的存活
    1. 标记对象
    2. 进行回收（Object#finalize()⽅法）  
2. 方法区（类和常量）回收/类的卸载阶段  
3. null与GC  

#### 1.3.3.4. 垃圾回收器  
1. 垃圾回收器分类  
2. CMS  
    1. 特点  
    2. 回收流程：3次标记、2次清除  
        3. 预清理：（`三色标记法的漏标问题处理`） **<font color = "red">这个阶段是用来</font><font color = "blue">处理</font><font color = "clime">前一个并发标记阶段因为引用关系改变导致没有标记到的存活对象的。`如果发现对象的引用发生变化，则JVM会标记堆的这个区域为Dirty Card。`那些能够从Dirty Card到达的对象也被标记（标记为存活），当标记做完后，这个Dirty Card区域就会消失。</font>**  
        4. 可终止的预处理。这个阶段`尝试着去承担下一个阶段Final Remark阶段足够多的工作`。   
    3. 
3. G1  
    1. G1的收集过程可能有4个阶段：新生代GC、老年代并发标记周期、混合回收、如果需要可能会进行Full GC。   
    2. 最终标记： **<font color = "blue">去处理剩下的SATB（开始快照）日志缓冲区和所有更新，找出所有未被访问的存活对象，同时安全完成存活数据计算。</font>**   
4. 三色标记，并发标记阶段  
    1. 多标/错标（浮动垃圾）  
    2. 漏标：把本来应该存活的垃圾，标记为了死亡。这就会导致非常严重的错误。  

#### 1.3.3.5. JVM调优  
  



    


