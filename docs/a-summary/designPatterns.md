<!-- TOC -->

- [1. 设计模式](#1-设计模式)
    - [1.1. 七大设计原则](#11-七大设计原则)
    - [1.2. 复用规则（继承和组合）详解](#12-复用规则继承和组合详解)
    - [1.3. 设计模式详解](#13-设计模式详解)
        - [1.3.1. 5种创建型设计模式](#131-5种创建型设计模式)
        - [1.3.2. 7种结构型设计模式（横向4 + 纵向2 + 1）](#132-7种结构型设计模式横向4--纵向2--1)
        - [1.3.3. 两种动态代理](#133-两种动态代理)
        - [1.3.4. 4种行为型设计模式](#134-4种行为型设计模式)
    - [1.4. 日常使用的设计模式](#14-日常使用的设计模式)
        - [1.4.1. Spring框架中用到了哪些设计模式](#141-spring框架中用到了哪些设计模式)
        - [1.4.2. Mybatis的设计模式](#142-mybatis的设计模式)
        - [1.4.3. 日常使用的设计模式](#143-日常使用的设计模式)
    - [1.5. 父类能调用子类中的方法？](#15-父类能调用子类中的方法)

<!-- /TOC -->

# 1. 设计模式  
## 1.1. 七大设计原则
* 针对单个类的设计原则：  
    * 单一职责原则。   
    * 开闭原则（ **<font color = "clime">对已经使用的类的改动是通过增加代码进行的，而不是修改现有代码，实现一个热插拔的效果</font>** ）；
* 要依赖抽象或接口：  
    * 依赖倒置原则（ **<font color = "clime">为了实现这一原则，就要求在编程的时候针对抽象类或者接口编程，而不是针对具体实现编程</font>** ）； 
    * 接口隔离原则；     
    * 里氏替换原则（ **<font color = "clime">子类可以扩展父类的功能，但不能改变父类原有的功能</font>** ）。  
* 类与类：  
    * 合成复用原则（ **<font color = "red">尽量使用对象[组合(has-a)/聚合(contanis-a)](/docs/java/Design/compose.md)，而不是继承关系达到软件复用的目的</font>** ）；
    * 迪米特法则（一个对象应当对其他对象尽可能少的了解）。  

&emsp; `★★★如果说继承是垂直结构，那么组合是横向结构。`  

## 1.2. 复用规则（继承和组合）详解  
1. 类和类之间的关系有三种：is-a（继承或泛化）、has-a（关联或聚合）和use-a（依赖）。  
![image](http://182.92.69.8:8081/img/java/design/design-27.png)  
2. `组合的含义更像是一个对象（类）由各方面构成`，这些方面并非来自于继承，但有时候却是必不可少的。`★★★【如果说继承是垂直结构，那么组合是横向结构。】`  
3. `对于委托，类与类之间或对象与对象之间可以没有任何逻辑上的关系（比如继承关系和组合关系），仅仅只是委托方和被委托方的关系。`不过，继承而来的方法本就会自动查找，所以这些方法不需要委托。`而组合经常会结合委托一起使用，或者说组合的过程中本就依赖于委托，`比如对于房子.煮饭()这个方法调用请求，应该委托或转发给厨房.煮饭()。  
&emsp; ~~委托是将一部分功能分割出去完成，即委托者（delegator）将自己委托给受托者（delegatee），`受托者方法中参数为委托者对象`；然后委托者调用受托者类对象。~~  

## 1.3. 设计模式详解
1. 常用设计模式有23种（不包含简单工厂模式）。 **<font color = "red">这23种设计模式的本质是面向对象设计原则的实际运用，是对类的封装性、继承性和多态性，以及类的关联关系和组合关系的充分理解。</font>**  
2.  **<font color = "red">结构型设计模式：多个类协同完成一个功能； 行为型设计模式，算法模式。</font>**  

### 1.3.1. 5种创建型设计模式
1. 单例模式
    1. ~~单例模式适用场景~~：全局只有一个示例，例如：数据库连接池、Spring单例bean...  
    2. 编码  
    ★★★双重校验锁的形式：DCL详解参考[Volatile](/docs/java/concurrent/Volatile.md)。`注⚠️：static、volicate、双重校验+锁synchronized。`  

    ```java
    public class LazyDoubleCheckSingleton {
        
        private static volatile LazyDoubleCheckSingleton lazy = null;

        private LazyDoubleCheckSingleton(){
            
        }
        
        public static LazyDoubleCheckSingleton getInstance(){
            // 第一重检测
            if(lazy == null){
                // 锁定代码块
                synchronized (LazyDoubleCheckSingleton.class){
                    // 第二重检测
                    if(lazy == null){
                        // 实例化对象
                        lazy = new LazyDoubleCheckSingleton();
                        //1.分配内存给这个对象
                        //2.初始化对象
                        //3.设置 lazy 指向刚分配的内存地址
                    }
                }
            } 
            // todo 返回实例
            return lazy;
        }
        
        /**
        * 逻辑操作
        **/
        public void showMessage(){
            System.out.println("Hello World!");
        }
        
    }
    ```

    ```java
    public static void main(String[] args){
        // 
        LazyDoubleCheckSingleton instance = LazyDoubleCheckSingleton.getInstance();
        //
        instance.methodOne();
    }
    ```
    &emsp; <font color = "red">只有在singleton == null的情况下才进行加锁创建对象，如果singleton!=null，就直接返回就行了，并没有进行并发控制。大大的提升了效率。</font>   
    &emsp; <font color = "clime">从上面的代码中可以看到，其实整个过程中进行了两次singleton == null的判断，所以这种方法被称之为"双重校验锁"。</font>   
    &emsp; <font color = "clime">还有值得注意的是，双重校验锁的实现方式中，静态成员变量singleton必须通过volatile来修饰，保证其初始化不被重排，否则可能被引用到一个未初始化完成的对象。</font>   
    3. `单例模式与static静态类`：静态使用于一些非状态Bean，单例使用于状态Bean。  
    &emsp; 1）首先单例模式会提供一个全局唯一的对象，静态类只是提供给很多静态方法，这些方法不用创建对象，通过类就可以直接调用；  
    &emsp; 2）如果是一个非常重的对象，单例模式可以懒加载，静态类就无法做到；  
    &emsp; 那么时候时候应该用静态类，什么时候应该用单例模式呢？首先如果只是想使用一些工具方法，那么最好用静态类，静态类比单例类更快，因为静态的绑定是在编译期进行的。如果要维护状态信息，或者访问资源时，应该选用单例模式。还可以这样说，当需要面向对象的能力时（比如继承、多态）时，选用单例类，当仅仅是提供一些方法时选用静态类。  
2. 简单工厂模式和抽象工厂模式
3. 建造者模式： **<font color = "red">建造者模式适用于创建对象需要很多步骤，但是步骤的顺序不一定固定。如果一个对象有非常复杂的内部结构（很多属性），可以将复杂对象的创建和使用进行分离。</font>**  
4. 原型模式：
    克隆的结果有2种，一种是浅复制，另一种是深复制。  
    * 浅复制: 对值类型的成员变量进行值的复制，对引用类型的成员变量只复制引用，不复制引用的对象。  
    * 深复制:  **<font color = "clime">对值类型的成员变量进行值的复制，对引用类型的成员变量也进行引用对象的复制。</font>**  

### 1.3.2. 7种结构型设计模式（横向4 + 纵向2 + 1）
1. 适配器模式  
    &emsp; 适配器继承或依赖已有的对象，实现想要的目标接口。  
    1. 平时开发中，面向接口编程，注入其他类，从而进行调用。  
    &emsp; 适配器(Adapter)模式中，Adapter，适配器类，即实现目标接口Target，又继承Adaptee类。适配器模式的核心角色，其他两个角色都是已经存在的角色，而适配器角色是需要新建立的，它的职责非常简单：把源角色转换为目标角色。`转换的方式有：即能通过继承，又能通过类关联的方式。`  
    2. **适配器模式有3种形式：对象适配器、类适配器、接口适配器。**  
        * `对象适配器（平时使用最多）`：不使用多继承或继承的方式，而是使用直接关联，或者称为委托的方式。  
        * 类适配器：Adapter类继承Adaptee（被适配类），同时实现Target接口（因为Java不支持多继承，所以只能通过接口的方法来实现多继承），在Client类中可以根据需要选择并创建任一种符合需求的子类，来实现具体功能。 
        * 接口适配器：通过抽象类来实现适配。即适配器类是一个抽象类。  
    3. 适配的思想。  
3. 代理模式：<font color = "red">提供了对目标对象另外的访问方式，即通过代理访问目标对象。</font>  
4. XXX装饰器模式XXX：`可替代继承（有继承就可以改写装饰器模式）`，此设计模式重点在于对已有的功能进行扩展。实际开发中， **<font color = "red">大多数用于对老项目的某些功能进行扩展。</font>** 新项目中一般不怎么用此模式。`装饰器模式解决继承的【臃肿】`。      
&emsp; Decorator，装饰角色，一般是一个抽象类，继承自或实现Component（抽象构件），在它的属性里面有一个变量指向Component抽象构件，这是装饰器最关键的地方。  
&emsp; 在Mybatis中，Cache的实现类LruCache、FifoCache等都是装饰一个类PerpetualCache。常见代码格式，就是装饰类中会有个被装饰类的属性，并且这个属性还是构造方法的参数。  
5. 桥接模式（if/else）

--------------

1. 外观模式/门面模式：**提供了一个统一的接口，用来访问子系统中的一群接口。**  
6. 组合模式

--------------

7. 享元模式（池化技术）  
    &emsp; 享元模式：①将对象的公共部分抽取出来成为内部状态（实现共享），②将随时间改变、不可共享的部分作为外部状态（通过更换外部状态实现对象复用），从而减少创建对象的数量，以减少内存开销和提高性能。  
    &emsp; 核心：共享和复用，共享（内部状态 - intrinsicState），复用（外部状态 - extrinsicState）  
    &emsp; 使用场景：  

    * 共享：当只存在内部状态时，可以在多线程中共享使用（String常量池）  
    * 复用：通过改变外部状态，可以更好实现对象的复用（线程池）  

&emsp; PS：外部状态在线程间需考虑并发问题，因此不适合共享，但当对象被使用完成后，通过修改外部状态，使其可以复用于下一次的访问需求。  

### 1.3.3. 两种动态代理
1. 动态编程  
&emsp; 动态编程是相对于静态编程而言，平时大多讨论的都是静态编程，java便是一种静态编程语言，它的类型检查是在编译期间完成的。而动态编程是绕过了编译期间，在运行时完成类型检查。  
&emsp; java有如下方法实现动态编程：`动态代理`，`动态编译`。    
3. JDK动态代理：  
    1. Java动态代理类位于java.lang.reflect包下，一般主要涉及到以下两个重要的类或接口，`一个是InvocationHandler接口、另一个则是Proxy类。`  
        * Proxy类。该类即为动态代理类。Proxy.newProxyInstance()生成代理对象；  
        * InvocationHandler接口。 **<font color = "clime">在使用动态代理时，需要定义一个位于代理类与委托类之间的中介类，中介类被要求实现InvocationHandler接口。</font>** 通过代理对象调用一个方法的时候，这个方法的调用会被转发为由InvocationHandler这个接口的invoke方法来进行调用。  
    0. ~~两大知识点：反射、因单继承只能为接口生成代理对象。~~  
    2. <font color = "clime">JDK动态代理的实现，大致流程：</font>使用`反射`来创建代理类。  
        1. <font color = "red">为接口创建代理类的字节码文件。</font>   
        2. <font color = "red">使用ClassLoader将字节码文件加载到JVM。</font>  
        3. <font color = "red">创建代理类实例对象，执行对象的目标方法。</font>  
    3. `~~限制：JDK动态代理为什么只能使用接口？~~`  
    &emsp; JDK动态代理是为接口生成代理对象，该代理对象继承了JAVA标准类库Proxy.java类并且实现了目标对象。由于JAVA遵循`单继承`多实现原则，所以JDK无法利用继承来为目标对象生产代理对象。   
2. 动态编译  
    &emsp; `动态编译就是利用字节码修改技术`，来操作java字节码在运行期间jvm中动态生成新类或者对已有类进行修改。动态编译是在java 6开始支持的，主要是通过一个JavaCompiler接口来完成的。可以解决需要动态插入代码的场景，比如动态代理的实现，实现AOP编程。  
    &emsp; 操作java字节码的工具有两个比较流行，一个是ASM，一个是Javassit。  

    * ASM：直接操作字节码指令，执行效率高，要是使用者掌握Java类字节码文件格式及指令，对使用者的要求比较高。
    * Javassit 提供了更高级的API，执行效率相对较差，但无需掌握字节码指令的知识，对使用者要求较低。

    &emsp; 应用层面来讲一般使用建议优先选择Javassit，如果后续发现Javassit 成为了整个应用的效率瓶颈的话可以再考虑ASM。当然如果开发的是一个基础类库，或者基础平台，还是直接使用ASM吧，相信从事这方面工作的开发者能力应该比较高。
4. CGLIB代理
    1. 依赖ASM字节码工具，通过动态生成`实现接口或继承类`的类字节码，实现动态代理。  
    &emsp; `针对接口，生成实现接口的类，即implements方式；针对类，生成继承父类的类，即extends方式。`  
    2. **<font color = "clime">CGLIB基于继承类生成动态代理需要注意：</font>**  
        1. final声明的类是不能被代理的；
        2. `类中的private,final方法不能被代理，static方法不生成代理方法。`

### 1.3.4. 4种行为型设计模式
1. 模板方法模式
2. 策略模式（if/else）
3. 责任链模式（if/else）
4. 观察者模式


## 1.4. 日常使用的设计模式  
### 1.4.1. Spring框架中用到了哪些设计模式 

* 工厂设计模式：Spring使用工厂模式通过 BeanFactory、ApplicationContext 创建 bean 对象。  
* 单例设计模式：Spring 中的 Bean 默认都是单例的。  
* 模板方法模式：Spring 中 jdbcTemplate、hibernateTemplate 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。  
* 观察者模式：Spring事件驱动模型就是观察者模式很经典的一个应用。  
* 代理设计模式：Spring AOP 功能的实现。  
* 适配器模式：Spring AOP 的增强或通知（Advice）使用到了适配器模式、spring MVC 中也是用到了适配器模式适配Controller。  
* 包装器设计模式：项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式可以根据客户的需求能够动态切换不同的数据源。 
* ……


### 1.4.2. Mybatis的设计模式
1. Builder模式：例如 SqlSessionFactoryBuilder、XMLConfigBuilder、XMLMapperBuilder、XMLStatementBuilder、CacheBuilder；  
2. 工厂模式：例如SqlSessionFactory、ObjectFactory、MapperProxyFactory；  
3. 单例模式：例如ErrorContext和LogFactory；  
4. 代理模式：Mybatis实现的核心，比如MapperProxy、ConnectionLogger，用的jdk的动态代理；还有executor.loader包使用了cglib或者javassist达到延迟加载的效果；  
5. 适配器模式: 例如Log的Mybatis接口和它对jdbc、log4j等各种日志框架的适配实现；  
6. 装饰者模式: 例如cache包中的cache.decorators子包中等各个装饰者的实现；  
7. 组合模式：例如SqlNode和各个子类ChooseSqlNode等；  
8. 模板方法模式: 例如BaseExecutor和SimpleExecutor，还有BaseTypeHandler和所有的子类例如IntegerTypeHandler；  
9. 迭代器模式: 例如迭代器模式PropertyTokenizer；  

### 1.4.3. 日常使用的设计模式
&emsp; 面试题：你使用过哪些设计模式？ 根据实际使用，设计模式分3类：  

* 框架：SpringAOP（代理）、mq（观察者）、享元模式(池化技术)  
* 不自觉使用的设计模式，如门面模式（接口开发）、对象适配器模式（Service层调用）、类适配器模式（继承和实现接口同时使用）。  
* 需要编码：  
    1. 单例和static；  
    2. 模板方法（抽象类）  
    3. 装饰器模式（抽象类）  
    4. 优化if/else：多态、简单工厂模式、策略模式、责任链模式
        * 策略模式：<font color = "red">策略模式使用的是面向对象的继承和多态机制</font>，从而实现同一行为在不同场景下具备不同实现。~~策略模式和简单工厂模式看起来非常相似，都是通过多态来实现不同子类的选取。策略模式使用前需要知道具体某一个对象，简单工厂则是通过条件创造对象，两者都是通过多态调用具体算法。~~ 
        ![image](http://182.92.69.8:8081/img/java/design/design-14.png)    


## 1.5. 父类能调用子类中的方法？  
&emsp; main方法中是能够的，即多态。  
&emsp; 父类是不能直接调用子类的方法的。父类先于子类存在，子类从父类中生出来，因此子类知道父类，能够调用父类方法。但父类不知道子类，子类能够任意的出生，只要你愿意，因此父类没法调用子类，他不知他会有这样的子类，也不知有多少个子类，但子类的父类是惟一的。  
&emsp; 简单点就是在JAVA中父类是不能调用子类的方法的。  