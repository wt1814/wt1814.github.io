
<!-- TOC -->

- [1. 计算机网络和负载均衡](#1-计算机网络和负载均衡)
    - [1.1. 计算机网络](#11-计算机网络)
        - [1.1.1. OSI七层网络模型](#111-osi七层网络模型)
        - [1.1.2. 应用层](#112-应用层)
            - [1.1.2.1. DNS](#1121-dns)
            - [1.1.2.2. HTTP](#1122-http)
            - [1.1.2.3. HTTPS](#1123-https)
        - [1.1.3. 传输层](#113-传输层)
            - [1.1.3.1. TCP](#1131-tcp)
                - [1.1.3.1.1. 连接建立阶段](#11311-连接建立阶段)
                    - [1.1.3.1.1.1. 连接建立](#113111-连接建立)
                    - [1.1.3.1.1.2. ★★★Http长短链接](#113112-★★★http长短链接)
                    - [1.1.3.1.1.3. TCP粘包](#113113-tcp粘包)
                - [1.1.3.1.2. 数据传输阶段](#11312-数据传输阶段)
        - [1.1.4. 网络的性能指标](#114-网络的性能指标)
    - [1.2. 负载均衡](#12-负载均衡)
        - [1.2.1. 负载均衡解决方案](#121-负载均衡解决方案)
        - [1.2.2. Nginx](#122-nginx)
            - [1.2.2.1. Nginx介绍](#1221-nginx介绍)
            - [1.2.2.2. Nginx使用](#1222-nginx使用)

<!-- /TOC -->

# 1. 计算机网络和负载均衡

## 1.1. 计算机网络
### 1.1.1. OSI七层网络模型
![image](http://182.92.69.8:8081/img/network/osi-2.png)  

### 1.1.2. 应用层
#### 1.1.2.1. DNS
1. **<font color = "clime">DNS解析流程：</font>** ...  
2. DNS将域名解析成ip，网络通信也即 ip:端口 间的通信。  

#### 1.1.2.2. HTTP
1. HTTP介绍  
    1. HTTP是无连接的、无状态的应用层协议。  
    2. `HTTP3个版本`。HTTP1.1新改动：持久连接；HTTP2新改动：多路复用...  
    &emsp; HTTP协议中1.0版本规范与1.1版本规范的区别是什么？  
    &emsp; 在HTTP1.0中，当建立连接后，客户端发送一个请求，服务器端返回一个信息后就关闭连接，当浏览器下次请求的时候又要建立连接。显然，这种不断建立连接的方式会造成很多问题。  
    &emsp; 在HTTP1.1中，引入了持续连接的概念。通过这种连接，浏览器可以在建立一个连接之后，发送请求并得到返回信息，然后继续发送请求再次等到返回信息。也就是说，客户端可以连续发送多个请求，而不用等待每一个响应的到来。  
    3. HTTP消息内容：  
        1. HTTP消息结构  
            1. HTTP的请求信息由四部分组成，分别是请求行、请求头、空行和请求数据。  
            &emsp; `HTTP的请求报文和响应报文包含哪些部分？`    
            &emsp; 请求报文包含3部分：（1）请求行，包含请求方法、URI、HTTP版本信息。（2）请求首部字段。（3）请求内容实体。   
            &emsp; 响应报文包含3部分：（1）状态行，包含HTTP版本、状态码、状态码的原因短语。（2）响应首部字段。（3）响应内容实体。    
            2. `HTTP请求头包含信息`：   
            &emsp; Accept：浏览器可接受的MIME类型。  
            &emsp; Accept-Charset：浏览器可接受的字符集。  
            &emsp; Accept-Encoding：浏览器能够进行解码的数据编码方式，比如gzip。Servlet能够向支持gzip的浏览器返回经gzip编码的HTML页面。许多情形下这可以减少5到10倍的下载时间。  
            &emsp; Accept-Language：浏览器所希望的语言种类，当服务器能够提供一种以上的语言版本时要用到。  
            &emsp; Authorization：授权信息，通常出现在对服务器发送的WWW-Authenticate头的应答中  
            &emsp; Connection：表示是否需要持久连接。  
            &emsp; Cookie：这是最重要的请求头信息之一  
            &emsp; Allow 服务器支持哪些请求方法（如GET、POST等）。  
        2. HTTP中GET与POST
        3. HTTP返回状态码
2. HTTP应用层协议：  
    1. 在浏览器地址栏键入URL，按下回车之后经历的流程：URL解析 ---> DNS解析 ---> TCP连接 ---> 发送HTTP请求 ---> 服务器处理请求并返回HTTP报文 ---> 浏览器解析渲染页面 ---> 连接结束。  
    2. Http与TCP  


#### 1.1.2.3. HTTPS
1. **<font color = "clime">HTTPS的整体过程分为证书验证、协商密钥、数据传输阶段。</font>**  
    ![image](http://182.92.69.8:8081/img/network/https-5.png)  
    1. 证书验证阶段，一次交互，客户端发送请求，获取到服务端的证书，并进行校验。若不合法，进行警告。  
    2. 协商密钥阶段，采取非对称加密。`客户端用公钥对随机数进行加密和传输`；`服务端用私钥解密随机数`，获取到随机数，完成连接。 **<font color = "clime">~~注：非对称加密的目的就是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密。~~</font>**  
    3. 完成连接后，采用对称加密进行数据传输。  
2. 本地随机数会被窃取嘛？  
&emsp; HTTPS并不包含对随机数的安全保证，HTTPS保证的只是传输过程安全，<font color = "red">而随机数存储于本地，本地的安全属于另一安全范畴。</font>  

### 1.1.3. 传输层
#### 1.1.3.1. TCP
##### 1.1.3.1.1. 连接建立阶段
###### 1.1.3.1.1.1. 连接建立
1. 连接建立
    1. 三次握手  
        ![image](http://182.92.69.8:8081/img/network/TCP-1.png)  
        1. 为什么只有三次握手才能确认双方的接受与发送能力是否正常，而两次却不可以？  
        &emsp; <font color = "clime">第三次握手中，客户端向服务器发送确认包ACK，`防止了服务器端的一直等待而浪费资源`。</font>例如：已失效的连接请求报文突然又传送到了服务器，从而会产生错误。  
    2. 四次挥手  
        ![image](http://182.92.69.8:8081/img/network/TCP-2.png)  
        1. **<font color = "clime">Client收到服务端F1N后，Client进入TIME_WAIT状态。</font>** 2MSL后自动关闭。 
        2. 为什么客户端最后还要等待2MSL？  
        &emsp; <font color = "red">保证客户端发送的最后一个`ACK报文`能够到达服务器，因为这个ACK报文可能丢失。</font>  
        &emsp; `站在服务器的角度看来，服务端已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是服务器发送的请求断开报文它没有收到，于是服务器又会重新发送一次。而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。`  
    &emsp;如果客户端收到服务端的FIN+ACK报文后，发送一个ACK给服务端之后就“自私”地立马进入CLOSED状态，可能会导致服务端无法确认收到最后的ACK指令，也就无法进入CLOSED状态，这是客户端不负责任的表现。  
    3. **<font color = "blue">`如果已经建立了连接，但是客户端突然出现故障了怎么办？`</font>**   
    &emsp; 客户端如果出现故障，服务器不能一直等下去，白白浪费资源。`在TCP设有一个保活计时器。`<font color = "clime">服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75分钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</font>  
2. TIME_WAIT问题
    1. TIME_WAIT状态，该socket所占用的本地端口号将一直无法释放。TIME_WAIT过多，可能出现做为客户端的程序无法向服务端建立新的socket连接的情况。  
    2. **大量的TIME_WAIT状态TCP连接存在，是因为大量的短连接存在。TIME_WAIT状态时socket还占用端口。** TIME_WAIT状态默认为2MSL。    
    3. 解决办法：
        1. 客户端  
        &emsp; **HTTP请求的头部，connection 设置为 keep-alive，** 保持存活一段时间：现在的浏览器，一般都这么进行了。     
        2. 服务器端  
            * **<font color = "red">允许time_wait状态的socket被重用。</font>**
            * 缩减time_wait时间，设置为 1 MSL（即2mins）。


###### 1.1.3.1.1.2. ★★★Http长短链接
1. TCP长连接  
	1. **<font color = "red">长连接，指在一个连接上可以连续发送多个数据包，在连接保持期间，如果没有数据包发送，需要双方发链路检测包。</font>**   
	&emsp; `长连接没有条件能够判断读写什么时候结束，所以必须要加报文头的长度。`读函数先是读取报文头的长度，再根据这个长度去读相应长度的报文。  
	2. 流程：TCP连接→数据包传输→保持连接(心跳)→数据传输→保持连接(心跳)→……→关闭连接（一个TCP连接通道有多个读写通信）。  
	![image](http://182.92.69.8:8081/img/network/TCP-4.png)   
	3. 优点：  
	&emsp; 可以省去较多的TCP建立和关闭的操作，减少浪费，节约时间。 
	4. 缺点：
	    * **<font color = "red">服务器端有很多TCP连接时，会降低服务器的性能。</font>**  
	    * 需要管理所有的TCP连接，`检测是否是无用的连接（长时间没有读写事件），并进行关闭等操作`。  
	&emsp; 解决方案：如关闭一些长时间没有读写事件发生的连接，这样可以避免一些恶意连接导致server端服务受损；如果条件再允许就可以以客户端机器为粒度，限制每个客户。
2. TCP短链接 
	1. 短连接是指通信双方有数据交互时，就建立一个TCP连接，数据发送完成后，则断开此TCP连接（管理起来比较简单，存在的连接都是有用的连接，不需要额外的控制手段）。  
	2. 流程：连接→数据传输→关闭连接→连接→数据传输→关闭连接。  
	![image](http://182.92.69.8:8081/img/network/TCP-5.png)   
	3. 优点：对于服务器来说管理较为简单，存在的连接都是有用的连接，不需要额外的控制手段。  
	4. 缺点：但如果客户请求频繁，将在TCP的建立和关闭操作上浪费较多时间和带宽。  
3. TCP长短连接使用场景：  
    1. **<font color = "red">长连接多用于操作频繁，点对点的通讯，而且连接数不能太多情况。</font>** 每个TCP连接都需要三次握手，这需要时间，如果每个操作都是短连接，再操作的话那么处理速度会降低很多，所以每个操作完后都不断开，下次处理时直接发送数据包就OK了，不用建立TCP连接。例如：数据库的连接用长连接，如果用短连接频繁的通信会造成socket错误，而且频繁的socket 创建也是对资源的浪费。  
    2. 像WEB网站的http服务一般都用短链接，因为长连接对于服务端来说会耗费一定的资源，像WEB网站这么频繁的成千上万甚至上亿客户端的连接用短连接会更省一些资源，如果用长连接，而且同时有成千上万的用户，如果每个用户都占用一个连接的话，那可想而知吧。所以并发量大，但每个用户无需频繁操作情况下需用短连好。  
4. HTTP长短连接  
&emsp; HTTP的长连接和短连接本质上是TCP长连接和短连接。  

###### 1.1.3.1.1.3. TCP粘包
1. **TCP是基于流传输的协议，请求数据在其传输的过程中是没有界限区分，所以在读取请求的时候，不一定能获取到一个完整的数据包。**  
2. **<font color = "red">TCP粘包/拆包常见解决方案：</font>** 
    * 每个包都固定长度。
    * 每个包的末尾使用固定的分隔符。
    * 将消息分为头部和消息体，在头部中保存有当前整个消息的长度。
    * 通过自定义协议进行粘包和拆包的处理。   

##### 1.1.3.1.2. 数据传输阶段

### 1.1.4. 网络的性能指标
&emsp; **<font color = "red">通常是以4个指标来衡量网络的性能，分别是`带宽、延时、吞吐率、PPS(Packet Per Second)`。</font>**  

## 1.2. 负载均衡
&emsp; 要想理解负载均衡，首先需要清楚OSI七层网络模型。  

### 1.2.1. 负载均衡解决方案
&emsp; **<font color = "clime">★★★负载均衡方案选择：</font>**  
* 小于3000万pv的，DNS轮询+监控；  
* **3000万以上的，nginx+监控；**  
&emsp; 5000万PV的，HAProxy+Keepalived,nginx，HAPROXY负责TCP的负载均衡，nginx负责7层调度；  
* **1亿以上的，LVS-DR+keepalived,nginx，LVS-DR负责TCP的负载均衡，nginx负责7层调度。**  

### 1.2.2. Nginx
#### 1.2.2.1. Nginx介绍
1. Nginx是一个高性能的Web服务器。同时处理大量的并发请求（可以处理2-3万并发连接数，官方监测能支持5万并发）。   
&emsp; <font color = "red">Nginx工作在4层或7层。</font> 
2. 多进程 
    1. Nginx启动时，会生成两种类型的进程，一个主进程master，一个（windows版本的目前只有一个）或多个工作进程worker。  
        * 主进程并不处理网络请求，主要负责调度工作进程：加载配置、启动工作进程、非停升级。  
        * **<font color = "red">`一般推荐worker进程数与CPU内核数一致，这样一来不存在大量的子进程生成和管理任务，避免了进程之间竞争CPU资源和进程切换的开销。`</font>**  
    2. <font color = "red">多进程的优缺点：</font>  
        1. 使用进程的好处是各个进程之间相互独立，不需要加锁，减少了使用锁对性能造成影响，同时降低编程的复杂度，降低开发成本。  
        2. 采用独立的进程，`可以让进程互相之间不会影响`，如果一个进程发生异常退出时，其它进程正常工作，master进程则很快启动新的worker进程，确保服务不会中断，从而将风险降到最低。     
        3. 缺点是操作系统生成一个子进程需要进行内存复制等操作，在资源和时间上会产生一定的开销。当有大量请求 时，会导致系统性能下降。   
3. 多路复用，Reactor

#### 1.2.2.2. Nginx使用
1. <font color = "red">Nginx服务器处理一个请求是按照两部分进行的。第一部分是IP和域名，由listen和server_name指令匹配server模块；第二部分是URL，匹配server模块里的location；最后就是location里的具体处理。</font>  
2. <font color = "red">Nginx使用场景：反向代理、虚拟主机、静态资源WEB服务、缓存、限流、黑白名单、防盗链、流量复制...</font>  
3. 负载均衡：  
    1. **<font color = "red">Nginx反向代理通过proxy_pass来配置；负载均衡使用Upstream模块实现。</font>**  
    &emsp; sever设置各个服务器，upstream 设置服务组，sever proxy_pass设置代理服务组  
    2. **<font color = "red">Nginx支持的负载均衡调度算法方式如下：</font>**  
        * **<font color = "red">轮询（默认）</font>** 
        * **<font color = "red">weight：</font>** 指定权重。  
        * **<font color = "red">ip_hash</font>**  
        * **<font color = "red">url_hash（第三方）</font>**  
        * **<font color = "red">fair（第三方）：</font>** 智能调整调度算法，动态的根据后端服务器的请求处理到响应的时间进行均衡分配。  

