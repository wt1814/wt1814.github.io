
<!-- TOC -->

- [1. JVM](#1-jvm)
    - [1.1. JDK、JRE、JVM](#11-jdkjrejvm)
    - [1.2. 编译成Class字节码文件](#12-编译成class字节码文件)
    - [1.3. 类加载](#13-类加载)
        - [1.3.1. JVM类的加载](#131-jvm类的加载)
        - [1.3.2. ~~JVM类加载器~~](#132-jvm类加载器)
    - [1.4. 运行时数据区/内存结构](#14-运行时数据区内存结构)
        - [1.4.1. JVM内存结构](#141-jvm内存结构)
            - [1.4.1.1. JVM内存结构](#1411-jvm内存结构)
            - [1.4.1.2. JVM栈](#1412-jvm栈)
            - [1.4.1.3. 逃逸分析](#1413-逃逸分析)
            - [1.4.1.4. 常量池详解](#1414-常量池详解)
            - [1.4.1.5. 直接内存](#1415-直接内存)
            - [1.4.1.6. 类存储内存小结](#1416-类存储内存小结)
                - [1.4.1.6.1. 变量](#14161-变量)
                - [1.4.1.6.2. 静态方法和实例方法](#14162-静态方法和实例方法)
        - [1.4.2. 内存(堆栈)中的对象](#142-内存堆栈中的对象)
            - [1.4.2.1. 创建对象](#1421-创建对象)
            - [1.4.2.2. 对象完整生命周期](#1422-对象完整生命周期)
            - [1.4.2.3. 对象大小](#1423-对象大小)
                - [1.4.2.3.1. 分析java对象的组成](#14231-分析java对象的组成)
        - [1.4.3. 内存泄露](#143-内存泄露)
        - [1.4.4. JVM参数配置](#144-jvm参数配置)
    - [1.5. JVM执行](#15-jvm执行)
    - [1.6. GC](#16-gc)
        - [1.6.1. GC-回收对象](#161-gc-回收对象)
        - [1.6.2. GC-回收位置/安全点](#162-gc-回收位置安全点)
        - [1.6.3. 回收算法与分代回收](#163-回收算法与分代回收)
        - [1.6.4. ~~跨代引用假说和卡表~~](#164-跨代引用假说和卡表)
        - [1.6.5. GC-垃圾回收器](#165-gc-垃圾回收器)
            - [1.6.5.1. 垃圾回收器](#1651-垃圾回收器)
            - [1.6.5.2. CMS回收器](#1652-cms回收器)
            - [1.6.5.3. G1回收器](#1653-g1回收器)
            - [1.6.5.4. 三色标记，并发标记阶段](#1654-三色标记并发标记阶段)
    - [1.7. JVM调优](#17-jvm调优)
        - [1.7.1. JVM调优-基础](#171-jvm调优-基础)
        - [1.7.2. JVM调优](#172-jvm调优)
        - [1.7.3. JVM问题排查](#173-jvm问题排查)
        - [1.7.4. Arthas工具](#174-arthas工具)

<!-- /TOC -->

# 1. JVM

## 1.1. JDK、JRE、JVM
![image](http://182.92.69.8:8081/img/java/JVM/JVM-4.png)  
1. JVM由4大部分组成：类`加载`器ClassLoader，运行时`数据区`Runtime Data Area，`执行`引擎Execution Engine，本地方法调用Native Interface。  
2. **<font color = "clime">JVM各组件的作用（JVM执行程序的过程）：</font>**   
    1. 首先通过类加载器（ClassLoader）把Java代码转换成字节码；  
    2. 运行时数据区（Runtime Data Area）再把字节码加载到内存中；  
    3. <font color = "red">而字节码文件只是JVM的一套指令集规范，并不能直接交给底层操作系统去执行，因此`需要特定的命令解析器执行引擎（Execution Engine），将字节码翻译成底层系统指令，再交由CPU去执行；`</font>  
    4. 而这个过程中需要调用其他语言的本地库接口（Native Interface）来实现整个程序的功能。  

## 1.2. 编译成Class字节码文件
&emsp; ......

## 1.3. 类加载
### 1.3.1. JVM类的加载
1. 类加载流程：  
![image](http://182.92.69.8:8081/img/java/JVM/JVM-5.png)  
2. 加载：查找并加载类的二进制数据。加载主要做三件事：找到类文件 -> 放入方法区 -> 开个入口（最后生成一个代表此类的java.lang.Class对象，作为访问方法区内的数据结构的入口）。  
&emsp; **<font color = "red">一句话概括：把代码数据加载到内存中，加载完成后，在方法区实例化一个对应的Class对象。</font>**  
3. 验证：确保被加载的类的正确性。验证阶段大致会完成4个阶段的检验动作：1. 文件格式验证、2. 元数据验证、3. 字节码验证、4. 符号引用验证。  
4. 准备(Preparation)  
&emsp; <font color = "red">为类的静态变量分配内存，并将其初始化为默认值，这些内存都将在方法区中分配。</font>对于该阶段有以下几点需要注意：  
    1. <font color = "red">这时候进行内存分配的仅包括类变量(`static`)，而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。</font>  
    2. <font color = "red">这里所设置的初始值"通常情况"下是数据类型默认的零值(如0、0L、null、false等)，比如定义了public static int value=111 ，那么 value 变量在准备阶段的初始值就是 0 而不是111(初始化阶段才会复制)。</font>  
    * <font color = "red">特殊情况：比如给value变量加上了fianl关键字public static final int value=111，那么准备阶段value的值就被赋值为 111。</font>  
5. 解析(Resolution)： **<font color = "red">将常量池内的符号引用转换为直接引用</font>** ，得到类或者字段、方法在内存中的指针或者偏移量，确保类与类之间相互引用正确性，完成内存结构布局，以便直接调用该方法。  
&emsp; `为什么要用符号引用呢？` **<font color = "blue">这是因为类加载之前，javac会将源代码编译成.class文件，这个时候javac是不知道被编译的类中所引用的类、方法或者变量它们的引用地址在哪里，所以只能用符号引用来表示。</font>**  
&emsp; **<font color = "clime">解析过程在某些情况下可以在初始化阶段之后再开始，这是为了支持Java的动态绑定。</font>**   
6. 初始化：执行`static`代码块(cinit)进行初始化，如果存在父类，先对父类进行初始化。  
7. 从class文件与JVM加载机制理解final、static、static final  

### 1.3.2. ~~JVM类加载器~~
1. <font color = "red">小结：</font>ClassLoader3个主要方法 ---> loadClass()双亲委派模型 ---> 继承关系（默认提供三个类加载器）
1. java.lang.ClassLoader中`3个主要方法`  
    * loadClass() 就是主要进行类加载的方法，默认的双亲委派机制就实现在这个方法中。
    * findClass() 根据名称或位置加载.class字节码
    * definclass() 把字节码转化为Class
2. `双亲委派模型`，一个类加载器首先将类加载请求转发到父类加载器，只有当父类加载器无法完成时才尝试自己加载。  
&emsp; 双亲委派模型中，类加载器之间的父子关系一般不会以继承（Inheritance）的关系来实现，而是使用`组合关系来复用父加载器`的代码的。  
&emsp; `好处`：避免类的重复加载；防止核心API被随意篡改。   
3. ~~破坏双亲委派模型：（重新研究）~~  
    1. 破坏双亲委派模型的方式  
        1. 继承ClassLoader，重写loadClass()方法。  
        2. `使用线程上下文类加载器(Thread Context ClassLoader)`  
    2. 破坏双亲委派模型的例子  
        1. `双亲委派模型有一个问题：顶层ClassLoader无法加载底层ClassLoader的类，典型例子JNDI、JDBC。`
            * **<font color = "clime">JDBC是启动类加载器加载，但 mysql 驱动是应用类加载器，而 JDBC 运行时又需要去访问子类加载器加载的驱动，就破坏了该模型。所以加入了`线程上下文类加载器(Thread Context ClassLoader)`，</font>** 可以通过Thread.setContextClassLoaser()设置该类加载器，然后顶层ClassLoader再使用Thread.getContextClassLoader()获得底层的ClassLoader进行加载。  
        2. Tomcat中使用了自定义ClassLoader，使得一个Tomcat中可以加载多个应用。一个Tomcat可以部署N个web应用，但是每个web应用都有自己的classloader，互不干扰。比如web1里面有com.test.A.class，web2里面也有com.test.A.class，`如果没打破双亲委派模型的话，那么web1加载完后，web2再加载的话会冲突。`    
        3. Spring破坏类加载器  
4. `继承树`：
    1. JVM默认提供三个类加载器：启动类加载器、扩展类加载器、应用类加载器。    
    2. ~~`自定义类加载器`：需要继承自ClassLoader，`重写方法findClass()`。~~   
5. `小结`：     
    1. `破坏双亲委派模型`：继承ClassLoader，`重写loadClass()方法`；或`使用线程上下文类加载器(Thread Context ClassLoader)`。    
    2. `自定义类加载器`：需要继承自ClassLoader，`重写方法findClass()`。   

## 1.4. 运行时数据区/内存结构
### 1.4.1. JVM内存结构
#### 1.4.1.1. JVM内存结构
1. &emsp; **<font color = "red">小结：</font>**  运行时数据区。【线程独享】：程序计数器、JVM栈、本地方法栈；【线程共享区】：堆、方法区（元空间）。  
2. 程序计数器看作是当前线程所执行的字节码的行号指示器。  
3. <font color = "red">JVM栈描述Java方法执行的内存模型。</font>Java虚拟机栈中出栈入栈的元素称为“栈帧”，栈对应线程，栈帧对应方法。每个方法被执行的时候，都会创建一个栈帧，把栈帧压入栈，当方法正常返回或者抛出未捕获的异常时，栈帧就会出栈。    
&emsp; Java虚拟机栈是由一个个栈帧组成，每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息。局部变量表存储八大原始类型、对象引用、returnAddress。栈帧存储方法需要的数据。  
&emsp; `为什么不把基本类型放堆中呢？`   
&emsp; 因为其占用的空间一般是 1~8 个字节——需要空间比较少，而且因为是基本类型，所以不会出现动态增长的情况——长度固定，因此栈中存储就够了。  
4. 堆  
    1. 堆分为新生代、老年代，默认比例1: 2。 新生代又按照8: 1: 1划分为Eden区和两个Survivor区。  
    2. **<font color = "blue">在Eden区中，JVM为每个线程分配了一个私有缓存区域[TLAB(Thread Local Allocation Buffer)](/docs/java/JVM/MemoryObject.md)。</font>**    
    3. 堆是分配对象存储的唯一选择吗？[逃逸分析](/docs/java/JVM/escape.md)  
5. 方法区：
    1. 在类加载阶段，在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口。  
    2. <font color = "clime">方法区的演进：</font>  
        1. 为什么JDK1.8移除永久代  
            1. 由于PermGen内存经常会溢出，引发java.lang.OutOfMemoryError: PermGen，因此JVM的开发者希望这一块内存可以更灵活地被管理，不要再经常出现这样的OOM。  
            2. 移除PermGen可以促进HotSpot JVM与JRockit VM的融合，因为JRockit没有永久代。  
        2. 演进历程：  
            * jdk1.6及之前：有永久代(permanent generation)。静态变量存放在永久代上。  
            * jdk1.7：有永久代，但已经逐步“去永久代”。[字符串常量池](/docs/java/JVM/ConstantPool.md) <font color = "red">、静态变量</font>移除，保存在堆中。  
            * jdk1.8及之后：无永久代。类型信息、字段、方法、<font color = "red">常量</font>保存在本地内存的元空间，<font color = "clime">但字符串常量池、静态变量仍在堆。</font>  
6. MetaSpace存储类的元数据信息。  
&emsp; 元空间与永久代之间最大的区别在于：元数据空间并不在虚拟机中，而是使用本地内存。元空间的内存大小受本地内存限制。  
7. 直接内存（非JVM控制）  
&emsp; 直接内存的大小并不受到java堆大小的限制，甚至不受到JVM进程内存大小的限制。它只受限于本机总内存（RAM及SWAP区或者分页文件）大小以及处理器寻址空间的限制（最常见的就是32位/64位CPU的最大寻址空间限制不同）。  
&emsp; DirectByteBuffer使用直接内存的原因有两点：  
&emsp; 1） 这块内存真正的分配并不在 Java 堆中，堆中只有一个很小的对象引用，这种方式能减轻 GC 压力  
&emsp; 2） 对于堆内对象，进行IO操作（Socket、文件读写）时需要先把对象复制一份到堆外内存再写入 Socket 或者文件，而当 DirectByteBuffer 就在堆外分配内存时可以省掉一次从堆内拷贝到堆外的操作，减少用户态到内核态的操作，性能表现会更好  
&emsp; 直接内存的回收：需注意堆外内存并不直接控制于JVM，这些内存只有在DirectByteBuffer回收掉之后才有机会被回收，而 Young GC 的时候只会将年轻代里不可达的DirectByteBuffer对象及其直接内存回收，如果这些对象大部分都晋升到了年老代，那么只能等到Full GC的时候才能彻底地回收DirectByteBuffer对象及其关联的堆外内存。因此，堆外内存的回收依赖于 Full GC  

#### 1.4.1.2. JVM栈
1. <font color = "red">JVM栈描述Java方法执行的内存模型。</font>Java虚拟机栈是线程私有的。Java虚拟机栈会出现两种异常：StackOverFlowError和OutOfMemoryError。    
2. 【方法】栈  
&emsp; Java虚拟机栈中出栈入栈的元素称为“栈帧”，栈对应线程，栈帧对应方法。每个方法被执行的时候，都会创建一个栈帧，把栈帧压入栈，当方法正常返回或者抛出未捕获的异常时，栈帧就会出栈。  
3. 方法【栈】  
    &emsp; <font color = "red">Java虚拟机栈是由一个个栈帧组成，每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息。</font>  
    * 局部变量表，局部变量表用于保存函数参数和局部变量。  
    * 操作数栈，操作数栈用于保存计算过程的中间结果，作为计算过程中变量临时的存储空间。  
    * 动态连接：每个栈帧中包含一个在常量池中对当前方法的引用， 目的是支持方法调用过程的动态连接。  
    * 方法返回地址
4. `为什么不把基本类型放堆中呢？`   
&emsp; 因为其占用的空间一般是 1~8 个字节——需要空间比较少，而且因为是基本类型，所以不会出现动态增长的情况——长度固定，因此栈中存储就够了。  

#### 1.4.1.3. 逃逸分析
1. <font color = "red">通过逃逸分析算法可以分析出某一个方法中的某个对象是否会被其它方法或者线程访问到。</font>如果分析结果显示某对象并不会被其他方法引用或被其它线程访问，则有可能在编译期间做一些深层次的优化。   
2. 对于NoEscape（ **<font color = "clime">没有逃逸</font>** ）状态的对象不一定分配在堆中，具体会有这种优化情况：   
    1. 对象可能分配在栈上。  
    2. `分离对象或标量替换。`  
    &emsp; **<font color = "clime">在HotSpot中并没有真正的实现"栈"中分配对象的功能，取而代之的是一个叫做"标量替换"的折中办法。</font>**  
    &emsp; 什么是标量？标量，不可再分，基本数据类型；相对的是聚合量，可再分，引用类型。  
    &emsp; **当JVM通过逃逸分析，确定要将对象分配到栈上时，即时编译可以将对象打散，将对象替换为一个个很小的局部变量，将这个打散的过程叫做标量替换。** 
    3. 消除同步锁：**<font color = "red">如果JVM通过逃逸分析，发现一个对象(局部变量)只能从一个线程被访问到，则访问这个对象时，可以不加同步锁。</font>** 如果程序中使用了synchronized锁，则JVM会将synchronized锁消除。  

#### 1.4.1.4. 常量池详解
&emsp; **<font color = "clime">常量池分为以下三种：class文件常量池、运行时常量池、全局字符串常量池。</font>**   

#### 1.4.1.5. 直接内存  


#### 1.4.1.6. 类存储内存小结
##### 1.4.1.6.1. 变量
1. 常量final static
2. 静态变量static
3. 全局变量
4. 局部变量 

##### 1.4.1.6.2. 静态方法和实例方法
&emsp; `静态方法`会在程序运行的时候`直接装载进入方法区`。而实例方法会在new的时候以对象的方法装载进入堆中。  
&emsp; 最大的区别在于内存的区别，由于main函数为static静态方法，会直接在运行的时候装载进入内存区，实例方法必须new，在堆中创建内存区域，再进行引用。  

-------------  

&emsp; 一、 静态方法常驻内存，实例方法不是，所以静态方法效率高但占内存。  
&emsp; 事实上，方法都是一样的，在加载时机和占用内存上，静态方法和实例方法是一样的，在类型第一次被使用时加载。调用的速度基本上没有差别。  

&emsp; 二、 静态方法在堆上分配内存，实例方法在堆栈上。   
&emsp; 事实上所有的方法都不可能在堆或者堆栈上分配内存，方法作为代码是被加载到特殊的代码内存区域，这个内存区域是不可写的。  

&emsp; 三、 实例方法需要先创建实例才可以调用，比较麻烦，静态方法不用，比较简单。  
&emsp; 事实上如果一个方法与他所在类型的实例无关，那么它就应该是静态的，决不会有人把它写成实例方法。所以所有的实例方法都与实例有关，既然与实例有关，那么创建实例就是必然的步骤，没有麻烦简单一说。实际上上你可以把所有的实例方法都写成静态的，将实例作为参数传入即可。  
&emsp; 有些方法看似与所在的实例无关，如IComparer.Compare方法，但实际上每一个实现这个接口的类都只会负责自己类型实例的比较，这是C#1.x规范中没有泛型所带来的历史遗留问题。  
&emsp; 大部分静态方法是与类的实例有关的，如各种Parse方法，他做成静态的原因是他没有实例作为参数。其他的大多是出于语义或者其他目的的考虑。  


### 1.4.2. 内存(堆栈)中的对象
#### 1.4.2.1. 创建对象
1. **<font color = "clime">创建对象过程：1. 检测类`是否被加载`；2. 为对象`分配内存`；3. 将分配内存空间的对象`初始化零值`；4. 对对象进行`其他设置`；5.执行`init方法`。</font>**   

    &emsp; 当类加载完成之后，紧接着就是对象分配内存空间和初始化的过程。  
        首先为对象分配合适大小的内存空间
        接着为实例变量赋默认值
        设置对象的头信息，对象hash码、GC分代年龄、元数据信息等
        执行构造函数(init)初始化

2. 步骤二：对象分配内存流程详解：
    * 分配内存两种方式：指针碰撞（内存空间绝对规整）；空闲列表（内存空间是不连续的）。
        * 标记-整理或复制 ---> 空间规整 ---> 指针碰撞； 
        * 标记-清除 ---> 空间不规整 ---> 空闲列表。       
    * 线程安全问题：1).采用CAS； **<font color = "clime">2).线程本地分配缓冲（TLAB）。</font>**  
    * **<font color = "blue">TLAB详解：</font>**  
        * 线程本地分配缓存，这是一个线程专用的内存分配区域。可以加速对象的分配。TLAB是在堆中开辟的内存区域。默认情况下，TLAB空间的内存非常小，仅占有整个Eden空间的1%。  
        * **<font color = "blue">TLAB通常很小，所以放不下大对象。`JVM设置了最大浪费空间`。</font>**  
        &emsp; 当大对象申请内存时，当剩余的空间小于最大浪费空间，那该TLAB属于的线程再重新向Eden区申请一个TLAB空间。进行对象创建，还是空间不够，那这个对象太大了，去Eden区直接创建吧！  
        &emsp; 当剩余的空间大于最大浪费空间，那这个大对象直接去Eden区创建。剩余空间还需要使用。
    * **<font color = "blue">`内存分配全流程：`逃逸分析 ---> 没有逃逸，尝试栈上分配 ---> 是否满足直接进入老年代的条件 ---> `尝试TLAB分配` ---> `新生代Eden区分配`。</font>**  
3. 堆内存分配策略：  
&emsp; 分配策略有：对象优先在Eden分配、大对象直接进入老年代、长期存活的对象将进入老年代、动态对象年龄判定、空间分配担保。  
&emsp; `空间分配担保：` **<font color = "clime">JVM在发生Minor GC之前，虚拟机会检查老年代最大可用的`连续空间`是否大于新生代所有对象的总空间。</font>**   


#### 1.4.2.2. 对象完整生命周期
&emsp; 在Java中，对象的生命周期包括以下几个阶段：  
1. 创建阶段(Created)  
2. 应用阶段(In Use)
3. 不可见阶段(Invisible)
4. 不可达阶段(Unreachable)
5. 收集阶段(Collected)
6. 终结阶段(Finalized)
7. 对象空间重分配阶段(De-allocated)


#### 1.4.2.3. 对象大小
##### 1.4.2.3.1. 分析java对象的组成
1. `对象内存大小原理：`在JVM中，对象在内存中的布局分为三块区域：对象头、实例数据和对齐填充。  
    * 实例数据：存放类的属性数据信息，包括父类的属性信息，如果是数组的实例部分还包括数组的长度，这部分内存按4字节对齐。    
    * 对齐填充：JVM要求对象起始地址必须是8字节的整数倍（8字节对齐）。填充数据不是必须存在的，仅仅是为了字节对齐。   
2. JVM中对象头的方式有以下两种（以32位JVM为例。注：1字节是8位）  
    * 普通对象：  
    ![image](http://182.92.69.8:8081/img/java/concurrent/multi-60.png)   
    * 数组对象：  
    ![image](http://182.92.69.8:8081/img/java/concurrent/multi-61.png)   

    对象头：包含Mark Word、class pointer、array length共3部分。  
    1. Mark Word：  
    &emsp; **<font color = "red">由于对象头信息是与对象自身定义的数据无关的额外存储成本，考虑到Java虚拟机的空间使用效率，</font>** **<font color = "clime">Mark Word被设计成一个非固定的动态数据结构，</font>** 以便在极小的空间内存储尽量多的信息。它会根据对象的状态复用自己的存储空间。  
    &emsp; 这部分主要用来存储对象自身的运行时数据，如hashcode、gc分代年龄等。mark word的位长度为JVM的一个Word大小，也就是说32位JVM的Mark word为32位，64位JVM为64位。为了让一个字大小存储更多的信息，JVM将字的最低两个位设置为标记位，
    ![image](http://182.92.69.8:8081/img/java/concurrent/multi-67.png)   

    ![image](http://182.92.69.8:8081/img/java/concurrent/multi-68.png)   
    2. class pointer：  
    &emsp; 这一部分用于存储对象的类型指针，该指针指向它的类元数据，JVM通过这个指针确定对象是哪个类的实例。该指针的位长度为JVM的一个字大小，即32位的JVM为32位，64位的JVM为64位。 
    3. array length：  
    &emsp; 如果对象是一个数组，那么对象头还需要有额外的空间用于存储数组的长度，这部分数据的长度也随着JVM架构的不同而不同：32位的JVM上，长度为32位；64位JVM则为64位。64位JVM如果开启+UseCompressedOops选项，该区域长度也将由64位压缩至32位。  


### 1.4.3. 内存泄露
1. 内存溢出与内存泄露  
&emsp; **<font color = "red">内存溢出out of memory</font>** ，是指<font color = "red">程序在申请内存时，`没有足够的内存空间供其使用`</font>，出现out of memory。  
&emsp; **<font color = "blue">内存泄露memory leak</font>** ，是指<font color = "red">程序在申请内存后，`无法释放已申请的内存空间`</font>。一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存，迟早会被占光。内存泄露，会导致频繁的Full GC。  
&emsp; 所以内存泄漏可能会导致内存溢出，但内存溢出并不完全都是因为内存泄漏，也有可能使用了太多的大对象导致。  
2. 内存溢出影响  
&emsp; **<font color = "clime">问题：`JVM堆内存溢出后，其他线程是否可继续工作？`</font>**  
&emsp; 当一个线程抛出OOM异常后，它所占据的内存资源会全部被释放掉，从而不会影响其他线程的运行！  
&emsp; **<font color = "red">其实发生OOM的线程一般情况下会死亡，也就是会被终结掉，该线程持有的对象占用的heap都会被gc了，释放内存。</font><font color = "clime">因为`发生OOM之前要进行gc，就算其他线程能够正常工作，也会因为频繁gc产生较大的影响。`</font>**  
3. 内存溢出的原因及解决方法小结  
4. `~~堆外内存泄漏~~`


### 1.4.4. JVM参数配置  
&emsp; 8g的机器一般分配一半的最大内存就可以了，因为机器本上还要占用一定内存。    
&emsp; 设置3g的新生代内存空间。  


## 1.5. JVM执行
&emsp; ...

## 1.6. GC
&emsp; ★★★`垃圾回收器`在`安全点`采用`回收算法`回收`对象`。  

### 1.6.1. GC-回收对象
1. 回收堆中对象：  
	1. 对象存活标准（什么对象能被回收？）
		1. ~~引用计数法、根可达性分析法~~(无法解决循环引用的问题)  
			1. **<font color = "clime">不可回收对象包含 1). 方法区中，类静态属性(static)引用的对象； 2). 方法区中，常量(final static)引用的对象；</font>** 
			2. `由以上可得java 全局变量 不可被回收。`  
		2. 四种引用  
			* 强引用  
			* **<font color = "red">软引用：SoftReference object=new  SoftReference(new Object()); 。当堆使用率临近阈值时，才会去回收软引用的对象。</font>**  
			* **<font color = "red">弱引用：WeakReference object=new  WeakReference (new Object();，ThreadLocal中有使用。只要发现弱引用，不管系统堆空间是否足够，都会将对象进行回收。</font>**  

					软引用和弱引用的使用：
					软引用，弱引用都非常适合来保存那些可有可无的缓存数据，如果这么做，当系统内存不足时，这些缓存数据会被回收，不会导致内存溢出。而当内存资源充足时，这些缓存数据又可以存在相当长的时间，从而起到加速系统的作用。  
					假如⼀个应⽤需要读取⼤量的本地图⽚，如果每次读取图⽚都从硬盘读取会严重影响性能，如果⼀次性全部加载到内存⼜可能造成内存溢出，这时可以⽤软引⽤解决这个问题。  

			* 虚引用：PhantomReference。虚引用是所有类型中最弱的一个。 **<font color = "red">一个持有虚引用的对象，和没有引用几乎是一样的，随时可能被垃圾回收器回收。</font>**    
	2. 对象生存还是死亡（Object#finalize()方法）？（怎么回收？）  
	&emsp; **<font color = "clime">如果有必要执行父类`Object#finalize()`方法，放入F-Queue队列；收集器将对F-Queue队列中的对象进行第二次小规模的标记；如果对象在执行finalize()方法时重新与引用链上的任何一个对象建立关联则逃脱死亡，否则执行死亡。</font>**  
	&emsp; ~~finalize 是 Object 类中的一个基础方法，它的设计目的是保证对象在被垃圾收集前完成特定资源的回收的，但其执行“不稳定”，且有一定的性能问题，已经在 JDK 9 中被设置为弃用的方法了。~~  
2. 回收方法区（类和常量）/类的卸载阶段  
	1. Java虚拟机规范对方法区是否实现垃圾回收没有做出强制的规定。存在未实现或未能完整实现方法区类型卸载的垃圾回收器（例如JDK 11的zGC收集器）。  
	&emsp; 方法区的回收效果比较难令人满意，条件很苛刻，但是回收又是很有必要的。在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。  
	
	2. 方法区的垃圾收集主要回收两部分：废弃的常量和不再使用的类型。  
	3. 类的卸载
		1. 类需要同时满足下面3个条件才能算是 “无用的类” ：  
			* 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。
			* 加载该类的 ClassLoader 已经被回收。
			* 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。
		2. `一个类何时结束生命周期，取决于代表它的Class对象何时结束生命周期。`   
		&emsp; 注：`由java虚拟机自带的三种类加载加载的类在虚拟机的整个生命周期中是不会被卸载的，`由用户自定义的类加载器所加载的类才可以被卸载。     
		3. `方法区是在Full GC时回收。`  
		&emsp; Full GC：收集整个堆，包括新生代，老年代，永久代(在 JDK 1.8 及以后，永久代被移除，换为 metaspace 元空间)等所有部分的模式。  
3. null与GC：  
&emsp; 《深入理解Java虚拟机》作者的观点：在需要“不使用的对象应手动赋值为null”时大胆去用，但不应当对其有过多依赖，更不能当作是一个普遍规则来推广。  
&emsp; **<font color = "red">虽然代码片段已经离开了变量xxx的`作用域`，但在此之后，没有任何对运行时栈的读写，placeHolder所在的索引还没有被其他变量重用，所以GC判断其为存活。</font>**    
&emsp; 加上`int replacer = 1;`和将placeHolder赋值为null起到了同样的作用：断开堆中placeHolder和栈的联系，让GC判断placeHolder已经死亡。    
&emsp; “不使用的对象应手动赋值为null”的原理，一切根源都是来自于JVM的一个“bug”：代码离开变量作用域时，并不会自动切断其与堆的联系。     

### 1.6.2. GC-回收位置/安全点
1. 安全点  
&emsp; **<font color = "clime">可达性分析算法必须是在一个确保一致性的内存快照中进行。</font>**   
&emsp; **<font color = "clime">安全点意味着在这个点时，所有工作线程的状态是确定的，JVM可以安全地执行GC。</font>**  
2. `安全区域和线程中断`   
&emsp; `在安全点上中断的是活跃运行的用户线程，对于已经挂起的线程该怎么处理呢？`**<font color = "blue">已经挂起的线程会被认定为处在安全区域内，中断的时候不需要考虑安全区域中的线程。</font>**  
&emsp; 当前安全区域的线程要被唤醒离开安全区域时，先检查能否离开，如果GC完成了，那么线程可以离开，否则它必须等待直到收到安全离开的信号为止。  

### 1.6.3. 回收算法与分代回收
1. 思想：算法  
    1. 各种GC算法：  
        * **<font color = "clime">标记-清除算法分为两个阶段：标记阶段和清除阶段。</font>** 不足：清除过程中，`扫描两次`，效率不高；清除后，产生`空间碎片`。  
        * `复制：1).（非标记-复制）只扫描一次；` 2). 没有碎片，空间连续； 3). 50%的内存空间始终空闲浪费。  
        * 标记-整理：1). 没有碎片，空间连续； 2). 不会产生内存减半； 3). 扫描两次，指针需要调整(移动对象)，效率偏低。  
        &emsp; **<font color = "clime">标记-清除和标记-整理都需要扫描两次。</font>**   
    2. 分代回收：  
        * 新生代采用复制算法，新生代存活率低，存活对象少。
        * 老年代采用标记-整理算法。 
            * 标记-清除算法效率高，搬运对象也比较少。`  
            * **<font color = "clime">注意：CMS回收老年代，但采用标记-清除算法；CMS收集器也会在内存空间的碎片化程度已经大到影响对象分配时（晋升失败(promotion failed) 或 并发模式失败(concurrent mode failure)），采用标记-整理算法收集一次，以获得规整的内存空间。</font>**    
2. 分代回收流程：各种GC（YGC、Full GC）执行流程   
    * `Partial GC(局部 GC)：并不收集整个 GC 堆的模式。`  
        * Young GC：只收集 Young Gen 的 GC，Young GC 还有种说法就叫做 Minor GC。  
        * Old GC：只收集 old gen 的 GC，只有垃圾收集器 CMS 的 concurrent collection 是这个模式。  
        * Mixed GC：收集整个 Young Gen 以及部分 old gen 的 GC，只有垃圾收集器 G1 有这个模式。  
    * `Full GC：收集整个堆，包括新生代，老年代，永久代(在 JDK 1.8 及以后，永久代被移除，换为 metaspace 元空间)等所有部分的模式。`  
3. YGC触发时机：eden区快要被占满的时候；在full gc前会让先执行以下young gc。  
4. Full GC  
&emsp; **<font color = "red">Full GC的触发时机：（老年代或永久代不足 ---> 老年代不满足年轻代晋升 ---> 回收器(例如CMS)---> 系统调用 ）</font>**   
    1. 老年代或永久代的`不足`
        1. 老年代空间不足(92%)  
        &emsp; 老年代空间不足的常见场景为大对象直接进入老年代、长期存活的对象进入老年代等。  
        &emsp; 为了避免以上原因引起的Full GC，应当尽量不要创建过大的对象以及数组。除此之外，可以通过-Xmn虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。还可以通过 -XX:MaxTenuringThreshold调大对象进入老年代的年龄，让对象在新生代多存活一段时间。  
        2. JDK 1.7及以前的永久代空间不足  
        &emsp; 为避免以上原因引起的Full GC，可采用的方法为增大永久代空间或转为使用CMS GC。  
    2. 老年代`不满足`年轻代晋升  
        1. 统计得到的Minor GC晋升到旧生代的`平均大小`大于旧生代的剩余空间  
        &emsp; Hotspot为了避免由于新生代对象晋升到旧生代导致旧生代空间不足的现象，在进行Minor GC时，做了一个判断，如果之前统计所得到的Minor GC晋升到旧生代的平均大小大于旧生代的剩余空间，那么就直接触发Full GC。  
        2. 空间分配担保失败  
        &emsp; **<font color = "clime">JVM在发生Minor GC之前，虚拟机会检查老年代最大可用的`连续空间`是否大于新生代所有对象的`总空间`，</font>** 如果大于，则此次Minor GC是安全的；如果小于，则虚拟机会查看HandlePromotionFailure设置项的值是否允许担保失败。如果HandlePromotionFailure=true，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小，如果大于则尝试进行一次Minor GC，但这次Minor GC依然是有风险的；如果小于或者HandlePromotionFailure=false，则改为进行一次Full GC。   
    3. CMS GC时出现promotion failed（晋升失败）和concurrent mode failure（并发模式失败）  
    &emsp; 执行CMS GC的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是GC过程中浮动垃圾过多导致暂时性的空间不足），便会报Concurrent Mode Failure错误，并触发Full GC。  
    4. <font color = "red">系统调用System.gc()</font>  
    &emsp; 只是建议虚拟机执行Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。  

### 1.6.4. ~~跨代引用假说和卡表~~
1. 跨代引用假说（跨代引用相对于同代引用仅占少数）  
&emsp; **既然跨代引用只是少数，那么就没必要去扫描整个老年代，也不必专门记录每一个对象是否存在哪些跨代引用，只需在新生代上建立一个全局的数据结构，称为记忆集(Remembered Set)，这个结构把老年代划分为若干个小块，标识出老年代的哪一块内存会存在跨代引用。此后当发生Minor GC时，只有包含了跨代引用的小块内存里的对象才会被加入GC Roots进行扫描。**  
&emsp; `卡表是记忆集的一种实现方式。`  

### 1.6.5. GC-垃圾回收器
#### 1.6.5.1. 垃圾回收器
1. 根据收集器的指标（性能考虑因素）分类（`两个关键指标，停顿时间和吞吐量`）：  
    * **<font color = "clime">吞吐量：运行用户代码时间/(运行用户代码时间+垃圾收集时间)。</font>**  
    * 停顿时间：执行垃圾收集时，程序的工作线程被暂停的时间。  
    * 内存占有（堆空间）：Java堆区所占的内存大小。  
    * 垃圾收集开销：吞吐量的补数，垃圾收集器所占时间与总时间的比例。  
    * 收集频率：相对于应用程序的执行，收集操作发生的频率。  
    * 快速：一个对象从诞生到被回收所经历的时间。  

    &emsp; <font color  = "red">其中内存占用、吞吐量和停顿时间，三者共同构成了一个“不可能三角”。</font>    
    &emsp; 停顿时间越短就越适合需要和用户交互的程序，良好的响应速度能提升用户体验；  
    &emsp; 高吞吐量则可以高效地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。  
2. 根据运行时，线程执行方式分类：  
    * 串行收集器 -> Serial和Serial Old  
    &emsp; **<font color = "red">只能有一个垃圾回收线程执行，用户线程暂停。</font>** 适用于内存比较小的嵌入式设备 。  
    * 并行收集器【吞吐量优先】 -> Parallel Scanvenge、Parallel Old  
    &emsp; **<font color = "red">多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。</font>** 适用于科学计算、后台处理等交互场景 。  
    * 并发收集器【停顿时间优先】 -> CMS、G1  
    &emsp; **<font color = "red">用户线程和垃圾收集线程同时执行</font><font color = "blue">（但并不一定是并行的，可能是交替执行的），</font><font color = "red">垃圾收集线程在执行的时候不会停顿用户线程的运行。</font>** `适用于相对时间有要求的场景，比如Web`。  
3. `JDK 7u4后的7和JDK8默认使用的都是ParallelScavenge+ParallelOld。`  
4. `根据实际情况选择合适垃圾收集器`  
&emsp; 堆内存4G以下可以用parallel，4-8G可以用ParNew + CMS，8G以上可以用G1，几百级以上用ZGC。


#### 1.6.5.2. CMS回收器
1. **<font color = "clime">CMS在某些阶段是并发，即CMS GC时并不是全部并发执行。大部分并发，但也有停顿(STW)，只是停顿时间更少。因为CMS是并发收集器，为了不影响用户线程使用，所以采用标记-清除算法。</font>**   
2. CMS GC`执行流程`：(**<font color = "clime">3次标记、2次清除</font>**)  
    1. 初始标记：标记GCRoots能直接关联到的对象。   
    2. 并发标记：进行GCRoots Tracing（可达性分析）过程，GC与用户线程并发执行。
    3. 预清理：（`三色标记法的漏标问题处理`） **<font color = "red">这个阶段是用来</font><font color = "blue">处理</font><font color = "clime">前一个并发标记阶段因为引用关系改变导致没有标记到的存活对象的。如果发现对象的引用发生变化，则JVM会标记堆的这个区域为Dirty Card。那些能够从Dirty Card到达的对象也被标记（标记为存活），当标记做完后，这个Dirty Card区域就会消失。</font>**  
    4. 可终止的预处理。这个阶段尝试着去承担下一个阶段Final Remark阶段足够多的工作。  
    5. 重新标记（remark）：修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录。会触发stop the word。  
    6. 并发清除：并发、标记-清除，GC与用户线程并发执行。   
    7. 并发重置。
3. CMS的`优缺点`：  
    1. 划时代的并发收集器。`关注停顿时间。`    
    2. `吞吐量低。`并发执行，线程切换。  
    3. **<font color = "blue">并发执行，`产生浮动垃圾（参考三色标记法中“错标”）`。</font>** ~~无法处理浮动垃圾(在并发标记和并发清理阶段又产生垃圾，这种浮动垃圾只能等到下一次gc再清理了)~~  
    4. 使用"标记-清除"算法，产生空间碎片。CMS GC在老生代回收时产生的内存碎片会导致老生代的利用率变低；或者可能在老生代总内存大小足够的情况下，却不能容纳新生代的晋升行为（由于没有连续的内存空间可用），导致触发FullGC。~~它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生，当然通过参数-XX:+UseCMSCompactAtFullCollection可以让jvm在执行完标记清除后再做整理~~  
        &emsp; 针对这个问题，`Sun官方给出了以下解决内存碎片问题的方法：`  
        * 增大Xmx或者减少Xmn  
        * `在应用访问量最低的时候，在程序中主动调用System.gc()，比如每天凌晨。`  
        * 在应用启动并完成所有初始化工作后，主动调用System.gc()，它可以将初始化的数据压缩到一个单独的chunk中，以腾出更多的连续内存空间给新生代晋升使用。  
        * `降低-XX:CMSInitiatingOccupancyFraction参数（内存占用率，默认70%）以提早执行CMS GC动作，`虽然CMSGC不会进行内存碎片的压缩整理，但它会合并老生代中相邻的free空间。这样就可以容纳更多的新生代晋升行为。 
        * CMS收集器提供了一个-XX：+UseCMS-CompactAtFullCollection开关参数（默认是开启的，此参数从JDK 9开始废弃），用于在CMS收集器不得不进行Full GC时开启内存碎片的合并整理过程。`还提供了另外一个参数-XX：CMSFullGCsBefore-Compaction（此参数从JDK 9开始废弃），这个参数的作用是要求CMS收集器在执行过若干次（数量由参数值决定）不整理空间的Full GC之后，下一次进入Full GC前会先进行碎片整理（默认值为0，表示每次进入Full GC时都进行碎片整理）。`  
    5. `并发模式失败（CMS垃圾回收）与晋升失败（新生代垃圾回收）`：都会退化成单线程的Full GC。  
        * 并发模式失败(concurrent mode failure)：`当CMS在执行回收时`，新生代发生垃圾回收，同时老年代又`没有足够的空间`容纳晋升的对象时。CMS垃圾回收会退化成单线程的Full GC。所有的应用线程都会被暂停，老年代中所有的无效对象都被回收。  
        * 晋升失败(promotion failed)：`当新生代发生垃圾回收`， **老年代`有足够的空间`可以容纳晋升的对象，但是由于空闲空间的`碎片化`，导致晋升失败。** ~此时会触发单线程且带压缩动作的Full GC。~  
    6. 减少remark阶段停顿：在执行并发操作之前先做一次Young GC。  

#### 1.6.5.3. G1回收器
1. G1是一种服务端应用使用的垃圾收集器，目标是用在`多核、大内存`的机器上， **<font color = "clime">G1在大多数情况下可以`实现指定的GC暂停时间，同时还能保持较高的吞吐量`。</font>**   
2. G1特点（为什么要选择G1？）  
    1. 并行和并发
    2. 分代收集：G1逻辑分代但物理不分代，将整个Java堆划分为多个大小相等的独立区域(Region)。E区、S区、H区、O区。  
    3. **<font color = "clime">`空间整合（不产生内存碎片）：`</font>** 与CMS的“标记--清理”算法不同，<font color = "red">G1从整体来看是基于“标记整理”算法实现的收集器；从局部上来看是基于“复制”算法实现的。</font>这两种算法都意味着<font color = "clime">G1运作期不会产生内存空间碎片</font>，收集后能提供规整的可用内存。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空而提前触发下一次GC。  
    4. **<font color = "clime">`可预测的停顿：`</font>** 这是G1相对于CMS的另一个大优势，<font color = "red">降低停顿时间是G1和CMS共同的关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，</font>能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。  
3. 回收流程：G1的收集过程可能有4个阶段：新生代GC、老年代并发标记周期、混合回收、如果需要可能会进行Full GC。   
    1. 老年代并发标记周期  
    &emsp; **<font color = "clime">当整个堆内存（包括老年代和新生代）被占满一定大小的时候（默认是45%，可以通过-XX:InitiatingHeapOccupancyPercent进行设置），老年代回收过程会被启动。</font>**  
    &emsp; **<font color = "clime">老年代并发标记周期，回收百分之百为垃圾的内存分段，</font>** H区（本质是o区）Humongous对象会独占整个内存分段。  
    2. 混合回收MixGC  
    &emsp; 老年代并发标记过程结束以后，紧跟着就会开始混合回收过程。混合回收的意思是年轻代和老年代会同时被回收。  
    &emsp; **<font color = "blue">步骤分2步：全局并发标记（global concurrent marking）、拷贝存活对象（evacuation）。</font>**  
        1. 全局并发标记(**<font color = "clime">3次标记、1次清除</font>**)    
            1. 初始标记
            2. 根区域扫描
            3. 并发标记
            4. 最终标记： **<font color = "blue">去处理剩下的SATB（开始快照）日志缓冲区和所有更新，找出所有未被访问的存活对象，同时安全完成存活数据计算。</font>**   
            5. 清除垃圾


#### 1.6.5.4. 三色标记，并发标记阶段
1. **<font color = "red">小结：</font>** 是什么 ---> 算法流程 ---> 缺点。    
2. 三色`是什么`？  
    * 黑色：本对象已访问过，而且本对象 引用到 的其他对象 也全部访问过了。  
    * 灰色：本对象已访问过，但是本对象 引用到 的其他对象 尚未全部访问完。全部访问后，会转换为黑色。  
    * 白色（被回收的对象）：尚未访问过。  
3. 三色标记`算法流程`： 1).根对象黑色... **<font color = "clime">如果标记结束后对象仍为白色，意味着已经“找不到”该对象在哪了，不可能会再被重新引用。</font>**  
4. 三色标记`算法`执行过程中可能存在问题：多标/错标和漏标。  
5. **<font color = "clime">`多标/错标`，本应该回收 但是 没有回收掉的内存，被称之为“浮动垃圾”</font>** ，并不会影响垃圾回收的正确性，只是需要等到下一轮垃圾回收才被清除。  
6. **<font color = "clime">漏标：把本来应该存活的垃圾，标记为了死亡。这就会导致非常严重的错误。</font>**   
	1. 两个必要条件：1). 灰色指向白色的引用消失。2). 黑色重新指向白色；  
  &emsp; 新增对象不算漏标。  
	2. CMS采用增量更新（针对新增的引用，将其记录下来等待遍历）， **<font color = "clime">关注引用的增加（黑色重新指向白色），`把黑色重新标记为灰色`，下次重新扫描属性。</font>** 破坏了条件“黑指向白”。  
  &emsp; CMS预清理：（`三色标记法的漏标问题处理`） **<font color = "red">这个阶段是用来</font><font color = "blue">处理</font><font color = "clime">前一个并发标记阶段因为引用关系改变导致没有标记到的存活对象的。如果发现对象的引用发生变化，则JVM会标记堆的这个区域为Dirty Card。那些能够从Dirty Card到达的对象也被标记（标记为存活），当标记做完后，这个Dirty Card区域就会消失。</font>**  
	3. G1采用开始时快照技术SATB， **<font color = "clime">关注引用的删除（灰色指向白色的引用消失），当B->D消失时，要把这个引用推到GC的堆栈，保证D还能被GC扫描到。破坏了条件“灰指向白的引用消失”。</font>** 保存在GC堆栈中的删除引用，会在最终标记remark阶段处理。    
	4. 使用SATB会大大减少扫描对象。  

## 1.7. JVM调优
### 1.7.1. JVM调优-基础
1. JVM参数：

|参数|描述|
|---|---|
|-Xms|用于在JVM启动时设置初始堆大小|
|-Xmx|用于设置最大堆大小|
|-Xmn|设置新生区的大小，剩下的空间用于老年区|
|-XX：PermGen|用于设置永久区存初始大小|
|-XX：MaxPermGen|用于设置Perm Gen的最大尺寸|
|-XX：SurvivorRatio|提供Eden区域的比例|
|-XX：NewRatio|用于提供老年代/新生代大小的比例，默认值为2|
    
2. JVM命令行调优工具：  
    * Jps：虚拟机进程状况工具。  
    * Jstack：java线程堆栈跟踪工具。  
    &emsp; **<font color = "clime">生成线程快照的主要目的是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等都是导致线程长时间停顿的常见原因。</font>**  
    &emsp; **`线程出现停顿的时候，通过jstack来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做什么事情，或者等待什么。`**  
    * Jmap：java内存映像工具。  
    &emsp; <font color = "red">jmap（JVM Memory Map）命令用于生成heap dump文件。如果不使用这个命令，</font> **<font color = "red">还可以使用-XX:+HeapDumpOnOutOfMemoryError参数来让虚拟机出现OOM的时候自动生成dump文件。</font>**   
    &emsp; jmap -dump:live,format=b,file=path pid。 **<font color = "blue">参数lime表示需要抓取目前在生命周期内的内存对象。</font>**   
    * Jhat：虚拟机堆转储快照分析工具。  
    * Jstat：虚拟机统计信息监视工具。  
    * Jinfo：java配置信息工具。  

### 1.7.2. JVM调优
1. 根据实际情况选择合适垃圾收集器  
&emsp; 堆内存4G以下可以用parallel，4-8G可以用ParNew + CMS，8G以上可以用G1，几百G以上用ZGC。
2. 内存设置  
&emsp; 如何将各分区调整到合适的大小，分析活跃数据的大小是很好的切入点。**活跃数据的大小是指，应用程序稳定运行时长期存活对象在堆中占用的空间大小，也就是Full GC后堆中老年代占用空间的大小。** 活跃数据和各分区之间的比例关系如下：  

|空间	|倍数|
|---|---|
|总大小	|3--4倍活跃数据的大小|
|新生代	|1--1.5倍活跃数据的大小|
|老年代	|2--3倍活跃数据的大小|
|永久代	|1.2--1.5倍Full GC后的永久代空间占用|

3. GC调优
    1. <font color = "clime">`GC的优化主要有2个维度，一是频率，二是时长。`</font> **<font color = "clime">如果满足下面的指标，则一般不需要进行GC调优：</font>**    
        * Minor GC执行时间不到50ms;
        * Minor GC执行不频繁，约10秒一次；
        * Full GC执行时间不到1s;
        * Full GC执行频率不算频繁，不低于10分钟1次。
    2. Young GC、Full GC优化策略 参考 1.2.3节。



--------
JVM 调优目标：使用较小的内存占用来获得较高的吞吐量或者较低的延迟。  

程序在上线前的测试或运行中有时会出现一些大大小小的 JVM 问题，比如 cpu load 过高、请求延迟、tps 降低等，甚至出现内存泄漏（每次垃圾收集使用的时间越来越长，垃圾收集频率越来越高，每次垃圾收集清理掉的垃圾数据越来越少）、内存溢出导致系统崩溃，因此需要对 JVM 进行调优，使得程序在正常运行的前提下，获得更高的用户体验和运行效率。  

这里有几个比较重要的指标：  

    内存占用：程序正常运行需要的内存大小。
    延迟：由于垃圾收集而引起的程序停顿时间。
    吞吐量：用户程序运行时间占用户程序和垃圾收集占用总时间的比值。

当然，和 CAP 原则一样，同时满足一个程序内存占用小、延迟低、高吞吐量是不可能的，程序的目标不同，调优时所考虑的方向也不同，在调优之前，必须要结合实际场景，有明确的的优化目标，找到性能瓶颈，对瓶颈有针对性的优化，最后进行测试，通过各种监控工具确认调优后的结果是否符合目标。  

### 1.7.3. JVM问题排查
1. 快速恢复业务：隔离故障服务器。  
2. `线程堆栈Jstack`  
    1. FGC过高  
    &emsp; **<font color = "clime">FGC过高可能是内存参数设置不合理，也有可能是代码中某个位置读取数据量较大导致系统内存耗尽。FGC过高可能导致CPU飚高。</font>**  
    &emsp; **<font color = "clime">解决思路（`FGC过高参考CPU飚高`）：FGC过高一般会导致CPU过高，打印线程堆栈信息。查看线程堆栈是用户线程，还是GC线程。如果是GC线程，打印内存快照进行分析（`查看内存溢出`），`进行Full GC优化`。</font>**  
    2. CPU飚高（解决5个步骤）  
    &emsp; **<font color = "red">CPU过高可能是系统频繁的进行Full GC，导致系统缓慢。</font><font color = "clime">而平常也可能遇到比较耗时的计算，导致CPU过高的情况。</font>**  
    &emsp; **<font color = "clime">怎么区分导致CPU过高的原因具体是Full GC次数过多还是代码中有比较耗时的计算？</font>** `如果是Full GC次数过多，那么通过jstack得到的线程信息会是类似于VM Thread之类的线程`；而`如果是代码中有比较耗时的计算，那么得到的就是一个线程的具体堆栈信息。` 

            1. 通过top命令找到CPU消耗最高的进程，并记住进程ID。  
            2. 再次通过top -Hp [进程 ID]找到CPU消耗最高的线程ID，并记住线程ID。  
            3. 通过JDK提供的jstack工具dump线程堆栈信息到指定文件中。具体命令：jstack -l [进程 ID] >jstack.log。  
            4. 由于刚刚的线程ID是十进制的，而堆栈信息中的线程ID是16进制的，因此需要将10进制的转换成16进制的，并用这个线程ID在堆栈中查找。使用printf "%x\n" [十进制数字] ，可以将10进制转换成16进制。  
            5. 通过刚刚转换的16进制数字从堆栈信息里找到对应的线程堆栈。就可以从该堆栈中看出端倪。      
    3. **<font color = "blue">★★★CPU高，查看所有进程占用率要远小于100。</font>**
        1. 可能多个线程执行同一方法，每个线程占有不高，但总和比较大。  
        2. 可以使用arthas工具的thread -n -i分析。
3. `内存快照`：内存溢出OOM  
	1. 解决方案：
		1. 修改JVM启动参数，直接增加内存。  
		2. `检查错误日志，查看“OutOfMemory”错误前是否有其它异常或错误。`  
		3. `对代码进行走查和分析，找出可能发生内存溢出的位置。` 
		4. `使用内存查看工具动态查看内存快照。` 
    2. 保存内存快照（两种方法）： 
        1. 添加JVM参数，(-XX:+HeapDumpOnOutOfMemoryError)，让JVM遇到OOM异常时能输出堆内信息，可以通过（-XX:+HeapDumpPath）参数设置堆内存溢出快照输出的文件地址。  
        2. jmap命令。`注：线上环境不能直接使用jmap命令。找到未进行GC的一个节点，从线上环境摘除。然后再使用jmap命令。`  
	3. 使用内存查看工具分析堆dump文件
    4. jvm内存快照dump文件太大： 
	    * **<font color = "clime">live参数表示需要抓取目前在生命周期内的内存对象，也就是说GC收不走的对象，然后绝大部分情况下，需要的看的就是这些内存。</font>**   
		* 如果Dump文件太大，可能需要加上-J-Xmx512m这种参数指定最大堆内存，即jhat -J-Xmx512m -port 9998 /tmp/dump.dat。
		* 如果dump文件太大，使用linux下的mat，既Memory Analyzer Tools。   

### 1.7.4. Arthas工具

