
<!-- TOC -->

- [1. 缓存更新（保证缓存与数据库的双写一致性）](#1-缓存更新保证缓存与数据库的双写一致性)
    - [1.1. 问题](#11-问题)
    - [1.2. 解决方案](#12-解决方案)
        - [1.2.1. 使用辅助队列](#121-使用辅助队列)

<!-- /TOC -->

&emsp; **<font color = "red">总结：</font>**  
1. 先删除缓存，再更新数据库，可以采用双删延迟策略。第二次删除前线程休眠冗余的读写时间，如果读从库，再加上延迟时间。  
2. 先更新数据库，再删缓存，采用异步延时删除策略。  
3. 采用延时删除策略中的问题：  
    * 同步方式会降低吞吐量，可以采用异步。
    * 第二次删除可能失败，提供一个保障的重试机制，方案一：采用消息队列，缺点对业务线代码造成大量的侵入；方案二：订阅binlog，订阅程序提取出所需要的数据以及key，另起一段非业务代码，获得该信息，尝试删除缓存操作，发现删除失败，将这些信息发送至消息队列，重新从消息队列中获得该数据，重试操作。


# 1. 缓存更新（保证缓存与数据库的双写一致性）  

<!-- 
 亿级流量高并发场景下，如何保证缓存与数据库的双写一致性？ 
 https://www.cnblogs.com/rjzheng/p/9041659.html
 https://mp.weixin.qq.com/s/-EErLaPPbO9gItIzefjTuw
 
-->

## 1.1. 问题  
<!--&emsp; **是否需要保证双写一致性？**  
&emsp; 一般来说，如果允许缓存可以稍微的跟数据库偶尔有不一致的情况，也就是说如果系统不是严格要求“缓存+数据库”必须保持一致性，最好不要做这个方案。即：读请求和写请求串行化，串到一个内存队列里去，从而达到防止并发请求导致数据错乱的问题。  -->

&emsp; **同时修改数据库和缓存中的数据有四种更新策略：**  

* 先更新数据库，再更新缓存  
* 先更新缓存，再更新数据库  
* 先删除缓存，再更新数据库  
* 先更新数据库，再删除缓存（推荐）  

## 1.2. 解决方案  
&emsp; 1. 一个比较简单的解决办法是设置过期时间，把过期时间设置得比较低，这样就只有在缓存没过期之前存在数据不一致问题，在一些业务场景下也还能接受。  

&emsp; 2. <font color = "red">采用延时双删策略。</font>  

```java
    public void write(String key,Object data){
        //1.删除缓存
        redis.delKey(key);
        //2.更新数据
        db.updateData(data);
        //3.休眠1S
        Thread.sleep(1000);
        //2.再次删除缓存
        redis.delKey(key);
    }
```
&emsp; 这么做，可以将1秒内所造成的缓存脏数据，再次删除。那么，这个1秒怎么确定的，具体该休眠多久呢？  
&emsp; 针对上面的情形，读者应该自行评估自己的项目的读数据业务逻辑的耗时。然后写数据的休眠时间则在读数据业务逻辑的耗时基础上，加几百ms即可。这么做的目的，就是确保读请求结束，写请求可以删除读请求造成的缓存脏数据。  

&emsp; 如果你用了mysql的读写分离架构怎么办？  
&emsp; ok，在这种情况下，造成数据不一致的原因如下，还是两个请求，一个请求A进行更新操作，另一个请求B进行查询操作。  
&emsp; （1）请求A进行写操作，删除缓存  
&emsp; （2）请求A将数据写入数据库了，  
&emsp; （3）请求B查询缓存发现，缓存没有值   
&emsp; （4）请求B去从库查询，这时，还没有完成主从同步，因此查询到的是旧值  
&emsp; （5）请求B将旧值写入缓存   
&emsp; （6）数据库完成主从同步，从库变为新值   
&emsp; 上述情形，就是数据不一致的原因。还是使用双删延时策略。只是，睡眠时间修改为在主从同步的延时时间基础上，加几百ms。  

### 1.2.1. 使用辅助队列  
&emsp; 3. <font color = "red">使用队列辅助，提供一个保障的重试机制。如果第二次缓存删除失败，就放进队列，然后另一个任务从队列中取出消息，不断去重试删除相应的key。</font>给出两套方案：  
&emsp; 方案一：  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/microService/problems/problem-21.png)  
&emsp; 流程如下所示：  
1. 更新数据库数据；  
2. 缓存因为种种问题删除失败；  
3. 将需要删除的key发送至消息队列；  
4. 自己消费消息，获得需要删除的key；  
5. 继续重试删除操作，直到成功。  

&emsp; 该方案有一个缺点，对业务线代码造成大量的侵入。于是有了方案二，在方案二中，启动一个订阅程序去订阅数据库的binlog，获得需要操作的数据。在应用程序中，另起一段程序，获得这个订阅程序传来的信息，进行删除缓存操作。  

&emsp; 方案二：  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/microService/problems/problem-22.png)  
&emsp; 流程如下图所示：  
1. 更新数据库数据；  
2. 数据库会将操作信息写入binlog日志当中；  
3. 订阅程序提取出所需要的数据以及key；  
4. 另起一段非业务代码，获得该信息；  
5. 尝试删除缓存操作，发现删除失败；  
6. 将这些信息发送至消息队列；  
7. 重新从消息队列中获得该数据，重试操作。  

&emsp; 说明：上述的订阅binlog程序在mysql中有现成的中间件叫canal，可以完成订阅binlog日志的功能。另外，重试机制，可以采用消息队列的方式。如果对一致性要求不是很高，直接在程序中另起一个线程，每隔一段时间去重试即可。  

