
<!-- TOC -->

- [1. TCP粘包/拆包](#1-tcp粘包拆包)
    - [1.1. TCP粘包/拆包问题及原因](#11-tcp粘包拆包问题及原因)
    - [1.2. TCP粘包/拆包常见解决方案](#12-tcp粘包拆包常见解决方案)

<!-- /TOC -->

&emsp; **TCP是基于流传输的协议，请求数据在其传输的过程中是没有界限区分，所以在读取请求的时候，不一定能获取到一个完整的数据包。** 

# 1. TCP粘包/拆包
<!-- 
Socket粘包问题的3种解决方案
https://mp.weixin.qq.com/s/ODxGlLrohCveH-2m-BSDWQ
-->

&emsp; 在Java语言中，传统的Socket编程分为两种实现方式，这两种实现方式也对应着两种不同的传输层协议：TCP 协议和 UDP 协议，但作为互联网中最常用的传输层协议 TCP，在使用时却会导致粘包和半包问题，于是为了彻底的解决此问题，便诞生了此篇文章。  

## 1.1. TCP粘包/拆包问题及原因  
&emsp; **TCP是基于流传输的协议，请求数据在其传输的过程中是没有界限区分，所以在读取请求的时候，不一定能获取到一个完整的数据包。** 如果一个包较大时，可能会切分成多个包进行多次传输。同时，如果存在多个小包时，可能会将其整合成一个大包进行传输。这就是TCP协议的粘包/拆包概念。  
<!-- 粘包拆包问题是处于网络比较底层的问题，在数据链路层、网络层以及传输层都有可能发生。我们日常的网络应用开发大都在传输层进行，由于UDP有消息保护边界，不会发生粘包拆包问题，而因此粘包拆包问题只发生在TCP协议中。具体讲TCP是个”流"协议，只有流的概念，没有包的概念，对于业务上层数据的具体含义和边界并不了解，它只会根据TCP缓冲区的实际情况进行包的划分。所以在业务上认为，一个完整的包可能会被TCP拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据包发送，这就是所谓的TCP粘包和拆包问题。

&emsp; 下图中演示了粘包和拆包的三种情况：  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/microService/netty/netty-38.png)  

* A和B两个包都刚好满足TCP缓冲区的大小，或者说其等待时间已经达到TCP等待时长，从而还是使用两个独立的包进行发送；  
* A和B两次请求间隔时间内较短，并且数据包较小，因而合并为同一个包发送给服务端；  
* B包比较大，因而将其拆分


&emsp; 产生粘包和拆包问题的主要原因是，操作系统在发送TCP数据的时候，底层会有一个缓冲区，例如1024个字节大小，如果一次请求发送的数据量比较小，没达到缓冲区大小，TCP则会将多个请求合并为同一个请求进行发送，这就形成了粘包问题；如果一次请求发送的数据量比较大，超过了缓冲区大小，TCP就会将其拆分为多次发送，这就是拆包，也就是将一个大的包拆分为多个小包进行发送。 
-->
&emsp; **问题举例说明：**    
&emsp; 下面针对客户端分别发送了两个数据表Packet1和Packet2给服务端的时候，TCP粘包和拆包会出现的情况进行列举说明：  
&emsp; (1)第一种情况，服务端分两次正常收到两个独立数据包，即没有发生拆包和粘包的现象；  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/microService/netty/netty-78.png)  
&emsp; (2)第二种情况，接收端只收到一个数据包，由于TCP是不会出现丢包的，所以这一个数据包中包含了客户端发送的两个数据包的信息，这种现象即为粘包。这种情况由于接收端不知道这两个数据包的界限，所以对于服务接收端来说很难处理。  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/microService/netty/netty-79.png)  
&emsp; (3)第三种情况，服务端分两次读取到了两个数据包，第一次读取到了完整的Packet1和Packet2包的部分内容，第二次读取到了Packet2的剩余内容，这被称为TCP拆包；  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/microService/netty/netty-80.png)  
&emsp; (4)第四种情况，服务端分两次读取到了两个数据包，第一次读取到了部分的Packet1内容，第二次读取到了Packet1剩余内容和Packet2的整包。  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/microService/netty/netty-81.png)  
&emsp; 如果此时服务端TCP接收滑窗非常小，而数据包Packet1和Packet2比较大，很有可能服务端需要分多次才能将两个包接收完全，期间发生多次拆包。   

&emsp; 以上列举情况的背后原因分别如下：  

* 应用程序写入的数据大于套接字缓冲区大小，这将会发生拆包。
* 应用程序写入数据小于套接字缓冲区大小，网卡将应用多次写入的数据发送到网络上，这将会发生粘包。
* 进行MSS(最大报文长度)大小的TCP分段，当TCP报文长度-TCP头部长度>MSS的时候将发生拆包。
* 接收方法不及时读取套接字缓冲区数据，这将发生粘包。

## 1.2. TCP粘包/拆包常见解决方案  
&emsp; 对于粘包和拆包问题，常见的解决方案有四种：  

* 客户端在发送数据包的时候，每个包都固定长度，比如1024个字节大小，如果客户端发送的数据长度不足1024个字节，则通过补充空格的方式补全到指定长度；  
* 客户端在每个包的末尾使用固定的分隔符，例如\r\n，如果一个包被拆分了，则等待下一个包发送过来之后找到其中的\r\n，然后对其拆分后的头部部分与前一个包的剩余部分进行合并，这样就得到了一个完整的包；  
* 将消息分为头部和消息体，在头部中保存有当前整个消息的长度，只有在读取到足够长度的消息之后才算是读到了一个完整的消息；  
* 通过自定义协议进行粘包和拆包的处理。  