<!-- TOC -->

- [1. Docker组件详解](#1-docker组件详解)
    - [1.1. 镜像详解](#11-镜像详解)
        - [1.1.1. 分层构建](#111-分层构建)
        - [1.1.2. 读写层](#112-读写层)
        - [1.1.3. 联合文件系统](#113-联合文件系统)
    - [1.2. 容器详解](#12-容器详解)
        - [1.2.1. 容器生命周期](#121-容器生命周期)
            - [1.2.1.1. 创建和运行](#1211-创建和运行)
            - [1.2.1.2. 休眠和销毁](#1212-休眠和销毁)
            - [1.2.1.3. 重启策略](#1213-重启策略)
        - [1.2.2. 容器的文件系统](#122-容器的文件系统)
        - [1.2.3. 容器数据卷](#123-容器数据卷)
        - [1.2.4. 容器通信](#124-容器通信)
            - [1.2.4.1. Docker宿主机与容器通信](#1241-docker宿主机与容器通信)
            - [1.2.4.2. Docker同宿主机容器和不同宿主机容器之间怎么通信？](#1242-docker同宿主机容器和不同宿主机容器之间怎么通信)
                - [1.2.4.2.1. 同宿主机容器通信](#12421-同宿主机容器通信)
                - [1.2.4.2.2. 容器连接](#12422-容器连接)
                - [1.2.4.2.3. 不同宿主机容器通信](#12423-不同宿主机容器通信)

<!-- /TOC -->

# 1. Docker组件详解

<!-- 
https://mp.weixin.qq.com/s/xq9lrHqBOWjQ65-V4Jrttg
-->

## 1.1. 镜像详解

### 1.1.1. 分层构建  
&emsp; Docker镜像是分层构建的，Dockerfile中每条指令都会新建一层。例如以下Dockerfile：  

```text
FROM ubuntu:18.04
COPY . /app
RUN make /app
CMD python /app/app.py
```
&emsp; 以上四条指令会创建四层，分别对应基础镜像、复制文件、编译文件以及入口文件，每层只记录本层所做的更改，而这些层都是只读层。当启动一个容器，Docker会在最顶部添加读写层，在容器内做的所有更改，如写日志、修改、删除文件等，都保存到了读写层内，一般称该层为容器层，如下图所示：  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/devops/docker/docker-15.png)  
&emsp; 每个镜像可依赖其他镜像进行构建，每一层的镜像可被多个镜像引用，下图的镜像依赖关系，K8S镜像其实是CentOS+GCC+GO+K8S这四个软件结合的镜像。  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/devops/docker/docker-19.png)  

### 1.1.2. 读写层  
&emsp; 下图形象的表现出了镜像和容器的关系：  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/devops/docker/docker-20.png)  
&emsp; 上图中Apache应用基于emacs镜像构建，emacs基于Debian系统镜像构建，在启动为容器时，在Apache镜像层之上构造了一个可写层，对容器本身的修改操作都在可写层中进行。Debian是该镜像的基础镜像（Base Image），它提供了内核Kernel的更高级的封装。同时其他的镜像也是基于同一个内核来构建的。  
&emsp; 事实上，<font color = "lime">容器（container）和镜像（image）的最主要区别就是容器加上了顶层的读写层。</font>所有对容器的修改都发生在此层，镜像并不会被修改。容器需要读取某个文件时，直接从底部只读层去读即可，而如果需要修改某文件，则将该文件拷贝到顶部读写层进行修改，只读层保持不变。  
&emsp; 每个容器都有自己的读写层，因此多个容器可以使用同一个镜像，另外容器被删除时，其对应的读写层也会被删除（如果希望多个容器共享或者持久化数据，可以使用Docker volume）。  
&emsp; 最后，执行命令 docker ps -s，可以看到最后有两列 size 和 virtual size。其中 size就是容器读写层占用的磁盘空间，而 virtual size 就是读写层加上对应只读层所占用的磁盘空间。如果两个容器是从同一个镜像创建，那么只读层就是100%共享，即使不是从同一镜像创建，其镜像仍然可能共享部分只读层（如一个镜像是基于另一个创建）。因此，docker 实际占用的磁盘空间远远小于virtual size 的总和。  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/devops/docker/docker-14.png)  

### 1.1.3. 联合文件系统  
&emsp; 这种分层结构能充分共享镜像层，能大大减少镜像仓库占用的空间。  
&emsp; Docker镜像分层的交互、管理就需要存储驱动程序，也即联合文件系统（UnionFS）。Docker利用UnionFS（联合文件系统）把相关镜像层的目录“联合”到同一个挂载点呈现出来的一个整体。Docker可使用多种驱动，如目前已经合并入Linux 内核、官方推荐的overlay等等，需要根据Docker以及宿主机系统的版本，进行合适的选择。  
&emsp; UnionFS有很多种，其中Docker中常用的是AUFS，这是UnionFS的升级版，除此之外还有DeviceMapper、Overlay2、ZFS和 VFS等。Docker镜像的每一层默认存放在/var/lib/docker/aufs/diff目录中，当用户启动一个容器时，Docker引擎首先在/var/lib/docker/aufs/diff中新建一个可读写层目录，然后使用UnionFS把该可读写层目录和指定镜像的各层目录联合挂载到/var/lib/docker/aufs/mnt里的一个目录中（其中指定镜像的各层目录都以只读方式挂载），通过LXC等技术进行环境隔离和资源控制，使容器里的应用仅依赖mnt目录中对应的挂载目录和文件运行起来。  
&emsp; 利用UnionFS写时复制的特点，在启动一个容器时，Docker引擎实际上只是增加了一个可写层和构造了一个Linux容器，这两者都几乎不消耗系统资源，因此Docker容器能够做到秒级启动，一台服务器上能够启动上千个Docker容器，而传统虚拟机在一台服务器上启动几十个就已经非常吃力了，而且虚拟机启动很慢，这是Docker相比于传统虚拟机的两个巨大的优势。  
&emsp; 当应用只是直接调用了内核功能来运作的情况下，应用本身就能直接作为最底层的层来构建镜像，但因为容器本身会隔绝环境，因此容器内部是无法访问宿主机里文件的（除非指定了某些目录或文件映射到容器内），这种情况下应用代码就只能使用内核的功能。  
&emsp; 但是Linux内核仅提供了进程管理、内存管理、文件系统管理等一些基础且底层的管理功能，在实际的场景中，几乎所有软件都是基于操作系统来开发的，因此往往都需要依赖操作系统的软件和运行库等，如果这些应用的下一层直接是内核，那么应用将无法运行。所以实际上应用镜像往往底层都是基于一个操作系统镜像来补足运行依赖的。  
&emsp; Docker中的操作系统镜像，与平常安装系统时用的ISO镜像不同。ISO镜像里包含了操作系统内核及该发行版系统包含的所有目录和软件，而Docker中的操作系统镜像，不包含系统内核，仅包含系统必备的一些目录（如/etc /proc等）和常用的软件和运行库等，可把操作系统镜像看作内核之上的一个应用，一个封装了内核功能，并为用户编写的应用提供运行环境的工具。   
&emsp; 应用基于这样的镜像构建，就能够利用上相应操作系统的各种软件的功能和运行库，此外，由于应用是基于操作系统镜像来构建的，就算换到另外的服务器，只要操作系统镜像中被应用使用到的功能能适配宿主机的内核，应用就能正常运行，这就是一次构建到处运行的原因。  

## 1.2. 容器详解  
&emsp; 容器是基于镜像启动起来的，是镜像的一个运行实例，容器中可以运行一个或多个进程。同时，用户可以从单个镜像上启动一个或多个容器。  
&emsp; 一个容器内的一个或多个进程的运行是依靠容器所在宿主机的内核，但是这些进程属于自己的独立的命名空间，拥有自己的root文件系统、自己的网络配置、自己的进程空间和自己的用户ID等等，所以容器内的进程相当由于运行在一个隔离的环境里，就相当于运行在一个新的操作系统中一样。容器使用root文件系统大部分是由镜像提供的，还有一些是由Docker为Docker容器生成的。  

&emsp; 运行的容器是共享宿主机内核的，也就是相当于容器在执行时还是依靠主机的内核代码的。这也就意味着一个基于 Windows 的容器化应用在 Linux 主机上无法运行的。也可以简单地理解为 Windows 容器需要运行在 Windows 宿主机之上，Linux 容器需要运行在 Linux 宿主机上。Docker 推荐单个容器只运行一个应用程序或进程，但是其实也可以运行多个应用程序。  

### 1.2.1. 容器生命周期  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/devops/docker/docker-4.png)  
&emsp; <font color = "lime">容器的生命周期大致可分为 4 个：创建、运行、休眠和销毁。</font>  

#### 1.2.1.1. 创建和运行
&emsp; 容器的创建和运行主要使用 docker container run 命名，比如下面的命令会从 Ubuntu:latest 这个镜像中启动 /bin/bash 这个程序。那么 /bin/bash 成为了容器中唯一运行的进程。  

    docker container run -it ubuntu:latest /bin/bash

&emsp; 当运行上述的命令之后，Docker 客户端会选择合适的 API 来调用 Docker daemon 接收到命令并搜索 Docker 本地缓存，观察是否有命令所请求的镜像。如果没有，就去查询 Docker Hub 是否存在相应镜像。找到镜像后，就将其拉取到本地，并存储在本地。一旦镜像拉取到本地之后，Docker daemon 就会创建容器并在其中运行指定应用。  

&emsp; ps -elf 命令可以看到会显示两个，那么其中一个是运行 ps -elf 产生的。  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/devops/docker/docker-22.png)  

&emsp; 假如，此时输入exit退出Bash Shell之后，那么容器也会退出（休眠）。因为容器如果不运行任何进程则无法存在，上面将容器的唯一进程杀死之后，容器也就没了。其实，当把进程的PID为1的进程杀死就会杀死容器。  

#### 1.2.1.2. 休眠和销毁
&emsp; docker container stop 命令可以让容器进入休眠状态，使用 docker container rm 可以删除容器。删除容器的最佳方式就是先停止容器，然后再删除容器，这样可以给容器中运行的应用/进程一个停止运行并清理残留数据的机会。因为先 stop 的话，docker container stop 命令会像容器内的 PID 1 进程发送 SIGTERM 信号，这样会给进程预留一个清理并优雅停止的机会。如果进程在 10s 的时间内没有终止，那么会发送 SIGKILL 信号强制停止该容器。但是 docker container rm 命令不会友好地发送 SIGTERM ，而是直接发送 SIGKILL 信号。

#### 1.2.1.3. 重启策略
&emsp; 容器还可以配置重启策略，这是容器的一种自我修复能力，可以在指定事件或者错误后重启来完成自我修复。配置重启策略有两种方式，一种是命令中直接传入参数，另一种是在 Compose 文件中声明。下面阐述命令中传入参数的方式，也就是在命令中加入 --restart 标志，该标志会检查容器的退出代码，并根据退出码已经重启策略来决定。Docker 支持的重启策略包括 always、unless-stopped 和 on-failed 四种。

* always策略会一直尝试重启处于停止状态的容器，除非通过docker container stop命令明确将容器停止。另外，当daemon重启的时候，被docker container stop停止的设置了 always策略的容器也会被重启。

        $ docker container run --it --restart always apline sh 
        # 过几秒之后，在终端中输入 exit，过几秒之后再来看一下。照理来说应该会处于stop状态，但是会发现又处于运行状态了。

* unless-stopped 策略和 always 策略是差不多的，最大的区别是，docker container stop停止的容器在daemon重启之后不会被重启。
* on-failure 策略会在退出容器并且返回值不会 0 的时候，重启容器。如果容器处于 stopped 状态，那么 daemon 重启的时候也会被重启。另外，on-failure 还接受一个可选的重启次数参数，如--restart=on-failure:5 表示最多重启 5 次。

### 1.2.2. 容器的文件系统   
&emsp; 容器会共享其所在主机的操作系统/内核（容器执行使用共享主机的内核代码），<font color = "red">但是容器内运行的进程所使用的是容器自己的文件系统，也就是容器内部的进程访问数据时访问的是容器的文件系统。</font>当从一个镜像启动容器的时候，除了把镜像当成容器的文件系统一部分之外，Docker还会在该镜像的最顶层加载一个可读写文件系统，容器中运行的程序就是在这个读写层中执行的。  
&emsp; 使用Docker，启动容器，会新建两层内容。这两层分别为 Docker 容器的初始层（Init Layer）与可读写层（Read-Write Layer）：  

* 初始层中大多是初始化容器环境时，与容器相关的环境信息，如容器主机名，主机 host 信息以及域名服务文件等。  
* 再来看可读写层，这一层的作用非常大，Docker 的镜像层以及顶上的两层加起来，Docker 容器内的进程只对可读写层拥有写权限，其他层对进程而言都是只读的（Read-Only）。比如想修改一个文件，这个文件会从该读写层下面的只读层复制到该读写层，该文件的只读版本仍然存在，但是已经被读写层中的该文件副本所隐藏了。这种机制被称为写时复制（copy on write）（在 AUFS 等文件系统下，写下层镜像内容就会涉及 COW （Copy-on-Write）技术）。另外，关于 VOLUME 以及容器的 hosts、hostname 、resolv.conf 文件等都会挂载到这里。需要额外注意的是，虽然Docker容器有能力在可读写层看到 VOLUME 以及 hosts 文件等内容，但那都仅仅是挂载点，真实内容位于宿主机上。  
&emsp; 在运行阶段时，容器产生的新文件、文件的修改都会在可读写层上，当停止容器（stop）运行之后并不会被损毁，但是删除容器会丢弃其中的数据。  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/devops/docker/docker-23.png)  

### 1.2.3. 容器数据卷
&emsp; 容器数据卷：持久化。docker运行产生的数据持久化。  

### 1.2.4. 容器通信  
<!-- 

 Docker知识进阶与容器编排技术 
 https://mp.weixin.qq.com/s/CsnbPMjsa5kzcWh9FimJSg
-->

#### 1.2.4.1. Docker宿主机与容器通信  
&emsp; 容器运行在宿主机上，如果外网能够访问容器，才能够使用它提供的服务。  
&emsp; Docker容器与宿主机进行通信可以通过映射容器的端口到宿主机上。例如，使用如下命令启动一个容器  

    docker run -p 8080:80 --name test nginx  

&emsp; 使用-p参数将容器的80端口映射到宿主机的8080端口，这样就可以通过curl localhost:8080访问到容器上80端口的服务了。另外一个参数-P可以将容器的端口映射到宿主机的高位随机端口上，而不需要手动指定。  

#### 1.2.4.2. Docker同宿主机容器和不同宿主机容器之间怎么通信？

<!-- 
docker同宿主机容器和不同宿主机容器之间怎么通信？
https://blog.51cto.com/2367685/2349762
--> 

##### 1.2.4.2.1. 同宿主机容器通信  
......


##### 1.2.4.2.2. 容器连接  
......

##### 1.2.4.2.3. 不同宿主机容器通信
......




