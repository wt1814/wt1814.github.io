<!-- TOC -->

- [1. Docker组件详解](#1-docker组件详解)
    - [1.1. 镜像详解](#11-镜像详解)
        - [1](#1)
        - [2](#2)
        - [3](#3)
    - [1.2. 容器详解](#12-容器详解)
        - [1.2.1. 容器生命周期](#121-容器生命周期)
        - [1.2.2. 容器数据卷](#122-容器数据卷)
        - [1.2.3. 容器通信](#123-容器通信)
            - [1.2.3.1. Docker宿主机与容器通信](#1231-docker宿主机与容器通信)
            - [1.2.3.2. Docker同宿主机容器和不同宿主机容器之间怎么通信？](#1232-docker同宿主机容器和不同宿主机容器之间怎么通信)
                - [1.2.3.2.1. 同宿主机容器通信](#12321-同宿主机容器通信)
                - [1.2.3.2.2. 容器连接](#12322-容器连接)
                - [1.2.3.2.3. 不同宿主机容器通信](#12323-不同宿主机容器通信)

<!-- /TOC -->

# 1. Docker组件详解

<!-- 
https://mp.weixin.qq.com/s/xq9lrHqBOWjQ65-V4Jrttg
-->

## 1.1. 镜像详解


### 1
&emsp; Docker镜像是分层构建的，Dockerfile 中每条指令都会新建一层。例如以下 Dockerfile：  

```text
FROM ubuntu:18.04
COPY . /app
RUN make /app
CMD python /app/app.py
```
&emsp; 以上四条指令会创建四层，分别对应基础镜像、复制文件、编译文件以及入口文件，每层只记录本层所做的更改，而这些层都是只读层。当启动一个容器，Docker 会在最顶部添加读写层，在容器内做的所有更改，如写日志、修改、删除文件等，都保存到了读写层内，一般称该层为容器层，如下图所示：  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/devops/docker/docker-15.png)  
&emsp; 事实上，容器（container）和镜像（image）的最主要区别就是容器加上了顶层的读写层。所有对容器的修改都发生在此层，镜像并不会被修改，也即前面说的 COW(copy-on-write)技术。容器需要读取某个文件时，直接从底部只读层去读即可，而如果需要修改某文件，则将该文件拷贝到顶部读写层进行修改，只读层保持不变。  
&emsp; 每个容器都有自己的读写层，因此多个容器可以使用同一个镜像，另外容器被删除时，其对应的读写层也会被删除（如果希望多个容器共享或者持久化数据，可以使用Docker volume）。  
&emsp; 最后，执行命令 docker ps -s，可以看到最后有两列 size 和 virtual size。其中 size就是容器读写层占用的磁盘空间，而 virtual size 就是读写层加上对应只读层所占用的磁盘空间。如果两个容器是从同一个镜像创建，那么只读层就是 100%共享，即使不是从同一镜像创建，其镜像仍然可能共享部分只读层（如一个镜像是基于另一个创建）。因此，docker 实际占用的磁盘空间远远小于 virtual size 的总和。  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/devops/docker/docker-14.png)  

&emsp; 以上就是Docker镜像分层的主要内容，至于这些层的交互、管理就需要存储驱动程序，也即联合文件系统（UnionFS）。Docker 可使用多种驱动，如目前已经合并入 Linux 内核、官方推荐的overlay， 曾在 Ubuntu、Debian等发行版中得到广泛使用的 AUFS，以及devicemapper、zfs等等，需要根据 Docker以及宿主机系统的版本，进行合适的选择。  

### 2 
![image](https://gitee.com/wt1814/pic-host/raw/master/images/devops/docker/docker-19.png)  
Docker镜像采用分层存储格式，每个镜像可依赖其他镜像进行构建，每一层的镜像可被多个镜像引用，上图的镜像依赖关系，K8S镜像其实是CentOS+GCC+GO+K8S这四个软件结合的镜像。  

这种分层结构能充分共享镜像层，能大大减少镜像仓库占用的空间，而对用户而言，他们所看到的容器，其实是Docker利用UnionFS（联合文件系统）把相关镜像层的目录“联合”到同一个挂载点呈现出来的一个整体，这里需要简单介绍一个UnionFS是什么：  

    UnionFS可以把多个物理位置独立的目录（也叫分支）内容联合挂载到同一个目录下，UnionFS允许控制这些目录的读写权限，此外对于只读的文件和目录，它具有“Copy on Write（写实复制）”的特点，即如果对一个只读的文件进行修改，在修改前会先把文件复制一份到可写层（可能是磁盘里的一个目录），所有的修改操作其实都是对这个文件副本进行修改，原来的只读文件并不会变化。

其中一个使用UnionFS的例子是：Knoppix，一个用于Linux演示、光盘教学和商业产品演示的Linux发行版，它就是把一个CD/DVD和一个存在在可读写设备（例如U盘）联合挂载，这样在演示过程中任何对CD/DVD上文件的改动都会在被应用在U盘上，不改变原来的CD/DVD上的内容。  
　　
UnionFS有很多种，其中Docker中常用的是AUFS，这是UnionFS的升级版，除此之外还有DeviceMapper、Overlay2、ZFS和 VFS等。Docker镜像的每一层默认存放在/var/lib/docker/aufs/diff目录中，当用户启动一个容器时，Docker引擎首先在/var/lib/docker/aufs/diff中新建一个可读写层目录，然后使用UnionFS把该可读写层目录和指定镜像的各层目录联合挂载到/var/lib/docker/aufs/mnt里的一个目录中（其中指定镜像的各层目录都以只读方式挂载），通过LXC等技术进行环境隔离和资源控制，使容器里的应用仅依赖mnt目录中对应的挂载目录和文件运行起来。  

利用UnionFS写实复制的特点，在启动一个容器时， Docker引擎实际上只是增加了一个可写层和构造了一个Linux容器，这两者都几乎不消耗系统资源，因此Docker容器能够做到秒级启动，一台服务器上能够启动上千个Docker容器，而传统虚拟机在一台服务器上启动几十个就已经非常吃力了，而且虚拟机启动很慢，这是Docker相比于传统虚拟机的两个巨大的优势。  

当应用只是直接调用了内核功能来运作的情况下，应用本身就能直接作为最底层的层来构建镜像，但因为容器本身会隔绝环境，因此容器内部是无法访问宿主机里文件的（除非指定了某些目录或文件映射到容器内），这种情况下应用代码就只能使用内核的功能。  

但是Linux内核仅提供了进程管理、内存管理、文件系统管理等一些基础且底层的管理功能，在实际的场景中，几乎所有软件都是基于操作系统来开发的，因此往往都需要依赖操作系统的软件和运行库等，如果这些应用的下一层直接是内核，那么应用将无法运行。所以实际上应用镜像往往底层都是基于一个操作系统镜像来补足运行依赖的。  

Docker中的操作系统镜像，与平常安装系统时用的ISO镜像不同。ISO镜像里包含了操作系统内核及该发行版系统包含的所有目录和软件，而Docker中的操作系统镜像，不包含系统内核，仅包含系统必备的一些目录（如/etc /proc等）和常用的软件和运行库等，可把操作系统镜像看作内核之上的一个应用，一个封装了内核功能，并为用户编写的应用提供运行环境的工具。   

应用基于这样的镜像构建，就能够利用上相应操作系统的各种软件的功能和运行库，此外，由于应用是基于操作系统镜像来构建的，就算换到另外的服务器，只要操作系统镜像中被应用使用到的功能能适配宿主机的内核，应用就能正常运行，这就是一次构建到处运行的原因。  

下图形象的表现出了镜像和容器的关系：  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/devops/docker/docker-20.png)  
上图中Apache应用基于emacs镜像构建，emacs基于Debian系统镜像构建，在启动为容器时，在Apache镜像层之上构造了一个可写层，对容器本身的修改操作都在可写层中进行。Debian是该镜像的基础镜像（Base Image），它提供了内核Kernel的更高级的封装。同时其他的镜像也是基于同一个内核来构建的（以下的BusyBox是一个精简版的操作系统镜像）：  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/devops/docker/docker-21.png)  
这时候就会有一个问题，应用基于操作系统镜像来构建，那如果操作系统镜像本身就很占空间，岂不是镜像的分发不方便，而且镜像仓库占用的空间也会很大。有人已经考虑到这一点，针对不同的场景分别构造了不同的操作系统镜像，下面介绍几种最常用的系统镜像。  


### 3  

<!-- 
https://mp.weixin.qq.com/s/xq9lrHqBOWjQ65-V4Jrttg
-->

## 1.2. 容器详解  
&emsp; 容器是基于镜像启动起来的，是镜像的一个运行实例，容器中可以运行一个或多个进程。同时，用户可以从单个镜像上启动一个或多个容器。  
&emsp; 一个容器内的一个或多个进程的运行是依靠容器所在宿主机的内核，但是这些进程属于自己的独立的命名空间，拥有自己的 root 文件系统、自己的网络配置、自己的进程空间和自己的用户 ID 等等，所以容器内的进程相当由于运行在一个隔离的环境里，就相当于运行在一个新的操作系统中一样。容器使用 root 文件系统大部分是由镜像提供的，还有一些是由 Docker 为 Docker 容器生成的。  
&emsp; Docker 容器的底层技术采用了 Namespace 和 cgroups，Namespace 技术可以让容器内的进程拥有自己的命名空间，也就是上面提到的那些，而 cgroups 可以控制容器内的进程内使用的 CPU 和内存等资源。  

&emsp; 运行的容器是共享宿主机内核的，也就是相当于容器在执行时还是依靠主机的内核代码的。这也就意味着一个基于 Windows 的容器化应用在 Linux 主机上无法运行的。也可以简单地理解为 Windows 容器需要运行在 Windows 宿主机之上，Linux 容器需要运行在 Linux 宿主机上。Docker 推荐单个容器只运行一个应用程序或进程，但是其实也可以运行多个应用程序。  

### 1.2.1. 容器生命周期  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/devops/docker/docker-4.png)  
&emsp; 容器的生命周期大致可分为 4 个：创建、运行、休眠和销毁。  



### 1.2.2. 容器数据卷
&emsp; 容器数据卷：持久化。docker运行产生的数据持久化.

### 1.2.3. 容器通信  


#### 1.2.3.1. Docker宿主机与容器通信  
&emsp; 容器运行在宿主机上，如果外网能够访问容器，才能够使用它提供的服务。  

&emsp; Docker容器与宿主机进行通信可以通过映射容器的端口到宿主机上。例如，使用如下命令启动一个容器  

    docker run -p 8080:80 --name test nginx  

&emsp; 使用 -p 参数将容器的 80 端口映射到宿主机的 8080 端口，这样就可以通过curl localhost:8080访问到容器上 80 端口的服务了。另外一个参数 -P 可以将容器的端口映射到宿主机的高位随机端口上，而不需要手动指定。  

#### 1.2.3.2. Docker同宿主机容器和不同宿主机容器之间怎么通信？

<!-- 
docker同宿主机容器和不同宿主机容器之间怎么通信？
https://blog.51cto.com/2367685/2349762
--> 

##### 1.2.3.2.1. 同宿主机容器通信  
......


##### 1.2.3.2.2. 容器连接  
......

##### 1.2.3.2.3. 不同宿主机容器通信
......




