<!-- TOC -->

- [1. Docker组件详解](#1-docker组件详解)
    - [1.1. 镜像详解](#11-镜像详解)
    - [1.2. 容器详解](#12-容器详解)
        - [1.2.1. 容器生命周期](#121-容器生命周期)
        - [1.2.2. 容器数据卷](#122-容器数据卷)
        - [1.2.3. 容器通信](#123-容器通信)
            - [1.2.3.1. Docker宿主机与容器通信](#1231-docker宿主机与容器通信)
            - [1.2.3.2. Docker同宿主机容器和不同宿主机容器之间怎么通信？](#1232-docker同宿主机容器和不同宿主机容器之间怎么通信)
                - [1.2.3.2.1. 同宿主机容器通信](#12321-同宿主机容器通信)
                - [1.2.3.2.2. 容器连接](#12322-容器连接)
                - [1.2.3.2.3. 不同宿主机容器通信](#12323-不同宿主机容器通信)

<!-- /TOC -->

# 1. Docker组件详解

## 1.1. 镜像详解

<!-- 
https://mp.weixin.qq.com/s/PM6K3j8bqBbbwtt4S4uyEw
-->
&emsp; Docker镜像是分层构建的，Dockerfile 中每条指令都会新建一层。例如以下 Dockerfile：  

```text
FROM ubuntu:18.04
COPY . /app
RUN make /app
CMD python /app/app.py
```
&emsp; 以上四条指令会创建四层，分别对应基础镜像、复制文件、编译文件以及入口文件，每层只记录本层所做的更改，而这些层都是只读层。当启动一个容器，Docker 会在最顶部添加读写层，在容器内做的所有更改，如写日志、修改、删除文件等，都保存到了读写层内，一般称该层为容器层，如下图所示：  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/devops/docker/docker-15.png)  
&emsp; 事实上，容器（container）和镜像（image）的最主要区别就是容器加上了顶层的读写层。所有对容器的修改都发生在此层，镜像并不会被修改，也即前面说的 COW(copy-on-write)技术。容器需要读取某个文件时，直接从底部只读层去读即可，而如果需要修改某文件，则将该文件拷贝到顶部读写层进行修改，只读层保持不变。  
&emsp; 每个容器都有自己的读写层，因此多个容器可以使用同一个镜像，另外容器被删除时，其对应的读写层也会被删除（如果你希望多个容器共享或者持久化数据，可以使用 Docker volume）。  
&emsp; 最后，执行命令 docker ps -s，可以看到最后有两列 size 和 virtual size。其中 size就是容器读写层占用的磁盘空间，而 virtual size 就是读写层加上对应只读层所占用的磁盘空间。如果两个容器是从同一个镜像创建，那么只读层就是 100%共享，即使不是从同一镜像创建，其镜像仍然可能共享部分只读层（如一个镜像是基于另一个创建）。因此，docker 实际占用的磁盘空间远远小于 virtual size 的总和。  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/devops/docker/docker-14.png)  

&emsp; 以上就是Docker镜像分层的主要内容，至于这些层的交互、管理就需要存储驱动程序，也即联合文件系统（UnionFS）。Docker 可使用多种驱动，如目前已经合并入 Linux 内核、官方推荐的overlay， 曾在 Ubuntu、Debian等发行版中得到广泛使用的 AUFS，以及devicemapper、zfs等等，需要根据 Docker以及宿主机系统的版本，进行合适的选择。  

## 1.2. 容器详解
### 1.2.1. 容器生命周期  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/devops/docker/docker-4.png)  

### 1.2.2. 容器数据卷
&emsp; 容器数据卷：持久化。docker运行产生的数据持久化.

### 1.2.3. 容器通信  


#### 1.2.3.1. Docker宿主机与容器通信  
&emsp; 容器运行在宿主机上，如果外网能够访问容器，才能够使用它提供的服务。  

&emsp; Docker容器与宿主机进行通信可以通过映射容器的端口到宿主机上。例如，使用如下命令启动一个容器  

    docker run -p 8080:80 --name test nginx  

&emsp; 使用 -p 参数将容器的 80 端口映射到宿主机的 8080 端口，这样就可以通过curl localhost:8080访问到容器上 80 端口的服务了。另外一个参数 -P 可以将容器的端口映射到宿主机的高位随机端口上，而不需要手动指定。  

#### 1.2.3.2. Docker同宿主机容器和不同宿主机容器之间怎么通信？

<!-- 
docker同宿主机容器和不同宿主机容器之间怎么通信？
https://blog.51cto.com/2367685/2349762
--> 

##### 1.2.3.2.1. 同宿主机容器通信  
......


##### 1.2.3.2.2. 容器连接  
......

##### 1.2.3.2.3. 不同宿主机容器通信
......




