<!-- TOC -->

- [1. Docker](#1-docker)
    - [1.1. 容器化技术](#11-容器化技术)
    - [1.2. Docker简介](#12-docker简介)
    - [1.3. Docker的使用场景](#13-docker的使用场景)
    - [1.4. Docker基本架构](#14-docker基本架构)
    - [1.5. Docker基本概念](#15-docker基本概念)
    - [1.6. Docker核心技术与实现原理](#16-docker核心技术与实现原理)

<!-- /TOC -->


# 1. Docker

## 1.1. 容器化技术  
<!-- 
https://www.jianshu.com/p/e1f7b8d5184c
-->

&emsp; 容器和虚拟机  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/devops/docker/docker-11.png)  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/devops/docker/docker-12.png)![image](https://gitee.com/wt1814/pic-host/raw/master/images/devops/docker/docker-13.png)  
&emsp; <font color = "red">传统虚拟化是在硬件层面实现虚拟化，需要有额外的虚拟机管理应用和虚拟机操作系统层；而Docker容器是在操作系统层面实现虚拟化，直接复用本地主机操作系统，更加轻量级。</font>  
&emsp; 虚拟机运行的是一个完成的操作系统，通过虚拟机管理程序对主机资源进行虚拟访问，相比之下需要的资源更多。  
&emsp; 容器是在本机运行，并与其他容器共享主机的内核，它运行的一个独立的进程，不占用其他任何可执行文件的内存，非常轻量。  

1. 虚拟机：虚拟化硬件 虚拟机 Virtual Machine 指通过软件模拟的具有完整硬件系统功能的、运行在一个完全隔离环境中的完整计算机系统。在实体计算机中能够完成的工作在虚拟机中都能够实现。  
&emsp; 在计算机中创建虚拟机时，需要将实体机的部分硬盘和内存容量作为虚拟机的硬盘和内存容量。每个虚拟机都有独立的 CMOS、硬盘和操作系统，可以像使用实体机一样对虚拟机进行操作。在容器技术之前，业界的网红是虚拟机。  
&emsp; 虚拟机技术的代表，是 VMWare 和 OpenStack。更多请参看百科虚拟机。  
2. 容器：将操作系统层虚拟化，是一个标准的软件单元  
&emsp; 随处运行：容器可以将代码与配置文件和相关依赖库进行打包，从而确保在任何环境下的运行都是一致的。  
&emsp; 高资源利用率：容器提供进程级的隔离，因此可以更加精细地设置 CPU 和内存的使用率，进而更好地利用服务器的计算资源。  
&emsp; 快速扩展：每个容器都可作为单独的进程予以运行，并且可以共享底层操作系统的系统资源，这样一来可以加快容器的启动和停止效率。  
3. 区别与联系  
&emsp; 虚拟机虽然可以隔离出很多「子电脑」，但占用空间更大，启动更慢。虚拟机软件可能还要花钱，例如VMWare；  
&emsp; 容器技术不需要虚拟出整个操作系统，只需要虚拟一个小规模的环境，类似「沙箱」；  
&emsp; 运行空间，虚拟机一般要几 GB 到 几十 GB 的空间，而容器只需要 MB 级甚至 KB 级；  

&emsp; 来看一下对比数据：  

|特性	|虚拟机	|容器|
|---|---|----|
|隔离级别	|操作系统级	|进程|
|隔离策略|	Hypervisor（虚拟机监控器）|	Cgroups（控制组群）|
|系统资源	|5 ～ 15%	|0 ～ 5%|
|启动时间	|分钟级	|秒级|
|镜像存储	|GB - TB	|KB - MB|
|集群规模	|上百	|上万|
|高可用策略	|备份、容灾、迁移	|弹性、负载、动态|

&emsp; 与虚拟机相比，容器更轻量且速度更快，因为它利用了 Linux 底层操作系统在隔离的环境中运行。虚拟机的 Hypervisor 创建了一个非常牢固的边界，以防止应用程序突破它，而容器的边界不那么强大。
&emsp; 物理机部署不能充分利用资源，造成资源浪费。虚拟机方式部署，虚拟机本身会占用大量资源，导致资源浪费，另外虚拟机性能也很差。而容器化部署比较灵活，且轻量级，性能较好。
&emsp; 虚拟机属于虚拟化技术，而 Docker 这样的容器技术，属于轻量级的虚拟化。  

* 容器时在linux上本机运行，并与其他容器共享主机的内核，它运行的一个独立的进程，不占用其他任何可执行文件的内存，非常轻量。  
* 虚拟机运行的是一个完成的操作系统，通过虚拟机管理程序对主机资源进行虚拟访问，相比之下需要的资源更多。  

----

![image](https://gitee.com/wt1814/pic-host/raw/master/images/devops/docker/docker-17.png)  
&emsp; 传统的虚拟化技术在虚拟机（VM）和硬件之间加了一个软件层Hypervisor，或者叫做虚拟机管理程序。Hypervisor的运行方式分为两类：  

* 直接运行在物理硬件之上。如基于内核的KVM虚拟机，这种虚拟化需要CPU支持虚拟化技术；
* 运行在另一个操作系统。如VMWare和VitrualBox等虚拟机。

&emsp; 因为运行在虚拟机上的操作系统是通过Hypervisor来最终分享硬件，所以虚拟机Guest OS发出的指令都需要被Hypervisor捕获，然后翻译为物理硬件或宿主机操作系统能够识别的指令。  
&emsp; VMWare和VirtualBox等虚拟机在性能方面远不如裸机，但基于硬件虚拟机的KVM约能发挥裸机80%的性能。这种虚拟化的优点是不同虚拟机之间实现了完全隔离，安全性很高，并且能够在一台物理机上运行多种内核的操作系统（如Linux和Window），但每个虚拟机都很笨重，占用资源多而且启动很慢。  
Docker引擎运行在操作系统上，是基于内核的LXC、Chroot等技术实现容器的环境隔离和资源控制，在容器启动后，容器里的进程直接与内核交互，无需经过Docker引擎中转，因此几乎没有性能损耗，能发挥出裸机的全部性能。  
&emsp; 但由于Docker是基于Linux内核技术实现容器化的，因此使得容器内运行的应用只能运行在Linux内核的操作系统上。目前在Window上安装的docker引擎其实是利用了Window自带的Hyper-V虚拟化工具自动创建了一个Linux系统，容器内的操作实际上是间接使用这个虚拟系统实现的。  

----

**容器和虚拟机的根本性区别**  
在虚拟机模型中，首先要启动物理机和 Hypervisor 引导程序（这边略过了 BIOS 和 Bootloader 等阶段）。一旦 Hypervisor 启动之后，就会占用机器上的全部物理资源，如 CPU、RAM、存储和 NIC。Hypervisor 接下来就会将这些物理资源划分为虚拟资源，并且看起来与真实物理资源完全一致。然后 Hypervison 将这些资源打包进一个叫做虚拟机（VM）的软件结构中。之后在 VM 中安装操作系统，并在操作系统上安装应用。假如要运行 4 个应用，那么一般来说需要创建 4 个虚拟机并安装 4 个操作系统，然后分别安装应用。  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/devops/docker/docker-24.png)  
在容器模型中。服务器启动之后，所选择的操作系统会启动。那么启动的操作系统会占用了全部硬件资源。在 OS 层之上，需要安装容器引擎，比如 docker。容器引擎会获取系统资源，然后将这些资源分割成安全的互相隔离的资源结构，称之为容器。此时，每个容器在其内部运行应用。  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/devops/docker/docker-25.png)  

两者的区别，主要如下：  

* 从高层面上来讲，Hypervisor 是硬件虚拟化，Hepervisor 将硬件物理资源划分为了虚拟资源，通过中间层将一层或多台独立的机器虚拟运行于物理硬件之上。而容器是操作系统虚拟化，将系统资源（软件和硬件资源）划分为了虚拟资源，是直接运行在操作系统内核之上的用户空间，使用的是操作系统的系统调用接口，不需要像传统的虚拟化和半虚拟化技术那样需要模拟层和管理层。除此之外，还可以让多个独立的用户空间运行在同一台宿主机上。
* 使用虚拟机的话，每个虚拟机都有自己的操作系统。但是，操作系统本身就有其额外开销。每个操作系统本身就会消耗一点 CPU、一点 ARM、一点存储空间。每个操作系统都需要打补丁升级，也都面临着被攻击的风险。这种现象被称为 OS Tax 或者 VM Tax，即表示每个 OS 都会额外占用一定的资源。
而容器模型则只需要一个操作系统，因为所有的容器共享同一个内核。那么意味着只有一个操作系统消耗 CPU、RAM 和存储资源。
那么相比之下容器模型的资源利用率会更高。当需要运行成百上千应用的时候，两者之间的区别会更明显。
* 另一个是启动时间的上的区别。
虚拟机中需要启动内核，内核启动过程中需要对硬件进行遍历和初始化。
而容器不是完整的操作系统，内部也不需要内核，因为是共享主机的内核，所以不需要上述遍历和初始化，所以启动要比虚拟机快。唯一对容器启动时间有影响的就是容器内应用启动所花费的时间。



## 1.2. Docker简介  

&emsp; Docker是提供应用打包部署与运行应用的容器化平台。 

* 开源的应用容器引擎，基于Go语言开发  
* 容器是完全使用沙箱机制，容器开销极低  
* Docker就是容器化技术的代名词	
* Docker也具备一定虚拟化职能

![image](https://gitee.com/wt1814/pic-host/raw/master/images/devops/docker/docker-1.png)  

## 1.3. Docker的使用场景  
&emsp; Docker作为一种轻量级的虚拟化方案，应用场景十分丰富，下面收集了一些常见的场景：

* 作为轻量级虚拟机使用  
&emsp; 可以使用Ubuntu等系统镜像创建容器，当作虚拟机来使用，相比于传统虚拟机，启动速度更快，资源占用更少，单机可以启动大量的操作系统容器，方便进行各种测试；  
* 作为云主机使用  
&emsp; 结合Kubernetes这样的容器管理系统，可以在大量服务器上动态分配和管理容器，在公司内部，甚至可以取代VMWare这样的虚拟机管理平台，使用Docker容器作为云主机使用；  
* 应用服务打包  
&emsp; 在Web应用服务开发场景，可以把Java运行环境、Tomcat服务器打包为一个基础镜像，在修改了代码包后加入到基础镜像来构建一个新的镜像，能很方便的升级服务和控制版本；  
* 容器云平台CaaS  
&emsp; Docker的出现，使得很多云平台供应商开始提供容器云的服务，简称容器即服务CaaS，以下对比一下IaaS、PaaS和SaaS：  
    * IaaS（基础设施即服务）：提供虚拟机或者其他基础资源作为服务提供给用户。用户可以从供应商那里获得虚拟机或者存储等资源来装载相关的应用，同时这些基础设施的繁琐的管理工作将由IaaS供应商来处理。其主要的用户是企业的系统管理员和运维人员；
    * PaaS（平台即服务）：把开发平台作为服务提供给用户。用户可以在一个包括SDK，文档和测试环境等在内的开发平台上非常方便地编写应用，而且不论是在部署，或者在运行的时候，用户都无需为服务器、操作系统、网络和存储等资源的管理操心，这些繁琐的工作都由PaaS供应商负责处理。其主要的用户是企业开发人员。
    * SaaS（软件即服务）：将应用作为服务提供给客户。用户只要接上网络，并通过浏览器，就能直接使用在云端上运行的应用，而不需要顾虑类似安装等琐事，并且免去初期高昂的软硬件投入。SaaS主要面对的是普通的用户。
    * CaaS（容器即服务）：完成IaaS和PaaS两个层级的功能。相对于传统的IaaS和PaaS服务，CaaS对底层的支持比PaaS更灵活，而对上层应用的操控又比IaaS更容易。同时因为Docker是比VM更细粒度的虚拟化服务，所以能够对计算资源做到更高效的利用。CaaS可以部署在任何物理机，虚拟机或IaaS云之上。
* 持续集成和持续部署  
&emsp; 互联网行业提倡敏捷开发，持续集成部署CI/CD便是最典型的开发模式。使用Docker容器云平台，就能实现从代码编写完成推送到Git/SVN后，自动触发后端CaaS平台将代码下载、编译并构建成测试Docker镜像，再替换测试环境容器服务，自动在Jenkins或者Hudson中运行单元/集成测试，测试通过后，马上就能自动将新版本镜像更新到线上，完成服务升级。整个过程全自动化，一气呵成，最大程度地简化了运维，而且保证线上、线下环境完全一致，而且线上服务版本与Git/SVN发布分支也实现统一。  
* 解决微服务架构的实施难题  
&emsp; 基于Spring Cloud这样的微服务框架，能够实现微服务的管理，但微服务本身还是需要运行在操作系统上。一个采用微服务架构开发的应用中，微服务的个数往往很多，这就导致了一台服务器上往往需要启动多个微服务来提高资源的利用率，而微服务本身可能就只能兼容部分操作系统。  
这就导致了就算有大量的服务器资源（操作系统可能不一样），但由于微服务本身与操作系统可能相关，就不能做到让微服务在任意服务器上运行，这就带来了资源的浪费和运维的困难。利用Docker容器的环境隔离能力，让微服务运行在容器内，就能够解决以上所说的问题。  
* 执行临时任务  
&emsp; 有时候用户只是想执行一次性的任务，但如果用传统虚拟机的方式就要搭建环境，执行完任务后还要释放资源，比较麻烦。使用Docker容器就可以构建临时的运行环境，执行完任务后关闭容器即可，方便快捷。  
* 多租户环境  
&emsp; 利用Docker的环境隔离能力，可以为不同的租户提供独占的容器，实现简单而且成本较低。  

## 1.4. Docker基本架构  
<!-- 
https://mp.weixin.qq.com/s/RvURRnoSFPywtR8Af7IZ-g
-->
Docker 的核心组件有：

* Docker 客户端和服务器  
* Docker 容器  
* Docker 镜像和 Registry（镜像仓库服务）  

&emsp; 一个完整的Docker基本架构由如下几个部分构成：  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/devops/docker/docker-16.png)  

&emsp; Docker采用的是客户端/服务器架构，客户端只需要向 Docker 服务器或守护进程发出请求即可完成各类操作。  
&emsp; Docker 是一个客户-服务器（C/S）架构的程序。Docker 客户端只需要向 Docker 服务器或守护进程发出请求，服务器或守护进程将完成所有工作并返回结果。Docker 提供了一个命令行工具和一整套 RESTful API。你可以在同一台宿主机上运行 Docker 守护进程和客户端，也可以从本地的 Docker 客户端连接到运行在另一台宿主机上的远程 Docker 守护进程。Docker 以 root 权限运行它的守护进程，来处理普通用户无法完成的操作（如挂载文件系统）。Docker 程序是 Docker 守护进程的客户端程序，同样也需要以 root 身份运行。  

---

![image](https://gitee.com/wt1814/pic-host/raw/master/images/devops/docker/docker-18.png)  

* distribution 负责与docker registry交互，上传镜像以及v2 registry 有关的源数据
* registry负责docker registry有关的身份认证、镜像查找、镜像验证以及管理registry mirror等交互操作
* image 负责与镜像源数据有关的存储、查找，镜像层的索引、查找以及镜像tar包有关的导入、导出操作
* reference负责存储本地所有镜像的repository和tag名，并维护与镜像id之间的映射关系
* layer模块负责与镜像层和容器层源数据有关的增删改查，并负责将镜像层的增删改查映射到实际存储镜像层文件的graphdriver模块
* graghdriver是所有与容器镜像相关操作的执行者

---

这个架构就简单清晰指明了server/client交互，容器和镜像、数据之间的一些联系。  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/devops/docker/docker-2.png)  
docker daemon就是docker的守护进程即server端，可以是远程的，也可以是本地的，这个不是C/S架构吗，客户端Docker client 是通过rest api进行通信。  
docker cli 用来管理容器和镜像，客户端提供一个只读镜像，然后通过镜像可以创建多个容器，这些容器可以只是一个RFS（Root file system根文件系统），也可以ishi一个包含了用户应用的RFS，容器再docker client中只是要给进程，两个进程之间互不可见。  
用户不能与server直接交互，但可以通过与容器这个桥梁来交互，由于是操作系统级别的虚拟技术，中间的损耗几乎可以不计。  


## 1.5. Docker基本概念  

<!-- 
https://mp.weixin.qq.com/s/RvURRnoSFPywtR8Af7IZ-g
-->

* Docker客户端：也就是在窗口中执行的命令，都是客户端。    
* Docker Daemon守护进程：用于去接受client的请求并处理请求。  
&emsp; Docker Daemon（或者Docker 服务器）用来监听 Docker API 的请求和管理 Docker 对象，比如镜像、容器、网络和卷。默认情况 docker 客户端和 docker daemon 位于同一主机，此时 daemon 监听 /var/run/docker.sock 这个 Unix 套接字文件，来获取来自客户端的 Docker 请求。当然通过配置，也可以借助网络来实现 Docker Client 和 daemon 之间的通信，默认非 TLS 端口为 2375，TLS 默认端口为 2376。  

* 引擎：创建和管理容器的工具，通过读取镜像来生成容器，并负责从仓库拉取镜像或提交镜像到仓库中；  
* 镜像(Image)
    * 一个只读的模板，镜像可以用来创建 Docker 容器
    * 用户基于镜像来运行自己的容器。镜像是基于 Union 文件系统的层式结构
    * 可以简单创建或更新现有镜像，或者直接下载使用其他人的。可以理解为生成容器的『源代码』

* 容器(Container)
    * 容器是从镜像创建的运行实例，在启动的时候创建一层可写层作为最上层（因为镜像是只读的）
    * 可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台
    * 可以把容器看做是一个简易版的 Linux 环境（包括root用户权限、进程空间、用户空间和网络空间等）和运行在其中的应用程序

* 仓库(Registry)
    * 集中存放镜像文件的场所，可以是公有的，也可以是私有的
    * 最大的公开仓库是 Docker Hub
    * 国内的公开仓库包括 Docker Pool 等
    * 当用户创建了自己的镜像之后就可以使用 push 命令将它上传到公有或者私有仓库，这样下次在另外一台机器上使用这个镜像时候，只需要从仓库上 pull 下来就可以了
    * Docker 仓库的概念跟 Git 类似，注册服务器可以理解为 GitHub 这样的托管服务
* 宿主机：运行引擎的操作系统所在服务器。  

## 1.6. Docker核心技术与实现原理    

<!-- 
https://www.jianshu.com/p/e1f7b8d5184c
http://dockone.io/article/2941

-->
docker本质就是宿主机的一个进程，docker是通过namespace实现资源隔离，通过cgroup实现资源限制，通过写时复制技术（copy-on-write）实现了高效的文件操作（类似虚拟机的磁盘比如分配500g并不是实际占用物理磁盘500g）  
1）namespaces 名称空间  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/devops/docker/docker-18.png)  
2）control Group 控制组  
cgroup的特点是：  　　　

* cgroup的api以一个伪文件系统的实现方式，用户的程序可以通过文件系统实现cgroup的组件管理
* cgroup的组件管理操作单元可以细粒度到线程级别，另外用户可以创建和销毁cgroup，从而实现资源载分配和再利用
* 所有资源管理的功能都以子系统的方式实现，接口统一子任务创建之初与其父任务处于同一个cgroup的控制组


四大功能：  

* 资源限制：可以对任务使用的资源总额进行限制
* 优先级分配：通过分配的cpu时间片数量以及磁盘IO带宽大小，实际上相当于控制了任务运行优先级
* 资源统计：可以统计系统的资源使用量，如cpu时长，内存用量等
* 任务控制：cgroup可以对任务执行挂起、恢复等操作
