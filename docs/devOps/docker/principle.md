<!-- TOC -->

- [1. Docker](#1-docker)
    - [1.1. 虚拟化技术](#11-虚拟化技术)
        - [1.1.1. 虚拟机结构介绍](#111-虚拟机结构介绍)
        - [1.1.2. 容器化技术Docker](#112-容器化技术docker)
        - [1.1.3. 虚拟机和容器对比](#113-虚拟机和容器对比)
    - [1.2. Docker简介](#12-docker简介)
    - [1.3. Docker的使用场景](#13-docker的使用场景)
    - [1.4. Docker基本概念](#14-docker基本概念)

<!-- /TOC -->

# 1. Docker
&emsp; **Docker中文社区：**https://www.docker.org.cn/dockershuji.html  

## 1.1. 虚拟化技术  
&emsp; 应用部署化的演变：  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/devops/docker/docker-40.png)  

### 1.1.1. 虚拟机结构介绍    
![image](https://gitee.com/wt1814/pic-host/raw/master/images/devops/docker/docker-31.png)  

* 基础设施(Infrastructure)。它可以是个人电脑，数据中心的服务器，或者是云主机。
* 主操作系统(Host Operating System)。个人电脑之上，运行的可能是MacOS，Windows或者某个Linux发行版。
* 虚拟机管理系统(Hypervisor)。利用Hypervisor，可以在主操作系统之上运行多个不同的从操作系统。类型1的Hypervisor有支持MacOS的HyperKit，支持Windows的Hyper-V以及支持Linux的KVM。类型2的Hypervisor有VirtualBox和VMWare。
* 从操作系统(Guest Operating System)。假设需要运行3个相互隔离的应用，则需要使用Hypervisor启动3个从操作系统，也就是3个虚拟机。这些虚拟机都非常大，也许有700MB，这就意味着它们将占用2.1GB的磁盘空间。更糟糕的是，它们还会消耗很多CPU和内存。
* 各种依赖。每一个从操作系统都需要安装许多依赖。如果你的的应用需要连接PostgreSQL的话，则需要安装libpq-dev；如果使用Ruby的话，应该需要安装gems；如果使用其他编程语言，比如Python或者Node.js，都会需要安装对应的依赖库。
* 应用。安装依赖之后，就可以在各个从操作系统分别运行应用了，这样各个应用就是相互隔离的。

&emsp; 传统虚拟化是在硬件层面实现虚拟化，虚拟机Virtual Machine指通过软件模拟的具有完整硬件系统功能的、运行在一个完全隔离环境中的完整计算机系统。在实体计算机中能够完成的工作在虚拟机中都能够实现。虚拟机运行的是一个完成的操作系统，通过虚拟机管理程序对主机资源进行虚拟访问，相比之下需要的资源更多。  

&emsp; 在虚拟机模型中，首先要启动物理机和 Hypervisor 引导程序（这边略过了 BIOS 和 Bootloader 等阶段）。一旦 Hypervisor 启动之后，就会占用机器上的全部物理资源，如 CPU、RAM、存储和 NIC。Hypervisor 接下来就会将这些物理资源划分为虚拟资源，并且看起来与真实物理资源完全一致。然后 Hypervison 将这些资源打包进一个叫做虚拟机（VM）的软件结构中。之后在 VM 中安装操作系统，并在操作系统上安装应用。假如要运行 4 个应用，那么一般来说需要创建 4 个虚拟机并安装 4 个操作系统，然后分别安装应用。  

### 1.1.2. 容器化技术Docker  
&emsp; Docker可以说是容器化技术的代名词。
![image](https://gitee.com/wt1814/pic-host/raw/master/images/devops/docker/docker-32.png)  

* 基础设施(Infrastructure)。
* 主操作系统(Host Operating System)。所有主流的Linux发行版都可以运行Docker。对于MacOS和Windows，也有一些办法”运行”Docker。
* Docker守护进程(Docker Daemon)。Docker守护进程取代了Hypervisor，它是运行在操作系统之上的后台进程，负责管理Docker容器。
* 各种依赖。对于Docker，应用的所有依赖都打包在Docker镜像中，Docker容器是基于Docker镜像创建的。
* 应用。应用的源代码与它的依赖都打包在Docker镜像中，不同的应用需要不同的Docker镜像。不同的应用运行在不同的Docker容器中，它们是相互隔离的。

&emsp; **Docker容器是在操作系统层面实现虚拟化**，是一个标准的软件单元 ，直接复用本地主机操作系统。容器是在本机运行，与其他容器共享主机的内核，它运行的一个独立的进程，不占用其他任何可执行文件的内存，更加轻量级。  
&emsp; 在容器模型中。服务器启动之后，所选择的操作系统会启动。那么启动的操作系统会占用了全部硬件资源。在 OS 层之上，需要安装容器引擎，比如 docker。<font color = "lime">容器引擎会获取系统资源，然后将这些资源分割成安全的互相隔离的资源结构，称之为容器。此时，每个容器在其内部运行应用。</font>  

### 1.1.3. 虚拟机和容器对比  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/devops/docker/docker-12.png)![image](https://gitee.com/wt1814/pic-host/raw/master/images/devops/docker/docker-13.png)  

![image](https://gitee.com/wt1814/pic-host/raw/master/images/devops/docker/docker-11.png)  

&emsp; 物理机部署不能充分利用资源，造成资源浪费。虚拟机方式部署，虚拟机本身会占用大量资源，导致资源浪费，另外虚拟机性能也很差。而容器化部署比较灵活，且轻量级，性能较好。  

* <font color = "red">从高层面上来讲，Hypervisor是硬件虚拟化，Hepervisor将硬件物理资源划分为了虚拟资源，通过中间层将一层或多台独立的机器虚拟运行于物理硬件之上。而容器是操作系统虚拟化，将系统资源（软件和硬件资源）划分为了虚拟资源，是直接运行在操作系统内核之上的用户空间，使用的是操作系统的系统调用接口，不需要像传统的虚拟化和半虚拟化技术那样需要模拟层和管理层。除此之外，还可以让多个独立的用户空间运行在同一台宿主机上。</font>
* **使用虚拟机的话，每个虚拟机都有自己的操作系统。但是，操作系统本身就有其额外开销。**每个操作系统本身就会消耗一点 CPU、一点 ARM、一点存储空间。每个操作系统都需要打补丁升级，也都面临着被攻击的风险。这种现象被称为 OS Tax 或者 VM Tax，即表示每个 OS 都会额外占用一定的资源。
而容器模型则只需要一个操作系统，因为所有的容器共享同一个内核。那么意味着只有一个操作系统消耗 CPU、RAM 和存储资源。
那么相比之下容器模型的资源利用率会更高。当需要运行成百上千应用的时候，两者之间的区别会更明显。
* 另一个是启动时间的上的区别。
虚拟机中需要启动内核，内核启动过程中需要对硬件进行遍历和初始化。
而容器不是完整的操作系统，内部也不需要内核，因为是共享主机的内核，所以不需要上述遍历和初始化，所以启动要比虚拟机快。唯一对容器启动时间有影响的就是容器内应用启动所花费的时间。  

&emsp; 区别与联系  
&emsp; 虚拟机虽然可以隔离出很多「子电脑」，但占用空间更大，启动更慢。  
&emsp; 容器技术不需要虚拟出整个操作系统，只需要虚拟一个小规模的环境，类似「沙箱」；  
&emsp; 运行空间，虚拟机一般要几GB到几十GB的空间，而容器只需要MB级甚至KB级；  

&emsp; 来看一下对比数据：  

|特性|虚拟机|容器|
|---|---|----|
|隔离级别|操作系统级|进程|
|隔离策略|Hypervisor（虚拟机监控器）|Cgroups（控制组群）|
|系统资源|5 ～ 15%|0 ～ 5%|
|启动时间|分钟级|秒级|
|镜像存储|GB - TB|KB - MB|
|集群规模|上百|上万|
|高可用策略	|备份、容灾、迁移|弹性、负载、动态|

## 1.2. Docker简介  
&emsp; Docker是提供应用打包部署与运行应用的容器化平台。Docker本身并不是容器，它是创建容器的工具，是应用容器引擎。 

![image](https://gitee.com/wt1814/pic-host/raw/master/images/devops/docker/docker-1.png)  

&emsp; Docker的特点：  

* Build, Ship and Run，即搭建、发送、运行。  
* Build once、Run anywhere，搭建一次，到处能用。  

<!-- 
&emsp; 容器带来的好处有哪些？  
1. 秒级的交付和部署  
2. 保证环境一致性  
3. 高效的资源利用  
4. 弹性的伸缩  
5. 动态调度迁移成本低  

&emsp; 随处运行：容器可以将代码与配置文件和相关依赖库进行打包，从而确保在任何环境下的运行都是一致的。  
&emsp; 高资源利用率：容器提供进程级的隔离，因此可以更加精细地设置 CPU 和内存的使用率，进而更好地利用服务器的计算资源。  
&emsp; 快速扩展：每个容器都可作为单独的进程予以运行，并且可以共享底层操作系统的系统资源，这样一来可以加快容器的启动和停止效率。
-->
## 1.3. Docker的使用场景  
&emsp; Docker作为一种轻量级的虚拟化方案，应用场景十分丰富，下面收集了一些常见的场景：

* 作为轻量级虚拟机使用  
&emsp; 可以使用Ubuntu等系统镜像创建容器，当作虚拟机来使用，相比于传统虚拟机，启动速度更快，资源占用更少，单机可以启动大量的操作系统容器，方便进行各种测试；  
* 作为云主机使用  
&emsp; 结合Kubernetes这样的容器管理系统，可以在大量服务器上动态分配和管理容器，在公司内部，甚至可以取代VMWare这样的虚拟机管理平台，使用Docker容器作为云主机使用；  
* 应用服务打包  
&emsp; 在Web应用服务开发场景，可以把Java运行环境、Tomcat服务器打包为一个基础镜像，在修改了代码包后加入到基础镜像来构建一个新的镜像，能很方便的升级服务和控制版本；  
* 容器云平台CaaS  
&emsp; Docker的出现，使得很多云平台供应商开始提供容器云的服务，简称容器即服务CaaS，以下对比一下IaaS、PaaS和SaaS：  
    * IaaS（基础设施即服务）：提供虚拟机或者其他基础资源作为服务提供给用户。用户可以从供应商那里获得虚拟机或者存储等资源来装载相关的应用，同时这些基础设施的繁琐的管理工作将由IaaS供应商来处理。其主要的用户是企业的系统管理员和运维人员；
    * PaaS（平台即服务）：把开发平台作为服务提供给用户。用户可以在一个包括SDK，文档和测试环境等在内的开发平台上非常方便地编写应用，而且不论是在部署，或者在运行的时候，用户都无需为服务器、操作系统、网络和存储等资源的管理操心，这些繁琐的工作都由PaaS供应商负责处理。其主要的用户是企业开发人员。
    * SaaS（软件即服务）：将应用作为服务提供给客户。用户只要接上网络，并通过浏览器，就能直接使用在云端上运行的应用，而不需要顾虑类似安装等琐事，并且免去初期高昂的软硬件投入。SaaS主要面对的是普通的用户。
    * CaaS（容器即服务）：完成IaaS和PaaS两个层级的功能。相对于传统的IaaS和PaaS服务，CaaS对底层的支持比PaaS更灵活，而对上层应用的操控又比IaaS更容易。同时因为Docker是比VM更细粒度的虚拟化服务，所以能够对计算资源做到更高效的利用。CaaS可以部署在任何物理机，虚拟机或IaaS云之上。
* 持续集成和持续部署  
&emsp; 互联网行业提倡敏捷开发，持续集成部署CI/CD便是最典型的开发模式。使用Docker容器云平台，就能实现从代码编写完成推送到Git/SVN后，自动触发后端CaaS平台将代码下载、编译并构建成测试Docker镜像，再替换测试环境容器服务，自动在Jenkins或者Hudson中运行单元/集成测试，测试通过后，马上就能自动将新版本镜像更新到线上，完成服务升级。整个过程全自动化，一气呵成，最大程度地简化了运维，而且保证线上、线下环境完全一致，而且线上服务版本与Git/SVN发布分支也实现统一。  
* 解决微服务架构的实施难题  
&emsp; 基于Spring Cloud这样的微服务框架，能够实现微服务的管理，但微服务本身还是需要运行在操作系统上。一个采用微服务架构开发的应用中，微服务的个数往往很多，这就导致了一台服务器上往往需要启动多个微服务来提高资源的利用率，而微服务本身可能就只能兼容部分操作系统。  
&emsp; 这就导致了就算有大量的服务器资源（操作系统可能不一样），但由于微服务本身与操作系统可能相关，就不能做到让微服务在任意服务器上运行，这就带来了资源的浪费和运维的困难。利用Docker容器的环境隔离能力，让微服务运行在容器内，就能够解决以上所说的问题。  
* 执行临时任务  
&emsp; 有时候用户只是想执行一次性的任务，但如果用传统虚拟机的方式就要搭建环境，执行完任务后还要释放资源，比较麻烦。使用Docker容器就可以构建临时的运行环境，执行完任务后关闭容器即可，方便快捷。  
* 多租户环境  
&emsp; 利用Docker的环境隔离能力，可以为不同的租户提供独占的容器，实现简单而且成本较低。  

## 1.4. Docker基本概念  
<!-- 
https://mp.weixin.qq.com/s/RvURRnoSFPywtR8Af7IZ-g
-->
<!-- 
![image](https://gitee.com/wt1814/pic-host/raw/master/images/devops/docker/docker-18.png)  

* distribution 负责与docker registry交互，上传镜像以及管理registry有关的源数据
* registry负责docker registry有关的身份认证、镜像查找、镜像验证以及管理registry mirror等交互操作
* image 负责与镜像源数据有关的存储、查找，镜像层的索引、查找以及镜像tar包有关的导入、导出操作
* reference负责存储本地所有镜像的repository和tag名，并维护与镜像id之间的映射关系
* layer模块负责与镜像层和容器层源数据有关的增删改查，并负责将镜像层的增删改查映射到实际存储镜像层文件的graphdriver模块
* graghdriver是所有与容器镜像相关操作的执行者
-->
&emsp; 一个完整的Docker基本架构由如下几个部分构成：  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/devops/docker/docker-16.png) 
&emsp; **Docker基本概念**  

<!-- 
https://mp.weixin.qq.com/s/RvURRnoSFPywtR8Af7IZ-g
-->

* Docker客户端：也就是在窗口中执行的命令，都是客户端。    
* Docker Daemon守护进程：用于接收client的请求并处理请求。  
&emsp; Docker Daemon（或者Docker 服务器）用来监听 Docker API 的请求和管理 Docker 对象，比如镜像、容器、网络和卷。默认情况 docker 客户端和 docker daemon 位于同一主机，此时 daemon 监听 /var/run/docker.sock 这个 Unix 套接字文件，来获取来自客户端的 Docker 请求。当然通过配置，也可以借助网络来实现 Docker Client 和 daemon 之间的通信，默认非 TLS 端口为 2375，TLS 默认端口为 2376。  
* 引擎：创建和管理容器的工具，通过读取镜像来生成容器，并负责从仓库拉取镜像或提交镜像到仓库中；  
* 镜像(Image)
    * 一个只读的模板，镜像可以用来创建Docker容器
    * 用户基于镜像来运行自己的容器。镜像是基于Union文件系统的层式结构
    * 可以简单创建或更新现有镜像，或者直接下载使用其他人的。可以理解为生成容器的『源代码』
* 容器(Container)
    * 容器是从镜像创建的运行实例，在启动的时候创建一层可写层作为最上层（因为镜像是只读的）
    * 可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台
* 仓库(Registry)
    * 集中存放镜像文件的场所，可以是公有的，也可以是私有的
    * 最大的公开仓库是Docker Hub
    * 国内的公开仓库包括Docker Pool等
    * 当用户创建了自己的镜像之后就可以使用push命令将它上传到公有或者私有仓库，这样下次在另外一台机器上使用这个镜像时候，只需要从仓库上 pull 下来就可以了
    * Docker 仓库的概念跟 Git 类似，注册服务器可以理解为 GitHub 这样的托管服务
* 宿主机：运行引擎的操作系统所在服务器。  

&emsp; Docker是一个客户-服务器（C/S）架构的程序。Docker 客户端只需要向 Docker 服务器或守护进程发出请求，服务器或守护进程将完成所有工作并返回结果。Docker 提供了一个命令行工具和一整套 RESTful API。可以在同一台宿主机上运行 Docker 守护进程和客户端，也可以从本地的 Docker 客户端连接到运行在另一台宿主机上的远程 Docker 守护进程。Docker 以 root 权限运行它的守护进程，来处理普通用户无法完成的操作（如挂载文件系统）。Docker 程序是 Docker 守护进程的客户端程序，同样也需要以 root 身份运行。  


