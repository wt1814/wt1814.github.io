

<!-- TOC -->

- [1. ES多表关联](#1-es多表关联)
    - [1.1. 应用端关联](#11-应用端关联)
    - [1.2. 宽表冗余存储](#12-宽表冗余存储)
    - [1.3. 嵌套文档（Nested）存储](#13-嵌套文档nested存储)
    - [1.4. 父子文档存储](#14-父子文档存储)
    - [1.5. 小结](#15-小结)

<!-- /TOC -->


# 1. ES多表关联  
<!-- 
ElasticSearch 如何像 MySQL 一样做多表联合查询？ 
https://mp.weixin.qq.com/s/SDRI7GmZmmO7bLvhCgUDCg
多表关联设计
https://mp.weixin.qq.com/s?__biz=MzI2NDY1MTA3OQ==&mid=2247484382&idx=1&sn=da073a257575867b8d979dac850c3f8e&chksm=eaa82bf6dddfa2e0bf920f0a3a63cb635277be2ae286a2a6d3fff905ad913ebf1f43051609e8&scene=21#wechat_redirect
-->

    实际业务问题：多层数据结构，一对多关系，如何用一个查询查询所有的数据？  
    比如数据结构如下：帖子--帖子评论--评论用户  3层。  
    现在需要查询一条帖子，最好能查询到帖子下的评论，还有评论下面的用户数据，一个查询能搞定吗？目前两层我可以查询到，3层就不行了。  
    如果一次查询不到，那如何设计数据结构？又应该如何查询呢？  

&emsp; Elasticsearch ，和大多数 NoSQL 数据库类似，是扁平化的。索引是独立文档的集合体。 文档是否匹配搜索请求取决于它是否包含所有的所需信息和关联程度。  
&emsp; Elasticsearch 中单个文档的数据变更是满足ACID的， 而涉及多个文档时则不支持事务。当一个事务部分失败时，无法回滚索引数据到前一个状态。  
&emsp; 扁平化有以下优势：  

* 索引过程是快速和无锁的。
* 搜索过程是快速和无锁的。
* 因为每个文档相互都是独立的，大规模数据可以在多个节点上进行分布。  

&emsp; Elasticsearch关联关系如何存储？  
&emsp; 关联关系仍然非常重要。某些时候，需要缩小扁平化和现实世界关系模型的差异。  
&emsp; 以下四种常用的方法，用来在 Elasticsearch 中进行关联数据的管理：  

## 1.1. 应用端关联  
<!-- 
&emsp; **（1）Application-side joins（服务端Join或客户端Join）**  
&emsp; 这种方式，索引之间完全独立（利于对数据进行标准化处理，如便于上述两种增量同步的实现），由应用端的多次查询来实现近似关联关系查询。  
&emsp; 这种方法<font color = "red">适用于第一个实体只有少量的文档记录的情况</font>（使用ES的terms查询具有上限，默认1024，具体可在elasticsearch.yml中修改），并且最好它们很少改变。这将允许应用程序对结果进行缓存，并避免经常运行第一次查询。 
-->
&emsp; 这是普遍使用的技术，即在应用接口层面来处理关联关系。  

&emsp; 适用场景：数据量少的业务场景。  
&emsp; 优点：数据量少时，用户体验好。  
&emsp; 缺点：数据量大，两次查询耗时肯定会比较长，影响用户体验。  

&emsp; 引申场景：关系型数据库和ES 结合，各取所长。将关系型数据库全量同步到 ES 存储，不做冗余存储。  
&emsp; 如前所述：ES 擅长的是检索，而 MySQL 才擅长关系管理。所以可以考虑二者结合，使用 ES 多索引建立相同的别名，针对别名检索到对应 ID 后再回 MySQL 查询，业务层面通过关联 ID join 出需要的数据。  

## 1.2. 宽表冗余存储 
<!-- 
&emsp; **（2）Data denormalization（数据的非规范化）**  
&emsp; 这种方式，通俗点就是通过<font color = "red">字段冗余</font>，以一张大宽表来实现粗粒度的index，这样可以充分发挥扁平化的优势。但是这是以牺牲索引性能及灵活度为代价的。  
&emsp; 使用的前提：冗余的字段应该是很少改变的；比较适合与一对少量关系的处理。当业务数据库并非采用非规范化设计时，这时要将数据同步到作为二级索引库的ES中，就很难使用上述增量同步方案，必须进行定制化开发，基于特定业务进行应用开发来处理join关联和实体拼接。  
&emsp; ps：宽表处理在处理一对多、多对多关系时，会有字段冗余问题，<font color = "red">适合“一对少量”且这个“一”更新不频繁的应用场景。</font>  
宽表化处理，在查询阶段如果只需要“一”这部分时，需要进行结果去重处理（可以使用ES5.x的字段折叠特性，但无法准确获取分页总数，产品设计上需采用上拉加载分页方式）  
-->
&emsp; 对应于官方文档中的“Data denormalization”，官方直接翻译为：“非规范化的数据”。  
&emsp; 通俗解释就是：冗余存储，对每个文档保持一定数量的冗余数据可以在需要访问时避免进行关联。  
&emsp; 这点通过logstash 同步关联数据到ES时，通常会建议：先通过视图对Mysql数据做好多表关联，然后同步视图数据到ES。此处的视图就是宽表。  
&emsp; 适用场景：一对多或者多对多关联。  
&emsp; 优点：速度快。因为每个文档都包含了所需的所有信息，当这些信息需要在查询进行匹配时，并不需要进行昂贵的关联操作。  
&emsp; 缺点：索引更新或删除数据，应用程序不得不处理宽表的冗余数据；  
&emsp; 由于冗余存储，导致某些搜索和聚合操作可能无法按照预期工作。  

## 1.3. 嵌套文档（Nested）存储  
<!--
&emsp; **（3）Nested objects（嵌套文档）**    
&emsp; 索引性能和查询性能二者不可兼得，必须进行取舍。嵌套文档将实体关系嵌套组合在单文档内部（类似与json的一对多层级结构），这种方式牺牲索引性能（文档内任一属性变化都需要重新索引该文档）来换取查询性能，可以同时返回关系实体，<font color = "red">比较适合于一对少量的关系处理。</font>   
&emsp; ps: 当使用嵌套文档时，使用通用的查询方式是无法访问到的，必须使用合适的查询方式（nested query、nested filter、nested facet等），很多场景下，使用嵌套文档的复杂度在于索引阶段对关联关系的组织拼装。  
 -->
&emsp; Nested类型是ES Mapping定义的集合类型之一，支持独立检索的类型。  
&emsp; 举例：有一个文档描述了一个帖子和一个包含帖子上所有评论的内部对象评论。可以借助 Nested 实现。  
&emsp; 实践注意1：当使用嵌套文档时，使用通用的查询方式是无法访问到的，必须使用合适的查询方式（nested query、nested filter、nested facet等），很多场景下，使用嵌套文档的复杂度在于索引阶段对关联关系的组织拼装。  
&emsp; 推荐实践：[Elasticsearch Nested类型深入详解](https://mp.weixin.qq.com/s?__biz=MzI2NDY1MTA3OQ==&mid=2247484228&idx=1&sn=a75546e29f5eb9be0d7d6c834bd91b83&chksm=eaa82b6cdddfa27a7f5fb5d35394acaba2b0d088f1bde9d0310075573bc38d576f861f26854f&scene=21#wechat_redirect)  
&emsp; 实践注意2：  

```text
index.mapping.nested_fields.limit 缺省值是50。
即：一个索引中最大允许拥有50个nested类型的数据。
index.mapping.nested_objects.limit 缺省值是10000。
即：1个文档中所有nested类型json对象数据的总量是10000。
```
&emsp; 适用场景：一对少量，子文档偶尔更新、查询频繁的场景。  
&emsp; 如果需要索引对象数组并保持数组中每个对象的独立性，则应使用嵌套 Nested 数据类型而不是对象 Oject 数据类型。  

&emsp; 优点：nested文档可以将父子关系的两部分数据（举例：博客+评论）关联起来，可以基于nested类型做任何的查询。  
&emsp; 缺点：查询相对较慢，更新子文档需要更新整篇文档。  

## 1.4. 父子文档存储  
<!-- 
&emsp; **（4）Parent/child relationships（父子文档）**  
&emsp; 父子文档牺牲了一定的查询性能来换取索引性能，<font color = "red">适用于一对多的关系处理</font>。其通过两种type的文档来表示父子实体，父子文档的索引是独立的。父-子文档ID映射存储在 Doc Values 中。当映射完全在内存中时， Doc Values 提供对映射的快速处理能力，另一方面当映射非常大时，可以通过溢出到磁盘提供足够的扩展能力。  
&emsp; 在查询parent-child替代方案时，发现了一种filter-terms的语法，要求某一字段里有关联实体的ID列表。基本的原理是在terms的时候，对于多项取值，如果在另外的index或者type里已知主键id的情况下，某一字段有这些值，可以直接嵌套查询。具体可参考官方文档的示例：通过用户里的粉丝关系，微博和用户的关系，来查询某个用户的粉丝发表的微博列表。  
&emsp; ps：父子文档相比嵌套文档较灵活，但只适用于“一对大量”且这个“一”不是海量的应用场景，该方式比较耗内存和CPU，<font color = "red">这种方式查询比嵌套方式慢5~10倍</font>，且需要使用特定的has_parent和has_child过滤器查询语法，查询结果不能同时返回父子文档（一次join查询只能返回一种类型的文档）。  
&emsp; 而受限于父子文档必须在同一分片上，ES父子文档在滚动索引、多索引场景下对父子关系存储和联合查询支持得不好，而且子文档type删除比较麻烦（子文档删除必须提供父文档ID）。  
-->
&emsp; 注意：6.X之前的版本的父子文档存储在相同索引的不同type中。而6.X之上的版本，单索引下已不存在多type的概念。父子文档Join的都是基于相同索引相同type实现的。  
&emsp; Join类型是ES Mapping定义的类型之一，用于在同一索引的文档中创建父/子关系。 关系部分定义文档中的一组可能关系，每个关系是父名称和子名称。  
&emsp; 实践参考：Elasticsearch 6.X 新类型Join深入详解  
&emsp; 适用场景：子文档数据量要明显多于父文档的数据量，存在1 对多量的关系；子文档更新频繁的场景。  
&emsp; 举例：1 个产品和供应商之间是1对N的关联关系。  
&emsp; 当使用父子文档时，使用has_child 或者has_parent做父子关联查询。  
&emsp; 优点：父子文档可独立更新。  
&emsp; 缺点：维护Join关系需要占据部分内存，查询较Nested更耗资源。  

## 1.5. 小结  
&emsp; 如果业务端对查询性能要求很高的话，还是<font color = "red">建议使用宽表化处理的方式</font>，这样也可以比较好地应对聚合的需求。在索引阶段需要做join处理，查询阶段可能需要做去重处理，分页方式可能也得权衡考虑下。  

![image](https://gitee.com/wt1814/pic-host/raw/master/images/ES/es-74.png)  
1. 在Elasticsearch开发实战中对于多表关联的设计要突破关系型数据库设计的思维定式。  
2. 不建议在es做join操作，parent-child能实现部分功能，但是它的开销比较大，如果可能，尽量在设计时使用扁平的文档模型。  
3. 尽量将业务转化为没有关联关系的文档形式，在文档建模处多下功夫，以提升检索效率。  
4. Nested&Join父子文选型必须考虑性能问题。 nested 类型检索使得检索效率慢几倍，父子Join 类型检索会使得检索效率慢几百倍。  

