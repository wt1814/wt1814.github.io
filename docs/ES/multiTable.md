




# ES多表关联  
<!-- 
多表关联设计
https://mp.weixin.qq.com/s?__biz=MzI2NDY1MTA3OQ==&mid=2247484382&idx=1&sn=da073a257575867b8d979dac850c3f8e&chksm=eaa82bf6dddfa2e0bf920f0a3a63cb635277be2ae286a2a6d3fff905ad913ebf1f43051609e8&scene=21#wechat_redirect
-->

    实际业务问题：多层数据结构，一对多关系，如何用一个查询查询所有的数据？  
    比如数据结构如下：帖子--帖子评论--评论用户  3层。  
    现在需要查询一条帖子，最好能查询到帖子下的评论，还有评论下面的用户数据，一个查询能搞定吗？目前两层我可以查询到，3层就不行了。  
    如果一次查询不到，那如何设计数据结构？又应该如何查询呢？  

&emsp; 目前ES主要有以下4种常用的方法来处理数据实体间的关联关系：  
&emsp; **（1）Application-side joins（服务端Join或客户端Join）**  
&emsp; 这种方式，索引之间完全独立（利于对数据进行标准化处理，如便于上述两种增量同步的实现），由应用端的多次查询来实现近似关联关系查询。  
&emsp; 这种方法<font color = "red">适用于第一个实体只有少量的文档记录的情况</font>（使用ES的terms查询具有上限，默认1024，具体可在elasticsearch.yml中修改），并且最好它们很少改变。这将允许应用程序对结果进行缓存，并避免经常运行第一次查询。  
&emsp; **（2）Data denormalization（数据的非规范化）**  
&emsp; 这种方式，通俗点就是通过<font color = "red">字段冗余</font>，以一张大宽表来实现粗粒度的index，这样可以充分发挥扁平化的优势。但是这是以牺牲索引性能及灵活度为代价的。  
&emsp; 使用的前提：冗余的字段应该是很少改变的；比较适合与一对少量关系的处理。当业务数据库并非采用非规范化设计时，这时要将数据同步到作为二级索引库的ES中，就很难使用上述增量同步方案，必须进行定制化开发，基于特定业务进行应用开发来处理join关联和实体拼接。  
&emsp; ps：宽表处理在处理一对多、多对多关系时，会有字段冗余问题，<font color = "red">适合“一对少量”且这个“一”更新不频繁的应用场景。</font>  
宽表化处理，在查询阶段如果只需要“一”这部分时，需要进行结果去重处理（可以使用ES5.x的字段折叠特性，但无法准确获取分页总数，产品设计上需采用上拉加载分页方式）  

&emsp; **（3）Nested objects（嵌套文档）**    
&emsp; 索引性能和查询性能二者不可兼得，必须进行取舍。嵌套文档将实体关系嵌套组合在单文档内部（类似与json的一对多层级结构），这种方式牺牲索引性能（文档内任一属性变化都需要重新索引该文档）来换取查询性能，可以同时返回关系实体，<font color = "red">比较适合于一对少量的关系处理。</font>   
&emsp; ps: 当使用嵌套文档时，使用通用的查询方式是无法访问到的，必须使用合适的查询方式（nested query、nested filter、nested facet等），很多场景下，使用嵌套文档的复杂度在于索引阶段对关联关系的组织拼装。  
&emsp; **（4）Parent/child relationships（父子文档）**  
&emsp; 父子文档牺牲了一定的查询性能来换取索引性能，<font color = "red">适用于一对多的关系处理</font>。其通过两种type的文档来表示父子实体，父子文档的索引是独立的。父-子文档ID映射存储在 Doc Values 中。当映射完全在内存中时， Doc Values 提供对映射的快速处理能力，另一方面当映射非常大时，可以通过溢出到磁盘提供足够的扩展能力。  
&emsp; 在查询parent-child替代方案时，发现了一种filter-terms的语法，要求某一字段里有关联实体的ID列表。基本的原理是在terms的时候，对于多项取值，如果在另外的index或者type里已知主键id的情况下，某一字段有这些值，可以直接嵌套查询。具体可参考官方文档的示例：通过用户里的粉丝关系，微博和用户的关系，来查询某个用户的粉丝发表的微博列表。  
&emsp; ps：父子文档相比嵌套文档较灵活，但只适用于“一对大量”且这个“一”不是海量的应用场景，该方式比较耗内存和CPU，<font color = "red">这种方式查询比嵌套方式慢5~10倍</font>，且需要使用特定的has_parent和has_child过滤器查询语法，查询结果不能同时返回父子文档（一次join查询只能返回一种类型的文档）。  
&emsp; 而受限于父子文档必须在同一分片上，ES父子文档在滚动索引、多索引场景下对父子关系存储和联合查询支持得不好，而且子文档type删除比较麻烦（子文档删除必须提供父文档ID）。  

&emsp; 如果业务端对查询性能要求很高的话，还是<font color = "red">建议使用宽表化处理的方式</font>，这样也可以比较好地应对聚合的需求。在索引阶段需要做join处理，查询阶段可能需要做去重处理，分页方式可能也得权衡考虑下。  