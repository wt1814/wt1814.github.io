---
title: MySQL深入
date: 2020-02-26 00:00:00
tags:
    - SQL
---

<!-- TOC -->

- [1. MySql存储引擎](#1-mysql存储引擎)
    - [1.1. InnoDB存储引擎](#11-innodb存储引擎)
        - [1.1.1. InnoDB的逻辑存储结构](#111-innodb的逻辑存储结构)
        - [1.1.2. InnoDB的索引](#112-innodb的索引)
        - [1.1.3. InnoDB的特性](#113-innodb的特性)
    - [1.2. MyISAM存储引擎](#12-myisam存储引擎)
        - [1.2.1. MyISAM的索引](#121-myisam的索引)
        - [1.2.2. MyISAM的特性：](#122-myisam的特性)
    - [1.3. 选择合适的存储引擎](#13-选择合适的存储引擎)
- [2. MySql的事务](#2-mysql的事务)
    - [2.1. 事务简介：](#21-事务简介)
    - [2.2. 数据库并发带来哪些问题?](#22-数据库并发带来哪些问题)
    - [2.3. 事务的隔离级别](#23-事务的隔离级别)
    - [2.4. Mysql事务实现原理](#24-mysql事务实现原理)
        - [2.4.1. 原子性的实现](#241-原子性的实现)
        - [2.4.2. 持久性的实现](#242-持久性的实现)
        - [2.4.3. 隔离性的实现](#243-隔离性的实现)
        - [2.4.4. 一致性的实现](#244-一致性的实现)
    - [2.5. 事务SQL语句](#25-事务sql语句)
- [3. MySql的锁](#3-mysql的锁)
    - [3.1. 数据库锁简介](#31-数据库锁简介)
    - [3.2. 锁的粒度，表锁、行锁、页锁](#32-锁的粒度表锁行锁页锁)
        - [3.2.1. 页锁：](#321-页锁)
        - [3.2.2. 表锁](#322-表锁)
        - [3.2.3. 行锁](#323-行锁)
        - [3.2.4. 间隙锁](#324-间隙锁)
    - [3.3. 锁类别，读锁、写锁：](#33-锁类别读锁写锁)
        - [3.3.1. MyISAM存储引擎和表级锁：](#331-myisam存储引擎和表级锁)
        - [3.3.2. InnoDB 存储引擎和表级锁](#332-innodb-存储引擎和表级锁)
        - [3.3.3. InnoDB 存储引擎和行级锁](#333-innodb-存储引擎和行级锁)
    - [3.4. 锁使用方式：乐观锁、悲观锁](#34-锁使用方式乐观锁悲观锁)
    - [3.5. 死锁](#35-死锁)
- [4. 多版本并发控制](#4-多版本并发控制)

<!-- /TOC -->

# 1. MySql存储引擎
1. MySQL是插件式的存储引擎，其中存储引擎分很多种。只要实现符合mysql存储引擎的接口，可以开发自己的存储引擎!  
2. 所有跨存储引擎的功能都是在服务层实现的。  
3. MySQL的存储引擎是针对表的，不是针对库的。也就是说在一个数据库中可以使用不同的存储引擎。但是不建议这样做。  

## 1.1. InnoDB存储引擎  
&emsp; MySQL5.5及之后版本默认的存储引擎：InnoDB。  

### 1.1.1. InnoDB的逻辑存储结构  
&emsp; 从InnoDb存储引擎的逻辑存储结构看，所有数据都被逻辑地存放在一个空间中，称之为表空间（tablespace）。表空间又由段（segment），区（extent），页（page）组成。页在一些文档中有时候也称为块（block）。InnoDb逻辑存储结构图如下：  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/SQL/sql-41.png)  
* 表空间（tablespace）：  
&emsp; 表空间是Innodb存储引擎逻辑的最高层，所有的数据都存放在表空间中。  
&emsp; 默认情况下，Innodb存储引擎有一个共享表空间ibdata1,即所有数据都存放在这个表空间中内。  
&emsp; 如果启用了innodbfileper_table参数，需要注意的是每张表的表空间内存放的只是数据、索引、和插入缓冲Bitmap，其他类的数据，比如回滚(undo)信息、插入缓冲检索页、系统事物信息，二次写缓冲等还是放在原来的共享表内的。  
* 段（segment）：  
&emsp; 表空间由段组成，常见的段有数据段、索引段、回滚段等。  
&emsp; InnoDB存储引擎表是索引组织的，因此数据即索引，索引即数据。数据段即为B+树的叶子结点，索引段即为B+树的非索引结点。  
&emsp; 在InnoDB存储引擎中对段的管理都是由引擎自身所完成，DBA不能也没必要对其进行控制。  
* 区（extent）：  
&emsp; 区是由连续页组成的空间，在任何情况下每个区的大小都为1MB。  
&emsp; 为了保证区中页的连续性，InnoDB存储引擎一次从磁盘申请4~5个区。  
&emsp; 默认情况下，InnoDB存储引擎页的大小为16KB，一个区中一共64个连续的区。  
* 页（page）：  
&emsp; 页是InnoDB磁盘管理的最小单位。  
&emsp; 在InnoDB存储引擎中，默认每个页的大小为16KB。  
&emsp; 从InnoDB1.2.x版本开始，可以通过参数innodbpagesize将页的大小设置为4K，8K，16K。  
&emsp; InnoDB存储引擎中，常见的页类型有：数据页，undo页，系统页，事务数据页，插入缓冲位图页，插入缓冲空闲列表页等。  

### 1.1.2. InnoDB的索引  
.......

### 1.1.3. InnoDB的特性  
* 支持事务  
* 支持行锁，采用MVCC来支持高并发  
* 支持外键  
* 支持崩溃后的安全恢复  
* 不支持全文索引  

## 1.2. MyISAM存储引擎  
### 1.2.1. MyISAM的索引  

### 1.2.2. MyISAM的特性：  
&emsp; MyISAM引擎是MySQL 5.1及之前版本的默认引擎，它的特性是：  
* 不支持事务  
* 不支持行锁，读取时对需要读到的所有表加锁，写入时则对表加排它锁  
* 不支持外键  
* 不支持崩溃后的安全恢复  
* 在表有读取查询的同时，支持往表中插入新纪录  
* 支持BLOB和TEXT的前500个字符索引，支持全文索引  
* 支持延迟更新索引，极大提升写入性能  
* 对于不会进行修改的表，支持压缩表，极大减少磁盘空间占用  

## 1.3. 选择合适的存储引擎  
&emsp; 如果对数据一致性要求比较高，需要事务支持，可以选择 InnoDB。  
&emsp; 如果数据查询多更新少，对查询性能要求比较高，可以选择 MyISAM。  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/SQL/sql-50.png)  

# 2. MySql的事务  
&emsp; MySql的事务基于InnoDB存储引擎讲解。  

## 2.1. 事务简介：  
&emsp; 事务的定义：事务是逻辑上的一组操作，要么都执行，要么都不执行。  
&emsp; ***事务的四大特性(ACID)：***  
* 原子性(Atomicity)：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；  
* 一致性(Consistency)：执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；  
* 隔离性(Isolation）：并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；  
* 持久性(Durability）：一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。  

## 2.2. 数据库并发带来哪些问题?  
&emsp; 多事务的并发进行一般会造成以下几个问题：  
* 脏读（Dirty read）: （一个线程读了另一个线程未提交的数据。）当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。  
* 丢失修改（Lost to modify）: （一个线程覆盖了另一个线程的数据。）指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。例如：事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失。  
* 不可重复读（Unrepeatableread）: （一个线程多次读，另一线程中间修改了数据。）指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。  
* 幻读（Phantom read）: （一个线程多次读，另一线程中间新增了数据。）幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。  

    不可重复度和幻读区别：  
    不可重复读的重点是修改比如多次读取一条记录发现其中某些列的值被修改，幻读的重点在于新增或者删除比如多次读取一条记录发现记录增多或减少了。  

## 2.3. 事务的隔离级别  
&emsp; MySQL的事务隔离级别解决并发事务问题。数据库的事务隔离越严格，并发副作用越小，但付出的代价也就越大。这是因为事务隔离实质上是将事务在一定程度上"串行"进行，这显然与"并发"是矛盾的。  
&emsp; SQL标准定义了四个隔离级别：  
* READ-UNCOMMITTED(读取未提交)：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。  
* READ-COMMITTED(读取已提交)：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。  
* REPEATABLE-READ(可重复读)：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。  
* SERIALIZABLE(可串行化)：最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。  

|隔离级别 |读数据一致性 |脏读|不可重复读|幻读|
|---|---|---|---|---|
|未提交读(Read uncommitted)	|最低级别|是|是|是|
|已提交读(Read committed)|语句级|否 |是	|是|
|可重复读(Repeatable read)|事务级 |否 |否 |是|
|可序列化(Serializable) |最高级别，事务级|否|否 |否| 

## 2.4. Mysql事务实现原理  
&emsp; 实现事务采取了哪些技术以及思想？  
* 原子性：使用 undo log ，从而达到回滚；  
* 持久性：使用 redo log，从而达到故障后恢复；  
* 隔离性：使用锁以及MVCC,运用的优化思想有读写分离，读读并行，读写并行；  
* 一致性：通过回滚，以及恢复，和在并发环境下的隔离做到一致性。  

&emsp; 原子性，持久性，隔离性的目的也是为了保障数据的一致性！  
&emsp; 总之，ACID只是个概念，事务最终目的是要保障数据的可靠性，一致性。  

### 2.4.1. 原子性的实现  

### 2.4.2. 持久性的实现  

### 2.4.3. 隔离性的实现  

### 2.4.4. 一致性的实现  


## 2.5. 事务SQL语句  


# 3. MySql的锁  
## 3.1. 数据库锁简介  
&emsp; ***存储引擎与锁：***  
* InnoDB：对于UPDATE、DELETE、INSERT语句，InnoDB会自动给涉及数据集加排他锁（X)。  
* MyISAM：MyISAM在执行查询语句SELECT前，会自动给涉及的所有表加读锁，在执行更新操作（UPDATE、DELETE、INSERT等）前，会自动给涉及的表加写锁，这个过程并不需要用户干预。  

&emsp; ***事务和锁的关联：***  
1. 事务与锁是不同的。事务具有ACID（原子性、一致性、隔离性和持久性），锁是用于解决隔离性的一种机制。  
2. 事务的隔离级别通过锁的机制来实现。另外锁有不同的粒度，同时事务也是有不同的隔离级别的。  
3. 开启事务就自动加锁。  

&emsp; ***锁的分类：***
![image](https://gitee.com/wt1814/pic-host/raw/master/images/SQL/sql-42.png)  
* 按使用方式：乐观锁、悲观锁。  
* 按粒度：表级锁、行级锁、页级锁。锁的粒度取决于具体的存储引擎。InnoDB实现了行级锁，页级锁，表级锁。  
* 锁类别：有共享锁（读锁）和排他锁（写锁）。锁类别取决于存储引擎执行的sql语句。  

## 3.2. 锁的粒度，表锁、行锁、页锁  
&emsp; 在数据库中，锁的粒度的不同可以分为表锁、页锁、行锁，这些锁的粒度之间也是会发生升级的，锁升级的意思就是将当前锁的粒度降低，数据库可以把一个表的1000个行锁升级为一个页锁，或者将页锁升级为表锁。  
&emsp; 不同的存储引擎支持的锁粒度是不一样的：  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/SQL/sql-43.png)  
&emsp; InnoDB行锁和表锁都支持！InnoDB只有通过索引条件检索数据才使用行级锁，否则，InnoDB将使用表锁。即InnoDB的行锁是基于索引的！  
&emsp; MyISAM只支持表锁！  

### 3.2.1. 页锁：  
&emsp; 页级锁定是MySQL中比较独特的一种锁定级别，在其他数据库管理软件中也并不是太常见。页级锁定的特点是锁定颗粒度介于行级锁定与表级锁之间，所以获取锁定所需要的资源开销，以及所能提供的并发处理能力也同样是介于上面二者之间。另外，页级锁定和行级锁定一样，会发生死锁。  
&emsp; 在数据库实现资源锁定的过程中，随着锁定资源颗粒度的减小，锁定相同数据量的数据所需要消耗的内存数量是越来越多的，实现算法也会越来越复杂。不过，随着锁定资源颗粒度的减小，应用程序的访问请求遇到锁等待的可能性也会随之降低，系统整体并发度也随之提升。  
&emsp; 使用页级锁定的主要是BerkeleyDB存储引擎。  

### 3.2.2. 表锁  
&emsp; 特点：对整张表加锁。开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。  
&emsp; 存储引擎的支持：使用表级锁定的主要是MyISAM，MEMORY，CSV等一些非事务性存储引擎。  
&emsp; 如何加表锁？MyISAM在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁，在执行更新操作（UPDATE、DELETE、INSERT等）前，会自动给涉及的表加写锁。这个过程并不需要用户干预，因此，用户一般不需要直接用LOCK TABLE命令给MyISAM表显式加锁。  

### 3.2.3. 行锁  
&emsp; 行级锁：对某行记录加锁。开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。  
&emsp; 使用行级锁定的主要是InnoDB存储引擎。  
&emsp; ***适用场景：*** 从锁的角度来说，表级锁更适合于以查询为主，只有少量按索引条件更新数据的应用，如Web应用。  
&emsp; 而行级锁则更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用，如一些在线事务处理（OLTP）系统。  
&emsp; ***行锁与索引：*** InnoDB行锁是通过给索引上的索引项加锁来实现的，只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁。  

### 3.2.4. 间隙锁  

&emsp; 当使用范围条件（> 、< 、between......）检索数据，InnoDB会给符合条件的已有数据记录的索引项加锁。对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)”，InnoDB也会对这个“间隙”加锁，这就是间隙锁。间隙锁和行锁合称（Next-Key锁）。  
&emsp; InnoDB 除了通过范围条件加锁时使用间隙锁外，如果使用相等条件请求给一个不存在的记录加锁，InnoDB 也会使用间隙锁。  

&emsp; 假如emp表中只有101条记录，其empid的值分别是1,2,...,100,101，下面的 SQL：  

```sql
select * from emp where empid > 100 for update;
```  
&emsp; 这是一个范围条件的检索，InnoDB 不仅会对符合条件的empid值为101的记录加锁，也会对empid大于101（这些记录并不存在）的“间隙”加锁。  

&emsp; InnoDB 使用间隙锁的目的：  
&emsp; 一方面是为了防止幻读。对于上例，如果不使用间隙锁，其他事务插入了 empid大于 100的任何记录，本事务再次执行 select 语句，就会发生幻读。  
&emsp; 另一方面，也是为了满足恢复和复制的需要。    

&emsp; InnoDB使用间隙锁的危害：因为执行SELECT语句中，如果通过范围查找的话，间隙锁会锁定整个范围内所有的索引键值，即使这个键值并不存在。这个就是间隙锁最致命的缺点，就是当锁定一个范围键值之后，即使某些不存在的键值也会被无辜的锁定，而造成在锁定的时候无法插入锁定值范围内的任何数据，在某些场景下这可能会针对性造成很大的危害。  

## 3.3. 锁类别，读锁、写锁：  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/SQL/sql-47.png)  

### 3.3.1. MyISAM存储引擎和表级锁：  
&emsp; MyISAM在执行查询语句（select）前，会自动给涉及的所有表加读锁，在执行增删改操作前，会自动给涉及的表加写锁。  

&emsp; 表锁下分为两种模式：表读锁（Table Read Lock）、表写锁（Table Write Lock）。读锁和写锁是互斥的，读写操作是串行。在表读锁和表写锁的环境下：读读不阻塞，读写阻塞，写写阻塞！  
* 读读不阻塞：当前用户在读数据，其他的用户也在读数据，不会加锁！  
* 读写阻塞：当前用户在读数据，其他的用户不能修改当前用户读的数据，会加锁！  
* 写写阻塞：当前用户在修改数据，其他的用户不能修改当前用户正在修改的数据，会加锁！  

![image](https://gitee.com/wt1814/pic-host/raw/master/images/SQL/sql-48.png)  

### 3.3.2. InnoDB 存储引擎和表级锁
&emsp; InnoDB 存储引擎表锁：当没有对数据表中的索引数据进行查询时，会执行表锁操作。采用两种意向锁（Intention Locks。
* 意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前，必须先取得该表的 IS 锁。  
* 意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前，必须先取得该表的 IX 锁。  

&emsp; 意向共享锁和意向排他锁是数据库主动加的，不需要手动处理。对于 UPDATE、DELETE 和 INSERT 语句，InnoDB 会自动给数据集加排他锁。  

### 3.3.3. InnoDB 存储引擎和行级锁  
&emsp; InnoDB 存储引擎行锁，当数据查询时针对索引数据进行时，会使用行级锁。  
* 共享锁（S）：当一个事务读取一条记录的时候，不会阻塞其他事务对同一记录的读请求，但会阻塞对其的写请求。当读锁释放后，才会执行其他事务的写操作。  
&emsp; 例如：select … lock in share mode  
* 排他锁（X）：当一个事务对一条记录进行写操作时，会阻塞其他事务对同一表的读写操作，当该锁释放后，才会执行其他事务的读写操作。  
&emsp; 例如：select … for update  

&emsp;在高并发的情况下，多个事务同时请求更新数据，由于资源被占用等待事务增多。  
&emsp;如此，会造成性能问题，可以通过innodb_lock_wait_timeout 来解决。innodb_lock_wait_timeout 是事务等待获取资源的最长时间，单位为秒。如果超过时间还未分配到资源，则会返回应用失败。  

&emsp; 四种锁的兼容情况：  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/SQL/sql-49.png)  
<center>共享锁，排他锁，意向共享锁，意向排他锁兼容图例</center>    
&emsp; 如果一个事务请求的锁模式与当前的锁兼容， InnoDB 就将请求的锁授予该事务；反之， 如果两者不兼容，该事务就要等待锁释放。  



## 3.4. 锁使用方式：乐观锁、悲观锁  
&emsp; 乐观锁是一种思想，具体实现是，表中有一个版本字段，第一次读的时候，获取到这个字段。处理完业务逻辑开始更新的时候，需要再次查看该字段的值是否和第一次的一样。如果一样更新，反之拒绝。之所以叫乐观，因为这个模式没有从数据库加锁，等到更新的时候再判断是否可以更新。  
&emsp; 悲观锁是数据库层面加锁，都会阻塞去等待锁。  

## 3.5. 死锁  
&emsp; insert、delete、update这些操作，独占锁占用事务时间过长，是会锁表的。  
&emsp; 解决方案：操作要进行拆分，重整数据库策略，比如限制处理1000条。删除操作，删除数据的速度和创建的索引数量是成正比的。所以在超大型数据库中，删除时处理好索引关系非常重要。推荐的折中方法：在删除数据之前删除表中索引，然后删除其中无用数据，删除完成后重新创建索引。  


# 4. 多版本并发控制  
&emsp; 每种存储引擎对MVCC的实现方式不同，InnoDB引擎的简单实现方式如下：  
&emsp; InnoDB通过为每个数据航增加两个隐含值的方式来实现。这两个隐含值记录了行的创建时间，以及过期时间。每一行存储事件发生时的系统版本号。每一次开始一个新事务时版本号会自动加1，每个事务都会保存开始时的版本号，每个查询根据事务的版本号来查询结果。  

