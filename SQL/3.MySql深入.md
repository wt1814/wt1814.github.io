---
title: MySQL深入
date: 2020-02-26 00:00:00
tags:
    - SQL
---

<!-- TOC -->

- [1. MySql存储引擎](#1-mysql存储引擎)
    - [1.1. 存储引擎操作](#11-存储引擎操作)
    - [1.2. InnoDB存储引擎](#12-innodb存储引擎)
        - [1.2.1. InnoDB的逻辑存储结构](#121-innodb的逻辑存储结构)
        - [1.2.2. InnoDB的索引](#122-innodb的索引)
        - [1.2.3. InnoDB的特性](#123-innodb的特性)
    - [1.3. MyISAM存储引擎](#13-myisam存储引擎)
        - [1.3.1. MyISAM的索引](#131-myisam的索引)
        - [1.3.2. MyISAM的特性](#132-myisam的特性)
    - [1.4. 选择合适的存储引擎](#14-选择合适的存储引擎)
- [2. MySql的事务](#2-mysql的事务)
    - [2.1. 事务简介](#21-事务简介)
    - [2.2. 并发事务处理带来的问题](#22-并发事务处理带来的问题)
    - [2.3. 事务的隔离级别](#23-事务的隔离级别)
    - [2.4. Mysql事务实现](#24-mysql事务实现)
        - [2.4.1. 事务实现基础](#241-事务实现基础)
            - [2.4.1.1. 事务日志](#2411-事务日志)
                - [2.4.1.1.1. 事务日志简介](#24111-事务日志简介)
                - [2.4.1.1.2. MySql中的详细事务日志](#24112-mysql中的详细事务日志)
            - [2.4.1.2. 多版本并发控制MVCC](#2412-多版本并发控制mvcc)
        - [2.4.2. 事务实现原理-1](#242-事务实现原理-1)
            - [2.4.2.1. 原子性的实现](#2421-原子性的实现)
            - [2.4.2.2. 持久性的实现](#2422-持久性的实现)
            - [2.4.2.3. 隔离性的实现](#2423-隔离性的实现)
            - [2.4.2.4. 一致性的实现](#2424-一致性的实现)
    - [2.5. 事务SQL语句](#25-事务sql语句)
- [3. MySql的锁](#3-mysql的锁)
    - [3.1. 数据库锁简介](#31-数据库锁简介)
        - [锁的分类](#锁的分类)
    - [3.3.1. MyISAM存储引擎](#331-myisam存储引擎)
    - [3.3. InnoDB 存储引擎](#33-innodb-存储引擎)
        - [3.3.2. InnoDB 存储引擎和表级锁](#332-innodb-存储引擎和表级锁)
        - [3.3.3. InnoDB 存储引擎和行级锁](#333-innodb-存储引擎和行级锁)
        - [3.2.4. 间隙锁](#324-间隙锁)
    - [3.4. 锁使用方式：乐观锁、悲观锁](#34-锁使用方式乐观锁悲观锁)
    - [3.5. 死锁](#35-死锁)

<!-- /TOC -->

# 1. MySql存储引擎
1. MySQL是插件式的存储引擎，其中存储引擎分很多种。只要实现符合mysql存储引擎的接口，可以开发自己的存储引擎!  
2. 所有跨存储引擎的功能都是在服务层实现的。  
3. MySQL的存储引擎是针对表的，不是针对库的。也就是说在一个数据库中可以使用不同的存储引擎。但是不建议这样做。  
4. MySQL常见的存储引擎有InnoDB、MyISAM、Memory、NDB。InnoDB 现在是 MySQL 默认的存储引擎，支持事务、行级锁定和外键。  

## 1.1. 存储引擎操作  
<!-- https://mp.weixin.qq.com/s/MCFHNOQnTtJ6MGVjM3DP4A -->

## 1.2. InnoDB存储引擎  
&emsp; MySQL5.5及之后版本默认的存储引擎：InnoDB。  

### 1.2.1. InnoDB的逻辑存储结构  
&emsp; 从InnoDb存储引擎的逻辑存储结构看，所有数据都被逻辑地存放在一个空间中，称之为表空间（tablespace）。表空间又由段（segment），区（extent），页（page）组成。页在一些文档中有时候也称为块（block）。InnoDb逻辑存储结构图如下：  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/SQL/sql-41.png)  
* 表空间（tablespace）：  
&emsp; 表空间是Innodb存储引擎逻辑的最高层，所有的数据都存放在表空间中。  
&emsp; 默认情况下，Innodb存储引擎有一个共享表空间ibdata1,即所有数据都存放在这个表空间中内。  
&emsp; 如果启用了innodbfileper_table参数，需要注意的是每张表的表空间内存放的只是数据、索引、和插入缓冲Bitmap，其他类的数据，比如回滚(undo)信息、插入缓冲检索页、系统事物信息，二次写缓冲等还是放在原来的共享表内的。  
* 段（segment）：  
&emsp; 表空间由段组成，常见的段有数据段、索引段、回滚段等。  
&emsp; InnoDB存储引擎表是索引组织的，因此数据即索引，索引即数据。数据段即为B+树的叶子结点，索引段即为B+树的非索引结点。  
&emsp; 在InnoDB存储引擎中对段的管理都是由引擎自身所完成，DBA不能也没必要对其进行控制。  
* 区（extent）：  
&emsp; 区是由连续页组成的空间，在任何情况下每个区的大小都为1MB。  
&emsp; 为了保证区中页的连续性，InnoDB存储引擎一次从磁盘申请4~5个区。  
&emsp; 默认情况下，InnoDB存储引擎页的大小为16KB，一个区中一共64个连续的区。  
* 页（page）：  
&emsp; 页是InnoDB磁盘管理的最小单位。  
&emsp; 在InnoDB存储引擎中，默认每个页的大小为16KB。  
&emsp; 从InnoDB1.2.x版本开始，可以通过参数innodbpagesize将页的大小设置为4K，8K，16K。  
&emsp; InnoDB存储引擎中，常见的页类型有：数据页，undo页，系统页，事务数据页，插入缓冲位图页，插入缓冲空闲列表页等。  

### 1.2.2. InnoDB的索引  
&emsp; 查看[索引](7.index.md)  

### 1.2.3. InnoDB的特性  
* 支持事务  
* 支持行锁，采用MVCC来支持高并发  
* 支持外键  
* 支持崩溃后的安全恢复  
* 不支持全文索引  
* InnoDB 不保存表的具体行数，执行select count(*) from table 时需要全表扫描。  

## 1.3. MyISAM存储引擎  
### 1.3.1. MyISAM的索引  
&emsp; 查看[索引](7.index.md)  

### 1.3.2. MyISAM的特性  
&emsp; MyISAM引擎是MySQL 5.1及之前版本的默认引擎，它的特性是：  

* 不支持事务  
* 不支持行锁，读取时对需要读到的所有表加锁，写入时则对表加排它锁  
* 不支持外键  
* 不支持崩溃后的安全恢复  
* 在表有读取查询的同时，支持往表中插入新纪录  
* 支持BLOB和TEXT的前500个字符索引，支持全文索引  
* 支持延迟更新索引，极大提升写入性能  
* 对于不会进行修改的表，支持压缩表，极大减少磁盘空间占用  
* MyISAM 用一个变量保存了整个表的行数，执行select count(*) from table时只需要读出该变量即可，速度很快；  

&emsp; <font color = "red">一张表，里面有ID自增主键，当insert了17条记录之后，删除了第15,16,17条记录，再把Mysql重启，再insert一条记录，这条记录的ID是18还是15 ？</font>  
&emsp; 如果表的类型是MyISAM，那么是18。因为MyISAM表会把自增主键的最大ID 记录到数据文件中，重启MySQL自增主键的最大ID也不会丢失；  
&emsp; 如果表的类型是InnoDB，那么是15。因为InnoDB 表只是把自增主键的最大ID记录到内存中，所以重启数据库或对表进行OPTION操作，都会导致最大ID丢失。  

&emsp; <font color = "red">哪个存储引擎执行 select count(*) 更快，为什么? </font>   
&emsp; MyISAM更快，因为MyISAM内部维护了一个计数器，可以直接调取。  

* 在 MyISAM 存储引擎中，把表的总行数存储在磁盘上，当执行 select count(*) from t 时，直接返回总数据。  
* 在 InnoDB 存储引擎中，跟 MyISAM 不一样，没有将总行数存储在磁盘上，当执行 select count(*) from t 时，会先把数据读出来，一行一行的累加，最后返回总数量。  

&emsp; InnoDB 中 count(*) 语句是在执行的时候，全表扫描统计总数量，所以当数据越来越大时，语句就越来越耗时了，为什么 InnoDB 引擎不像 MyISAM 引擎一样，将总行数存储到磁盘上？这跟 InnoDB 的事务特性有关，由于多版本并发控制（MVCC）的原因，InnoDB 表“应该返回多少行”也是不确定的。  

## 1.4. 选择合适的存储引擎  
&emsp; 如果对数据一致性要求比较高，需要事务支持，可以选择 InnoDB。  
&emsp; 如果数据查询多更新少，对查询性能要求比较高，可以选择 MyISAM。  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/SQL/sql-50.png)  

# 2. MySql的事务  
&emsp; MySql的事务基于InnoDB存储引擎讲解。  

## 2.1. 事务简介  
&emsp; 事务的定义：事务是逻辑上的一组操作，要么都执行，要么都不执行。  
&emsp; ***事务的四大特性(ACID)：***  
* 原子性(Atomicity)：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；  
* 一致性(Consistency)：执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；  
* 隔离性(Isolation）：并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；  
* 持久性(Durability）：一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。  

## 2.2. 并发事务处理带来的问题  
&emsp; 多事务的并发进行一般会造成以下几个问题：  
* <font color = "red">脏读（Dirty read）: （一个线程读了另一个线程未提交的数据。）</font>当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。  
* <font color = "red">丢失修改（Lost to modify）: （一个线程覆盖了另一个线程的数据。）</font>指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。例如：事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失。  
* <font color = "red">不可重复读（Unrepeatableread）: （一个线程多次读，另一线程中间修改了数据。）</font>指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。  
* <font color = "red">幻读（Phantom read）: （一个线程多次读，另一线程中间新增了数据。）</font>幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。  

        不可重复度和幻读区别：  
        不可重复读的重点是修改：在同一事务中，同样的条件，第一次读的数据和第二次读的数据不一样。（因为中间有其他事务提交了修改）
        幻读的重点在于新增或者删除：在同一事务中，同样的条件,，第一次和第二次读出来的记录数不一样。（因为中间有其他事务提交了插入/删除） 

&emsp; 并发事务处理带来的问题的解决办法：  
* “更新丢失”通常是应该完全避免的。但防止更新丢失，并不能单靠数据库事务控制器来解决，需要应用程序对要更新的数据加必要的锁来解决，因此，防止更新丢失应该是应用的责任。
* “脏读” 、 “不可重复读”和“幻读” ，其实都是数据库读一致性问题，必须由数据库提供一定的事务隔离机制来解决：
    * 一种是加锁：在读取数据前，对其加锁，阻止其他事务对数据进行修改。
    * 另一种是数据多版本并发控制（MultiVersion Concurrency Control，简称 MVCC 或 MCC），也称为多版本数据库：不用加任何锁， 通过一定机制生成一个数据请求时间点的一致性数据快照 （Snapshot)， 并用这个快照来提供一定级别 （语句级或事务级） 的一致性读取。从用户的角度来看，好象是数据库可以提供同一数据的多个版本。

## 2.3. 事务的隔离级别  
&emsp; MySQL的事务隔离级别解决并发事务问题。数据库的事务隔离越严格，并发副作用越小，但付出的代价也就越大。这是因为事务隔离实质上是将事务在一定程度上"串行"进行，这显然与"并发"是矛盾的。  
&emsp; SQL标准定义了四个隔离级别：  

* READ-UNCOMMITTED(读取未提交)：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。  
* READ-COMMITTED(读取已提交)：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。  
* REPEATABLE-READ(可重复读)：<font color = "red">MySQL的默认事务隔离级别</font>。对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<font color = "red">可以阻止脏读和不可重复读，但幻读仍有可能发生</font>。  
* SERIALIZABLE(可串行化)：最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。  

|隔离级别 |读数据一致性 |脏读|不可重复读|幻读|
|---|---|---|---|---|
|未提交读(Read uncommitted)	|最低级别|是|是|是|
|已提交读(Read committed)|语句级|否 |是	|是|
|可重复读(Repeatable read)|事务级 |否 |否 |是|
|可序列化(Serializable) |最高级别，事务级|否|否 |否| 

## 2.4. Mysql事务实现  
<!-- https://mp.weixin.qq.com/s/MCFHNOQnTtJ6MGVjM3DP4A -->
&emsp; 实现事务采取了哪些技术以及思想？  

* 原子性：使用 undo log ，从而达到回滚；  
* 持久性：使用 redo log，从而达到故障后恢复；  
* 隔离性：使用锁以及MVCC,运用的优化思想有读写分离，读读并行，读写并行；  
* 一致性：通过回滚，以及恢复，和在并发环境下的隔离做到一致性。  

&emsp; 原子性，持久性，隔离性的目的也是为了保障数据的一致性！  
&emsp; 总之，ACID只是个概念，事务最终目的是要保障数据的可靠性，一致性。  


&emsp; 事务的实现是基于数据库的存储引擎。不同的存储引擎对事务的支持程度不一样。MySQL 中支持事务的存储引擎有 InnoDB 和 NDB。  
&emsp; 事务的实现就是如何实现ACID特性。  
&emsp; 事务的隔离性是通过锁实现，而事务的原子性、一致性和持久性则是通过事务日志实现 。  

### 2.4.1. 事务实现基础  
#### 2.4.1.1. 事务日志  
##### 2.4.1.1.1. 事务日志简介  
&emsp; InnoDB 使用日志来减少提交事务时的开销。因为日志中已经记录了事务，就无须在每个事务提交时把缓冲池的脏块刷新(flush)到磁盘中。  
&emsp; 事务修改的数据和索引通常会映射到表空间的随机位置，所以刷新这些变更到磁盘需要很多随机 IO。  
&emsp; InnoDB 假设使用常规磁盘，随机IO比顺序IO昂贵得多，因为一个IO请求需要时间把磁头移到正确的位置，然后等待磁盘上读出需要的部分，再转到开始位置。  
&emsp; InnoDB 用日志把随机IO变成顺序IO。一旦日志安全写到磁盘，事务就持久化了，即使断电了，InnoDB可以重放日志并且恢复已经提交的事务。  
&emsp; InnoDB 使用一个后台线程智能地刷新这些变更到数据文件。这个线程可以批量组合写入，使得数据写入更顺序，以提高效率。  
&emsp; 事务日志可以帮助提高事务效率：  

* 使用事务日志，存储引擎在修改表的数据时只需要修改其内存拷贝，再把该修改行为记录到持久在硬盘上的事务日志中，而不用每次都将修改的数据本身持久到磁盘。  
* 事务日志采用的是追加的方式，因此写日志的操作是磁盘上一小块区域内的顺序I/O，而不像随机I/O需要在磁盘的多个地方移动磁头，所以采用事务日志的方式相对来说要快得多。  
* 事务日志持久以后，内存中被修改的数据在后台可以慢慢刷回到磁盘。  
* 如果数据的修改已经记录到事务日志并持久化，但数据本身没有写回到磁盘，此时系统崩溃，存储引擎在重启时能够自动恢复这一部分修改的数据。  

&emsp; 目前来说，大多数存储引擎都是这样实现的，通常称之为预写式日志（Write-Ahead Logging），修改数据需要写两次磁盘。  

##### 2.4.1.1.2. MySql中的详细事务日志
&emsp; 事务日志包括：重做日志redo和回滚日志undo  

* redo log（重做日志） 实现持久化和原子性  
&emsp; 在innoDB的存储引擎中，事务日志通过重做(redo)日志和innoDB存储引擎的日志缓冲(InnoDB Log Buffer)实现。事务开启时，事务中的操作，都会先写入存储引擎的日志缓冲中，在事务提交之前，这些缓冲的日志都需要提前刷新到磁盘上持久化，这就是DBA们口中常说的“日志先行”(Write-Ahead Logging)。当事务提交之后，在Buffer Pool中映射的数据文件才会慢慢刷新到磁盘。此时如果数据库崩溃或者宕机，那么当系统重启进行恢复时，就可以根据redo log中记录的日志，把数据库恢复到崩溃前的一个状态。未完成的事务，可以继续提交，也可以选择回滚，这基于恢复的策略而定。
&emsp; 在系统启动的时候，就已经为redo log分配了一块连续的存储空间，以顺序追加的方式记录Redo Log，通过顺序IO来改善性能。所有的事务共享redo log的存储空间，它们的Redo Log按语句的执行顺序，依次交替的记录在一起。
* undo log（回滚日志）  实现一致性  
&emsp; undo log 主要为事务的回滚服务。在事务执行的过程中，除了记录redo log，还会记录一定量的undo log。undo log记录了数据在每个操作前的状态，如果事务执行过程中需要回滚，就可以根据undo log进行回滚操作。单个事务的回滚，只会回滚当前事务做的操作，并不会影响到其他的事务做的操作。  
&emsp; Undo记录的是已部分完成并且写入硬盘的未完成的事务，默认情况下回滚日志是记录下表空间中的（共享表空间或者独享表空间）  

&emsp; 二种日志均可以视为一种恢复操作，redo_log是恢复提交事务修改的页操作，而undo_log是回滚行记录到特定版本。二者记录的内容也不同，redo_log是物理日志，记录页的物理修改操作，而undo_log是逻辑日志，根据每行记录进行记录。  

#### 2.4.1.2. 多版本并发控制MVCC  
<!-- https://www.jianshu.com/p/cfe3c269ad19 -->

&emsp; 每种存储引擎对MVCC的实现方式不同，InnoDB引擎的简单实现方式如下：  
&emsp; InnoDB通过为每个数据行增加两个隐含值的方式来实现。这两个隐含值记录了行的创建时间，以及过期时间。每一行存储事件发生时的系统版本号。每一次开始一个新事务时版本号会自动加1，每个事务都会保存开始时的版本号，每个查询根据事务的版本号来查询结果。  

&emsp; MySQL的大多数事务型存储引擎实现都不是简单的行级锁。基于提升并发性考虑，一般都同时实现了多版本并发控制（MVCC），包括Oracle、PostgreSQL。只是实现机制各不相同。
&emsp; 可以认为 MVCC 是行级锁的一个变种，但它在很多情况下避免了加锁操作，因此开销更低。虽然实现机制有所不同，但大都实现了非阻塞的读操作，写操作也只是锁定必要的行。
&emsp; MVCC 的实现是通过保存数据在某个时间点的快照来实现的。也就是说不管需要执行多长时间，每个事物看到的数据都是一致的。
&emsp; 典型的MVCC实现方式，分为乐观（optimistic）并发控制和悲观（pressimistic）并发控制。下边通过 InnoDB的简化版行为来说明 MVCC 是如何工作的。
&emsp; InnoDB 的 MVCC，是通过在每行记录后面保存两个隐藏的列来实现。这两个列，一个保存了行的创建时间，一个保存行的过期时间（删除时间）。当然存储的并不是真实的时间，而是系统版本号（system version number）。每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。  
&emsp; <font color = "red">REPEATABLE READ（可重读）隔离级别下MVCC如何工作：</font>  

* SELECT
&emsp; InnoDB会根据以下两个条件检查每行记录：
&emsp; 只有符合上述两个条件的才会被查询出来
    * InnoDB只查找版本早于当前事务版本的数据行，这样可以确保事务读取的行，要么是在开始事务之前已经存在要么是事务自身插入或者修改过的  
    * 行的删除版本号要么未定义，要么大于当前事务版本号，这样可以确保事务读取到的行在事务开始之前未被删除  
* INSERT：InnoDB为新插入的每一行保存当前系统版本号作为行版本号  
* DELETE：InnoDB为删除的每一行保存当前系统版本号作为行删除标识  
* UPDATE：InnoDB为插入的一行新纪录保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为删除标识  

&emsp; 保存这两个额外系统版本号，使大多数操作都不用加锁。使数据操作简单，性能很好，并且也能保证只会读取到符合要求的行。不足之处是每行记录都需要额外的存储空间，需要做更多的行检查工作和一些额外的维护工作。  
&emsp; MVCC 只在 COMMITTED READ（读提交）和REPEATABLE READ（可重复读）两种隔离级别下工作。  


### 2.4.2. 事务实现原理-1  
#### 2.4.2.1. 原子性的实现  

#### 2.4.2.2. 持久性的实现  

#### 2.4.2.3. 隔离性的实现  

#### 2.4.2.4. 一致性的实现  


## 2.5. 事务SQL语句  
......

# 3. MySql的锁  
## 3.1. 数据库锁简介  
&emsp; ***存储引擎与锁：***  
* InnoDB：对于UPDATE、DELETE、INSERT语句，InnoDB会自动给涉及数据集加排他锁（X)。  
* MyISAM：MyISAM在执行查询语句SELECT前，会自动给涉及的所有表加读锁，在执行更新操作（UPDATE、DELETE、INSERT等）前，会自动给涉及的表加写锁，这个过程并不需要用户干预。  

&emsp; ***事务和锁的关联：***  
1. 事务与锁是不同的。事务具有ACID（原子性、一致性、隔离性和持久性），锁是用于解决隔离性的一种机制。  
2. 事务的隔离级别通过锁的机制来实现。另外锁有不同的粒度，同时事务也是有不同的隔离级别的。  
3. 开启事务就自动加锁。  

### 锁的分类
![image](https://gitee.com/wt1814/pic-host/raw/master/images/SQL/sql-42.png)  
* 按使用方式：乐观锁、悲观锁。  
* 锁类别：有共享锁（读锁）和排他锁（写锁）。锁类别取决于存储引擎执行的sql语句。  
    ![image](https://gitee.com/wt1814/pic-host/raw/master/images/SQL/sql-47.png)  
* 按粒度：表级锁、行级锁、页级锁。锁的粒度取决于具体的存储引擎。InnoDB实现了行级锁，页级锁，表级锁。  
    &emsp; <font color = "red">在数据库中，锁的粒度的不同可以分为表锁、页锁、行锁，这些锁的粒度之间也是会发生升级的，锁升级的意思就是将当前锁的粒度降低，数据库可以把一个表的1000个行锁升级为一个页锁，或者将页锁升级为表锁。</font>  
    &emsp; 不同的存储引擎支持的锁粒度是不一样的：  
    ![image](https://gitee.com/wt1814/pic-host/raw/master/images/SQL/sql-43.png)  
    &emsp; InnoDB行锁和表锁都支持！InnoDB只有通过索引条件检索数据才使用行级锁，否则，InnoDB将使用表锁。即InnoDB的行锁是基于索引的！  
    &emsp; MyISAM只支持表锁！  

    * 页锁  
    &emsp; 页级锁定是MySQL中比较独特的一种锁定级别，在其他数据库管理软件中也并不是太常见。页级锁定的特点是锁定粒度介于行级锁定与表级锁之间，所以获取锁定所需要的资源开销，以及所能提供的并发处理能力也同样是介于上面二者之间。另外，页级锁定和行级锁定一样，会发生死锁。  
    &emsp; 在数据库实现资源锁定的过程中，随着锁定资源颗粒度的减小，锁定相同数据量的数据所需要消耗的内存数量是越来越多的，实现算法也会越来越复杂。不过，随着锁定资源颗粒度的减小，应用程序的访问请求遇到锁等待的可能性也会随之降低，系统整体并发度也随之提升。  
    &emsp; 使用页级锁定的主要是BerkeleyDB存储引擎。  

    * 表锁  
    &emsp; 特点：对整张表加锁。开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。  
    &emsp; 存储引擎的支持：使用表级锁定的主要是MyISAM，MEMORY，CSV等一些非事务性存储引擎。  
    &emsp; 如何加表锁？MyISAM在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁，在执行更新操作（UPDATE、DELETE、INSERT等）前，会自动给涉及的表加写锁。这个过程并不需要用户干预，因此，用户一般不需要直接用LOCK TABLE命令给MyISAM表显式加锁。  

    * 行锁  
    &emsp; 行级锁：对某行记录加锁。开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。  
    &emsp; 使用行级锁定的主要是InnoDB存储引擎。  
    &emsp; ***适用场景：*** 从锁的角度来说，表级锁更适合于以查询为主，只有少量按索引条件更新数据的应用，如Web应用。而行级锁则更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用，如一些在线事务处理（OLTP）系统。  
    &emsp; ***行锁与索引：*** ***<font color = "red">InnoDB行锁是通过给索引上的索引项加锁来实现的，只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁。</font>***  

## 3.3.1. MyISAM存储引擎  
&emsp; MyISAM在执行查询语句（select）前，会自动给涉及的所有表加读锁，在执行增删改操作前，会自动给涉及的表加写锁。  

&emsp; 表锁下分为两种模式：表读锁（Table Read Lock）、表写锁（Table Write Lock）。读锁和写锁是互斥的，读写操作是串行。在表读锁和表写锁的环境下：读读不阻塞，读写阻塞，写写阻塞！  
* 读读不阻塞：当前用户在读数据，其他的用户也在读数据，不会加锁！  
* 读写阻塞：当前用户在读数据，其他的用户不能修改当前用户读的数据，会加锁！  
* 写写阻塞：当前用户在修改数据，其他的用户不能修改当前用户正在修改的数据，会加锁！  

![image](https://gitee.com/wt1814/pic-host/raw/master/images/SQL/sql-48.png)  

## 3.3. InnoDB 存储引擎  

### 3.3.2. InnoDB 存储引擎和表级锁
&emsp; InnoDB 存储引擎表锁：当没有对数据表中的索引数据进行查询时，会执行表锁操作。采用两种意向锁（Intention Locks)。
* 意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前，必须先取得该表的 IS 锁。  
* 意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前，必须先取得该表的 IX 锁。  

&emsp; 意向共享锁和意向排他锁是数据库主动加的，不需要手动处理。对于 UPDATE、DELETE 和 INSERT 语句，InnoDB 会自动给数据集加排他锁。  

### 3.3.3. InnoDB 存储引擎和行级锁  
&emsp; InnoDB 存储引擎行锁，当数据查询时针对索引数据进行时，会使用行级锁。  
* 共享锁（S）：当一个事务读取一条记录的时候，不会阻塞其他事务对同一记录的读请求，但会阻塞对其的写请求。当读锁释放后，才会执行其他事务的写操作。例如：select … lock in share mode  
* 排他锁（X）：当一个事务对一条记录进行写操作时，会阻塞其他事务对同一表的读写操作，当该锁释放后，才会执行其他事务的读写操作。例如：select … for update  

&emsp;在高并发的情况下，多个事务同时请求更新数据，由于资源被占用等待事务增多。  
&emsp;如此，会造成性能问题，可以通过innodb_lock_wait_timeout 来解决。innodb_lock_wait_timeout 是事务等待获取资源的最长时间，单位为秒。如果超过时间还未分配到资源，则会返回应用失败。  

&emsp; 四种锁的兼容情况：  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/SQL/sql-49.png)  
<center>共享锁，排他锁，意向共享锁，意向排他锁兼容图例</center>    
&emsp; 如果一个事务请求的锁模式与当前的锁兼容， InnoDB 就将请求的锁授予该事务；反之， 如果两者不兼容，该事务就要等待锁释放。  

### 3.2.4. 间隙锁  

&emsp; 当使用范围条件（> 、< 、between......）检索数据，InnoDB会给符合条件的已有数据记录的索引项加锁。对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)”，InnoDB也会对这个“间隙”加锁，这就是间隙锁。间隙锁和行锁合称（Next-Key锁）。  
&emsp; InnoDB 除了通过范围条件加锁时使用间隙锁外，如果使用相等条件请求给一个不存在的记录加锁，InnoDB 也会使用间隙锁。  

&emsp; 假如emp表中只有101条记录，其empid的值分别是1,2,...,100,101，下面的 SQL：  

```sql
select * from emp where empid > 100 for update;
```  
&emsp; 这是一个范围条件的检索，InnoDB 不仅会对符合条件的empid值为101的记录加锁，也会对empid大于101（这些记录并不存在）的“间隙”加锁。  

&emsp; InnoDB 使用间隙锁的目的：  
&emsp; 一方面是为了防止幻读。对于上例，如果不使用间隙锁，其他事务插入了 empid大于 100的任何记录，本事务再次执行 select 语句，就会发生幻读。  
&emsp; 另一方面，也是为了满足恢复和复制的需要。    

&emsp; InnoDB使用间隙锁的危害：因为执行SELECT语句中，如果通过范围查找的话，间隙锁会锁定整个范围内所有的索引键值，即使这个键值并不存在。这个就是间隙锁最致命的缺点，就是当锁定一个范围键值之后，即使某些不存在的键值也会被无辜的锁定，而造成在锁定的时候无法插入锁定值范围内的任何数据，在某些场景下这可能会针对性造成很大的危害。  

## 3.4. 锁使用方式：乐观锁、悲观锁  
&emsp; 乐观锁是一种思想，具体实现是，表中有一个版本字段，第一次读的时候，获取到这个字段。处理完业务逻辑开始更新的时候，需要再次查看该字段的值是否和第一次的一样。如果一样更新，反之拒绝。之所以叫乐观，因为这个模式没有从数据库加锁，等到更新的时候再判断是否可以更新。  
&emsp; 悲观锁是数据库层面加锁，都会阻塞去等待锁。  

## 3.5. 死锁  
&emsp; insert、delete、update这些操作，独占锁占用事务时间过长，是会锁表的。  
&emsp; 解决方案：操作要进行拆分，重整数据库策略，比如限制处理1000条。删除操作，删除数据的速度和创建的索引数量是成正比的。所以在超大型数据库中，删除时处理好索引关系非常重要。推荐的折中方法：在删除数据之前删除表中索引，然后删除其中无用数据，删除完成后重新创建索引。  





