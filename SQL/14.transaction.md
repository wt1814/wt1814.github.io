---
title: MySql事务
date: 2020-02-27 00:00:00
tags:
    - SQL
---

<!-- TOC -->

- [1. MySql的事务](#1-mysql的事务)
    - [1.1. 事务简介](#11-事务简介)
    - [1.2. 并发事务处理带来的问题](#12-并发事务处理带来的问题)
    - [1.3. 事务的隔离级别](#13-事务的隔离级别)
    - [1.4. Mysql事务实现-1](#14-mysql事务实现-1)
        - [1.4.1. 事务实现基础](#141-事务实现基础)
            - [1.4.1.1. 事务日志](#1411-事务日志)
                - [1.4.1.1.1. 事务日志简介](#14111-事务日志简介)
                - [1.4.1.1.2. MySql中的详细事务日志](#14112-mysql中的详细事务日志)
            - [1.4.1.2. 多版本并发控制MVCC](#1412-多版本并发控制mvcc)
        - [1.4.2. 事务实现原理-1](#142-事务实现原理-1)
            - [1.4.2.1. 原子性的实现](#1421-原子性的实现)
            - [1.4.2.2. 持久性的实现](#1422-持久性的实现)
            - [1.4.2.3. 隔离性的实现](#1423-隔离性的实现)
            - [1.4.2.4. 一致性的实现](#1424-一致性的实现)
    - [1.5. 事务SQL语句](#15-事务sql语句)

<!-- /TOC -->

![image](https://gitee.com/wt1814/pic-host/raw/master/images/SQL/sql-57.png)  

# 1. MySql的事务  
&emsp; MySql的事务基于InnoDB存储引擎讲解。  

## 1.1. 事务简介  
&emsp; 事务的定义：事务是逻辑上的一组操作，要么都执行，要么都不执行。  
&emsp; ***事务的四大特性(ACID)：***  
* 原子性(Atomicity)：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；  
* 一致性(Consistency)：执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；  
* 隔离性(Isolation）：并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；  
* 持久性(Durability）：一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。  

## 1.2. 并发事务处理带来的问题  
&emsp; 多事务的并发进行一般会造成以下几个问题： 

* <font color = "red">脏读（Dirty read）: （一个线程读了另一个线程未提交的数据。）</font>  
&emsp; 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。  
* <font color = "red">丢失修改（Lost to modify）: （一个线程覆盖了另一个线程的数据。）</font>  
&emsp; 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。例如：事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失。  
* <font color = "red">不可重复读（Unrepeatableread）: （一个线程多次读，另一线程中间修改了数据。）</font>  
&emsp; 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。  
* <font color = "red">幻读（Phantom read）: （一个线程多次读，另一线程中间新增了数据。）</font>  
&emsp; 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。  

        不可重复度和幻读区别：  
        不可重复读的重点是修改：在同一事务中，同样的条件，第一次读的数据和第二次读的数据不一样。（因为中间有其他事务提交了修改）
        幻读的重点在于新增或者删除：在同一事务中，同样的条件,，第一次和第二次读出来的记录数不一样。（因为中间有其他事务提交了插入/删除） 

&emsp; 并发事务处理带来的问题的解决办法：  

* “更新丢失”通常是应该完全避免的。但防止更新丢失，并不能单靠数据库事务控制器来解决，需要应用程序对要更新的数据加必要的锁来解决，因此，防止更新丢失应该是应用的责任。
* “脏读” 、 “不可重复读”和“幻读” ，其实都是数据库读一致性问题，必须由数据库提供一定的事务隔离机制来解决：
    * 一种是加锁：在读取数据前，对其加锁，阻止其他事务对数据进行修改。
    * 另一种是数据多版本并发控制（MultiVersion Concurrency Control，简称 MVCC 或 MCC），也称为多版本数据库：不用加任何锁， 通过一定机制生成一个数据请求时间点的一致性数据快照 （Snapshot)， 并用这个快照来提供一定级别 （语句级或事务级） 的一致性读取。从用户的角度来看，好象是数据库可以提供同一数据的多个版本。

## 1.3. 事务的隔离级别  
&emsp; MySQL的事务隔离级别解决并发事务问题。数据库的事务隔离越严格，并发副作用越小，但付出的代价也就越大。这是因为事务隔离实质上是将事务在一定程度上"串行"进行，这显然与"并发"是矛盾的。  
&emsp; SQL标准定义了四个隔离级别：  

* READ-UNCOMMITTED(读取未提交)：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。  
* READ-COMMITTED(读取已提交)：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。  
* REPEATABLE-READ(可重复读)：<font color = "red">MySQL的默认事务隔离级别</font>。对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<font color = "red">可以阻止脏读和不可重复读，但幻读仍有可能发生</font>。  
* SERIALIZABLE(可串行化)：最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。  

|隔离级别 |读数据一致性 |脏读|不可重复读|幻读|
|---|---|---|---|---|
|未提交读(Read uncommitted)	|最低级别|是|是|是|
|已提交读(Read committed)|语句级|否 |是	|是|
|可重复读(Repeatable read)|事务级 |否 |否 |是|
|可序列化(Serializable) |最高级别，事务级|否|否 |否| 

## 1.4. Mysql事务实现-1  
<!-- https://mp.weixin.qq.com/s/MCFHNOQnTtJ6MGVjM3DP4A -->
&emsp; 实现事务采取了哪些技术以及思想？  

* 原子性：使用 undo log ，从而达到回滚；  
* 持久性：使用 redo log，从而达到故障后恢复；  
* 隔离性：使用锁以及MVCC,运用的优化思想有读写分离，读读并行，读写并行；  
* 一致性：通过回滚，以及恢复，和在并发环境下的隔离做到一致性。  

&emsp; 原子性，持久性，隔离性的目的也是为了保障数据的一致性！  
&emsp; 总之，ACID只是个概念，事务最终目的是要保障数据的可靠性，一致性。  


&emsp; 事务的实现是基于数据库的存储引擎。不同的存储引擎对事务的支持程度不一样。MySQL 中支持事务的存储引擎有 InnoDB 和 NDB。  
&emsp; 事务的实现就是如何实现ACID特性。  
&emsp; <font color = "red">事务的隔离性是通过锁实现，而事务的原子性、一致性和持久性则是通过事务日志实现。</font>  

### 1.4.1. 事务实现基础  
#### 1.4.1.1. 事务日志  
##### 1.4.1.1.1. 事务日志简介  
&emsp; InnoDB 使用日志来减少提交事务时的开销。因为日志中已经记录了事务，就无须在每个事务提交时把缓冲池的脏块刷新(flush)到磁盘中。  
&emsp; 事务修改的数据和索引通常会映射到表空间的随机位置，所以刷新这些变更到磁盘需要很多随机 IO。  
&emsp; InnoDB 假设使用常规磁盘，随机IO比顺序IO昂贵得多，因为一个IO请求需要时间把磁头移到正确的位置，然后等待磁盘上读出需要的部分，再转到开始位置。  
&emsp; InnoDB 用日志把随机IO变成顺序IO。一旦日志安全写到磁盘，事务就持久化了，即使断电了，InnoDB可以重放日志并且恢复已经提交的事务。  
&emsp; InnoDB 使用一个后台线程智能地刷新这些变更到数据文件。这个线程可以批量组合写入，使得数据写入更顺序，以提高效率。  
&emsp; 事务日志可以帮助提高事务效率：  

* 使用事务日志，存储引擎在修改表的数据时只需要修改其内存拷贝，再把该修改行为记录到持久在硬盘上的事务日志中，而不用每次都将修改的数据本身持久到磁盘。  
* 事务日志采用的是追加的方式，因此写日志的操作是磁盘上一小块区域内的顺序I/O，而不像随机I/O需要在磁盘的多个地方移动磁头，所以采用事务日志的方式相对来说要快得多。  
* 事务日志持久以后，内存中被修改的数据在后台可以慢慢刷回到磁盘。  
* 如果数据的修改已经记录到事务日志并持久化，但数据本身没有写回到磁盘，此时系统崩溃，存储引擎在重启时能够自动恢复这一部分修改的数据。  

&emsp; 目前来说，大多数存储引擎都是这样实现的，通常称之为预写式日志（Write-Ahead Logging），修改数据需要写两次磁盘。  

##### 1.4.1.1.2. MySql中的详细事务日志
&emsp; 事务日志包括：重做日志redo和回滚日志undo  

* redo log（重做日志） 实现持久化和原子性  
&emsp; 在innoDB的存储引擎中，事务日志通过重做(redo)日志和innoDB存储引擎的日志缓冲(InnoDB Log Buffer)实现。事务开启时，事务中的操作，都会先写入存储引擎的日志缓冲中，在事务提交之前，这些缓冲的日志都需要提前刷新到磁盘上持久化，这就是DBA们口中常说的“日志先行”(Write-Ahead Logging)。当事务提交之后，在Buffer Pool中映射的数据文件才会慢慢刷新到磁盘。此时如果数据库崩溃或者宕机，那么当系统重启进行恢复时，就可以根据redo log中记录的日志，把数据库恢复到崩溃前的一个状态。未完成的事务，可以继续提交，也可以选择回滚，这基于恢复的策略而定。
&emsp; 在系统启动的时候，就已经为redo log分配了一块连续的存储空间，以顺序追加的方式记录Redo Log，通过顺序IO来改善性能。所有的事务共享redo log的存储空间，它们的Redo Log按语句的执行顺序，依次交替的记录在一起。
* undo log（回滚日志）  实现一致性  
&emsp; undo log 主要为事务的回滚服务。在事务执行的过程中，除了记录redo log，还会记录一定量的undo log。undo log记录了数据在每个操作前的状态，如果事务执行过程中需要回滚，就可以根据undo log进行回滚操作。单个事务的回滚，只会回滚当前事务做的操作，并不会影响到其他的事务做的操作。  
&emsp; Undo记录的是已部分完成并且写入硬盘的未完成的事务，默认情况下回滚日志是记录下表空间中的（共享表空间或者独享表空间）  

&emsp; 二种日志均可以视为一种恢复操作，redo_log是恢复提交事务修改的页操作，而undo_log是回滚行记录到特定版本。二者记录的内容也不同，redo_log是物理日志，记录页的物理修改操作，而undo_log是逻辑日志，根据每行记录进行记录。  

#### 1.4.1.2. 多版本并发控制MVCC  
<!-- https://www.jianshu.com/p/cfe3c269ad19 -->

&emsp; 每种存储引擎对MVCC的实现方式不同，InnoDB引擎的简单实现方式如下：  
&emsp; InnoDB通过为每个数据行增加两个隐含值的方式来实现。这两个隐含值记录了行的创建时间，以及过期时间。每一行存储事件发生时的系统版本号。每一次开始一个新事务时版本号会自动加1，每个事务都会保存开始时的版本号，每个查询根据事务的版本号来查询结果。  

&emsp; MySQL的大多数事务型存储引擎实现都不是简单的行级锁。基于提升并发性考虑，一般都同时实现了多版本并发控制（MVCC），包括Oracle、PostgreSQL。只是实现机制各不相同。  
&emsp; 可以认为 MVCC 是行级锁的一个变种，但它在很多情况下避免了加锁操作，因此开销更低。虽然实现机制有所不同，但大都实现了非阻塞的读操作，写操作也只是锁定必要的行。  
&emsp; MVCC 的实现是通过保存数据在某个时间点的快照来实现的。也就是说不管需要执行多长时间，每个事物看到的数据都是一致的。  
&emsp; 典型的MVCC实现方式，分为乐观（optimistic）并发控制和悲观（pressimistic）并发控制。下边通过 InnoDB的简化版行为来说明 MVCC 是如何工作的。  
&emsp; InnoDB 的 MVCC，是通过在每行记录后面保存两个隐藏的列来实现。这两个列，一个保存了行的创建时间，一个保存行的过期时间（删除时间）。当然存储的并不是真实的时间，而是系统版本号（system version number）。每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。  

&emsp; <font color = "red">REPEATABLE READ（可重读）隔离级别下MVCC如何工作：</font>  

* SELECT  
&emsp; InnoDB会根据以下两个条件检查每行记录（只有符合这两个条件的才会被查询出来）：  
    * InnoDB只查找版本早于当前事务版本的数据行，这样可以确保事务读取的行，要么是在开始事务之前已经存在要么是事务自身插入或者修改过的  
    * 行的删除版本号要么未定义，要么大于当前事务版本号，这样可以确保事务读取到的行在事务开始之前未被删除  
* INSERT：InnoDB为新插入的每一行保存当前系统版本号作为行版本号  
* DELETE：InnoDB为删除的每一行保存当前系统版本号作为行删除标识  
* UPDATE：InnoDB为插入的一行新纪录保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为删除标识  

&emsp; 保存这两个额外系统版本号，使大多数操作都不用加锁。使数据操作简单，性能很好，并且也能保证只会读取到符合要求的行。不足之处是每行记录都需要额外的存储空间，需要做更多的行检查工作和一些额外的维护工作。  
&emsp; MVCC 只在 COMMITTED READ（读提交）和REPEATABLE READ（可重复读）两种隔离级别下工作。  

&emsp; ***<font color = "red">总结：</font>***    
&emsp; MVCC（Multi-Version Concurrency Control ，多版本并发控制）指的就是在使用读已提交（READ COMMITTD）、可重复读（REPEATABLE READ）这两种隔离级别的事务在执行普通的SELECT操作时访问记录的版本链的过程，这样子可以使不同事务的读-写、写-读操作并发执行，从而提升系统性能。  
&emsp; 这两个隔离级别的一个很大不同就是：生成ReadView的时机不同，READ COMMITTD在每一次进行普通SELECT操作前都会生成一个ReadView，而REPEATABLE READ只在第一次进行普通SELECT操作前生成一个ReadView，数据的可重复读其实就是ReadView的重复使用。  


### 1.4.2. 事务实现原理-1  
#### 1.4.2.1. 原子性的实现  

#### 1.4.2.2. 持久性的实现  

#### 1.4.2.3. 隔离性的实现  

#### 1.4.2.4. 一致性的实现  


## 1.5. 事务SQL语句  
......
