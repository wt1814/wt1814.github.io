---
title: SQL优化
date: 2020-02-25 00:00:00
tags:
    - SQL
---


<!-- TOC -->

- [1. MySql性能，最大数据量、最大并发数、查询耗时：](#1-mysql性能最大数据量最大并发数查询耗时)
- [2. SQL优化维度](#2-sql优化维度)
- [3. 慢查询，（监控）](#3-慢查询监控)
    - [3.1. 慢查询简介：](#31-慢查询简介)
    - [3.2. 慢查询使用：](#32-慢查询使用)
    - [3.3. 慢查询工具：](#33-慢查询工具)
- [4. EXPLAIN、PROCEDURE ANALYSE，(分析)](#4-explainprocedure-analyse分析)
    - [4.1. EXPLAIN，分析查询](#41-explain分析查询)
    - [4.2. PROCEDURE ANALYSE()取得建议](#42-procedure-analyse取得建议)
    - [4.3. profiling](#43-profiling)
        - [4.3.1. 查看 profile 开启情况](#431-查看-profile-开启情况)
        - [4.3.2. 启用 profile](#432-启用-profile)
        - [4.3.3. 查看执行的 SQL 列表](#433-查看执行的-sql-列表)
        - [4.3.4. 查询指定 ID 的执行详细信息](#434-查询指定-id-的执行详细信息)
        - [4.3.5. 获取 CPU、 Block IO 等信息](#435-获取-cpu-block-io-等信息)
- [5. Sql语句优化](#5-sql语句优化)
    - [5.1. 基本查询优化](#51-基本查询优化)
    - [5.2. 子查询优化](#52-子查询优化)
    - [5.3. 关联查询优化](#53-关联查询优化)
    - [5.4. 组合查询优化](#54-组合查询优化)
    - [5.5. INSERT的优化](#55-insert的优化)
- [6. Sql索引优化](#6-sql索引优化)
    - [6.1. 索引简介](#61-索引简介)
    - [6.2. 创建索引原则](#62-创建索引原则)
    - [6.3. 索引条件下推（ICP）](#63-索引条件下推icp)
    - [6.4. mysql建了多个单索引，查询多个条件时如何走索引的？](#64-mysql建了多个单索引查询多个条件时如何走索引的)
    - [6.5. 索引失效](#65-索引失效)
    - [6.6. 索引底层原理：](#66-索引底层原理)
        - [6.6.1. BTree索引：](#661-btree索引)
            - [6.6.1.1. B+ Tree简介：](#6611-b-tree简介)
            - [6.6.1.2. InnoDB引擎的底层实现：](#6612-innodb引擎的底层实现)
            - [6.6.1.3. MyISAM引擎的底层实现：](#6613-myisam引擎的底层实现)
            - [6.6.1.4. 为什么使用B+树？](#6614-为什么使用b树)
            - [6.6.1.5. 为什么官方建议使用自增长主键作为索引？](#6615-为什么官方建议使用自增长主键作为索引)
        - [6.6.2. Hash索引](#662-hash索引)
    - [6.7. 索引维护、索引工具的使用](#67-索引维护索引工具的使用)
- [7. 数据库表结构设计](#7-数据库表结构设计)
    - [7.1. 选择合适的数据类型](#71-选择合适的数据类型)
    - [7.2. 表的拆分](#72-表的拆分)
    - [7.3. 读写分离](#73-读写分离)
- [8. Sql服务器](#8-sql服务器)
    - [8.1. 查看 MySQL 服务器运行的状态值](#81-查看-mysql-服务器运行的状态值)
    - [8.2. 服务器参数调优](#82-服务器参数调优)
        - [8.2.1. 内存相关](#821-内存相关)
        - [8.2.2. IO 相关](#822-io-相关)
        - [8.2.3. 安全相关](#823-安全相关)
        - [8.2.4. 其他](#824-其他)

<!-- /TOC -->

![image](https://gitee.com/wt1814/pic-host/raw/master/images/SQL/sql-52.png)  

# 1. MySql性能，最大数据量、最大并发数、查询耗时：  
* 最大数据量：  
&emsp; MySQL没有限制单表最大记录数，它取决于操作系统对文件大小的限制。  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/SQL/sql-28.png)  
&emsp; 《阿里巴巴Java开发手册》提出单表行数超过500万行或者单表容量超过2GB，才推荐分库分表。性能由综合因素决定，抛开业务复杂度，影响程度依次是硬件配置、MySQL配置、数据表设计、索引优化。500万这个值仅供参考，并非铁律。  

* 最大并发数：  
&emsp; 并发数是指同一时刻数据库能处理多少个请求，由max_connections和max_user_connections决定。max_connections是指MySQL实例的最大连接数，上限值是16384，max_user_connections是指每个数据库用户的最大连接数。  
&emsp; MySQL会为每个连接提供缓冲区，意味着消耗更多的内存。如果连接数设置太高硬件吃不消，太低又不能充分利用硬件。一般要求两者比值超过10%，计算方法如下：  
        
        max_used_connections / max_connections * 100% = 3/100 *100% ≈ 3%  
&emsp; 查看最大连接数与响应最大连接数：  

```sql
show variables like '%max_connections%';
show variables like '%max_user_connections%';
```

&emsp; 在配置文件my.cnf中修改最大连接数  

        [mysqld]
        max_connections = 100
        max_used_connections = 20
* 查询耗时0.5秒：  
&emsp; 建议将单次查询耗时控制在0.5秒以内，0.5秒是个经验值，源于用户体验的3秒原则。如果用户的操作3秒内没有响应，将会厌烦甚至退出。响应时间=客户端UI渲染耗时+网络请求耗时+应用程序处理耗时+查询数据库耗时，0.5秒就是留给数据库1/6的处理时间。  

# 2. SQL优化维度  
1. 服务器的优化；  
2. 表结构设计；  
3. SQL语句的优化；  

    对查询语句的监控、分析、优化是SQL优化的一般步骤。常规调优思路：  
    1. 查看slowlog，分析slowlog，分析出查询慢的语句。  
    2. 按照一定优先级，进行一个一个的排查所有慢语句。  
    3. 分析top sql，进行explain调试，查看语句执行时间。  
    4. 调整索引或语句本身。  

----
# 3. 慢查询，（监控）  

## 3.1. 慢查询简介：  
&emsp; MySQL慢查询日志是MySQL提供的一种日志记录，用来记录在MySQL中响应时间超过阈值的语句，具体指运行时间超过long_query_time值（默认值为10，即10秒，通常设置为1秒）的SQL，则会被记录到慢查询日志中（日志可以写入文件或者数据库表，如果对性能要求高的话，建议写文件）。默认情况下，MySQL数据库是不开启慢查询日志的，如果不是调优需要的话，不建议启动该参数。  
&emsp; 一般来说，慢查询发生在大表（比如：一个表的数据量有几百万），且查询条件的字段没有建立索引，此时，要匹配查询条件的字段会进行全表扫描，耗时超过long_query_time，则为慢查询语句。  

## 3.2. 慢查询使用：  
1. 参数说明：  
    
        slow_query_log，慢查询开启状态。
        slow_query_log_file，慢查询日志存放的位置。
        long_query_time，查询超过多少秒才记录。
2. 设置步骤：  
&emsp; 1). 查看慢查询相关参数。  

        #查看是否开启慢查询
        #slowquerylog = off，表示没有开启慢查询
        #slowquerylog_file 表示慢查询日志存放的目录
        show variables like 'slow_query%';
        show variables like 'long_query_time';  
&emsp; 2). 设置方法。
&emsp;方法一：全局变量设置。（即时性的，重启mysql之后失效，常用的）  

        --将 slow_query_log 全局变量设置为“ON”状态
        set global slow_query_log='ON';
        --设置慢查询日志存放的位置
        set global slow_query_log_file='/usr/local/mysql/data/slow.log';
        --查询超过1秒就记录
        set global long_query_time=1;  
&emsp;方法二：配置文件设置。修改配置文件my.cnf，在[mysqld]下的下方加入。  

        [mysqld]
        slow_query_log = ON
        slow_query_log_file = /usr/local/mysql/data/slow.log
        long_query_time = 1
&emsp; 3）重启MySQL服务。  

        service mysqld restart
&emsp; 4）查看设置后的参数。  

        show variables like 'slow_query%';
        show variables like 'long_query_time';  

## 3.3. 慢查询工具：  
......

----
# 4. EXPLAIN、PROCEDURE ANALYSE，(分析)  
## 4.1. EXPLAIN，分析查询  

```sql
EXPLAIN SELECT column_name FROM table_name;  
```
![image](https://gitee.com/wt1814/pic-host/raw/master/images/SQL/sql-29.png)  
&emsp; expain出来的信息列分别是id、select_type、table、partitions、***type***、possible_keys、key、key_len、ref、rows、filtered、***Extra***。  

|列名	|用途|
|---|---|
|id	|每一个SELECT关键字查询语句都对应一个唯一id|
|select_type	|SELECT关键字对应的查询类型|
|table	|表名|
|partitions	|匹配的分区信息|
|type	|单表的访问方法|
|possible_keys	|可能用到的索引|
|key	|实际使用到的索引|
|key_len	|实际使用到的索引长度|
|ref	|当使用索引列等值查询时，与索引列进行等值匹配的对象信息|
|rows	|预估需要读取的记录条数|
|filtered	|某个表经过条件过滤后剩余的记录条数百分比|
|Extra	|额外的一些信息|

* id：SELECT识别符。这是SELECT的查询序列号。  
    * id值相同  
    &emsp; id值相同一般出现在多表关联的场景，访问表的顺序是从上到下。  
    ![image](https://gitee.com/wt1814/pic-host/raw/master/images/SQL/sql-30.png)  
    &emsp; 两个id 都为1，先访问b表然后访问a表。  
    * id值不同  
    &emsp; id 值不同的情况，从大到小执行，值越大越先开始执行或者被访问。  
    ![image](https://gitee.com/wt1814/pic-host/raw/master/images/SQL/sql-31.png)  
    &emsp; 从结果来看，id为2那一行的子查询先被执行。然后再去访问id=1中a表。  
    * id包含了相同和不同的情况。  
    &emsp; 该情况一般是先有2个表或者子查询和表join，然后再和第三个表关联查询。比如  
    
    ```sql
    EXPLAIN SELECT t2.* FROM(SELECT t3.id FROM t3 WHERE t3.other_column = '') s1,t2 WHERE s1.id = t2.id;
    ```
    ![image](https://gitee.com/wt1814/pic-host/raw/master/images/SQL/sql-32.png)  
    &emsp; 分析结果可看出，先走id最大的2，也就是先走括号里面的查t3表的语句。走完查t3后，顺序执行，有一个，derived是衍生的意思，意思是在执行完t3查询后的s1虚表基础上，中的2，就是id为2的。最后执行的查t2表。  

* select_type：常见的有如下6种SIMPLE、PRIMARY、SUBQUERY、DERIVED、UNION、UNION RESULT，主要是告诉我们查询的类型是普通查询、联合查询、子查询等复杂的查询。  
    * SIMPLE：最简单的查询，查询中不包含子查询或者UNION。  
    * PRIMARY：查询中若包含任何复杂的子查询，最外层查询则被标记为PRIMARY，也就是最后被执行的语句。  
    * SUBQUERY：在SELECT from或者WHERE列表中包含了子查询  
    * DERIVED：导出表的SELECT(FROM子句的子查询)；在FROM列表中包含的子查询被标记为DERIVED（衍生）MySQL会递归执行这些子查询，把结果放在临时表里。  
    * UNION：UNION中的第二个或后面的SELECT语句；若第二个SELECT出现在UNION之后，则被标记为UNION；若UNION包含在FROM子句的子查询中，外层SELECT将被标记为DERIVED  
    * UNION RESULT：UNION的结果；  
    * DEPENDENT SUBQUERY：子查询中的第一个 SELECT, 取决于外面的查询. 即子查询依赖于外层查询的结果. 出现该值的时候一定要特别注意，可能需要使用join的方式优化子查询。  
    * DEPENDENT UNION：UNION中的第二个或后面的SELECT语句,取决于外面的查询；  

* table：（查询涉及的表或衍生表）  
&emsp; 其值为表名或者表的别名，表示访问哪一个表。  
&emsp; 当from中有子查询的时候，表名是derivedN的形式，其中N指向子查询，也就是explain结果中的下一列  
&emsp; 当有union result的时候，表名是union 1,2等的形式，1,2表示参与union的query id  
&emsp; 注意MySQL对待这些表和普通表一样，但是这些临时表是没有任何索引的。数据量大的情况下可能会有性能问题。  

* type：联接类型，表示访问表的方式。  
&emsp; 从最好到最差的结果依次如下:system > const > eq_ref > ref > range > index > ALL。  
&emsp; 一个好的SQL语句至少要达到range 级别。杜绝出现all级别。下面给出各种联接类型，按照从最佳类型到最坏类型进行排序：  
    * System：表仅有一行(=系统表)。这是const联接类型的一个特例。  
    * Const：表最多有一个匹配行,它将在查询开始时被读取。因为仅有一行,在这行的列值可被优化器剩余部分认为是常数。const表很快,因为它们只读取一次!  
    * eq_ref：对于每个来自于前面的表的行组合,从该表中读取一行。这可能是最好的联接类型,除了const类型。  
    * Ref：对于每个来自于前面的表的行组合,所有有匹配索引值的行将从这张表中读取。  
    * ref_or_null：该联接类型如同ref,但是添加了MySQL可以专门搜索包含NULL值的行。  
    * index_merge：该联接类型表示使用了索引合并优化方法。  
    * unique_subquery：该类型替换了下面形式的IN子查询的ref: value IN (SELECT primary_key FROM single_table WHERE some_expr) unique_subquery是一个索引查找函数,可以完全替换子查询,效率更高。  
    * index_subquery：该联接类型类似于unique_subquery。可以替换IN子查询,但只适合下列形式的子查询中的非唯一索引: value IN (SELECT key_column FROM single_table WHERE some_expr)  
    * Range：只检索给定范围的行,使用一个索引来选择行。  
    * Index：该联接类型与ALL相同,除了只有索引树被扫描。这通常比ALL快,因为索引文件通常比数据文件小。  
    * ALL：对于每个来自于先前的表的行组合,进行完整的表扫描。  
* possible_keys：指出MySQL能使用哪个索引在该表中找到行。  
* key：显示MySQL实际决定使用的键(索引)。如果没有选择索引,键是NULL。很少的情况下，MYSQL会选择优化不足的索引。这种情况下，可以在SELECT语句中使用USE INDEX（indexname）来强制使用一个索引或者用IGNORE INDEX（indexname）来强制MYSQL忽略索引。  
* key_len：索引长度，显示MySQL决定使用的键长度。如果键是NULL,则长度为NULL。  
* ref：显示使用哪个列或常数与key一起从表中选择行。  
* rows：扫描行数。该值是个预估值。显示MySQL认为它执行查询时必须检查的行数。多行之间的数据相乘可以估算要处理的行数。  
* filtered：显示了通过条件过滤出的行数的百分比估计值。  
* extra：该列包含MySQL解决查询的详细信息。注意，常见的不太友好的值，如下：Using filesort，Using temporary，意思MYSQL根本不能使用索引，常出现在使用order by。  
    * Distinct：MySQL发现第1个匹配行后,停止为当前的行组合搜索更多的行。  
    * Not exists：MySQL能够对查询进行LEFT JOIN优化,发现1个匹配LEFT JOIN标准的行后,不再为前面的的行组合在该表内检查更多的行。  
    * range checked for each record (index map: #):MySQL没有发现好的可以使用的索引,但发现如果来自前面的表的列值已知,可能部分索引可以使用。  
    * Using filesort：额外排序。MySQL需要额外的一次传递,以找出如何按排序顺序检索行。  
    * Using index:从只使用索引树中的信息而不需要进一步搜索读取实际的行来检索表中的列信息。  
    * Using temporary：使用了临时表。为了解决查询,MySQL需要创建一个临时表来容纳结果。这通常发生在对不同的列集进行ORDER BY上，而不是GROUP BY上。  
    * Using where:WHERE 子句用于限制哪一个行匹配下一个表或发送到客户。  
    * Using sort_union(...), Using union(...), Using intersect(...):这些函数说明如何为index_merge联接类型合并索引扫描。  
    * Using index for group-by:类似于访问表的Using index方式，Using index for group-by表示MySQL发现了一个索引,可以用来查询GROUP BY或DISTINCT查询的所有列,而不要额外搜索硬盘访问实际的表。  

## 4.2. PROCEDURE ANALYSE()取得建议  
&emsp; 使用proceduer analyse()对当前已有应用的表类型的判断，该函数可以对数据表中的列的数据类型（字段类型）提出优化建议（Optimal_fieldtype）。  

```sql
SELECT column_name FROM table_name PROCEDURE ANALYSE();
```

## 4.3. profiling  
&emsp; 使用 profiling 命令可以了解 SQL 语句消耗资源的详细信息（每个执行步骤的开销）。  

### 4.3.1. 查看 profile 开启情况  
```
select @@profiling;
```
&emsp; 返回结果：  

```
mysql> select @@profiling;
+-------------+
| @@profiling |
+-------------+
|           0 |
+-------------+
1 row in set, 1 warning (0.00 sec)
```
&emsp; 0 表示关闭状态,1 表示开启  

### 4.3.2. 启用 profile  
```
set profiling = 1;  
```
&emsp; 返回结果：  

```
mysql> set profiling = 1;  
Query OK, 0 rows affected, 1 warning (0.00 sec)

mysql> select @@profiling;
+-------------+
| @@profiling |
+-------------+
|           1 |
+-------------+
1 row in set, 1 warning (0.00 sec)
```
&emsp; 在连接关闭后，profiling 状态自动设置为关闭状态。  

### 4.3.3. 查看执行的 SQL 列表  
```
show profiles;  
```
&emsp; 返回结果：  
```
mysql> show profiles;
+----------+------------+------------------------------+
| Query_ID | Duration   | Query                        |
+----------+------------+------------------------------+
|        1 | 0.00062925 | select @@profiling           |
|        2 | 0.00094150 | show tables                  |
|        3 | 0.00119125 | show databases               |
|        4 | 0.00029750 | SELECT DATABASE()            |
|        5 | 0.00025975 | show databases               |
|        6 | 0.00023050 | show tables                  |
|        7 | 0.00042000 | show tables                  |
|        8 | 0.00260675 | desc role                    |
|        9 | 0.00074900 | select name,is_key from role |
+----------+------------+------------------------------+
9 rows in set, 1 warning (0.00 sec)
```
&emsp; 该命令执行之前，需要执行其他 SQL 语句才有记录。  

### 4.3.4. 查询指定 ID 的执行详细信息  

```
show profile for query Query_ID;
```
&emsp; 返回结果：  

```
mysql> show profile for query 9;
+----------------------+----------+
| Status               | Duration |
+----------------------+----------+
| starting             | 0.000207 |
| checking permissions | 0.000010 |
| Opening tables       | 0.000042 |
| init                 | 0.000050 |
| System lock          | 0.000012 |
| optimizing           | 0.000003 |
| statistics           | 0.000011 |
| preparing            | 0.000011 |
| executing            | 0.000002 |
| Sending data         | 0.000362 |
| end                  | 0.000006 |
| query end            | 0.000006 |
| closing tables       | 0.000006 |
| freeing items        | 0.000011 |
| cleaning up          | 0.000013 |
+----------------------+----------+
15 rows in set, 1 warning (0.00 sec)
```
&emsp; 每行都是状态变化的过程以及它们持续的时间。Status 这一列和 show processlist 的 State 是一致的。因此，需要优化的注意点与上文描述的一样。  

### 4.3.5. 获取 CPU、 Block IO 等信息  

```
show profile block io,cpu for query Query_ID;

show profile cpu,block io,memory,swaps,context switches,source for query Query_ID;

show profile all for query Query_ID;
```



---
# 5. Sql语句优化  
## 5.1. 基本查询优化  
&emsp; ***查询结果集优化***  
&emsp; 避免使用select *。count(1)或count(列)代替count(*)。  

    count(*) 和 count(1)和count(列名)区别：  
    执行效果上： 
        count(*)包括了所有的列，相当于行数，在统计结果的时候，不会忽略列值为NULL  
        count(1)忽略所有列，用1代表代码行，在统计结果的时候，不会忽略列值为NULL  
        count(列名)只包括列名那一列，在统计结果的时候，会忽略列值为空（这里的空不是只空字符串或者0，而是表示null）的计数，即某个字段值为NULL时，不统计。
    执行效率上：  
        列名为主键，count(列名)会比count(1)快  
        列名不为主键，count(1)会比count(列名)快  
        如果表多个列并且没有主键，则 count（1） 的执行效率优于 count（*）  
        如果有主键，则 select count（主键）的执行效率是最优的  
        如果表只有一个字段，则 select count（*）最优。

&emsp; ***group by优化***  
1. 优化GROUP BY: 提高GROUP BY语句的效率，可以通过将不需要的记录在GROUP BY之前过滤掉。即联合使用where子句和having子句。  

2. 在默认情况下，MySQL中的GROUP BY语句会对其后出现的字段进行默认排序（非主键情况），就好比我们使用ORDER BY col1,col2,col3…所以我们在后面跟上具有相同列（与GROUP BY后出现的col1,col2,col3…相同）ORDER BY子句并没有影响该SQL的实际执行性能。  
那么就会有这样的情况出现，我们对查询到的结果是否已经排序不在乎时，可以使用ORDER BY NULL禁止排序达到优化目的。下面使用EXPLAIN命令分析SQL。  
&emsp; 在user_1中执行select id, sum(money) form user_1 group by name时，会默认排序（注意group by后的column是非index才会体现group by的排序，如果是primary key，那之前说过了InnoDB默认是按照主键index排好序的）  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/SQL/sql-53.png)  
&emsp; 不禁止排序，即不使用ORDER BY NULL时：有明显的Using filesort。  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/SQL/sql-54.png)  
&emsp; 当使用ORDER BY NULL禁止排序后，Using filesort不存在  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/SQL/sql-55.png)  

&emsp; ***Order by优化：***  
&emsp; MySQL可以使用一个索引来满足ORDER BY 子句的排序，而不需要额外的排序，但是需要满足以下几个条件：  
1. WHERE 条件和OREDR BY 使用相同的索引：即key_part1与key_part2是复合索引，where中使用复合索引中的key_part1  

    SELECT*FROM user WHERE key_part1=1 ORDER BY key_part1 DESC, key_part2 DESC;
2. 而且ORDER BY顺序和索引顺序相同：  

    SELECT*FROM user ORDER BY key_part1, key_part2;
3. 并且要么都是升序要么都是降序：  

    SELECT*FROM user ORDER BY key_part1 DESC, key_part2 DESC;

&emsp; 但以下几种情况则不使用索引：  
1. ORDER BY中混合ASC和DESC：  

    SELECT*FROM user ORDER BY key_part1 DESC, key_part2 ASC;
2. 查询行的关键字与ORDER BY所使用的不相同，即WHERE 后的字段与ORDER BY 后的字段是不一样的  

    SELECT*FROM user WHERE key2 = ‘xxx’ ORDER BY key1;
3. ORDER BY对不同的关键字使用，即ORDER BY后的关键字不相同  
    
    SELECT*FROM user ORDER BY key1, key2;

## 5.2. 子查询优化  
&emsp; 使用子查询有时候可以使用更有效的JOIN连接代替，这是因为MySQL中不需要在内存中创建临时表完成SELECT子查询与主查询两部分查询工作。但是并不是所有的时候都成立，最好是在on关键字后面的列有索引的话，效果会更好！  
&emsp; 比如在表major中major_id是有索引的：  
```
select * from student u left join major m on u.major_id=m.major_id where m.major_id is null;
```

&emsp; 而通过子查询时，在内存中创建临时表完成SELECT子查询与主查询两部分查询工作，会有一定的消耗  
```
select * from student u where major_id not in (select major_id from major);
```

## 5.3. 关联查询优化  


## 5.4. 组合查询优化  
1. MySQL处理UNION的策略是先创建临时表，然后再把各个查询结果插入到临时表中，最后再来做查询。因此很多优化策略在UNION查询中都没有办法很好的时候。经常需要手动将WHERE、LIMIT、ORDER BY等字句“下推”到各个子查询中，以便优化器可以充分利用这些条件先优化。  
2. 如果结果集允许重复的话,使用UNION ALL代替UNION。  

## 5.5. INSERT的优化  
1. 尽量使用多个值表的 INSERT 语句，这种方式将大大缩减客户端与数据库之间的连接、关闭等消耗。（同一客户的情况下），即：  

    INSERT INTO tablename values(1,2),(1,3),(1,4)  
2. 如果在不同客户端插入很多行，可使用INSERT DELAYED语句得到更高的速度，DELLAYED含义是让INSERT语句马上执行，其实数据都被放在内存的队列中。并没有真正写入磁盘。LOW_PRIORITY刚好相反。  
3. 将索引文件和数据文件分在不同的磁盘上存放（InnoDB引擎是在同一个表空间的）。  
4. 如果批量插入，则可以增加bluk_insert_buffer_size变量值提供速度（只对MyISAM有用）  
5. 当从一个文本文件装载一个表时，使用LOAD DATA INFILE，通常比INSERT语句快20倍。  

---
# 6. Sql索引优化  
## 6.1. 索引简介  
&emsp; 索引（Index）是帮助MySQL高效获取数据的数据结构。  
&emsp; ***创建索引的优势：***  
* 提高数据的检索速度，降低数据库IO成本：使用索引的意义就是通过缩小表中需要查询的记录的数目从而加快搜索的速度。  
* 降低数据排序的成本，降低CPU消耗：索引之所以查的快，是因为先将数据排好序，若该字段正好需要排序，则真好降低了排序的成本。  

&emsp; ***创建索引的劣势：***  
* 占用存储空间：索引实际上也是一张表，记录了主键与索引字段，一般以索引文件的形式存储在磁盘上。  
* 降低更新表的速度：表的数据发生了变化，对应的索引也需要一起变更，从而减低的更新速度。否则索引指向的物理数据可能不对，这也是索引失效的原因之一。  
* 优质索引创建难：索引的创建并非一日之功，也并非一直不变。需要频繁根据用户的行为和具体的业务逻辑去创建最佳的索引。  

&emsp; ***索引的分类：***  
* 从存储结构角度：BTree索引（B-Tree或B+Tree索引），Hash索引，full-index全文索引，R-Tree索引。这里所描述的是索引存储时保存的形式。  
* 从物理存储角度：根据数据的物理顺序与键值的逻辑（索引）顺序关系，聚集索引，非聚集索引。  
* 从逻辑角度：在 InnoDB 里面，索引类型有三种，普通索引、唯一索引（主键索引是特殊的唯一 索引）、全文索引。  
    * 普通（Normal）：也叫非唯一索引，是最普通的索引，没有任何的限制。  
    * 唯一（Unique）：唯一索引要求键值不能重复。另外需要注意的是，主键索引是一 种特殊的唯一索引，它还多了一个限制条件，要求键值不能为空。主键索引用 primay key 创建。  
    * 全文（Fulltext）：针对比较大的数据，比如存放的是消息内容，有几 KB 的数 据的这种情况，如果要解决 like 查询效率低的问题，可以创建全文索引。只有文本类型 的字段才可以创建全文索引，比如 char、varchar、text。  

## 6.2. 创建索引原则  
&emsp; 为了使索引的使用效率更高，在创建索引时，必须考虑在哪些字段上创建索引和创建什么类型的索引。  
* 在去重distinct字段上建立索引；  
* 多表连接的字段上需要建立索引；  
* where条件字段上需要建立索引；  
&emsp; 注：=和in可以乱序。比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式。  
* 分组字段上需要建立索引；  
* 排序字段上需要建立索引；  
&emsp; 利用索引进行排序操作是非常快的，而且可以利用同一索引同时进 行查找和排序操作。当索引的顺序与ORDER BY中的列顺序相同且所有的列是同一方向(全部升序或者全部降序)时，可以使用索引来排序，如果查询是连接多个表，仅当ORDER BY中的所有列都是第一个表的列时才会使用索引，其它情况都会使用filesort。  
* 在联合UNION字段上建立索引；  
</br>  
</br>  
* 尽量选择区分度高的列作为索引  
&emsp; 区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就 是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段要求是0.1以上，即平均1条扫描10条 记录
* 尽量使用数据量少的索引  
&emsp; 如果索引的值很长，那么查询的速度会受到影响。例如，对一个CHAR(100)类型的字段进行全文检索需要的时间肯定要比对CHAR(10)类型的字段需要的时间要多。  
* 尽量使用前缀来索引  
&emsp; 如果索引字段的值很长，最好使用值的前缀来索引。例如，TEXT和BLOG类型的字段，进行全文检索会很浪费时间。如果只检索字段的前面的若干个字符，这样可以提高检索速度。  
* 使用基于函数的索引  
&emsp; 任何对列的操作都可能导致全表扫描，例如：select * from emp where substr(ename,1,2)=’SM’；但是这种查询在客服系统又经常使用。可以创建一个带有substr函数的基于函数的索引，create index emp_ename_substr on eemp (substr(ename,1,2));这样在执行上面的查询语句时，会使用基于函数的索引。  
* 根据业务场景建立覆盖索引  
&emsp; 覆盖索引（covering index）指一个查询语句的执行只用从索引中就能够取得，不必从数据表中读取。也可以称之为实现了索引覆盖。  
&emsp; 当一条查询语句符合覆盖索引条件时，MySQL只需要通过索引就可以返回查询所需要的数据，这样避免了查到索引后再返回表操作，减少I/O提高效率。  

<br/>  

* 限制索引的数目  
&emsp; 索引的数目不是越多越好。每个索引都需要占用磁盘空间，索引越多，需要的磁盘空间就越大。修改表时，对索引的重构和更新很麻烦。越多的索引，会使更新表变得很浪费时间。  
* 尽量使用数据量少的索引  
&emsp; 如果索引的值很长，那么查询的速度会受到影响。例如，对一个CHAR（100）类型的字段进行全文检索需要的时间肯定要比对CHAR（10）类型的字段需要的时间要多。  
* 删除不再使用或者很少使用的索引  
&emsp; 表中的数据被大量更新，或者数据的使用方式被改变后，原有的一些索引可能不再需要。数据库管理员应当定期找出这些索引，将它们删除，从而减少索引对更新操作的影响。  

<br/>   

* 根据需要建立多列联合索引：  
&emsp; ***联合索引最左前缀匹配原则：***  
&emsp; mysql查询时索引会一直向右匹配，直到遇到范围查询(>、<、between、like)就停止匹配。mysql从左到右的使用索引中的字段，一个查询可以只使用索引中的一部份，但只能是最左侧部分。例如索引是key index(a,b,c)。可以支持 a|a,b|a,b,c 3种组合进行查找，但不支持b,c进行查找。当最左侧字段是常量引用时，索引就十分有效。  

&emsp; ***WHERE+ 多个字段ORDER BY，满足最左前缀。***  
&emsp; SELECT * FROM [table] WHERE uid=1 ORDER x,y LIMIT 0,10;  
&emsp; 建立索引(uid,x,y)实现order by的优化,比建立(x,y,uid)索引效果要好得多。  

&emsp; ***单列索引和联合索引的选择：***  
1. 联合索引的几个字段是否经常同时以AND方式出现在Where子句中？单字段查询是否极少甚至没有？假如是，则可以建立联合索引；否则考虑单字段索引；  
&emsp; 当出现多个索引做相交操作时（多个AND条件），通常来说一个包含所有相关列的索引要优于多个独立索引。  
2. 假如联合索引中包含的字段经常单独出现在where子句中，则分解为多个单字段索引；  
&emsp; 当出现多个索引做联合操作时（多个OR条件），对结果集的合并、排序等操作需要耗费大量的CPU和内存资源，特别是当其中的某些索引的选择性不高，需要返回合并大量数据时，查询成本更高。所以这种情况下还不如走全表扫描。  
&emsp; 因此explain时如果发现有索引合并（Extra字段出现Using union），应该好好检查一下查询和表结构是不是已经是最优的，如果查询和表都没有问题，那只能说明索引建的非常糟糕，应当慎重考虑索引是否合适，有可能一个包含所有相关列的多列索引更适合。  
3. 假如联合索引所包含的字段超过3个，那么仔细考虑其必要性，考虑减少联合的字段；  
4. 假如既有单字段索引，又有这几个字段上的联合索引，一般可以删除联合索引；  

## 6.3. 索引条件下推（ICP）  
&emsp; 官方文档：https://dev.mysql.com/doc/refman/5.7/en/index-condition-pushdown-optimization.html  

&emsp; 索引下推（Index Condition Pushdown）：MySQL5.6引入了索引下推优化，默认开启。  
&emsp; 索引条件下推（ICP）是对MySQL使用索引从表中检索行的情况的优化。如果没有ICP，存储引擎会遍历索引以查找基表中的行，并将它们返回给MySQL服务器，该服务器会评估WHERE行的条件。启用ICP后，如果WHERE只使用索引中的列来评估部分 条件，MySQL服务器会推送这部分内容。WHERE条件下到存储引擎。然后，存储引擎通过使用索引条目来评估推送的索引条件，并且仅当满足该条件时才从表中读取行。ICP可以减少存储引擎必须访问基表的次数以及MySQL服务器必须访问存储引擎的次数。  
&emsp; 索引下推简而言之就是在复合索引由于某些条件(比如 like %aa)失效的情况下，当存在失效的过滤字段在索引覆盖范围内，使用比较的方式在不回表的情况下进一步缩小查询的范围。其实就是对索引失效的进一步修复，属于最左前缀索引原则的一个特殊情况。  
<br/>
&emsp; 示例：people表中（zipcode，lastname，firstname）构成一个索引。  
&emsp; SELECT * FROM people WHERE zipcode='95054' AND lastname LIKE '%etrunia%' AND address LIKE '%Main Street%';  
&emsp; 如果没有使用索引下推技术，则MySQL会通过zipcode='95054'从存储引擎中查询对应的数据，返回到MySQL服务端，然后MySQL服务端基于lastname LIKE '%etrunia%'和address LIKE '%Main Street%'来判断数据是否符合条件。  
&emsp; 如果使用了索引下推技术，则MYSQL首先会返回符合zipcode='95054'的索引，然后根据lastname LIKE '%etrunia%'和address LIKE '%Main Street%'来判断索引是否符合条件。如果符合条件，则根据该索引来定位对应的数据，如果不符合，则直接reject掉。有了索引下推优化，可以在有like条件查询的情况下，减少回表次数。  

## 6.4. mysql建了多个单索引，查询多个条件时如何走索引的？  
......

## 6.5. 索引失效  
1. 隐式转换导致索引失效。  
&emsp; 由于表的字段tu_mdn定义为varchar2(20)，但在查询时把该字段作为number类型以where条件传给sql语句,这样会导致索引失效。  
&emsp; 错误的例子：select * from test where tu_mdn=13333333333;  
&emsp; 正确的例子：select * from test where tu_mdn='13333333333';  
2. 对索引列进行null值运算。  
&emsp; 索引无法存储null值。B-tree索引is null不会走，is not null会走。  
3. 对索引列进行运算导致索引失效。  
&emsp; 逻辑运算（NOT、OR）；比较运算（=、<>、!=、>、>=、!>、<、<=、!<）、all，some，many关键字；范围查询in，exist关键字、like关键字。  
&emsp; 用or分割条件，若or前后只要有一个列没有索引，就都不会用索引。  
4. 对索引进行模糊查询like时可能使索引失效（以%开头）。  
&emsp; 前导模糊查询不能利用索引(like '%XX'或者like '%XX%')。假如有这样一列code的值为'AAA','AAB','BAA','BAB' ,如果where code like '%AB'条件，由于条件首字母是是模糊%的，所以不能利用索引的顺序，必须一个个去查询。这样会导致全索引扫描或者全表扫描。如果是这样的条件where code like 'A % '，就可以查找CODE中A开头的CODE的位置，当碰到B开头的数据时，就可以停止查找了，因为后面的数据一定不满足要求。这样就可以利用索引了。  
&emsp; 解决办法：可采用在建立索引时用reverse(columnName)这种方法处理。  
5. 对索引列使用函数导致索引失效。  
&emsp; 对于这样情况应当创建基于函数的索引。  
&emsp; 错误的例子：select * from test where round(id)=10; 此时id的索引已经不起作用了。  
&emsp; 正确的例子：首先建立函数索引，create index test_id_fbi_idx on test(round(id));然后 select * from test where round(id)=10; 这时函数索引起作用了。  
6. 联合索引最左前缀匹配原则。  

## 6.6. 索引底层原理：  
&emsp; 不同的存储引擎支持的索引类型不一样：  
&emsp; InnoDB支持事务，支持行级别锁定，支持B-tree、Full-text等索引，不支持Hash索引；  
&emsp; MyISAM不支持事务，支持表级别锁定，支持B-tree、Full-text等索引，不支持Hash索引；  

### 6.6.1. BTree索引：  
&emsp; MySQL的BTree索引使用的是B树中的B+Tree，但对于MyIsam与InnoDB两种存储引擎的实现方式是不同的。  

#### 6.6.1.1. B+ Tree简介：  
B+ Tree请查看： [B+ Tree章节](../java/function/2.structure.md)  

#### 6.6.1.2. InnoDB引擎的底层实现： 
&emsp; 在InnoDB中，数据和索引文件是合起来储存的，如图所示，InnoDB 的存储文件有两个，后缀名分别是 .frm 和 .idb，其中 .frm 是表的定义文件，而idb是数据文件/索引文件。  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/SQL/sql-33.png)  
&emsp; InnoDB索引类型可以分为主键索引和辅助索引（非主键索引）。  
&emsp; 主键索引树中，叶子结点保存着主键和对应行的全部数据。主键索引又被称为聚簇索引。  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/SQL/sql-34.png)  

&emsp; 辅助索引树中，叶子结点保存着索引值和主键值。辅助索引又被称为非聚簇索引。当使用辅助索引进行查询时，一般需要进行回表操作。  
&emsp; 非聚簇索引一定会回表查询吗?（覆盖索引）  
&emsp; 不一定，这涉及到查询语句所要求的字段是否全部命中了索引，如果全部命中了索引，即索引覆盖，那么就不必再进行回表查询。  
    
    索引覆盖，要查询的字段都建立了索引，那么引擎会直接在索引表中查询而不会访问原始数据（否则只要有一个字段没有建立索引就会做全表扫描），这叫索引覆盖。  
&emsp; 总结：B+树在满足聚簇索引和覆盖索引的时候不需要回表查询数据。  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/SQL/sql-35.png)  

&emsp; ***自适应哈希索引：***  
&emsp; 常用的InnoDB引擎中默认使用的是B+树索引，它会实时监控表上索引的使用情况。  
&emsp; 如果认为建立哈希索引可以提高查询效率，则自动在内存中的“自适应哈希索引缓冲区”建立哈希索引（在InnoDB中默认开启自适应哈希索引）。  
&emsp; 通过观察搜索模式，MySQL会利用index key的前缀建立哈希索引，如果一个表几乎大部分都在缓冲池中，那么建立一个哈希索引能够加快等值查询。  
&emsp; 注意：在某些工作负载下，通过哈希索引查找带来的性能提升远大于额外的监控索引搜索情况和保持这个哈希表结构所带来的开销。  
&emsp; 但某些时候，在负载高的情况下，自适应哈希索引中添加的read/write锁也会带来竞争，比如高并发的join操作。like操作和%的通配符操作也不适用于自适应哈希索引，可能要关闭自适应哈希索引。  

#### 6.6.1.3. MyISAM引擎的底层实现：  
&emsp; 在MyISAM储存引擎中，数据和索引文件是分开储存的，Myisam的存储文件有三个，后缀名分别是 .frm、.MYD、MYI，其中 .frm 是表的定义文件，.MYD 是数据文件，.MYI 是索引文件。  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/SQL/sql-36.png)  
&emsp; MyISAM也是B+树结构，但是MyISAM索引的叶子节点的数据保存的是行数据的地址。因此，MyISAM中索引检索的算法首先在索引树中找到行数据的地址，然后根据地址找到对应的行数据。  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/SQL/sql-37.png)  
&emsp; MyISAM的索引文件仅仅保存数据记录的地址。主键索引和辅助索引，只是主索引要求key是唯一的，而辅助索引的key可以重复。如果在Col2上建立一个辅助索引，则此索引的如下图：  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/SQL/sql-38.png)  

#### 6.6.1.4. 为什么使用B+树？  
&emsp; 为什么索引结构默认使用B+Tree，而不是Hash，二叉树，红黑树？  
&emsp; ***1). B+的磁盘读写代价更低。***  
&emsp; 一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗，相对于内存存取，I/O存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I/O操作次数的渐进复杂度。换句话说，索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数。  
&emsp; B-tree：因为B树不管叶子节点还是非叶子节点，都会保存数据，这样导致在非叶子节点中能保存的指针数量变少，指针少的情况下要保存大量数据，只能增加树的高度，导致IO操作变多，查询性能变低；  
&emsp; （从物理存储结构上说，B-Tree和B+Tree都以页(4K)来划分节点的大小，但是由于B+Tree中中间节点不存储数据，因此B+Tree能够在同样大小的节点中，存储更多的key，提高查找效率。）  
&emsp; Hash：虽然可以快速定位，但是没有顺序，IO复杂度高。  
&emsp; 二叉树：树的高度不均匀，不能自平衡，查找效率跟数据有关（树的高度），并且IO代价高。  
&emsp; 红黑树：树的高度随着数据量增加而增加，IO代价高。
&emsp; ***2). B+-tree的查询效率更加稳定。***  
&emsp; 由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。  

#### 6.6.1.5. 为什么官方建议使用自增长主键作为索引？  
&emsp; 性能：根据B+Tree的特点，自增主键是连续的，在插入过程中尽量减少页分裂，即使要进行页分裂，也只会分裂很少一部分。并且能减少数据的移动，每次插入都是插入到最后。即减少分裂和移动的频率。  
&emsp; 存储空间：由于每个非主键索引的叶子节点上都是主键的值。如果用业务字段做主键，那么每个二级索引的叶子节点占用约xxx个字节，而如果用整型做主键，则只要4个字节，如果是长整型（bigint）则是8个字节。即主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。  
&emsp; 适合用业务字段做主键的场景需求：1).只有一个索引；2).该索引必须是唯一索引。这就是典型的KV场景。由于没有其他索引，所以也就不用考虑其他索引的叶子节点大小的问题。  

    主键的选择：  
    如果定义了主键(PRIMARY KEY)，那么InnoDB会选择主键作为聚集索引。  
    如果没有显式定义主键，则InnoDB会选择第一个不包含有NULL值的唯一索引作为主键索引。  
    如果也没有这样的唯一索引，则InnoDB会选择内置6字节长的ROWID作为隐含的聚集索引(ROWID随着行记录的写入而主键递增，这个ROWID不像ORACLE的ROWID那样可引用，是隐含的)。  

### 6.6.2. Hash索引  
&emsp; 哈希索引底层的数据结构就是哈希表。对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码（hash code），并且Hash索引将所有的哈希码存储在索引中，同时在索引表中保存指向每个数据行的指针。  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/SQL/sql-39.png)  
&emsp; 哈希索引适用的场景：等值查询。  
&emsp; 哈希索引不适用的场景：不支持范围查询、不支持索引完成排序、不支持联合索引的最左前缀匹配规则、不支持部分匹配、只支持等值查询如=，IN()，不支持 < >。  



## 6.7. 索引维护、索引工具的使用  
1. 冗余和重复索引：冗余索引是指在相同的列上按照相同的顺序创建的相同类型的索引，应当尽量避免这种索引，发现后立即删除。比如有一个索引(A,B)，再创建索引(A)就是冗余索引。冗余索引经常发生在为表添加新索引时，比如有人新建了索引(A,B)，但这个索引不是扩展已有的索引(A)。
2. 大多数情况下都应该尽量扩展已有的索引而不是创建新索引。但有极少情况下出现性能方面的考虑需要冗余索引，比如扩展已有索引而导致其变得过大，从而影响到其他使用该索引的查询。
3. 删除长期未使用的索引。

&emsp; MySql索引工具：1.mysqlidxchx 2.pt-index-usage 3.userstat 4.check-unused-keys  


# 7. 数据库表结构设计  
## 7.1. 选择合适的数据类型  
1) 使用可以存下数据最小的数据类型  
2) 使用简单的数据类型。int 要比 varchar 类型在mysql处理简单   
3) 尽量使用 tinyint、smallint、mediumint 作为整数类型而非 int  
4) 尽可能使用 not null 定义字段，因为 null 占用4字节空间  
5) 尽量少用 text 类型,非用不可时最好考虑分表  
6) 尽量使用 timestamp 而非 datetime  
7) 单表不要有太多字段，建议在 20 以内  

## 7.2. 表的拆分 
&emsp; 当数据库中的数据非常大时，查询优化方案也不能解决查询速度慢的问题时，可以考虑拆分表，让每张表的数据量变小，从而提高查询效率。  
1. 垂直拆分：将表中多个列分开放到不同的表中。例如用户表中一些字段经常被访问，将这些字段放在一张表中，另外一些不常用的字段放在另一张表中。插入数据时，使用事务确保两张表的数据一致性。  
2. 水平拆分：按照行进行拆分。例如用户表中，使用用户ID，对用户ID取10的余数，将用户数据均匀的分配到0~9的10个用户表中。查找时也按照这个规则查询数据。  

## 7.3. 读写分离  
&emsp; 一般情况下对数据库而言都是“读多写少”。换言之，数据库的压力多数是因为大量的读取数据的操作造成的。可以采用数据库集群的方案，使用一个库作为主库，负责写入数据；其他库为从库，负责读取数据。这样可以缓解对数据库的访问压力。  


# 8. Sql服务器  
## 8.1. 查看 MySQL 服务器运行的状态值  
&emsp; 执行命令：  

```
show status
```
&emsp; 由于返回结果太多，此处不贴出结果。其中，在返回的结果中，主要关注 “Queries”、“Threadsconnected” 和 “Threadsrunning” 的值，即查询次数、线程连接数和线程运行数。

&emsp; 可以通过执行如下脚本监控 MySQL 服务器运行的状态值  

```
#!/bin/bash
while true
do
mysqladmin -uroot -p"密码" ext | awk '/Queries/{q=$4}/Threads_connected/{c=$4}/Threads_running/{r=$4}END{printf("%d %d %d\n",q,c,r)}' >> status.txt
sleep 1
done
```
&emsp; 执行该脚本 24 小时，获取 status.txt 里的内容，再次通过 awk 计算==每秒请求 MySQL 服务的次数==  

```
awk '{q=$1-last;last=$1}{printf("%d %d %d\n",q,$2,$3)}' status.txt
```
&emsp; 复制计算好的内容到 Excel 中生成图表观察数据周期性。  
&emsp; 如果观察的数据有周期性的变化，如上图的解释，需要修改缓存失效策略。  
&emsp; 例如：  
&emsp; 通过随机数在[3,6,9] 区间获取其中一个值作为缓存失效时间，这样分散了缓存失效时间，从而节省了一部分内存的消耗。  
&emsp; 当访问高峰期时，一部分请求分流到未失效的缓存，另一部分则访问 MySQL 数据库，这样减少了 MySQL 服务器的压力。  

## 8.2. 服务器参数调优  
&emsp; 笔者并没有使用这些参数对 MySQL 服务器进行调优，具体详情介绍和性能效果请参考文章末尾的资料或另行百度。 

### 8.2.1. 内存相关
&emsp; sortbuffersize 排序缓冲区内存大小  
&emsp; joinbuffersize 使用连接缓冲区大小  
&emsp; readbuffersize 全表扫描时分配的缓冲区大小  

### 8.2.2. IO 相关
&emsp; Innodblogfile_size 事务日志大小  
&emsp; Innodblogfilesingroup 事务日志个数  
&emsp; Innodblogbuffer_size 事务日志缓冲区大小  
&emsp; Innodbflushlogattrx_commit 事务日志刷新策略 ，其值如下：  

    0：每秒进行一次 log 写入 cache，并 flush log 到磁盘
    1：在每次事务提交执行 log 写入 cache，并 flush log 到磁盘
    2：每次事务提交，执行 log 数据写到 cache，每秒执行一次 flush log 到磁盘

### 8.2.3. 安全相关
&emsp; expirelogsdays 指定自动清理 binlog 的天数  
&emsp; maxallowedpacket 控制 MySQL 可以接收的包的大小  
&emsp; skipnameresolve 禁用 DNS 查找  
&emsp; read_only 禁止非 super 权限用户写权限  

### 8.2.4. 其他
&emsp; max_connections 控制允许的最大连接数  
&emsp; tmptablesize 临时表大小  
&emsp; maxheaptable_size 最大内存表大小  




