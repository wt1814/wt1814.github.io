# SpringDI  
## 依赖注入发生的时间  
&emsp; 当 Spring IOC 容器完成了Bean定义资源的定位、载入和解析注册以后，IOC 容器中已经管理类 Bean 定义的相关数据，但是此时 IOC 容器还没有对所管理的 Bean 进行依赖注入，依赖注入在以下两种情况发生：  
&emsp; 1)、用户第一次调用getBean()方法时，IOC容器触发依赖注入。  
&emsp; 2)、当用户在配置文件中将<bean>元素配置了 lazy-init=false 属性，即让容器在解析注册 Bean 定义时进行预实例化，触发依赖注入。  

&emsp; getBean()方法定义在BeanFactory 接口中，可以通过分析其子类的具体实现，理解 Spring IOC 容器在用户索取 Bean 时如何完成依赖注入。  
![avatar](../../images/sourceCode/Spring/SpringDI-2.png)  
&emsp; 在BeanFactory中可以看到getBean(String...)方法，但它具体实现在 AbstractBeanFactory 中。  

## SpringDI时序图：  
![avatar](../../images/sourceCode/Spring/SpringDI-1.png)  
## AbstractBeanFactory.#getBean()，获取Bean  
&emsp; AbstractBeanFactory 的 getBean()相关方法的源码如下：  

```java
//获取 IOC 容器中指定名称的Bean @Override
public Object getBean(String name) throws BeansException {
    //doGetBean 才是真正向 IOC 容器获取被管理 Bean 的过程
    return doGetBean(name, null, null, false);
}

//获取 IOC 容器中指定名称和类型的Bean @Override
public <T> T getBean(String name, @Nullable Class<T> requiredType) throws BeansException {
    //doGetBean 才是真正向 IOC 容器获取被管理 Bean 的过程
    return doGetBean(name, requiredType, null, false);
}

//获取 IOC 容器中指定名称和参数的Bean @Override
public Object getBean(String name, Object... args) throws BeansException {
    //doGetBean 才是真正向 IOC 容器获取被管理 Bean 的过程
    return doGetBean(name, null, args, false);
}

//获取 IOC 容器中指定名称、类型和参数的Bean
public <T> T getBean(String name, @Nullable Class<T> requiredType, @Nullable Object... args) throws BeansException {
    //doGetBean 才是真正向 IOC 容器获取被管理 Bean 的过程
    return doGetBean(name, requiredType, args, false);
}
```  
&emsp; #getBean()调用#doGetBean()方法。  
### AbstractBeanFactory.#deGetBean()，获取Bean  
![avatar](../../images/sourceCode/Spring/SpringDI-3.png)  
&emsp; ***主要流程：***  
&emsp; 1、先处理Bean 的名称，因为如果以“&”开头的Bean名称表示获取的是对应的FactoryBean对象；  
&emsp; 2、从缓存中获取单例Bean，有则进一步判断这个Bean是不是在创建中，如果是的就等待创建完毕，否则直接返回这个Bean对象  
&emsp; 3、如果不存在单例Bean缓存，则先进行循环依赖的解析  
&emsp; 4、解析完毕之后先获取父类BeanFactory，获取到了则调用父类的getBean方法，不存在则先合并然后创建Bean  

&emsp; ***源码：***  

```java
@SuppressWarnings("unchecked")
//真正实现向 IOC 容器获取Bean 的功能，也是触发依赖注入功能的地方
protected <T> T doGetBean(final String name, @Nullable final Class<T> requiredType, @Nullable final Object[] args, boolean typeCheckOnly) throws BeansException {

    //根据指定的名称获取被管理 Bean 的名称，剥离指定名称中对容器的相关依赖
    //如果指定的是别名，将别名转换为规范的 Bean 名称
    final String beanName = transformedBeanName(name);
    Object bean;

    //先从缓存中取是否已经有被创建过的单态类型的 Bean
    //对于单例模式的 Bean 整个 IOC 容器中只创建一次，不需要重复创建
    Object sharedInstance = getSingleton(beanName);
    //IOC 容器创建单例模式 Bean 实例对象
    if (sharedInstance != null && args == null) {
        if (logger.isDebugEnabled()) {
            //如果指定名称的 Bean 在容器中已有单例模式的 Bean 被创建
            //直接返回已经创建的 Bean
            if (isSingletonCurrentlyInCreation(beanName)) {
                logger.debug("Returning eagerly cached instance of singleton bean '" + beanName +
                        "' that is not fully initialized yet - a consequence of a circular reference");
            } else {
                logger.debug("Returning cached instance of singleton bean '" + beanName + "'");
            }
        }

        //获取给定 Bean 的实例对象，主要是完成 FactoryBean 的相关处理
        //注意：BeanFactory 是管理容器中 Bean 的工厂，而 FactoryBean 是
        //创建创建对象的工厂 Bean，两者之间有区别
        bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);
    } else {
        //缓存没有正在创建的单例模式 Bean
        //缓存中已经有已经创建的原型模式 Bean
        //但是由于循环引用的问题导致实例化对象失败
        if (isPrototypeCurrentlyInCreation(beanName)) {
            throw new BeanCurrentlyInCreationException(beanName);
        }

        //对 IOC 容器中是否存在指定名称的BeanDefinition 进行检查，首先检查是否
        //能在当前的 BeanFactory 中获取的所需要的Bean，如果不能则委托当前容器
        //的父级容器去查找，如果还是找不到则沿着容器的继承体系向父级容器查找BeanFactory parentBeanFactory = getParentBeanFactory();
        //当前容器的父级容器存在，且当前容器中不存在指定名称的 Bean
        if (parentBeanFactory != null && !containsBeanDefinition(beanName)) {
            //解析指定 Bean 名称的原始名称
            String nameToLookup = originalBeanName(name);
            if (parentBeanFactory instanceof AbstractBeanFactory) {
                return ((AbstractBeanFactory) parentBeanFactory).doGetBean(
                        nameToLookup, requiredType, args, typeCheckOnly);
            } else if (args != null) {
                //委派父级容器根据指定名称和显式的参数查找
                return (T) parentBeanFactory.getBean(nameToLookup, args);
            } else {
                //委派父级容器根据指定名称和类型查找
                return parentBeanFactory.getBean(nameToLookup, requiredType);
            }
        }
        //创建的 Bean 是否需要进行类型验证，一般不需要
        if (!typeCheckOnly) {
            //向容器标记指定的 Bean 已经被创建
            markBeanAsCreated(beanName);
        }

        try {
            //根据指定 Bean 名称获取其父级的 Bean 定义
            //主要解决 Bean 继承时子类合并父类公共属性问题
            final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);
            checkMergedBeanDefinition(mbd, beanName, args);

            //获取当前 Bean 所有依赖 Bean 的名称
            String[] dependsOn = mbd.getDependsOn();
            //如果当前 Bean 有依赖 Bean
            if (dependsOn != null) {
                for (String dep : dependsOn) {
                    if (isDependent(beanName, dep)) {
                        throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                                "Circular depends-on relationship between '" + beanName + "' and '" + dep + "'");
                    }
                    //递归调用 getBean 方法，获取当前 Bean 的依赖Bean registerDependentBean(dep, beanName);
                    //把被依赖 Bean 注册给当前依赖的 Bean getBean(dep);
                }
            }

            //创建单例模式 Bean 的实例对象
            if (mbd.isSingleton()) {
                //这里使用了一个匿名内部类，创建 Bean 实例对象，并且注册给所依赖的对象
                sharedInstance = getSingleton(beanName, () -> {
                    try {
                        //创建一个指定 Bean 实例对象，如果有父级继承，则合并子类和父类的定义
                        return createBean(beanName, mbd, args);
                    } catch (BeansException ex) {
                        //显式地从容器单例模式 Bean 缓存中清除实例对象
                        destroySingleton(beanName);
                        throw ex;
                    }
                });
                //获取给定 Bean 的实例对象
                bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
            }
            //IOC 容器创建原型模式 Bean 实例对象
            else if (mbd.isPrototype()) {
                //原型模式(Prototype)是每次都会创建一个新的对象
                Object prototypeInstance = null;
                try {
                    //回调 beforePrototypeCreation 方法，默认的功能是注册当前创建的原型对象
                    beforePrototypeCreation(beanName);
                    //创建指定 Bean 对象实例
                    prototypeInstance = createBean(beanName, mbd, args);
                } finally {
                    //回调 afterPrototypeCreation 方法，默认的功能告诉 IOC 容器指定 Bean 的原型对象不再创建
                    afterPrototypeCreation(beanName);
                }
                //获取给定 Bean 的实例对象
                bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);
            }

            //要创建的 Bean 既不是单例模式，也不是原型模式，则根据 Bean 定义资源中
            //配置的生命周期范围，选择实例化 Bean 的合适方法，这种在 Web 应用程序中
            //比较常用，如：request、session、application 等生命周期
            else {
                String scopeName = mbd.getScope();
                final Scope scope = this.scopes.get(scopeName);
                //Bean 定义资源中没有配置生命周期范围，则 Bean 定义不合法
                if (scope == null) {
                    throw new IllegalStateException("No Scope registered for scope name '" + scopeName + "'");
                }
                try {
                    //这里又使用了一个匿名内部类，获取一个指定生命周期范围的实例
                    Object scopedInstance = scope.get(beanName, () -> {
                        beforePrototypeCreation(beanName);
                        try {
                            return createBean(beanName, mbd, args);
                        } finally {
                            afterPrototypeCreation(beanName);
                        }
                    });
                    //获取给定 Bean 的实例对象
                    bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);
                } catch (IllegalStateException ex) {
                    throw new BeanCreationException(beanName,
                            "Scope '" + scopeName + "' is not active for the current thread; consider " + "defining a scoped proxy for this bean if you intend to refer to it from a singleton", ex);
                }
            }
        } catch (BeansException ex) {
            cleanupAfterBeanCreationFailure(beanName);
            throw ex;
        }
    }


    //对创建的 Bean 实例对象进行类型检查
    if (requiredType != null && !requiredType.isInstance(bean)) {
        try {
            T convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType);
            if (convertedBean == null) {
                throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());
            }
            return convertedBean;
        } catch (TypeMismatchException ex) {
            if (logger.isDebugEnabled()) {
                logger.debug("Failed to convert bean '" + name + "' to required type '" + ClassUtils.getQualifiedName(requiredType) + "'", ex);
            }
            throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());
        }
    }
    return (T) bean;
}
```  
&emsp; 通过上面对向 IOC 容器获取 Bean 方法的分析，可以看到在 Spring 中，如果 Bean 定义的单例模式(Singleton)，则容器在创建之前先从缓存中查找，以确保整个容器中只存在一个实例对象。如果 Bean 定义的是原型模式(Prototype)，则容器每次都会创建一个新的实例对象。除此之外，Bean 定义还可以扩展为指定其生命周期范围。  
&emsp; 上面的源码只是定义了根据 Bean 定义的模式，采取的不同创建 Bean 实例对象的策略，具体的 Bean 实例对象的创建过程由实现了 ObjectFactory 接口的匿名内部类的 createBean() 方法完成，ObjectFactory 使 用 委 派 模 式 ， 具 体 的 Bean 实 例 创 建 过 程 交 由 其 实 现 类AbstractAutowireCapableBeanFactory 完成，继续分析AbstractAutowireCapableBeanFactory 的 createBean()方法的源码，理解其创建 Bean 实例的具体实现过程。  

## AbstractAutowireCapableBeanFactory.#createBean()，实例化Bean  
