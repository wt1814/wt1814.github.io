## 2.2. Spring Boot 2.2.0启动全过程源码分析：
&emsp; 源码学习方法：看着大佬文章，找到源码一步一步理解。  
&emsp; SpringBoot启动类代码如下：  

```java
public static void main(String[] args) {
    SpringApplication.run(DemoApplication.class, args);
}
```  
&emsp; 进入SpringApplication#run方法中，一路点击#run方法。  

```java
public static ConfigurableApplicationContext run(Class<?>[] primarySources, String[] args) {
    return (new SpringApplication(primarySources)).run(args);
}
```
&emsp; SpringApplication.run()中首先new SpringApplication对象，然后调用该对象的run方法。即run()方法主要包括两大步骤：  
1. 创建SpringApplication 对象；  
2. 运行run()方法。  

### 1. SpringApplication初始化  
![avatar](../../images/springBoot/springBoot-4.png)  

```java
public SpringApplication(ResourceLoader resourceLoader, Class... primarySources) {

    this.sources = new LinkedHashSet();
    this.bannerMode = Mode.CONSOLE;
    this.logStartupInfo = true;
    this.addCommandLineProperties = true;
    this.addConversionService = true;
    this.headless = true;
    this.registerShutdownHook = true;
    this.additionalProfiles = new HashSet();
    this.isCustomEnvironment = false;
    this.resourceLoader = resourceLoader;
    //断言主要加载资源类不能为 null，否则报错
    Assert.notNull(primarySources, "PrimarySources must not be null");
    //初始化主要加载资源类集合并去重
    this.primarySources = new LinkedHashSet(Arrays.asList(primarySources));
    // 判断当前是否是一个 Web 应用
    this.webApplicationType = WebApplicationType.deduceFromClasspath();
    //设置应用上下文初始化器
    // 从类路径下找到 META/INF/Spring.factories 配置的所有 ApplicationContextInitializer，然后保存起来
    this.setInitializers(this.getSpringFactoriesInstances(ApplicationContextInitializer.class));
    //设置监听器
    // 从类路径下找到 META/INF/Spring.factories 配置的所有 ApplicationListener，然后保存起来
    this.setListeners(this.getSpringFactoriesInstances(ApplicationListener.class));
    // 推断主入口应用类。从多个配置类中找到有 main 方法的主配置类（只有一个）
    this.mainApplicationClass = this.deduceMainApplicationClass();
}
```  
#### 流程解析：  
&emsp; 从上述流程中，挑以下几个进行分析。
##### 推断当前 WEB 应用类型  

```java
this.webApplicationType = deduceWebApplicationType();
```
&emsp; deduceWebApplicationType方法和相关的源码：  

```java
private WebApplicationType deduceWebApplicationType() {

    if (ClassUtils.isPresent(REACTIVE_WEB_ENVIRONMENT_CLASS, null) && !ClassUtils.isPresent(MVC_WEB_ENVIRONMENT_CLASS, null)) {
        return WebApplicationType.REACTIVE;
    }

    for (String className : WEB_ENVIRONMENT_CLASSES) {
        if (!ClassUtils.isPresent(className, null)) {
            return WebApplicationType.NONE;
        }
    }
    return WebApplicationType.SERVLET;
}

private static final String REACTIVE_WEB_ENVIRONMENT_CLASS = "org.springframework." 
        + "web.reactive.DispatcherHandler";
private static final String MVC_WEB_ENVIRONMENT_CLASS = "org.springframework."
        + "web.servlet.DispatcherServlet";
private static final String[] WEB_ENVIRONMENT_CLASSES = { "javax.servlet.Servlet",
        "org.springframework.web.context.ConfigurableWebApplicationContext" };

public enum WebApplicationType {
    /**
     * 非 WEB 项目
     */
    NONE,
    /**
     * SERVLET WEB 项目
     */
    SERVLET,
    /**
     * 响应式 WEB 项目
     */
    REACTIVE
}
```  
&emsp; 这个就是根据类路径下是否有对应项目类型的类推断出不同的应用类型。  
##### 设置应用上下文初始化器  

```java
this.setInitializers(this.getSpringFactoriesInstances(ApplicationContextInitializer.class));
```
1. 参数ApplicationContextInitializer.class用来初始化指定的 Spring 应用上下文，如注册属性资源、激活 Profiles 等。  
2. this.getSpringFactoriesInstances()方法和相关的源码：  

```java
private <T> Collection<T> getSpringFactoriesInstances(Class<T> type) {
    return this.getSpringFactoriesInstances(type, new Class[0]);
}

private <T> Collection<T> getSpringFactoriesInstances(Class<T> type, Class<?>[] parameterTypes, Object... args) {
    //获取当前线程上下文类加载器
    ClassLoader classLoader = this.getClassLoader();
    //获取 ApplicationContextInitializer 的实例名称集合并去重
      //根据类路径下的 META-INF/spring.factories 文件解析并获取 ApplicationContextInitializer 接口的所有配置的类路径名称
    Set<String> names = new LinkedHashSet(SpringFactoriesLoader.loadFactoryNames(type, classLoader));
    //根据以上类路径创建初始化器实例列表
    List<T> instances = this.createSpringFactoriesInstances(type, parameterTypes, classLoader, args, names);
    //初始化器实例列表排序
    AnnotationAwareOrderComparator.sort(instances);
    //返回初始化器实例列表
    return instances;
}
```  
##### 设置监听器  

```java
this.setListeners(this.getSpringFactoriesInstances(ApplicationListener.class));
```  
&emsp; 参数ApplicationListener.class继承了JDK 的 java.util.EventListener 接口，实现了观察者模式，它一般用来定义感兴趣的事件类型，事件类型限定于 ApplicationEvent的子类。  

----------------
### 2. SpringApplication 实例 run()方法运行过程
&emsp; 进入SpringApplication#run方法中，一路点击#run方法。  

```java
public ConfigurableApplicationContext run(String... args) {

    // 1、创建并启动计时监控类
    StopWatch stopWatch = new StopWatch();
    stopWatch.start();//首先记录了当前任务的名称，默认为空字符串，然后记录当前 Spring Boot 应用启动的开始时间
    // 2、初始化应用上下文和异常报告集合
    ConfigurableApplicationContext context = null;
    Collection<SpringBootExceptionReporter> exceptionReporters = new ArrayList();
    // 3、设置系统属性 `java.awt.headless` 的值，默认值为：true
    this.configureHeadlessProperty();
    // 4、创建所有 Spring 运行监听器并发布应用启动事件
    // 从类路径下找到 META/INF/Spring.factories 获取 SpringApplicationRunListeners
    SpringApplicationRunListeners listeners = this.getRunListeners(args);
    // 回调所有 SpringApplicationRunListeners 的 starting() 方法
    listeners.starting();
    Collection exceptionReporters;
    try {
        // 5、初始化默认应用参数类，封装命令行参数
        ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);
        // 6、根据运行监听器和应用参数来准备 Spring 环境
        //包括创建环境，创建环境完成后回调 SpringApplicationRunListeners#environmentPrepared()方法，表示环境准备完成
        ConfigurableEnvironment environment = this.prepareEnvironment(listeners, applicationArguments);
        this.configureIgnoreBeanInfo(environment);
        // 7、打印 Banner
        Banner printedBanner = this.printBanner(environment);
        // 8、创建应用上下文（决定创建 web 的 IOC 容器还是普通的 IOC 容器）
            //根据不同的应用类型初始化不同的上下文应用类
        context = this.createApplicationContext();
        // 9、准备异常报告器
        exceptionReporters = this.getSpringFactoriesInstances(SpringBootExceptionReporter.class, new Class[]{ConfigurableApplicationContext.class}, context);
        // 10、准备应用上下文
        /*
         * 将 environment 保存到 IOC 容器中，并且调用 applyInitializers() 方法
         * applyInitializers() 方法回调之前保存的所有的 ApplicationContextInitializer 的 initialize() 方法
         * 然后回调所有的 SpringApplicationRunListener#contextPrepared() 方法
         * 最后回调所有的 SpringApplicationRunListener#contextLoaded() 方法
         */
        this.prepareContext(context, environment, listeners, applicationArguments, printedBanner);
        // 11、刷新应用上下文，IOC 容器初始化（如果是 Web 应用还会创建嵌入式的 Tomcat），扫描、创建、加载所有组件
        this.refreshContext(context);
        // 12、应用上下文刷新后置处理，从 IOC 容器中获取所有的 ApplicationRunner 和 CommandLineRunner 进行回调
        this.afterRefresh(context, applicationArguments);
        // 13、停止计时监控类
        stopWatch.stop();
        // 14、输出日志记录执行主类名、时间信息
        if (this.logStartupInfo) {
            (new StartupInfoLogger(this.mainApplicationClass)).logStarted(this.getApplicationLog(), stopWatch);
        }
        // 15、发布应用上下文启动完成事件，调用所有SpringApplicationRunListeners#started()方法
        listeners.started(context);
        // 16、执行ApplicationRunner和CommandLineRunner两种运行器
        this.callRunners(context, applicationArguments);
    } catch (Throwable var10) {
        this.handleRunFailure(context, var10, exceptionReporters, listeners);
        throw new IllegalStateException(var10);
    }
    try {
        // 17、发布应用上下文就绪事件，触发所有SpringApplicationRunListener 监听器的running事件方法。
        listeners.running(context);
        // 18、返回应用上下文
        return context;
    } catch (Throwable var9) {
        this.handleRunFailure(context, var9, exceptionReporters, (SpringApplicationRunListeners)null);
        throw new IllegalStateException(var9);
    }
}
```  
#### 流程解析：  
&emsp; 从上述流程中，挑以下几个进行分析。
##### 3、设置系统属性 `java.awt.headless` 的值  

```java
this.configureHeadlessProperty();
```  
&emsp; 设置该默认值为：true，Java.awt.headless = true 有什么作用？  
&emsp; 对于一个Java服务器来说经常要处理一些图形元素，例如地图的创建或者图形和图表等。这些API基本上总是需要运行一个X-server以便能使用AWT（Abstract Window Toolkit，抽象窗口工具集）。然而运行一个不必要的 X-server 并不是一种好的管理方式。有时你甚至不能运行 X-server,因此最好的方案是运行 headless 服务器，来进行简单的图像处理。  
&emsp; 参考：www.cnblogs.com/princessd8251/p/4000016.html  

##### 6、根据运行监听器和应用参数来准备 Spring 环境  

```java
ConfigurableEnvironment environment = this.prepareEnvironment(listeners, applicationArguments);
this.configureIgnoreBeanInfo(environment);
```  
&emsp; this.prepareEnvironment()源码：  

```java
private ConfigurableEnvironment prepareEnvironment(SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments) {
    // 6.1) 获取（或者创建）应用环境
        //分为标准 Servlet 环境和标准环境
    ConfigurableEnvironment environment = this.getOrCreateEnvironment();
    // 6.2) 配置应用环境
        // 配置 property sources
        //配置 Profiles
    this.configureEnvironment((ConfigurableEnvironment)environment, applicationArguments.getSourceArgs());
    ConfigurationPropertySources.attach((Environment)environment);
    listeners.environmentPrepared((ConfigurableEnvironment)environment);
    this.bindToSpringApplication((ConfigurableEnvironment)environment);
    if (!this.isCustomEnvironment) {
        environment = (new EnvironmentConverter(this.getClassLoader())).convertEnvironmentIfNecessary((ConfigurableEnvironment)environment, this.deduceEnvironmentClass());
    }

    ConfigurationPropertySources.attach((Environment)environment);
    return (ConfigurableEnvironment)environment;
}
```  
##### 10、准备应用上下文  

```java
this.prepareContext(context, environment, listeners, applicationArguments, printedBanner);
```
&emsp; this.prepareContext()源码：  

```java
private void prepareContext(ConfigurableApplicationContext context, ConfigurableEnvironment environment, SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments, Banner printedBanner) {
    //绑定环境到上下文
    context.setEnvironment(environment);
    //配置上下文的 bean 生成器及资源加载器
    this.postProcessApplicationContext(context);
    //为上下文应用所有初始化器
    this.applyInitializers(context);
    //触发所有 SpringApplicationRunListener 监听器的 contextPrepared 事件方法
    listeners.contextPrepared(context);
    //记录启动日志
    if (this.logStartupInfo) {
        this.logStartupInfo(context.getParent() == null);
        this.logStartupProfileInfo(context);
    }
    //注册两个特殊的单例bean
    ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();
    beanFactory.registerSingleton("springApplicationArguments", applicationArguments);
    if (printedBanner != null) {
        beanFactory.registerSingleton("springBootBanner", printedBanner);
    }

    if (beanFactory instanceof DefaultListableBeanFactory) {
        ((DefaultListableBeanFactory)beanFactory).setAllowBeanDefinitionOverriding(this.allowBeanDefinitionOverriding);
    }

    if (this.lazyInitialization) {
        context.addBeanFactoryPostProcessor(new LazyInitializationBeanFactoryPostProcessor());
    }
    //加载所有资源
    Set<Object> sources = this.getAllSources();
    Assert.notEmpty(sources, "Sources must not be empty");
    this.load(context, sources.toArray(new Object[0]));
    //触发所有 SpringApplicationRunListener 监听器的 contextLoaded 事件方法
    listeners.contextLoaded(context);
}
```  
#### 总结：  
&emsp; run() 阶段主要是回调4个监听器(ApplicationContextInitializer、ApplicationRunner、CommandLineRunner、SpringApplicationRunListener)中的方法与加载项目中组件到 IOC 容器中，而所有需要回调的监听器都是从类路径下的 META/INF/Spring.factories 中获取，从而达到启动前后的各种定制操作。  
