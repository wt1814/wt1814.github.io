---
title: 行为型设计模式
date: 2020-01-30 00:00:00
tags:
    - 设计模式
---


# 策略（Strategy）模式  
&emsp; 策略模式，它是将定义的算法家族分别封装起来，让它们之间可以互相替换，从而让算法的变化不会影响到使用算法的用户。  
&emsp; 策略模式使用的是面向对象的继承和多态机制，从而实现同一行为在不同场景下具备不同实现。 

&emsp; ***使用场景：***   
&emsp; 策略模式可以解决在有多种算法相似的情况下，使用if...else或switch...case所带来的复杂性和臃肿性。在日常业务开发中，策略模式适用以下场景：  
1. 针对同一类型问题，有多种处理方式，每一种都能独立解决问题；  
2. 算法需要自由切换的场景；  
3. 需要屏蔽算法规则的场景。  

&emsp; 注意事项：如果一个系统的策略多于四个，就需要考虑使用混合模式，解决策略类膨胀的问题。  

&emsp; ***策略模式在框架中的使用：JDK中比较器Comparator 接口、Spring的Resource 类、Spring 的初始化也采用了策略模式，不同的类型的类采用不 同的初始化策略。***  

&emsp; ***策略模式的优点：***  
1. 策略模式符合开闭原则。  
2. 避免使用多重条件转移语句，如if...else...语句、switch语句。  
3. 使用策略模式可以提高算法的保密性和安全性。  

&emsp; ***策略模式的缺点：***  
1. 客户端必须知道所有的策略，并且自行决定使用哪一个策略类。  
2. 代码中会产生非常多策略类，增加维护难度。  

&emsp; ***模式角色组成：***  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/design/design-14.png)  

* Strategy：抽象策略类，定义所有支持的算法的公共接口。     
* ConcreteStrategy：具体策略类，包装了相关的算法或行为。  
* Context：环境类，用一个ConcreteStrategy对象来配置。维护一个对Strategy对象的引用。可定义一个接口来让Strategy访问它的数据。  

# 模板方法（Template Method）模式  
&emsp; 模板方法模式定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。  
&emsp; 模版方法模式实际上是封装了一个固定流程，该流程由几个步骤组成，具体步骤可以由子类进行不同实现，从而让固定的流程产生不同的结果。它非常简单，其实就是类的继承机制，但它却是一个应用非常广泛但模式。模版方法模式的本质是抽象封装流程，具体进行实现。  

&emsp; ***使用场景：***  
1. 一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现。  
2. 各子类中公共的行为被提取出来并集中到一个公共的父类中，从而避免代码重复。  

&emsp; ***模版方法模式的优点：***  
1. 利用模板方法将相同处理逻辑的代码放到抽象父类中，可以提高代码的复用性。 
2. 将不同的代码不同的子类中，通过对子类的扩展增加新的行为，提高代码的扩展性。 
3. 把不变的行为写在父类上，去除子类的重复代码，提供了一个很好的代码复用平台， 符合开闭原则。 

&emsp; ***模版方法模式的缺点：***  
1. 类数目的增加，每一个抽象类都需要一个子类来实现，这样导致类的个数增加。 
2. 类数量的增加，间接地增加了系统实现的复杂度。 
3. 继承关系自身缺点，如果父类添加新的抽象方法，所有子类都要改一遍。


&emsp; ***模式角色组成：***  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/design/design-15.png)  

* Abstract：抽象模板角色，定义并实现了一个模板方法。这个模板方法一般是一个具体方法，它给出了一个顶级逻辑的骨架，而逻辑的组成步骤在相应的抽象操作中，推迟到子类实现。顶级逻辑也有可能调用一些具体方法。  

        模板方法中的方法可以分为两大类：模板方法和基本方法。
        模板方法：一个模板方法是定义在抽象类中的，把基本操作方法组合在一起形成一个总算法或一个总行为的方法。一个抽象类可以有任意多个模板方法，而不限于一个。每一个模板方法都可以调用任意多个具体方法。  
        基本方法：基本方法又可以分为三种：抽象方法(Abstract Method)、具体方法(Concrete Method)和钩子方法(Hook Method)。  
        　　●　抽象方法：一个抽象方法由抽象类声明，由具体子类实现。在Java语言里抽象方法以abstract关键字标示；  
        　　●　具体方法：一个具体方法由抽象类声明并实现，而子类并不实现或置换。  
        　　●　钩子方法：一个钩子方法由抽象类声明并实现，而子类会加以扩展。通常抽象类给出的实现是一个空实现，作为方法的默认实现。  
        　　默认钩子方法：一个钩子方法常常由抽象类给出一个空实现作为此方法的默认实现。这种空的钩子方法叫做“Do Nothing Hook”。显然，这种默认钩子方法在缺省适配模式里面已经见过了，一个缺省适配模式讲的是一个类为一个接口提供一个默认的空实现，从而使得缺省适配类的子类不必像实现接口那样必须给出所有方法的实现，因为通常一个具体类并不需要所有的方法。  
        　　命名规则：钩子方法的名字应当以do开始。  

* Concrete：每一个抽象模板角色都可以有任意多个具体模板角色与之对应，而每一个具体模板角色都可以给出这些抽象方法（也就是顶级逻辑的组成步骤）的不同实现，从而使得顶级逻辑的实现各不相同。  
 
# 观察者（Observer）模式  


# 职责链（Chain of Responsibility）模式  



# 命令（Command）模式  
......

# 备忘录（Memento）模式  
......

# 状态（State）模式  
......

# 中介者（Mediator）模式  
......

# 访问者（Visitor）模式  
......

# 解释器（Interpreter）模式  
......

# 迭代器（Iterator）模式  
......

