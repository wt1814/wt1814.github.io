---
title: 结构型设计模式
date: 2020-01-29 00:00:00
tags:
    - 设计模式
---

<!-- TOC -->

- [1. 动态代理（Proxy）模式](#1-动态代理proxy模式)
- [2. 装饰（Decorator）模式](#2-装饰decorator模式)
    - [2.1. 在JDK中的应用，IO流](#21-在jdk中的应用io流)
- [3. 适配器（Adapter）模式](#3-适配器adapter模式)
- [4. 门面（Facade）模式](#4-门面facade模式)
- [5. 桥接（Bridge）模式](#5-桥接bridge模式)
- [6. 享元（Flyweight）模式](#6-享元flyweight模式)
- [7. 组合（Composite）模式](#7-组合composite模式)

<!-- /TOC -->

# 1. 动态代理（Proxy）模式  
&emsp; 请查看[动态代理](6.proxy.md)

# 2. 装饰（Decorator）模式  
&emsp; 装饰者模式（Decorator Pattern）是指在不改变原有对象的基础之上，将功能附加到对象上，提供了比继承更有弹性的替代方案（扩展原有对象的功能）。  
&emsp; <font color = "red">装饰器模式的核心是功能拓展。使用装饰器模式可以透明且动态地扩展类的功能。</font>  

&emsp; ***使用场景：***  
1. 用于扩展一个类的功能或给一个类添加附加职责。
2. 动态的给一个对象添加功能，这些功能可以再动态的撤销。
3. 需要为一批的兄弟类进行改装或添加功能。  

&emsp; ***优点：***  
1. 装饰器是继承的有力补充，比继承灵活，不改变原有对象的情况下动态地给一个对象扩展功能，即插即用。  
2. 通过使用不同装饰类以及这些装饰类的排列组合，可以实现不同效果。  
3. 装饰器完全遵守开闭规则。  

&emsp; ***缺点：***  
1. 会出现更多的代码，更多的类，增加程序复杂性。  
2. 动态装饰时，多层装饰时会更复杂。  

&emsp; ***模式角色组成：***  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/design/design-11.png)  

* Component，抽象构件角色，是一个abstract class，组件对象的接口，可以给这些对象动态的添加职责。  
* ConcreteComponent，具体的处理类，用于实现operation方法。具体的组件对象，实现了组件接口。该对象通常就是被装饰器装饰的原始对象，可以给这个对象添加职责。  
* Decorator，所有装饰器的父类，是一个abstract class，需要定义一个与组件接口一致的接口(主要是为了实现装饰器功能的复用，即具体的装饰器A可以装饰另外一个具体的装饰器B，因为装饰器类也是一个Component)，并持有一个Component对象，该对象其实就是被装饰的对象。如果不继承组件接口类，则只能为某个组件添加单一的功能，即装饰器对象不能在装饰其他的装饰器对象。  
* ConcreteDecorator，具体的装饰器类，实现具体要向被装饰对象添加的功能。用来装饰具体的组件对象或者另外一个具体的装饰器对象。  

## 2.1. 在JDK中的应用，IO流  
&emsp; java IO流是典型的装饰器模式。  
&emsp; FilterInputStream，FilterOutputStream，FilterRead，FilterWriter分别为具体装饰器的父类，相当于Decorator类，它们分别实现了InputStream，OutputStream，Reader，Writer类(这些类相当于Component，是其他组件类的父类，也是Decorator类的父类)。继承自InputStream，OutputStream，Reader，Writer这四个类的其他类是具体的组件类，每个都有相应的功能，相当于ConcreteComponent类。而继承自FilterInputStream，FilterOutputStream，FilterRead，FilterWriter这四个类的其他类就是具体的装饰器对象类，即ConcreteDecorator类。通过这些装饰器类，可以提供更加具体的有用的功能。如FileInputStream是InputStream的一个子类，从文件中读取数据流，BufferedInputStream是继承自FilterInputStream的具体的装饰器类，该类提供一个内存的缓冲区类保存输入流中的数据。使用如下的代码来使用BufferedInputStream装饰FileInputStream，就可以提供一个内存缓冲区来保存从文件中读取的输入流。  

# 3. 适配器（Adapter）模式  

&emsp; 适配器模式（Adapter Pattern），将一个类的接口转换成客户端期望的另一种接口，从而使原本因接口不匹配而导致无法在一起工作的两个类能够一起工作。  

&emsp; ***使用场景：***  
1. 已经存在的类，它的方法和需求不匹配（方法结果相同或相似）的情况。  	
2. 适配器模式不是软件设计阶段考虑的设计模式，是随着软件维护，由于不同产品、不同厂家造成功能类似而接口不相同情况下的解决方案。  

&emsp; ***优点：***   
1. 能提高类的透明性和复用，现有的类复用但不需要改变。   
2. 目标类和适配器类解耦，提高程序的扩展性。   
3. 在很多业务场景中符合开闭原则。  
   	
&emsp; ***缺点：***   
1. 适配器编写过程需要全面考虑，可能会增加系统的复杂性。   
2. 增加代码阅读难度，降低代码可读性，过多使用适配器会使系统代码变得凌乱。  

&emsp; ***模式角色组成：***  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/design/design-13.png)  

* Target，目标接口，即期望转换成的接口。  
* Adaptee，现有类，源角色，它是已经存在的，运行良好的类或对象，经过适配器角色的包装，转换成目标接口。  
* Adapter，适配器类，即实现目标接口Target，又继承Adaptee类。适配器模式的核心角色，其他两个角色都是已经存在的角色，而适配器角色是需要新建立的，它的职责非常简单：把源角色转换为目标角色。转换的方式有：通过继承或者类关联的方式。  

&emsp; ***适配器模式有3种形式：类适配器、对象适配器、接口适配器。***  

# 4. 门面（Facade）模式  
&emsp; 门面模式(Facade Pattern)又叫外观模式，提供了一个统一的接口，用来访问子系统中的一群接口。其主要特征是定义一个高层接口，让子系统更容易使用。  
&emsp; 在日常编码工作中，有意无意地大量使用门面模式，但凡只要高层模块需要调度多个子系统（2个以上类对象），都会自觉地创建一个新类封装这些子系统，提供精简接口，让高层模块可以更加容易间接调用这些子系统地功能。尤其是现阶段各种第三方SDK，各种开源类库，很大概率都会使用门面模式。  

&emsp; ***使用场景：***  
1. 子系统越来越复杂，增加门面模式提供简单接口。  
2. 构建多层系统结构，利用门面对象作为每层的入口，简化层间调用。  

&emsp; ***优点：***
1. 简化了调用过程，无需深入了解子系统，以防给子系统带来风险。
2. 减少系统依赖、松散耦合。
3. 更好地划分访问层次，提高了安全性。
4. 遵循迪米特法则，即最少知道原则。

&emsp; ***缺点：***
1. 当增加子系统和扩展子系统行为时，可能容易带来未知风险。  
2. 不符合开闭原则。  
3. 某些情况下可能违背单一职责原则。  

&emsp; ***模式角色组成：***  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/design/design-12.png)  

* Facade门面角色：外观模式的核心。它被客户角色调用，它熟悉子系统的功能。门面角色内部根据客户角色的需求预定了几种功能的组合。一般情况下，门面角色会将所有从客户端发来的请求委派到相应的子系统去，也就说该角色没有实际的业务逻辑，只是一个委托类。  
* subsystem子系统角色:实现了子系统的功能。  
* 客户角色：通过调用Facede来完成要实现的功能。  



# 5. 桥接（Bridge）模式  
......

# 6. 享元（Flyweight）模式  
......


# 7. 组合（Composite）模式  
......

