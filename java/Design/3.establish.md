---
title: 创建型设计模式
date: 2020-01-28 00:00:00
tags:
    - 设计模式
---
<!-- TOC -->

- [1. 单例模式](#1-单例模式)
    - [1.1. 设计安全的单例模式](#11-设计安全的单例模式)
        - [1.1.1. 懒汉式单例](#111-懒汉式单例)
        - [1.1.2. 双重校验锁的形式](#112-双重校验锁的形式)
        - [1.1.3. 枚举方法](#113-枚举方法)
- [2. 工厂方法模式](#2-工厂方法模式)
- [3. 抽象工厂模式](#3-抽象工厂模式)
- [4. 建造者模式](#4-建造者模式)
- [5. 原型模式](#5-原型模式)

<!-- /TOC -->

# 1. 单例模式  
&emsp; ***定义：*** 单例模式（Singleton)，保证一个类仅有一个实例，并提供一个访问它的全局访问点，并且自行实例化向整个系统提供。  
&emsp; ***适用场景：*** 一些资源管理器常常设计成单例模式。  
1. 需要管理的资源包括软件外部资源。例如每台计算机可以有若干个打印机。  
2. 需要管理的资源包括软件内部资源。例如大多数的软件都有一个属性（properties）文件存放系统配置，这样的系统应当由一个对象来管理一个属性文件。软件内部资源也包括例如负责记录网站来访人数的部件，记录软件系统内部事件、出错信息的部件，或是对系统的表现进行检查的部件等。这些部件都必须集中管理。  

&emsp; ***模式角色组成：***  
&emsp; 从具体实现角度来说，就是以下三点：  
1. 单例模式的类定义中含有一个该类的静态私有对象（在本类中建一个实例）；  
2. 单例模式的类只提供私有的构造函数，外界无法通过构造器来创建对象。  
3. 单例模式的类提供了一个静态的公有的函数用于创建或获取它本身的静态私有对象（在类初始化时，已经自行实例化）

## 1.1. 设计安全的单例模式  

### 1.1.1. 懒汉式单例  

```
public class Singleton {
    private static Singleton singleton=null;// 未初始化
    private Singleton(){

    }
    public static synchronized Singleton getSingleton() {
        if (singleton == null){
            singleton=new Singleton();
        }
        return singleton;
    }
}
```
&emsp; 懒汉式也是通过一个类的静态变量实现的。但是并没有直接初始化。而是在函数getInstance()中实例化的，也就是每次想用这个实例的时候初始化的；如果已经初始化了，那么就不用初始化了。  
&emsp; 但是懒汉式，其实也有一个小缺点，就是第一次使用的时候，需要进行初始化操作，可能会有比较高的耗时。如果是已知某一个对象一定会使用到的话，其实可以采用一种饿汉的实现方式。  


### 1.1.2. 双重校验锁的形式   

```
public class Singleton{
    private static volatile Singleton instance=null;
    private Singleton(){
        //do something
    }
    public static  Singleton getInstance(){
        if(instance==null){
            synchronized(Singleton.class){
                if(instance==null){
                    instance=new Singleton();
                }
            }
        }
        return instance;
    }
}
```
&emsp; 只有在singleton == null的情况下再进行加锁创建对象，如果singleton!=null的话，就直接返回就行了，并没有进行并发控制。大大的提升了效率。  
&emsp; 从上面的代码中可以看到，其实整个过程中进行了两次singleton == null的判断，所以这种方法被称之为"双重校验锁"。  
&emsp; 还有值得注意的是，双重校验锁的实现方式中，静态成员变量singleton必须通过volatile来修饰，保证其初始化不被重排，否则可能被引用到一个未初始化完成的对象。  

### 1.1.3. 枚举方法  
&emsp; Java中的枚举单例模式是使用枚举在Java中实现单例模式。解决了以下三个问题：(1)自由串行化。(2)保证只有一个实例。(3)线程安全。  

```
public enum Singleton {
    INSTANCE;
    public void otherMethods() {
    }
}
```
&emsp; 如果想调用它的方法时，仅需要以下操作：  

```
public class Hello {
    public static void main(String[] args){
        SingletonDemo.INSTANCE.otherMethods();
    }
}
```

# 2. 工厂方法模式  
&emsp; ***定义：*** 工厂方法模式，定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。  
&emsp; ***适用场景：***  
&emsp; 首先，工厂方法模式是new一个对象的替代品，所以在所有需要生成对象的地方都可以使用，但是需要慎重地考虑是否要增加一个工厂类进行管理，增加代码的复杂度。复杂对象适合使用工厂模式，而简单对象，特别是只需要通过new就可以完成创建的对象，无需使用工厂模式。  
&emsp; 其次，需要灵活的、可扩展的框架时，可以考虑采用工厂方法模式。（万物皆对象，那万物也就皆产品类，例如需要设计一个连接邮件服务器的框架，有三种网络协议可供选择：POP3、IMAP、HTTP，可以把这三种连接方法作为产品类，定义一个接口如IConnectMail，然后定义对邮件的操作方法，用不同的方法实现三个具体的产品类（也就是连接方式）再定义一个工厂方法，按照不同的传入条件，选择不同的连接方式。）
&emsp; ***模式角色组成：***  
* AbstractFactory，抽象工厂角色，这是工厂方法模式的核心。  
* ConcreateFactory1，具体工厂角色，它含有和具体业务逻辑有关的代码。由应用程序调用以创建对应的具体产品的对象。   
* Product，抽象产品角色。  
* ConcreateProduct1，具体产品角色，具体工厂角色所创建的对象就是此角色的实例。  

# 3. 抽象工厂模式  
&emsp; ***定义：*** 为创建一组相关或相互依赖的对象提供一个接口，而且无须指定它们的具体类。  
&emsp; ***适用场景：***  简单工厂、工厂方法都是单产品系。抽象工厂是多产品系（产品家族）。  
抽象工厂中包含一系列的去构造一个抽象产品的方法，而具体产品的实现则是放在了具体工厂中进行。  
一个对象族（或是一组没有任何关系的对象）都有相同的约束，则可以使用抽象工厂模式。  
&emsp; ***模式角色组成：***  

* AbstractFactory，提供创建对象的接口。  
* ConcreteFactory，提供真正创建对象的实现类，组合并创建不同的对象，实现一个产品族。  
* AbstractProduct，提供对象的使用接口。  
* ConcreteProduct，提供真正的适用对象，隐藏该对象的创建过程，是工厂创建的对象。  
* Client，使用者，通过抽象工厂接口，使用不同的具体工厂方法创建对象组合，从而直接使用对象，无需关注对象的创建过程。  


# 4. 建造者模式  



# 5. 原型模式  


