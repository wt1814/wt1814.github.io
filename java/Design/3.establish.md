---
title: 创建型设计模式
date: 2020-01-28 00:00:00
tags:
    - 设计模式
---
<!-- TOC -->

- [1. 单例模式](#1-单例模式)
    - [1.1. 设计安全的单例模式](#11-设计安全的单例模式)
        - [1.1.1. 懒汉式单例](#111-懒汉式单例)
        - [1.1.2. 双重校验锁的形式](#112-双重校验锁的形式)
        - [静态内部类法](#静态内部类法)
        - [1.1.3. 枚举方法](#113-枚举方法)
- [2. 工厂方法模式](#2-工厂方法模式)
- [3. 抽象工厂模式](#3-抽象工厂模式)
- [4. 建造者模式](#4-建造者模式)
- [5. 原型模式](#5-原型模式)

<!-- /TOC -->

# 1. 单例模式  
&emsp; ***定义：*** 单例模式（Singleton)，保证一个类仅有一个实例，并提供一个访问它的全局访问点，并且自行实例化向整个系统提供。  
&emsp; 单例模式减少了内存开销；可以避免对资源的多重占用。  
&emsp; ***适用场景：*** 一些资源管理器常常设计成单例模式。  
1. 需要管理的资源包括软件外部资源。例如每台计算机可以有若干个打印机。  
2. 需要管理的资源包括软件内部资源。例如大多数的软件都有一个属性（properties）文件存放系统配置，这样的系统应当由一个对象来管理一个属性文件。软件内部资源也包括例如负责记录网站来访人数的部件，记录软件系统内部事件、出错信息的部件，或是对系统的表现进行检查的部件等。这些部件都必须集中管理。  

&emsp; ***模式角色组成：***  
&emsp; 从具体实现角度来说，就是以下三点：  
1. 单例模式的类定义中含有一个该类的静态私有对象（在本类中建一个实例）；  
2. 单例模式的类只提供私有的构造函数，外界无法通过构造器来创建对象。  
3. 单例模式的类提供了一个静态的公有的函数用于创建或获取它本身的静态私有对象（在类初始化时，已经自行实例化）

## 1.1. 设计安全的单例模式  

### 1.1.1. 懒汉式单例  

```
//懒汉式单例
//在外部需要使用的时候才进行实例化
public class LazySimpleSingleton {
    private LazySimpleSingleton(){}
    //静态块， 公共内存区域
    private static LazySimpleSingleton lazy = null;
    public static LazySimpleSingleton getInstance(){
        if(lazy == null){
            lazy = new LazySimpleSingleton();
        } r
        eturn lazy;
    }
}
```
&emsp; 懒汉式也是通过一个类的静态变量实现的。但是并没有直接初始化。而是在函数getInstance()中实例化的，也就是每次想用这个实例的时候初始化的；如果已经初始化了，那么就不用初始化了。  
&emsp; 但是懒汉式，其实也有一个小缺点，就是第一次使用的时候，需要进行初始化操作，可能会有比较高的耗时。如果是已知某一个对象一定会使用到的话，其实可以采用一种饿汉的实现方式。  


### 1.1.2. 双重校验锁的形式   

```
public class LazyDoubleCheckSingleton {
    private volatile static LazyDoubleCheckSingleton lazy = null;
    private LazyDoubleCheckSingleton(){}
    public static LazyDoubleCheckSingleton getInstance(){
        if(lazy == null){
            synchronized (LazyDoubleCheckSingleton.class){
                if(lazy == null){
                    lazy = new LazyDoubleCheckSingleton();
                    //1.分配内存给这个对象
                    //2.初始化对象
                    //3.设置 lazy 指向刚分配的内存地址
                }
            }
        } r
        eturn lazy;
    }
}
```
&emsp; 只有在singleton == null的情况下再进行加锁创建对象，如果singleton!=null的话，就直接返回就行了，并没有进行并发控制。大大的提升了效率。  
&emsp; 从上面的代码中可以看到，其实整个过程中进行了两次singleton == null的判断，所以这种方法被称之为"双重校验锁"。  
&emsp; 还有值得注意的是，双重校验锁的实现方式中，静态成员变量singleton必须通过volatile来修饰，保证其初始化不被重排，否则可能被引用到一个未初始化完成的对象。  

### 静态内部类法  

```
//这种形式兼顾饿汉式的内存浪费， 也兼顾 synchronized 性能问题
//完美地屏蔽了这两个缺点
public class LazyInnerClassSingleton {
    //默认使用 LazyInnerClassGeneral 的时候， 会先初始化内部类
    //如果没使用的话， 内部类是不加载的
    private LazyInnerClassSingleton(){

    }
    //每一个关键字都不是多余的
    //static 是为了使单例的空间共享
    //保证这个方法不会被重写， 重载
    public static final LazyInnerClassSingleton getInstance(){
    //在返回结果以前， 一定会先加载内部类
        return LazyHolder.LAZY;
    }  
    //默认不加载
    private static class LazyHolder{
        private static final LazyInnerClassSingleton LAZY = new LazyInnerClassSingleton();
    }
}
```  
&emsp; 使用内部类的好处是，静态内部类不会在单例加载时就加载，而是在调用getInstance()方法时才进行加载，达到了类似懒汉模式的效果，而这种方法又是线程安全的。  

### 1.1.3. 枚举方法  
&emsp; Java中的枚举单例模式是使用枚举在Java中实现单例模式。解决了以下三个问题：(1)自由串行化。(2)保证只有一个实例。(3)线程安全。  

```
public enum EnumSingleton {
    INSTANCE;
    private Object data;
    public Object getData() {
        return data;
    } 
    public void setData(Object data) {
        this.data = data;
    } 
    public static EnumSingleton getInstance(){
        return INSTANCE;
    }
}
```
&emsp; 如果想调用它的方法时，仅需要以下操作：  

```
public class test {
    public static void main(String[] args){
        EnumSingleton.INSTANCE.getInstance();
    }
}
```

# 2. 工厂方法模式  
&emsp; ***定义：*** 工厂方法模式，定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。  
&emsp; ***适用场景：***  
1. 创建对象需要大量重复的代码。
2. 客户端（应用层）不依赖于产品类实例如何被创建、实现等细节。
3. 一个类通过其子类来指定创建哪个对象。

&emsp; ***工厂方法的缺点：***  
1. 类的个数容易过多，增加复杂度。
2. 增加了系统的抽象性和理解难度。

&emsp; ***模式角色组成：***  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/design/design-4.png)  

* AbstractFactory，抽象工厂角色，这是工厂方法模式的核心。  
* ConcreateFactory1，具体工厂角色，它含有和具体业务逻辑有关的代码。由应用程序调用以创建对应的具体产品的对象。   
* Product，抽象产品角色。  
* ConcreateProduct1，具体产品角色，具体工厂角色所创建的对象就是此角色的实例。  

# 3. 抽象工厂模式  
&emsp; ***定义：*** 为创建一组相关或相互依赖的对象提供一个接口，而且无须指定它们的具体类。客户端（应用层）不依赖于产品类实例如何被创建、实现等细节，强调的是一系列相关的产品对象（属于同一产品族）一起使用创建对象需要大量重复的代码。需要提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。  

&emsp; 详细讲解两个概念：***产品等级结构和产品族。***  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/design/design-5.png)  
&emsp; 从上图中看出有正方形，圆形和菱形三种图形，相同颜色深浅的就代表同一个产品族，相同形状的代表同一个产品等级结构。  

&emsp; 同样可以从生活中来举例，比如，美的电器生产多种家用电器。那么上图中，颜色最深的正方形就代表美的洗衣机、颜色最深的圆形代表美的空调、颜色最深的菱形代表美的热水器，颜色最深的一排都属于美的品牌，都是美的电器这个产品族。再看最右侧的菱形，颜色最深的我们指定了代表美的热水器，那么第二排颜色稍微浅一点的菱形，代表海信的热水器。同理，同一产品结构下还有格力热水器，格力空调，格力洗衣机。  
&emsp; 再看下面的这张图，最左侧的小房子就认为具体的工厂，有美的工厂，有海信工厂，有格力工厂。每个品牌的工厂都生产洗衣机、热水器和空调。  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/design/design-6.png)  

&emsp; ***抽象工厂的缺点：***  
1. 规定了所有可能被创建的产品集合，产品族中扩展新的产品困难，需要修改抽象工厂的接口。
2. 增加了系统的抽象性和理解难度。

&emsp; ***模式角色组成：***  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/design/design-7.png)  

* AbstractFactory，提供创建对象的接口。  
* ConcreteFactory，提供真正创建对象的实现类，组合并创建不同的对象，实现一个产品族。  
* AbstractProduct，提供对象的使用接口。  
* ConcreteProduct，提供真正的适用对象，隐藏该对象的创建过程，是工厂创建的对象。  
* Client，使用者，通过抽象工厂接口，使用不同的具体工厂方法创建对象组合，从而直接使用对象，无需关注对象的创建过程。  


# 4. 建造者模式  



# 5. 原型模式  


