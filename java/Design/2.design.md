---
title: 设计模式
date: 2020-01-27 00:00:00
tags:
    - 设计模式
---

&emsp; 常用设计模式有23种（不包含简单工厂模式）。这23种设计模式的本质是面向对象设计原则的实际运用，是对类的封装性、继承性和多态性，以及类的关联关系和组合关系的充分理解。  

# 如何判断那里需要使用设计模式  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/design/design-1.png)  
&emsp; 在编码实现中，有一些代码是一次写好后续基本不会改变的，或者不太需要扩展的，比如一些工具类等。有一部分是会经常变得，设计模式大多都应用在需求会变化的这一部分。分析这些代码会如何变，选择合适的设计模式来优化这部分代码。  

# 分类：  
&emsp; 设计模式有两种分类方法，即根据模式的目的来分和根据模式的作用范围来分。  

## 根据目的来分  
&emsp; 根据模式是用来完成什么工作来划分，这种方式可分为创建型模式、结构型模式和行为型模式3种。  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/design/design-2.png)  
* 创建型模式，共5种：  
&emsp; 创建型模式的主要关注点是“怎样创建对象？”，它的主要特点是“将对象的创建与使用分离”。这样可以降低系统的耦合度，使用者不需要关注对象的创建细节，对象的创建由相关的工厂来完成。  

&emsp; 创建型模式分为以下5种：  
&emsp; 单例（Singleton）模式：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。
&emsp; 工厂方法（FactoryMethod）模式：定义一个用于创建产品的接口，由子类决定生产什么产品。
&emsp; 抽象工厂（AbstractFactory）模式：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。
&emsp; 建造者（Builder）模式：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。
&emsp; 原型（Prototype）模式：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。  

* 结构型模式，共7种：  
&emsp; 结构型模式描述如何将类或对象按某种布局组成更大的结构。  

结构型模式分为以下7种：
代理（Proxy）模式：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。
适配器（Adapter）模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。
桥接（Bridge）模式：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现的，从而降低了抽象和实现这两个可变维度的耦合度。
装饰（Decorator）模式：动态地给对象增加一些职责，即增加其额外的功能。
外观（Facade）模式：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。
享元（Flyweight）模式：运用共享技术来有效地支持大量细粒度对象的复用。
组合（Composite）模式：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。  










