---
title: Collection源码
date: 2020-02-19 00:00:00
tags:
    - JDK
---
## List  
### ArrayList  
&emsp; ArrayList可以简单的认为是一个动态数组；实际上ArrayList就是用数组实现的，长度不够时，调用Arrays.copyOf方法，拷贝当前数组到一个新的长度更大的数组；  
&emsp; ArrayList特点：随机访问速度快，插入和移除性能较差(数组的特点)；支持null元素；有顺序；元素可以重复；线程不安全；  
#### ArrayList 类定义  

```java
public class ArrayList<E> extends AbstractList<E> implements List<E>, RandomAccess, Cloneable, java.io.Serializable
```
&emsp; 注：AbstractList.java  
```java
/*
   modCount 成员变量，来记录修改次数，主要是在使用迭代器遍历的时候，用来检查列表中的元素是否发生结构性变化（列表元素数量发生改变）了，主要在多线程环境下需要使用，防止一个线程正在迭代遍历，另一个线程修改了这个列表的结构。否则抛出ConcurrentModificationException。
*/
protected transient int modCount = 0;
```


#### 字段属性  

```java
//初始化容量，默认为 10
private static final int DEFAULT_CAPACITY = 10;
//空的数组实例
private static final Object[] EMPTY_ELEMENTDATA = {};
//这也是一个空的数组实例，和EMPTY_ELEMENTDATA空数组相比是用于了解添加元素时数组膨胀多少
private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};
//存储 ArrayList集合的元素，集合的长度即这个数组的长度
//1、当 elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA 时将会清空 ArrayList
//2、当添加第一个元素时，elementData 长度会扩展为 DEFAULT_CAPACITY=10
transient Object[] elementData;
//表示集合的长度
private int size;
```  
#### 构造函数  

```java
/**
 * 创建一个 DEFAULTCAPACITY_EMPTY_ELEMENTDATA 声明的数组，注意此时初始容量是0，而不是10。
 */
public ArrayList() { }
/**
 * 使用默认容量构造一个数组
 * @throws IllegalArgumentException 如果初始化容量initialCapacity是一个负数，则会抛出这个IllegalArgumentException异常
 */
public ArrayList(int initialCapacity) { }
/**
 * 构造包含指定的元素的列表集合，按照顺序返回这个集合的迭代器。将已有的集合复制到 ArrayList 集合中去。
 * @throws NullPointerException 如果传入的Collection为null，则会抛出NullPointerException空指针异常
 */
public ArrayList(Collection<? extends E> c) { }
```
#### 成员函数（增、删、改、查）  
##### 增加，add(E e)  

```java
/**
 * 将指定元素追加到列表末尾。所以ArrayList是有序的，也就是元素的存储顺序和添加顺序是一致的。
 */
public boolean add(E e) {
    ensureCapacityInternal(size + 1);  //确保内部的容量
    elementData[size++] = e;//在list末尾追加元素
    return true;
}

/**
 * 在list的指定索引处插入指定元素
 */
public void add(int index, E element) {
    //检查索引是否越界
    rangeCheckForAdd(index);
    //确保内部的容量
    ensureCapacityInternal(size + 1);  // Increments modCount!!
    System.arraycopy(elementData, index, elementData, index + 1, size - index);
    elementData[index] = element;
    size++;
}
```  
&emsp; 对于ArrayList集合添加元素：
1. 当通过ArrayList()构造一个空集合，初始长度是为0的，第1次添加元素，会创建一个长度为10的数组，并将该元素赋值到数组的第一个位置。  
2. 第2次添加元素，集合不为空，而且由于集合的长度size+1是小于数组的长度10，所以直接添加元素到数组的第二个位置，不用扩容。  
3. 第11次添加元素，此时size+1 = 11，而数组长度是10，这时候创建一个长度为10+10*0.5 = 15 的数组（扩容1.5倍），然后将原数组元素引用拷贝到新数组。并将第11次添加的元素赋值到新数组下标为10的位置。  
4. 第Integer.MAX_VALUE - 8 = 2147483639，然后 2147483639%1.5=1431655759（这个数是要进行扩容）次添加元素，为了防止溢出，此时会直接创建一个1431655759+1大小的数组，这样一直，每次添加一个元素，都只扩大一个范围。  
5. 第Integer.MAX_VALUE - 7次添加元素时，创建一个大小为 Integer.MAX_VALUE的数组，在进行元素添加。  
6. 第Integer.MAX_VALUE + 1次添加元素时，抛出OutOfMemoryError异常。  
&emsp; 注意：能向集合中添加null的，因为数组可以有null值存在。  

##### 删除，remove(int index)、remove(Object o)  
######  根据索引删除元素  

```java
public E remove(int index) {
    rangeCheck(index);//判断给定索引的范围，超过集合大小则抛出异常

    modCount++;
    E oldValue = elementData(index);//得到索引处的删除元素

    int numMoved = size - index - 1;
    if (numMoved > 0)//size-index-1 > 0 表示 0<= index < (size-1),即索引不是最后一个元素
        //通过 System.arraycopy()将数组elementData 的下标index+1之后长度为 numMoved的元素拷贝到从index开始的位置
        System.arraycopy(elementData, index+1, elementData, index,
                numMoved);
    elementData[--size] = null; //将数组最后一个元素置为 null，便于垃圾回收

    return oldValue;
}
```  
&emsp; remove(int index)方法表示删除索引index处的元素，首先通过 rangeCheck(index)方法判断给定索引的范围，超过集合大小则抛出异常；接着通过System.arraycopy方法对数组进行自身拷贝。

###### 直接删除指定元素  

```java
public boolean remove(Object o) {
    if (o == null) {//如果删除的元素为null
        for (int index = 0; index < size; index++)
            if (elementData[index] == null) {
                fastRemove(index);
                return true;
            }
    } else {//不为null，通过equals方法判断对象是否相等
        for (int index = 0; index < size; index++)
            if (o.equals(elementData[index])) {
                fastRemove(index);
                return true;
            }
    }
    return false;
}
```  
&emsp; remove(Object o)方法是删除第一次出现的该元素。然后通过System.arraycopy进行数组自身拷贝。  
##### 修改，E set(int index, E element)  

查找元素，E get(int index)、int indexOf(Object o)
遍历集合
遍历方式：①、普通 for 循环遍历 ②、迭代器 iterator
③、迭代器的变种forEach ④、迭代器 ListIterator

ArrayList实现了RandomAccess接口（该接口是个标志性接口），表明它具有随机访问的能力。ArrayList底层基于数组实现，所以它可在常数阶的时间内完成随机访问，效率很高。对ArrayList进行遍历时，一般情况下，使用foreach循环遍历，但这并不是推荐的遍历方式。ArrayList具有随机访问的能力，如果在一些效率要求比较高的场景下，更推荐下面这种方式：
for (int i = 0; i < list.size(); i++) {
    list.get(i);
}

关于遍历时删除
不要在foreach循环里进行元素的remove/add 操作。remove元素请使用 Iterator方式，如果并发操作，需要对Iterator对象加锁。
clone方法
/**
 * 返回此ArrayList实例的浅拷贝。(元素本身不会被复制。)
 */
public Object clone() {
    try {
        ArrayList<?> v = (ArrayList<?>) super.clone();
        v.elementData = Arrays.copyOf(elementData, size);
        v.modCount = 0;
        return v;
    } catch (CloneNotSupportedException e) {
        // this shouldn't happen, since we are Cloneable
        throw new InternalError(e);
    }
}

其他方法：
subList()、size()、isEmpty()、rimToSize()
1.2.LinkedList
1.2.1. LinkedList类定义
public class LinkedList<E> extends AbstractSequentialList<E> implements List<E>, Deque<E>, Cloneable, java.io.Serializable
Cloneable实现克隆、Serializable序列化、List定义了一些集合类的方法、Deque双向队列接口(两端都可以进行增加删除操作)。
注意：LinkedList并没有实现RandomAccess，所以随机访问是非常慢的。
1.2.2. 属性
//链表元素（节点）的个数
//transient关键字的作用是保持变量不被序列化
transient int size = 0;
//指向第一个节点的指针
transient Node<E> first;
//指向最后一个节点的指针
transient Node<E> last;
注意：Node类是LinkedList 类中的一个内部类，其中每一个元素就代表一个 Node 类对象，LinkedList集合就是由许多个Node对象链接构成。
private static class Node<E> {
    E item;//实际存储的元素
    Node<E> prev;//指向上一个节点的引用
    Node<E> next;//指向下一个节点的引用

    //构造函数
    Node(Node<E> prev, E element, Node<E> next) {
        this.item = element;
        this.next = next;
        this.prev = prev;
    }
}
如下图所示：

上图的LinkedList是有四个元素，也就是由4个Node对象组成，size=4，head指向第一个elementA，tail指向最后一个节点elementD。
1.2.3. 构造函数
public LinkedList() {
}
public LinkedList(Collection<? extends E> c) {
    this();
    addAll(c);
}
LinkedList有两个构造函数，第一个是默认的空的构造函数，第二个是将已有元素的集合Collection的实例添加到LinkedList中，调用的是addAll()方法。
注意：LinkedList是没有初始化链表大小的构造函数，因为链表不像数组，一个定义好的数组是必须要有确定的大小，然后去分配内存空间，而链表不一样，它没有确定的大小，通过指针的移动来指向下一个内存地址的分配。
1.2.4. 成员方法：
添加元素
1).addFirst(E e)将指定元素添加到链表头

2).addLast(E e)和add(E e)将指定元素添加到链表尾
3).add(int index, E element)将指定的元素插入此列表中的指定位置
4).addAll(Collection<? extends E> c)
按照指定集合的迭代器返回的顺序，将指定集合中的所有元素追加到此列表的末尾。
此方法还有一个addAll(int index, Collection<? extends E> c)，将集合c中所有元素插入到指定索引的位置。
删除元素
1).remove()和removeFirst()从此列表中移除并返回第一个元素
2).removeLast()从该列表中删除并返回最后一个元素
3).remove(int index)删除此列表中指定位置的元素
4).remove(Object o)如果存在，则从该列表中删除指定元素的第一次出现
修改元素
set(int index, E element)方法，用指定的元素替换此列表中指定位置的元素。
public E set(int index, E element) {
    //判断索引 index >= 0 && index <= size中时抛出IndexOutOfBoundsException异常
    checkElementIndex(index);
    Node<E> x = node(index);//获取指定索引处的元素
    E oldVal = x.item;
    x.item = element;//将指定位置的元素替换成要修改的元素
    return oldVal;//返回指定索引位置原来的元素
}
这里主要是通过 node(index) 方法获取指定索引位置的节点，然后修改此节点位置的元素即可。
查找元素
1).getFirst()返回此列表中的第一个元素
2).getLast()返回此列表中的最后一个元素
3).get(int index)返回指定索引处的元素
4).indexOf(Object o)返回此列表中指定元素第一次出现的索引，如果此列表不包含元素，则返回-1。
遍历
1).普通for循环
2).迭代器。迭代器的另一种形式就是使用foreach循环，底层实现也是使用的迭代器。
1.3. Vector


----------------------------------
3.Set
Set接口的实现类，最大特点是不允许出现重复元素；
HashSet：基于HashMap实现，一个性能相对较好的Set；
LinkedHashSet：基于LinkedHashMap实现，一个保存了插入顺序的Set；
TreeSet；基于TreeSet实现，一个实现了排序的Set；
HashSet、LinkedHashSet、TreeSet底层由对应Map的方法来实现。
3.1. ***HashSet
HashSet是一个由HashMap实现的集合。元素无序且不能重复。
HashSet的底层实现是什么? HashSet的实现是依赖于HashMap的，HashSet的值存储在HashMap中。在HashSet的构造法中会初始化一个HashMap对象，HashSet不允许值重复，因此，HashSet的值是作为HashMap的key存储在HashMap中的，当存储的值已经存在时返回false。而HashMap的value则存储了一个PRESENT，它是一个静态的Object对象。

1. HashSet 定义
HashSet是一个由 HashMap 实现的集合。元素无序且不能重复。
public class HashSet<E> extends AbstractSet<E> implements Set<E>, Cloneable, java.io.Serializable

HashSet 也实现了 Cloneable 接口和 Serializable 接口，分别用来支持克隆以及支持序列化。还实现了 Set 接口，该接口定义了 Set 集合类型的一套规范。
2. ***字段属性
//HashSet集合中的内容是通过 HashMap 数据结构来存储的
private transient HashMap<E,Object> map;
//向HashSet中添加数据，数据在上面的 map 结构是作为 key 存在的，而value统一都是 PRESENT
private static final Object PRESENT = new Object();
第一个定义一个 HashMap，作为实现 HashSet 的数据结构；第二个 PRESENT 对象，因为前面讲过 HashMap 是作为键值对 key-value 进行存储的，而 HashSet 不是键值对，那么选择 HashMap 作为实现，其原理就是存储在 HashSet 中的数据 作为 Map 的 key，而 Map 的value 统一为 PRESENT。
3. 构造函数
①、无参构造
public HashSet() {
    map = new HashMap<>();
}
②、指定初始容量
public HashSet(int initialCapacity) {
    map = new HashMap<>(initialCapacity);
}
③、指定初始容量和加载因子
public HashSet(int initialCapacity, float loadFactor) {
    map = new HashMap<>(initialCapacity, loadFactor);
}
④、构造包含指定集合中的元素
public HashSet(Collection<? extends E> c) {
    map = new HashMap<>(Math.max((int) (c.size()/.75f) + 1, 16));
    addAll(c);
}
添加元素
public boolean add(E e) {
    return map.put(e, PRESENT)==null;
}
　　通过 map.put() 方法来添加元素，在上一篇博客介绍该方法时，说明了该方法如果新插入的key不存在，则返回null，如果新插入的key存在，则返回原key对应的value值（注意新插入的value会覆盖原value值）。
　　也就是说 HashSet 的 add(E e) 方法，会将 e 作为 key，PRESENT 作为 value 插入到 map 集合中，如果 e 不存在，则插入成功返回 true;如果存在，则返回false。

***HashSet类是如何实现添加元素保证不重复的---哈希码的原理
HashSet底层是由HashMap实现的。HashMap中hashCode()和equles()方法。


3.2. LinkedHashSet

3.3. TreeSet

----------------------------------
4. Stack，栈

