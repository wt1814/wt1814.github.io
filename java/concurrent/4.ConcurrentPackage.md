---
title: JUC
date: 2020-01-09 00:00:00
tags:
    - 并发编程
---

<!-- TOC -->

- [1. 基础算法、组件](#1-基础算法组件)
    - [1.1. CAS算法](#11-cas算法)
        - [1.1.1. CAS算法思想](#111-cas算法思想)
        - [1.1.2. CAS缺点](#112-cas缺点)
        - [Unsafe类](#unsafe类)
    - [1.2. AQS，抽象队列同步器，基础组件](#12-aqs抽象队列同步器基础组件)
        - [1.2.1. 属性](#121-属性)
            - [1.2.1.1. 同步状态state](#1211-同步状态state)
            - [1.2.1.2. 先进先出FIFO等待队列](#1212-先进先出fifo等待队列)
        - [1.2.2. 成员方法](#122-成员方法)
            - [1.2.2.1. 独占模式](#1221-独占模式)
            - [1.2.2.2. 共享模式](#1222-共享模式)
            - [1.2.2.3. AQS的模板方法设计模式](#1223-aqs的模板方法设计模式)
            - [1.2.2.4. 自定义同步器](#1224-自定义同步器)
- [2. java.util.concurrent.locks包](#2-javautilconcurrentlocks包)
- [3. Atomic，原子类](#3-atomic原子类)
    - [3.1. atomic类简介](#31-atomic类简介)
    - [3.2. atomic使用](#32-atomic使用)
        - [3.2.1. 原子更新基本类型或引用类型](#321-原子更新基本类型或引用类型)
        - [3.2.2. 原子更新数组中的元素](#322-原子更新数组中的元素)
        - [3.2.3. 原子更新对象中的字段](#323-原子更新对象中的字段)
        - [3.2.4. 高性能原子类](#324-高性能原子类)
    - [atomic分析](#atomic分析)
- [4. Collections，14个并发容器](#4-collections14个并发容器)
    - [4.1. CopyOnWrite简介](#41-copyonwrite简介)
    - [4.2. List，CopyOnWriteArrayList](#42-listcopyonwritearraylist)
        - [4.2.1. 源码解析](#421-源码解析)
        - [4.2.2. 示例代码](#422-示例代码)
    - [4.3. Map，ConcurrentHashMap、ConcurrentSkipListMap](#43-mapconcurrenthashmapconcurrentskiplistmap)
        - [4.3.1. ConcurrentHashMap](#431-concurrenthashmap)
        - [4.3.2. ConcurrentSkipListMap](#432-concurrentskiplistmap)
    - [4.4. Set，CopyOnWriteArraySet、ConcurrentSkipListSet](#44-setcopyonwritearraysetconcurrentskiplistset)
    - [4.5. Queue](#45-queue)
- [5. Tools，工具类](#5-tools工具类)
- [6. 15种锁分类](#6-15种锁分类)

<!-- /TOC -->

&emsp; 本文描述java.util.concurrent的API接口文档，相关方法使用的详情参考：http://www.matools.com/api/java8 。JUC包包括5部分：  
* locks：显式锁相关；  
* atomic：原子变量类相关，是构建非阻塞算法的基础；  
* collections：并发容器相关；  
* executor：线程池相关；  
* tools：同步工具相关，如信号量、闭锁、栅栏等功能；  

![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/concurrent/concurrent-1.png)  

# 1. 基础算法、组件  
## 1.1. CAS算法  
&emsp; CAS，Compare And Swap，即比较并交换。一种无锁原子算法，CAS是一种乐观锁。  

### 1.1.1. CAS算法思想  
&emsp; 在函数CAS(V,E,N)中有3个参数，V表示要更新的变量，E预期值，N新值。CAS操作需要提供一个期望值，当期望值与当前线程的变量值相同时，说明还没线程修改该值，当前线程可以进行修改，也就是执行CAS操作；但如果期望值与当前线程不符，则说明该值已被其他线程修改，此时不执行更新操作，但可以选择重新读取该变量再尝试再次修改该变量，也可以放弃操作。  
&emsp; 当多个线程同时使用CAS操作一个变量时，只有一个会胜出，并成功更新，其余均会失败。**失败的线程不会挂起，仅是被告知失败，并且允许再次尝试，当然也允许实现的线程放弃操作（一般情况下，这是一个自旋操作，即不断的重试）**。基于这样的原理，CAS操作即使没有锁，也可以发现其他线程对当前线程的干扰。  

### 1.1.2. CAS缺点  
&emsp; CAS虽然很高效的解决原子操作，但是CAS仍然存在三大问题：ABA问题，循环时间长开销大、只能保证一个共享变量的原子操作。  
* 循环时间长开销大：  
  &emsp; 自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。  
* 只能保证一个共享变量的原子操作：  
  &emsp; 当对一个共享变量执行操作时，可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁，或者有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如有两个共享变量i＝2,j=a，合并一下ij=2a，然后用CAS来操作ij。从Java1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，可以把多个变量放在一个对象里来进行CAS操作。    
* ABA问题（A修改为B，再修改为A）：  
  &emsp; 因为CAS需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。  
  &emsp; ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么A－B－A 就会变成1A-2B－3A。   
  &emsp; ***<font color = "red">从Java1.5开始JDK的atomic包里提供了一个类[AtomicStampedReference](6.AtomicStampedReference.md)来解决ABA问题。</font>***  

### Unsafe类  

    此处只讲解Unsafe类，关于JUC包下的类如何使用Unsafe类，后面分析。

&emsp; CAS并发原语体现在 Java 语言中的 sum.misc.Unsafe 类中的各个方法。调用 Unsafe 类中的 CAS 方法， JVM 会实现出 CAS 汇编指令。这是一种完全依赖于硬件的功能，通过它实现了原子操作。  

    Java无法直接访问底层操作系统，而是通过本地（native）方法来访问。不过尽管如此，JVM还是开了一个后门，JDK中有一个类Unsafe，它提供了硬件级别的原子操作。
    UnSafe 类中的所有方法都是 native 修饰的，也就是说该类中的方法都是直接调用操作系统底层资源执行相应任务。
    这个类尽管里面的方法都是public的，但是并没有办法使用它们，JDK API文档也没有提供任何关于这个类的方法的解释。总而言之，对于Unsafe类的使用都是受限制的，只有授信的代码才能获得该类的实例，当然JDK库里面的类是可以随意使用的。
 
&emsp; Unsafe类的三个方法：  

```
public final native boolean compareAndSwapObject(Object paramObject1, long paramLong, Object paramObject2, Object paramObject3);
public final native boolean compareAndSwapInt(Object paramObject, long paramLong, int paramInt1, int paramInt2);
public final native boolean compareAndSwapLong(Object paramObject, long paramLong1, long paramLong2, long paramLong3);
```

## 1.2. AQS，抽象队列同步器，基础组件  
<!-- 
https://mp.weixin.qq.com/s/sKrqxvi4OBPzAVZh9RbPfw

https://mp.weixin.qq.com/s/48mK_bPVfulJmo-PerCkhQ
https://mp.weixin.qq.com/s?__biz=MzAwNDA2OTM1Ng==&mid=2453141018&idx=1&sn=d9241ddc0a9d253c0a061da3aadc2abf&chksm=8cf2d499bb855d8f7057f0a10eea19be98fbfb2944597a0d58b956853de70849256b33feac20&mpshare=1&scene=1&srcid=&sharer_sharetime=1575175649149&sharer_shareid=b256218ead787d58e0b58614a973d00d&key=2917945cca1d4931e548eff42042001a7b7f1af307a789975fd52b9d2417bae7f902ca4f882c225bec7d5c2237961afcdd258196f50f0e746ca8e8382a0f3b4f6a351fe4d720392a538077347495533b&ascene=1&uin=MTE1MTYxNzY2MQ%3D%3D&devicetype=Windows+10&version=62070158&lang=zh_CN&pass_ticket=De11NSuLeV6nkkbtuWfLx7yZorE9n9qAe694TFI9MguzC071bXHIIrhkcMw8W8eR
-->

&emsp; AQS 是AbstractQueuedSynchronizer 的简称，翻译成中文就是 抽象队列同步器 ，这三个单词分开来看：  

* Abstract （抽象）：也就是说， AQS 是一个抽象类，只实现一些主要的逻辑，有些方法推迟到子类实现
* Queued （队列）：AQS 是用先进先出队列来存储数据的
* Synchronizer （同步）：即 AQS 实现同步功能

&emsp; AQS是JUC并发包中的核心基础组件。它是构建锁或者其他同步组件（如ReentrantLock、ReentrantReadWriteLock、Semaphore等）的基础框架。  
1. 内部实现的关键是：先进先出的队列、state状态  
2. 拥有两种线程模式：独占模式、共享模式。  
    * 独占式：有且只有一个线程能获取到锁，如：ReentrantLock。  
    * 共享式：可以多个线程同时获取到锁，如：Semaphore/CountDownLatch。   

### 1.2.1. 属性  

    AQS核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。 

![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/concurrent/concurrent-2.png)   
&emsp; AQS使用一个int成员变量来表示同步状态，通过内置的FIFO队列来完成获取资源线程的排队工作。AQS使用CAS对该同步状态进行原子操作实现对其值的修改。  
<!-- 
&emsp; AQS维护了一个同步状态（volatile int state）和一个先进先出FIFO等待队列（多线程争用资源被阻塞时会进入此队列）。
-->

#### 1.2.1.1. 同步状态state  

```java
   //AQS使用一个int类型的成员变量state来表示同步状态，是由volatile修饰的。当state>0时表示已经获取了锁，当state = 0时表示释放了锁。
   private volatile int state;
   //获取state值
   protected final int getState() {
       return state;
   }
   //设置state值
   protected final void setState(int newState) {
       state = newState;
   }
   /**使用CAS设置当前状态，该方法能够保证状态设置的原子性；*/
   protected final boolean compareAndSetState(int expect, int update) {
       // See below for intrinsics setup to support this
       return unsafe.compareAndSwapInt(this, stateOffset, expect, update);
   }
```
&emsp; 内部通过一个int类型的成员变量state来控制同步状态，是由volatile修饰的。并且提供了几个访问这个字段的方法：getState()、setState、compareAndSetState。这几个方法都是final修饰的，说明子类中无法重写它们。另外它们都是protected修饰的，说明只能在子类中使用这些方法。  

&emsp; ***怎么通过state控制同步状态？***  
&emsp; 通过修改state字段代表的同步状态来实现多线程的独占模式或者共享模式。例如：当state=0时，则说明没有任何线程占有共享资源的锁，当state=1时，则说明有线程目前正在使用共享变量，其他线程必须加入同步队列进行等待。  
&emsp; 在独占模式下，可以把state的初始值设置成0，每当某个线程要进行某项独占操作前，都需要判断state的值是不是0，如果不是0的话意味着别的线程已经进入该操作，则本线程需要阻塞等待；如果是0的话就把state的值设置成1，自己进入该操作。这个先判断再设置的过程我们可以通过CAS操作保证原子性，把这个过程称为尝试获取同步状态。如果一个线程获取同步状态成功了，那么在另一个线程尝试获取同步状态的时候发现state的值已经是1了就一直阻塞等待，直到获取同步状态成功的线程执行完了需要同步的操作后释放同步状态，也就是把state的值设置为0，并通知后续等待的线程。  
&emsp; 在共享模式下的道理也差不多，比如说某项操作允许10个线程同时进行，超过这个数量的线程就需要阻塞等待。那么就可以把state的初始值设置为10，一个线程尝试获取同步状态的意思就是先判断state的值是否大于0，如果不大于0的话意味着当前已经有10个线程在同时执行该操作，本线程需要阻塞等待；如果state的值大于0，那么可以把state的值减1后进入该操作，每当一个线程完成操作的时候需要释放同步状态，也就是把state的值加1，并通知后续等待的线程。  

#### 1.2.1.2. 先进先出FIFO等待队列  

```java
static final class Node {
    //共享模式
    static final Node SHARED = new Node();
    //独占模式
    static final Node EXCLUSIVE = null;
    //因为超时或者中断，节点会被设置为取消状态，被取消的节点时不会参与到竞争中的，他会一直保持取消状态不会转变为其他状态；
    static final int CANCELLED =  1;
    //后继节点的线程处于等待状态，而当前节点的线程如果释放了同步状态或者被取消，将会通知后继节点，使后继节点的线程得以运行
    static final int SIGNAL    = -1;
    //节点在等待队列中，节点线程等待在Condition上，当其他线程对Condition调用了signal()后，改节点将会从等待队列中转移到同步队列中，加入到同步状态的获取中
    static final int CONDITION = -2;
    //表示下一次共享式同步状态获取将会无条件地传播下去
    static final int PROPAGATE = -3;
    //等待状态
    volatile int waitStatus;
    //前驱节点
    volatile Node prev;
    //后继节点
    volatile Node next;
    //当前节点的线程
    volatile Thread thread;
}
/*等待队列的队首结点(懒加载，这里体现为竞争失败的情况下，加入同步队列的线程执行到enq方法的时候会创
建一个Head结点)。该结点只能被setHead方法修改。并且结点的waitStatus不能为CANCELLED*/
private transient volatile Node head;
/**等待队列的尾节点，也是懒加载的。（enq方法）。只在加入新的阻塞结点的情况下修改*/
private transient volatile Node tail;

//构建等待队列
public class ConditionObject implements Condition, java.io.Serializable {
    //...
}
```

### 1.2.2. 成员方法  
&emsp; AQS定义两种资源共享方式：独占Exclusive和共享Share。独占模式和共享模式下在什么情况下会往CLH同步队列里添加节点，什么情况下会从CLH同步队列里移除节点，以及线程阻塞和恢复的实现细节？  

#### 1.2.2.1. 独占模式


#### 1.2.2.2. 共享模式

#### 1.2.2.3. AQS的模板方法设计模式

#### 1.2.2.4. 自定义同步器
&emsp; 不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS已经在顶层实现好了。自定义同步器实现时主要实现以下几种方法：


----  
# 2. java.util.concurrent.locks包  
&emsp; 参考[Lock](8.Lock.md)  

---
# 3. Atomic，原子类  
## 3.1. atomic类简介  
&emsp; 原子操作定义：原子操作是指不会被线程调度机制打断的操作，这种操作一旦开始，就一直运行到结束，中间不会有任何线程上下文切换。原子操作是在多线程环境下避免数据不一致必须的手段。  
&emsp; 原子操作可以是一个步骤，也可以是多个操作步骤，但是其顺序不可以被打乱，也不可以被切割而只执行其中的一部分，将整个操作视作一个整体是原子性的核心特征。  
&emsp; int++并不是一个原子操作，所以当一个线程读取它的值并加1时，另外一个线程有可能会读到之前的值，这就会引发错误。为了解决这个问题，必须保证增加操作是原子的，在JDK1.5之前可以使用同步技术来做到这一点。到JDK1.5，java.util.concurrent.atomic包提供了int和long类型的包装类，它们可以自动的保证对于它们的操作是原子的并且不需要使用同步。  

&emsp; 原子类原理：原子类是基于CAS实现的。  
&emsp; 原子类与锁：原子类不是锁的常规替换方法。仅当对象的重要更新限定于单个变量时才应用它。  
&emsp; 原子类和java.lang.Integer等类的区别：原子类不提供诸如hashCode和compareTo之类的方法。因为原子变量是可变的。  

## 3.2. atomic使用  
### 3.2.1. 原子更新基本类型或引用类型  
&emsp; 原子更新基本类型：AtomicBoolean、AtomicInteger、AtomicLong。  
&emsp; 原子更新引用类型：AtomicReference、AtomicStampedRerence、AtomicMarkableReference。  
&emsp; 这几个类的操作基本类似，底层都是调用Unsafe的compareAndSwapXxx()来实现，基本用法如下：  

```java
private static void testAtomicReference() {

    AtomicInteger atomicInteger = new AtomicInteger(1);
    atomicInteger.incrementAndGet();
    atomicInteger.getAndIncrement();
    atomicInteger.compareAndSet(3, 666);
    System.out.println(atomicInteger.get());

    AtomicStampedReference<Integer> atomicStampedReference = new AtomicStampedReference<>(1, 1);
    atomicStampedReference.compareAndSet(1, 2, 1, 3);
    atomicStampedReference.compareAndSet(2, 666, 3, 5);
    System.out.println(atomicStampedReference.getReference());
    System.out.println(atomicStampedReference.getStamp());
}
```

### 3.2.2. 原子更新数组中的元素  
&emsp; 原子更新数组：AtomicIntegerArray、AtomicLongArray、AtomicReferenceArray。  
&emsp; 这几个类的操作基本类似，更新元素时都要指定在数组中的索引位置，基本用法如下：  

```java
private static void testAtomicReferenceArray() {

    AtomicIntegerArray atomicIntegerArray = new AtomicIntegerArray(10);
    atomicIntegerArray.getAndIncrement(0);
    atomicIntegerArray.getAndAdd(1, 666);
    atomicIntegerArray.incrementAndGet(2);
    atomicIntegerArray.addAndGet(3, 666);
    atomicIntegerArray.compareAndSet(4, 0, 666);

    System.out.println(atomicIntegerArray.get(0));
    System.out.println(atomicIntegerArray.get(1));
    System.out.println(atomicIntegerArray.get(2));
}
```

### 3.2.3. 原子更新对象中的字段  
&emsp; 原子更新对象的属性：AtomicIntegerFieldUpdater、AtomicLongFieldUpdater、AtomicReferenceFieldUpdater。这几个类的操作基本类似，都需要传入要更新的字段名称，基本用法如下：  

```java
private static void testAtomicReferenceField() {

    AtomicReferenceFieldUpdater<User, String> updateName = AtomicReferenceFieldUpdater.newUpdater(User.class, String.class,"name");
    AtomicIntegerFieldUpdater<User> updateAge = AtomicIntegerFieldUpdater.newUpdater(User.class, "age");
    User user = new User("tong ge", 21);
    updateName.compareAndSet(user, "tong ge", "read source code");
    updateAge.compareAndSet(user, 21, 25);
    updateAge.incrementAndGet(user);
    System.out.println(user);
}
```

### 3.2.4. 高性能原子类  
&emsp; 高性能原子类，是java8中增加的原子类，它们使用分段的思想，把不同的线程hash到不同的段上去更新，最后再把这些段的值相加得到最终的值，这些类主要有：  

* Striped64下面四个类的父类。  
* LongAccumulator，long类型的聚合器，需要传入一个long类型的二元操作，可以用来计算各种聚合操作，包括加乘等。  
* LongAdder，long类型的累加器，LongAccumulator的特例，只能用来计算加法，且从0开始计算。  
* DoubleAccumulator，double类型的聚合器，需要传入一个double类型的二元操作，可以用来计算各种聚合操作，包括加乘等。  
* DoubleAdder，double类型的累加器，DoubleAccumulator的特例，只能用来计算加法，且从0开始计算。  

&emsp; 这几个类的操作基本类似，其中DoubleAccumulator和DoubleAdder底层其实也是用long来实现的，基本用法如下：  

```java
private static void testNewAtomic() {

    LongAdder longAdder = new LongAdder();
    longAdder.increment();
    longAdder.add(666);
    System.out.println(longAdder.sum());

    LongAccumulator longAccumulator = new LongAccumulator((left, right)->left + right * 2, 666);
    longAccumulator.accumulate(1);
    longAccumulator.accumulate(3);
    longAccumulator.accumulate(-4);
    System.out.println(longAccumulator.get());
}
```

## atomic分析  
&emsp; 查看 AtomicInteger 代码如下，可以看到该类下的方法大部分是 调用了 Unsafe 类  

```
public class AtomicInteger extends Number implements java.io.Serializable {
    private static final Unsafe unsafe = Unsafe.getUnsafe();
    private static final long valueOffset;
    static {
        try {
            //用于获取value字段相对当前对象的“起始地址”的偏移量
            valueOffset = unsafe.objectFieldOffset(AtomicInteger.class.getDeclaredField("value"));
        } catch (Exception ex) { throw new Error(ex); }
    }
    private volatile int value;
    //返回当前值
    public final int get() {
        return value;
    }
    //递增加detla
    public final int getAndAdd(int delta) {
        //三个参数，1、当前的实例 2、value实例变量的偏移量 3、当前value要加上的数（value+delta）。
        return unsafe.getAndAddInt(this, valueOffset, delta);
    }
    //递增加1
    public final int incrementAndGet() {
        return unsafe.getAndAddInt(this, valueOffset, 1) + 1;
    }
...
}
```
&emsp; AtomicInteger 底层用的是volatile的变量和CAS来进行更改数据的。volatile保证线程的可见性，多线程并发时，一个线程修改数据，可以保证其它线程立马看到修改后的值；CAS 保证数据更新的原子性。  

&emsp; valueOffset：AtomicInteger 中的变量 valueOffset 表示该变量值在内存中的偏移地址，因为 UnSafe 就是根据内存偏移地址获取数据。  
&emsp; volatile int value：变量 value 用 volatile 修饰，保证了多线程之间的内存可见性。  

----  
# 4. Collections，14个并发容器  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/concurrent/concurrent-5.png)  
&emsp; 按照线程安全模型分类：copy-on-write、CAS（JDK1.8 ConcurrentHashMap）、读写分离（LinkedBlockingQueue）。  

## 4.1. CopyOnWrite简介  
&emsp; CopyOnWrite，简称COW。所谓写时复制，即读操作时不加锁以保证性能不受影响；写操作时加锁，复制资源的一份副本，在副本上执行写操作，写操作完成后将资源的引用指向副本。  

&emsp; ***优点：*** 可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。  
&emsp; ***缺点：*** 1.占内存（写时复制，new两个对象）；2.不能保证数据实时一致性。  
* 内存占用问题:  
因为CopyOnWrite的写时复制机制，所以在进行写操作的时候，内存里会同时驻扎两个对象的内存，旧的对象和新写入的对象（注意:在复制的时候只是复制容器里的引用，只是在写的时候会创建新对象添加到新容器里，而旧容器的对象还在使用，所以有两份对象内存）。如果这些对象占用的内存比较大，比如说200M左右，那么再写入100M数据进去，内存就会占用300M，那么这个时候很有可能造成频繁的Yong GC和Full GC。之前系统中使用了一个服务由于每晚使用CopyOnWrite机制更新大对象，造成了每晚15秒的Full GC，应用响应时间也随之变长。  
针对内存占用问题，可以通过压缩容器中的元素的方法来减少大对象的内存消耗，比如，如果元素全是10进制的数字，可以考虑把它压缩成36进制或64进制。或者不使用CopyOnWrite容器，而使用其他的并发容器，如ConcurrentHashMap。  
* 数据一致性问题:  
CopyOnWrite容器只能保证数据的最终一致性，不能保证数据的实时一致性。所以如果希望写入的的数据，马上能读到，不要使用CopyOnWrite容器。 

&emsp; ***使用场景：*** CopyOnWrite并发容器用于读多写少的并发场景。比如白名单，黑名单，商品类目的访问和更新场景，假如有一个搜索网站，用户在这个网站的搜索框中，输入关键字搜索内容，但是某些关键字不允许被搜索。这些不能被搜索的关键字会被放在一个黑名单当中，黑名单每天晚上更新一次。当用户搜索时，会检查当前关键字在不在黑名单当中，如果在，则提示不能搜索。  

## 4.2. List，CopyOnWriteArrayList  
&emsp; 并发版ArrayList，底层结构也是数组，和ArrayList不同之处在于：当新增和删除元素时会创建一个新的数组，在新的数组中增加或者排除指定对象，最后用新增数组替换原来的数组。  
~~&emsp; 适用场景：由于读操作不加锁，写（增、删、改）操作加锁，因此适用于读多写少的场景。~~  
&emsp; 局限：由于读的时候不会加锁（读的效率高，就和普通ArrayList一样），读取的当前副本，因此可能读取到脏数据。每次对集合结构进行修改时，都需要拷贝数据，占用内存较大；  
&emsp; 总结：CopyOnWriteArrayList基于ReentrantLock保证了增加元素和删除元素动作的互斥。在读上没有做任何锁操作，这样就保证了读的性能，带来的副作用是有些时候可能会读取到脏数据。  
&emsp; 在读多写少的高并发环境中，使用CopyOnWriteArrayList可以提高系统的性能，但是，在写多读少的场合，CopyOnWriteArrayList的性能可能不如Vector。  

### 4.2.1. 源码解析  

```java
public class CopyOnWriteArrayList<E>
        implements List<E>, RandomAccess, Cloneable, java.io.Serializable {

    final transient ReentrantLock lock = new ReentrantLock();
    private transient volatile Object[] array;

    //创建一个大小为0的数组
    public CopyOnWriteArrayList() {
        setArray(new Object[0]);
    }

    // 添加元素，有锁
    /*    add方法并没有加上synchronized关键字，它通过使用ReentrantLock来保证线程安全。*/
    public boolean add(E e) {
        final ReentrantLock lock = this.lock;
        lock.lock(); // 修改时加锁，保证并发安全
        try {
            Object[] elements = getArray(); // 当前数组
            int len = elements.length;
            Object[] newElements = Arrays.copyOf(elements, len + 1); // 创建一个新数组，比老的大一个空间
            newElements[len] = e; // 要添加的元素放进新数组
            setArray(newElements); // 用新数组替换原来的数组
            return true;
        } finally {
            lock.unlock(); // 解锁
        }
    }

    //
    public E remove(int index) {
        final ReentrantLock lock = this.lock;
        lock.lock();
        try {
            Object[] elements = getArray();
            int len = elements.length;
            E oldValue = get(elements, index);
            int numMoved = len - index - 1;
            if (numMoved == 0)
                setArray(Arrays.copyOf(elements, len - 1));
            else {
                Object[] newElements = new Object[len - 1];
                System.arraycopy(elements, 0, newElements, 0, index);
                System.arraycopy(elements, index + 1, newElements, index,
                        numMoved);
                setArray(newElements);
            }
            return oldValue;
        } finally {
            lock.unlock();
        }
    }

    // 读元素，不加锁，因此可能读取到旧数据
    public E get(int index) {
        return get(getArray(), index);
    }

    //创建一个新的COWIterator对象实例，并保存了一个当前数组的快照，
    // 在调用 next遍历时则仅对此快照数组进行遍历，
    // 因此遍历CopyOnWriteArrayList时不会抛出Concurrent- Modi ficatiedException
    public Iterator<E> iterator() {
        return new COWIterator<E>(getArray(), 0);
    }
}
```

### 4.2.2. 示例代码  

```java
import java.util.Map;
import com.ifeve.book.forkjoin.CopyOnWriteMap;

/**
 * 黑名单服务
 * @author fangtengfei
 */
public class BlackListServiceImpl {

    private static CopyOnWriteMap<String, Boolean> blackListMap = new CopyOnWriteMap<String, Boolean>(1000);

    public static boolean isBlackList(String id) {
        return blackListMap.get(id) == null ? false : true;
    }

    public static void addBlackList(String id) {
        blackListMap.put(id, Boolean.TRUE);
    }

    /**
     * 批量添加黑名单
     * @param ids
     */
    public static void addBlackList(Map<String,Boolean> ids) {
        blackListMap.putAll(ids);
    }

}
```

## 4.3. Map，ConcurrentHashMap、ConcurrentSkipListMap  
&emsp; JDK中并没有提供CopyOnWriteMap。JUC容器Map的实现有ConcurrentHashMap，线程安全的哈希表，相当于线程安全的HashMap；ConcurrentSkipListMap，线程安全的有序的哈希表，相当于线程安全的TreeMap。  

### 4.3.1. ConcurrentHashMap
&emsp; 详见[ConcurrentHashMap详解](5.ConcurrentHashMap.md)

### 4.3.2. ConcurrentSkipListMap
&emsp; ConcurrentSkipListMap与TreeMap都是有序的哈希表。  
&emsp; ConcurrentSkipListMap线程安全，TreeMap非线程安全；  
&emsp; ConcurrentSkipListMap是通过跳表（skip list）实现的，而TreeMap是通过红黑树实现的。

## 4.4. Set，CopyOnWriteArraySet、ConcurrentSkipListSet  
&emsp; JUC容器Set的实现有CopyOnWriteArraySet与ConcurrentSkipListSet。CopyOnWriteArraySet相当于线程安全的HashSet，CopyOnWriteArraySet的实现依赖于CopyOnWriteArrayList；ConcurrentSkipListSet相当于线程安全的TreeSet，ConcurrentSkipListSet的实现依赖于ConcurrentSkipListMap。  
&emsp; CopyOnWriteArraySet适用于读多写少的高并发场合，在需要并发写的场合，则可以使用 Set s = Collections.synchronizedSet(Set<T> s)得到一个线程安全的Set。 

## 4.5. Queue  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/concurrent/concurrent-6.png)  
&emsp; 在并发队列上，JDK提供了两套实现，一个是以ConcurrentLinkedQueue为代表的高性能队列，一个是以BlockingQueue接口为代表的阻塞队列。  
&emsp; ConcurrentLinkedQueue是一个适用于高并发场景下的队列。它通过无锁的方式，实现了高并发状态下的高性能。通常，ConcurrentLinkedQueue的性能要好于BlockingQueue 。  
&emsp; 与 ConcurrentLinkedQueue 的使用场景不同，BlockingQueue 的主要功能并不是在于提升高并发时的队列性能，而在于简化多线程间的数据共享。  

&emsp; JDK7提供了6个阻塞队列实现类。分别是：  

* ArrayBlockingQueue：一个由数组结构组成的有界阻塞队列。  
* LinkedBlockingQueue：一个由链表结构组成的有界阻塞队列。  
* PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列。  
* DelayQueue：一个使用优先级队列实现的无界阻塞队列。  
* SynchronousQueue：一个不存储元素的阻塞队列。  
* LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。  

----
# 5. Tools，工具类  
&emsp; 参考[tools](7.tools.md)  

----  
# 6. 15种锁分类  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/concurrent/concurrent-4.png)  
