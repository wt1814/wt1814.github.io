---
title: 多线程编程
date: 2020-01-07 00:00:00
tags:
    - 并发编程
---

<!-- TOC -->

- [1. 多线程基本概念](#1-多线程基本概念)
    - [1.1. 父子线程](#11-父子线程)
    - [1.2. 线程死锁、饥饿、活锁：](#12-线程死锁饥饿活锁)
- [2. JMM](#2-jmm)
    - [2.1. 并发问题及含义](#21-并发问题及含义)
    - [2.2. Java并发原因：重排序](#22-java并发原因重排序)
        - [2.2.1. 为什么代码会重排序？](#221-为什么代码会重排序)
        - [2.2.2. 指令重排序分类](#222-指令重排序分类)
        - [2.2.3. 重排序规则](#223-重排序规则)
            - [2.2.3.1. 重排序遵守数据依赖性](#2231-重排序遵守数据依赖性)
            - [2.2.3.2. 重排序遵守as-if-serial语义](#2232-重排序遵守as-if-serial语义)
        - [2.2.4. 重排序对多线程的影响](#224-重排序对多线程的影响)
    - [2.3. 了解计算机硬件内存模型](#23-了解计算机硬件内存模型)
    - [2.4. Java内存模型的抽象](#24-java内存模型的抽象)
        - [2.4.1. JMM中内存划分](#241-jmm中内存划分)
        - [2.4.2. 内存间的交互操作](#242-内存间的交互操作)
        - [2.4.3. JMM中的happens-before原则](#243-jmm中的happens-before原则)
        - [2.4.4. ~~内存屏障~~](#244-内存屏障)
    - [2.5. java并发原语](#25-java并发原语)
- [3. 线程同步](#3-线程同步)
    - [3.1. 线程安全](#31-线程安全)
    - [3.2. Synchronized](#32-synchronized)
        - [3.2.1. synchronized使用：](#321-synchronized使用)
            - [3.2.1.1. synchronized同步普通方法](#3211-synchronized同步普通方法)
            - [3.2.1.2. synchronized同步静态方法](#3212-synchronized同步静态方法)
            - [3.2.1.3. synchronized同步语句块](#3213-synchronized同步语句块)
                - [3.2.1.3.1. 同步类](#32131-同步类)
                - [3.2.1.3.2. 同步this实例](#32132-同步this实例)
                - [3.2.1.3.3. 同步对象实例](#32133-同步对象实例)
        - [3.2.2. synchronized与ReentrantLock的比较](#322-synchronized与reentrantlock的比较)
        - [3.2.3. synchronized原理](#323-synchronized原理)
            - [3.2.3.1. 反编译Synchronized代码块](#3231-反编译synchronized代码块)
                - [3.2.3.1.1. 同步代码块](#32311-同步代码块)
                - [3.2.3.1.2. 同步方法](#32312-同步方法)
                    - [3.2.3.1.2.1. Monitor和Java对象头详解](#323121-monitor和java对象头详解)
            - [3.2.3.2. synchronized与Object#wait()](#3232-synchronized与objectwait)
        - [3.2.4. synchronized的锁优化](#324-synchronized的锁优化)
            - [3.2.4.1. synchronized锁升级](#3241-synchronized锁升级)
                - [3.2.4.1.1. synchronized锁对比](#32411-synchronized锁对比)
            - [3.2.4.2. 锁消除](#3242-锁消除)
            - [3.2.4.3. 锁粗化](#3243-锁粗化)
    - [3.3. Volatile](#33-volatile)
        - [3.3.1. Volatile原理](#331-volatile原理)
        - [3.3.2. Volatile使用](#332-volatile使用)
            - [3.3.2.1. 如何正确使用volatile变量](#3321-如何正确使用volatile变量)
            - [3.3.2.2. 示例一：状态标志](#3322-示例一状态标志)
            - [3.3.2.3. 单例模式的实现](#3323-单例模式的实现)
    - [3.4. ThreadLocal](#34-threadlocal)
        - [3.4.1. ThreadLocal源码](#341-threadlocal源码)
            - [3.4.1.1. ThreadLocal存储结构](#3411-threadlocal存储结构)
            - [3.4.1.2. ThreadLocal成员方法](#3412-threadlocal成员方法)
                - [3.4.1.2.1. set()](#34121-set)
                - [3.4.1.2.2. get()](#34122-get)
        - [3.4.2. ThreadLocal使用](#342-threadlocal使用)
            - [3.4.2.1. 使用示例](#3421-使用示例)
            - [3.4.2.2. SimpleDateFormat非线程安全问题](#3422-simpledateformat非线程安全问题)
        - [3.4.3. ThreadLocal的内存泄漏](#343-threadlocal的内存泄漏)
        - [3.4.4. ThreadLocal局限性（变量不具有传递性）](#344-threadlocal局限性变量不具有传递性)
            - [3.4.4.1. 类InheritableThreadLocal的使用](#3441-类inheritablethreadlocal的使用)
            - [3.4.4.2. 类TransmittableThreadLocal的使用](#3442-类transmittablethreadlocal的使用)
        - [3.4.5. ThreadLocal的优化](#345-threadlocal的优化)
- [4. 线程通信](#4-线程通信)
- [5. 进程通信](#5-进程通信)

<!-- /TOC -->



# 1. 多线程基本概念  

## 1.1. 父子线程  
&emsp; 某线程a中启动另外一个线程t，那么称线程t是线程a的一个子线程，而线程a是线程t的父线程。最典型的是在main方法中启动一个线程去执行。其中main方法隐含的main线程为父线程。  
&emsp; ***与进程相比，创建的子线程从主线程那继承了什么？***  
&emsp; 对于线程而言，并没有继承数据段和代码段，包括栈，而线程最大的优势是，多线程是共享地址空间的，从一个线程切换到同一个进程下的另一个线程运行，页表、数据区等很多都已经在内存或缓存里，而从一个进程切换到另一个进程，由于进程的空间都是独立的，所以切换就涉及到开销。这一点其实对于现在的硬件来讲，尤其是程序员来说，整体速度上影响不大，只是不方便同步。所以线程并不会继承那些看得见的东西（比如变量、代码等）。 

## 1.2. 线程死锁、饥饿、活锁：  
&emsp; 死锁、饥饿和活锁都属于多线程的活跃性问题，如果发现这几种情况，那么相关线程可能就不再活跃，也就说它可能很难再继续往下执行了。  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/concurrent/multi-1.png)  

* 死锁：死锁应该是最糟糕的一种情况了。指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。  

* 饥饿：指某一个或者多个线程因为种种原因无法获得所需要的资源，导致一直无法执行。比如：  
&emsp; 1）它的线程优先级可能太低，而高优先级的线程不断抢占它需要的资源，导致低优先级的线程无法工作。  
&emsp; 2）另外一种可能是，某一个线程一直占着关键资源不放，导致其他需要这个资源的线程无法正常执行，这种情况也是饥饿的一种。  
&emsp; 与死锁相比，饥饿还是有可能在未来一段时间内解决的（比如高优先级的线程已经完成任务，不再疯狂的执行）  

* 活锁：指任务或者执行者没有被阻塞，由于某些条件没有满足，导致一直重复尝试，失败，尝试，失败。活锁可以认为是一种特殊的饥饿。线程都秉承着"谦让"的原则，主动将资源释放给他人使用，那么就会出现资源不断在两个线程之间跳动，而没有一个线程可以同时拿到所有资源而正常执行。  


# 2. JMM  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/concurrent/multi-10.png)   
## 2.1. 并发问题及含义  
&emsp; 并发编程存在原子性、可见性、有序性问题。  

* 原子性，即一系列操作要么都执行，要么都不执行。线程切换会导致原子性问题。  
* 可见性，一个线程对共享变量的修改，另一个线程可能不会马上看到。由于多核CPU，每个CPU核都有高速缓存，会缓存共享变量，某个线程对共享变量的修改会改变高速缓存中的值，但却不会马上写入内存。另一个线程读到的是另一个核缓存的共享变量的值，出现缓存不一致问题。  
* 有序性，即程序执行的顺序按照代码的先后顺序执行。编译器和处理器会对指令进行重排，以优化指令执行性能，重排不会改变单线程执行结果，但在多线程中可能会引起各种各样的问题。  

&emsp; ***总结：***  
&emsp; 出现线程安全问题的原因：线程切换带来的原子性问题；缓存不能及时刷新导致的可见性问题；编译器优化带来的有序性问题。  
&emsp; “缓存不能及时刷新“和“编译器为了优化性能而改变程序中语句的先后顺序”都是重排序的一种。  

## 2.2. Java并发原因：重排序  
### 2.2.1. 为什么代码会重排序？  
&emsp; 在执行程序时，为了提供性能，处理器和编译器常常会对指令进行重排序，但是不能随意重排序，它需要满足以下两个条件：  

* 在单线程环境下不能改变程序运行的结果；  
* 存在数据依赖关系的不允许重排序。  

&emsp; 需要注意的是：重排序不会影响单线程环境的执行结果，但是会破坏多线程的执行语义。  

### 2.2.2. 指令重排序分类  
&emsp; 从Java源代码到最终实际执行的指令序列，会分别经历下面三种重排序：  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/concurrent/multi-2.png)  

1. 编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。  
&emsp; 编译器优化：对于没有数据依赖关系的操作，编译器在编译的过程中会进行一定程度的重排。  
2. 指令级并行的重排序。现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。  
&emsp; 指令重排序：CPU优化行为，也是会对不存在数据依赖关系的指令进行一定程度的重排。  
3. 内存系统的重排序。由于处理器使用缓存和读／写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。  
&emsp; 内存系统重排序：内存系统没有重排序，但是由于有缓存的存在，使得程序整体上会表现出乱序的行为。  

&emsp; 上面的这些重排序都可能导致多线程程序出现内存可见性问题。对于编译器，JMM的编译器重排序规则会禁止特定类型的编译器重排序（不是所有的编译器重排序都要禁止）。对于处理器重排序，JMM的处理器重排序规则会要求Java编译器在生成指令序列时，插入特定类型的内存屏障指令，通过内存屏障指令来禁止特定类型的处理器重排序（不是所有的处理器重排序都要禁止）。  
&emsp; JMM属于语言级的内存模型，它确保在不同的编译器和不同的处理器平台之上，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证。  

### 2.2.3. 重排序规则  
#### 2.2.3.1. 重排序遵守数据依赖性  
&emsp; 如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性。数据依赖分下列三种类型：  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/concurrent/multi-3.png)  
&emsp; 上面三种情况，只要重排序两个操作的执行顺序，程序的执行结果将会被改变。  

&emsp; 编译器和处理器可能会对操作做重排序。编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序。  
&emsp; 注意，这里所说的数据依赖性仅针对单个处理器中执行的指令序列和单个线程中执行的操作，不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑。  

#### 2.2.3.2. 重排序遵守as-if-serial语义  
&emsp; as-if-serial 语义的意思指：不管怎么重排序(编译器和处理器为了提高并行度)，(单线程)程序的执行结果不能被改变。编译器，runtime和处理器都必须遵守as-if-serial语义。  

### 2.2.4. 重排序对多线程的影响  
&emsp; 示例代码：  

```
class Demo {
    int a = 0;
    boolean flag = false;

    public void write() {
        a = 1;            //1
        flag = true;    //2
    }

    public void read() {
        if(flag) {            //3
            int i = a * a;    //4
        }
    }
}
```
&emsp; 由于操作1和2没有数据依赖关系，编译器和处理器可以对这两个操作重排序；操作3和操作4没有数据依赖关系，编译器和处理器也可以对这两个操作重排序。  
1. 当操作1和操作2重排序时，可能会产生什么效果？  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/concurrent/multi-4.png)  
&emsp; 如上图所示，操作1和操作2做了重排序。程序执行时，线程A首先写标记变量flag，随后线程B读这个变量。由于条件判断为真，线程B将读取变量a。此时，变量a还根本没有被线程A写入，在这里多线程程序的语义被重排序破坏了！  
2. 当操作3和操作4重排序时会产生什么效果（借助这个重排序，可以顺便说明控制依赖性）。  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/concurrent/multi-5.png)  
&emsp; 在程序中，操作3和操作4存在控制依赖关系。当代码中存在控制依赖性时，会影响指令序列执行的并行度。为此，编译器和处理器会采用猜测（Speculation）执行来克服控制相关性对并行度的影响。以处理器的猜测执行为例，执行线程B 的处理器可以提前读取并计算a * a，然后把计算结果临时保存到一个名为重排序缓冲（reorder buffer ROB）的硬件缓存中。当接下来操作3的条件判断为真时，就把该计算结果写入变量i中。  
&emsp; 从图中可以看出，猜测执行实质上对操作3和4做了重排序。重排序在这里破坏了多线程程序的语义！  
&emsp; 在单线程程序中，对存在控制依赖的操作重排序，不会改变执行结果（这也是as-if-serial语义允许对存在控制依赖的操作做重排序的原因）；但在多线程程序中，对存在控制依赖的操作重排序，可能会改变程序的执行结果。  

## 2.3. 了解计算机硬件内存模型  
......

## 2.4. Java内存模型的抽象  

    顺序一致内存模型：为了保证共享内存的正确性（原子性、可见性、有序性），内存模型定义了共享内存系统中多线程程序读写操作行为的规范。内存模型解决并发问题主要采用两种方式：限制处理器优化和使用内存屏障。
&emsp; Java内存模型（Java Memory Model，JMM）是一种符合顺序一致内存模型规范的，屏蔽了各种硬件和操作系统的访问差异的，保证了Java程序在各种平台下对内存的访问都能保证效果一致的机制及规范。  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/concurrent/multi-6.png)  
&emsp; JMM定义了Java虚拟机（JVM）在计算机内存（RAM）中的工作方式。JMM主要规定了以下两点：  
* 规定了一个线程如何以及何时可以看到其他线程修改过后的共享变量的值，即线程之间共享变量的可见性。  
* 如何在需要的时候对共享变量进行同步。  

&emsp; 在并发编程需要处理的两个关键问题是：线程之间如何通信和线程之间如何同步，即两条标准的体现。  
&emsp; 线程通信是一种手段，而线程同步是一种目的，即线程通信的主要目的是用于线程同步。线程同步是为了解决线程安全问题。

* 线程通信  

    通信是指线程之间以何种机制来交换信息。在命令式编程中，线程之间的通信机制有两种：共享内存和消息传递。
    在共享内存的并发模型里，线程之间共享程序的公共状态，线程之间通过写-读内存中的公共状态来隐式进行通信。
    在消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过明确的发送消息来显式进行通信。

* 线程同步  

    同步是指程序用于控制不同线程之间操作发生相对顺序的机制。
    在共享内存的并发模型里，同步是显式进行的。程序员必须显式指定某个方法或某段代码需要在线程之间互斥执行。
    在消息传递的并发模型里，由于消息的发送必须在消息的接收之前，因此同步是隐式进行的。    

&emsp; Java的并发采用的是共享内存模型，Java线程之间的通信总是隐式进行，整个通信过程对程序员完全透明。  

### 2.4.1. JMM中内存划分  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/concurrent/multi-7.png)   

* 主内存：Java 内存模型规定了所有变量都存储在主内存(Main Memory)中（此处的主内存与物理硬件的主内存RAM 名字一样，两者可以互相类比，但此处仅是虚拟机内存的一部分）。  
* 工作内存：每条线程都有自己的工作内存(Working Memory，又称本地内存，可与CPU高速缓存类比)，线程的工作内存中保存了该线程使用到的主内存中的共享变量的副本拷贝。线程对变量的所有操作都必须在工作内存进行，而不能直接读写主内存中的变量。工作内存是 JMM 的一个抽象概念，并不真实存在。  

&emsp; 从上图来看，如果线程A和线程B要通信的话，要如下两个步骤：  
1. 线程A需要将本地内存A中的共享变量副本刷新到主内存去；  
2. 线程B去主内存读取线程A之前已更新过的共享变量。  

### 2.4.2. 内存间的交互操作  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/concurrent/multi-8.png)   
&emsp; Java内存模型为主内存和工作内存间的变量拷贝及同步定义8种原子性操作指令。  
* lock（锁定）：作用于主内存的变量，把一个变量标识为一条线程独占状态。  
* unlock（解锁）：作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。  
* read（读取）：作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用。  
* load（载入）：作用于工作内存的变量，它把通过read操作从主内存中得到的变量值放入工作内存的变量副本中。  
* use（使用）：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。assign（赋值）：作用于工作内存的变量它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。  
* store（存储）：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作使用。  
* write（写入）：作用于主内存的变量，它把通过store操作从工作内存中得到的变量的值放入主内存的变量中。  

&emsp; 要把一个变量从主内存中复制到工作内存，就需要按顺寻地执行read和load操作，如果把变量从工作内存中同步回主内存中，就要按顺序地执行store和write操作。  
&emsp; Java内存模型只要求上述两个操作必须按顺序执行，而没有保证必须是连续执行。也就是read和load之间，store和write之间是可以插入其他指令的。  

&emsp; Java内存模型还规定了在执行上述八种基本操作时，必须满足如下规则：  
* 不允许read和load、store和write操作之一单独出现。  
* 不允许一个线程丢弃它的最近assign的操作，即变量在工作内存中改变了之后必须同步到主内存中。  
* 不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步回主内存中。  
* 一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量。即就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作。  
* 一个变量在同一时刻只允许一条线程对其进行lock操作，lock和unlock必须成对出现  
* 如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值  
* 如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去unlock一个被其他线程锁定的变量。  
* 对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）。  

### 2.4.3. JMM中的happens-before原则  
&emsp; JSR-133内存模型使用happens-before的概念来阐述操作之间的内存可见性。在JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在happens-before关系。这里提到的两个操作既可以是在一个线程之内，也可以是在不同线程之间。  
&emsp; Happens-before规则主要用来约束两个操作，两个操作之间具有 happens-before关系, 并不意味着前一个操作必须要在后一个操作之前执行，happens-before 仅仅要求前一个操作(执行的结果)对后一个操作可见, (the first is visible to and ordered before the second，前一个操作的结果可以被后续的操作获取)。  
&emsp; happens-before关系的分析需要分为单线程和多线程的情况：  
* 单线程下的 happens-before 字节码的先后顺序天然包含happens-before关系：因为单线程内共享一份工作内存，不存在数据一致性的问题。在程序控制流路径中靠前的字节码 happens-before 靠后的字节码，即靠前的字节码执行完之后操作结果对靠后的字节码可见。然而，这并不意味着前者一定在后者之前执行。实际上，如果后者不依赖前者的运行结果，那么它们可能会被重排序。  
* 多线程下的 happens-before 多线程由于每个线程有共享变量的副本，如果没有对共享变量做同步处理，线程1更新执行操作A共享变量的值之后，线程2开始执行操作B，此时操作A产生的结果对操作B不一定可见。  


&emsp; 为了方便程序开发，Java 内存模型实现了下述的先行发生关系：  
* 程序次序规则： 一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作。  
* 管程锁定规则： 一个unLock操作先行发生于后面对同一个锁的lock操作。  
* volatile变量规则： 对一个变量的写操作 happens-before 后面对这个变量的读操作。  
* 传递规则： 如果操作A 先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A 先行发生于操作C。  
* 线程启动规则： Thread对象的start()方法先行发生于此线程的每个一个动作。  
* 线程中断规则： 对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生。  
* 线程终结规则： 线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束 、Thread.isAlive()的返回值手段检测到线程已经终止执行。  
* 对象终结规则： 一个对象的初始化完成先行发生于它的 finalize()方法的开始  

        as-if-serial规则和happens-before规则的区别：  
        as-if-serial语义保证单线程内程序的执行结果不被改变，happens-before关系保证正确同步的多线程程序的执行结果不被改变。  
        as-if-serial语义给编写单线程程序的程序员创造了一个幻境：单线程程序是按程序的顺序来执行的。happens-before关系给编写正确同步的多线程程序的程序员创造了一个幻境：正确同步的多线程程序是按happens-before指定的顺序来执行的。  
        as-if-serial语义和happens-before这么做的目的，都是为了在不改变程序执行结果的前提下，尽可能地提高程序执行的并行度。  

### 2.4.4. ~~内存屏障~~  
&emsp; ***Java中如何保证底层操作的有序性和可见性？可以通过内存屏障。***  

&emsp; 内存屏障是被插入两个 CPU 指令之间的一种指令，用来禁止处理器指令发生重排序（像屏障一样），从而保障有序性的。另外，为了达到屏障的效果，它也会使处理器写入、读取值之前，将主内存的值写入高速缓存，清空无效队列，从而保障可见性。  
&emsp; 例如：

    Store1;
    Store2;
    Load1;
    StoreLoad;  //内存屏障
    Store3;
    Load2;
    Load3;

&emsp; 对于上面的一组 CPU 指令（Store表示写入指令，Load表示读取指令），StoreLoad 屏障之前的 Store 指令无法与StoreLoad 屏障之后的 Load 指令进行交换位置，即重排序。但是 StoreLoad 屏障之前和之后的指令是可以互换位置的，即 Store1 可以和 Store2 互换，Load2 可以和 Load3 互换。  

&emsp; 常见的 4 种屏障：  
* LoadLoad 屏障：对于这样的语句 Load1; LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。  
* StoreStore 屏障：对于这样的语句 Store1; StoreStore; Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。  
* LoadStore 屏障：对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被执行前，保证Load1要读取的数据被读取完毕。  
* StoreLoad 屏障：对于这样的语句Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。它的开销是四种屏障中最大的（冲刷写缓冲器，清空无效化队列）。在大多数处理器的实现中，这个屏障也被称为全能屏障，兼具其它三种内存屏障的功能。  

&emsp; Java 中对内存屏障的使用在一般的代码中不太容易见到，常见的有 volatile 和 synchronized 关键字修饰的代码块，还可以通过 Unsafe 这个类来使用内存屏障。  

## 2.5. java并发原语
&emsp; Java内存模型，除了定义了一套规范，还提供了一系列原语，封装了底层实现后，供开发者直接使用。  
* 原子性可以通过synchronized和Lock来实现。  
* 可见性可以通过Volatile、synchronized、final来实现。  
* 有序性可以通过synchronized或者Lock、volatile来实现。  


# 3. 线程同步  
&emsp; JMM中定义了线程的两种行为：线程通信、线程同步。线程通信是一种手段，而线程同步是一种目的，即线程通信的主要目的是用于线程同步。线程同步是为了解决线程安全问题。  

## 3.1. 线程安全  
&emsp; 线程安全包含原子性和可见性两个方面，Java的同步机制都是围绕这两个方面来确保线程安全的。  
&emsp; 若多个线程同时对资源执行写操作，一般都需要考虑线程同步，否则的话就可能影响线程安全。线程安全问题有“丢失修改”、“不可重复读”、“读‘脏’数据”等。  

&emsp; ***线程安全的解决方案如下：***  
1. 阻塞/互斥同步（悲观锁）
&emsp; synchronized和ReentrantLock。  
&emsp; 互斥同步最主要的问题就是线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步。  
&emsp; 互斥同步属于一种悲观的并发策略。  
2. 非阻塞同步（乐观锁，CAS）
3. 无同步方案  
&emsp; 要保证线程安全，并不是一定就要进行同步。如果一个方法本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性。  
    * 栈封闭  
    &emsp; 多个线程访问同一个方法的局部变量时，不会出现线程安全问题，因为局部变量存储在虚拟机栈中，属于线程私有的。  
    ![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/concurrent/multi-9.png)   
    * 线程本地存储（Thread Local Storage）  
    &emsp; 如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行。如果能保证，就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。  
    &emsp; 符合这种特点的应用并不少见，大部分使用消费队列的架构模式（如“生产者-消费者”模式）都会将产品的消费过程尽量在一个线程中消费完。其中最重要的一个应用实例就是经典Web交互模型中的“一个请求对应一个服务器线程”（Thread-per-Request）的处理方式，这种处理方式的广泛应用使得很多Web服务端应用都可以使用线程本地存储来解决线程安全问题。  
    &emsp; 可以使用java.lang.ThreadLocal类来实现线程本地存储功能。  
    * 可重入代码（Reentrant Code）  
    &emsp; 这种代码也叫做纯代码（Pure Code），可以在代码执行的任何时刻中断它，转而去执行另外一段代码（包括递归调用它本身），而在控制权返回后，原来的程序不会出现任何错误。  
    &emsp; 可重入代码有一些共同的特征，例如不依赖存储在堆上的数据和公用的系统资源、用到的状态量都由参数中传入、不调用非可重入的方法等。
4. 线程安全：不可变  
&emsp; 不可变（Immutable）的对象一定是线程安全的，不需要再采取任何的线程安全保障措施。只要一个不可变的对象被正确地构建出来，永远也不会看到它在多个线程之中处于不一致的状态。多线程环境下，应当尽量使对象成为不可变，来满足线程安全。  
&emsp; 不可变的类型：final关键字修饰的基本数据类型、String、枚举类型、Number 部分子类，如Long和Double等数值包装类型，BigInteger和BigDecimal等大数据类型。但同为Number的原子类AtomicInteger和AtomicLong则是可变的。    

## 3.2. Synchronized  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/concurrent/multi-16.png)  

&emsp; 当synchronized能够保证在同一时刻最多只有一个线程执行该段代码。  

&emsp; ***synchronized的特性：***  
* 原子性：保证被synchronized修饰的一个或者多个操作，在执行的过程中不会被任何的因素打断，即所谓的原子操作，直到锁被释放。  
* 可见性：保证持有锁的当前线程在释放锁之前，对共享变量的修改会刷新到主存中，并对其它线程可见。  
* 有序性：保证多线程时刻中只有一个线程执行，线程执行的顺序都是有序的。  
* 可重入性：保证在多线程中，有其他的线程试图竞争持有锁的临界资源时，其它的线程会处于等待状态，而当前持有锁的线程可以重复的申请自己持有锁的临界资源。  

### 3.2.1. synchronized使用：  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/concurrent/multi-11.png)  
&emsp; ***synchronized的范围：类锁和对象锁。*** 
1. 类锁：当synchronized修饰静态方法或synchronized修饰代码块传入某个class对象（synchronized (XXXX.class)）时被称为类锁。某个线程得到了一个类锁之后，其他所有被该类锁加锁方法或代码块是锁定的，其他线程是无法访问的，但是其他线程还是可以访问没有被该类锁加锁的任何代码。  
2. 对象锁：当 synchronized 修饰非静态方法或synchronized修饰代码块时传入非class对象（synchronized this)）时被称为对象锁。某个线程得到了对象锁之后，该对象的其他被 synchronized修饰的方法（同步方法）是锁定的，其他线程是无法访问的。但是其他线程还是可以访问没有进行同步的方法或者代码；当获取到与对象关联的内置锁时，并不能阻止其他线程访问该对象，当某个线程获得对象的锁之后，只能阻止其他线程获得同一个锁。  
3. 类锁和对象锁的关系： 如同每个类只有一个class对象，而类的实例可以有很多个一样，每个类只有一个类锁，每个实例都有自己的对象锁，所以不同对象实例的对象锁是互不干扰的。但是有一点必须注意的是，其实类锁只是一个概念上的东西，并不是真实存在的，它只是用来理解锁定实例方法和静态方法的区别的。类锁和对象锁是不一样的锁，是互相独立的，两者不存在竞争关系，线程获得对象锁的同时，也可以获得该类锁，即同时获得两个锁，这是允许的。  
&emsp; 类锁与实例锁不相互阻塞，但相同的类锁，相同的当前实例锁，相同的对象锁会相互阻塞。  

#### 3.2.1.1. synchronized同步普通方法  
&emsp; 这种方法使用虽然最简单，但是只能作用在单例上面，如果不是单例，同步方法锁将失效。  

```
/**
 * 用在普通方法
 */
private synchronized void synchronizedMethod() {
    System.out.println("synchronizedMethod");
    try {
        Thread.sleep(2000);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
}
```
&emsp; 此时，同一个实例只有一个线程能获取锁进入这个方法。  
&emsp; 对于普通同步方法，锁是当前实例对象，进入同步代码前要获得当前实例的锁。  
&emsp; 当两个线程同时对一个对象的一个方法进行操作，只有一个线程能够抢到锁。因为一个对象只有一把锁，一个线程获取了该对象的锁之后，其他线程无法获取该对象的锁，就不能访问该对象的其他synchronized实例方法。可是，两个线程实例化两个不同的对象，获得的锁是不同的锁，所以互相并不影响。  

#### 3.2.1.2. synchronized同步静态方法  
&emsp; 同步静态方法，不管有多少个类实例，同时只有一个线程能获取锁进入这个方法。  

```
/**
 * 用在静态方法
 */
private synchronized static void synchronizedStaticMethod() {
    System.out.println("synchronizedStaticMethod");
    try {
        Thread.sleep(2000);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
}
```
&emsp; 同步静态方法是类级别的锁，一旦任何一个线程进入这个方法，其他所有线程将无法访问这个类的任何同步类锁的方法。  
&emsp; 对于静态同步方法，锁是当前类的Class对象，进入同步代码前要获得当前类对象的锁。  
&emsp; 注意:两个线程实例化两个不同的对象，但是访问的方法是静态的，此时获取的锁是同一个锁，两个线程发生了互斥（即一个线程访问，另一个线程只能等着），因为静态方法是依附于类而不是对象的，当synchronized修饰静态方法时，锁是class对象。  

#### 3.2.1.3. synchronized同步语句块  
&emsp; 对于同步代码块，锁是synchronized括号里面配置的对象，对给定对象加锁，进入同步代码块前要获得给定对象的锁。  

##### 3.2.1.3.1. 同步类
&emsp; 下面提供了两种同步类的方法，锁住效果和同步静态方法一样，都是类级别的锁，同时只有一个线程能访问带有同步类锁的方法。  

```
/**
 * 用在类
 */
private void synchronizedClass() {
    synchronized (TestSynchronized.class) {
        System.out.println("synchronizedClass");
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}

/**
 * 用在类
 */
private void synchronizedGetClass() {
    synchronized (this.getClass()) {
        System.out.println("synchronizedGetClass");
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```
&emsp; 这里的两种用法是同步块的用法，这里表示只有获取到这个类锁才能进入这个代码块。  

##### 3.2.1.3.2. 同步this实例  
&emsp; 这也是同步块的用法，表示锁住整个当前对象实例，只有获取到这个实例的锁才能进入这个方法。  

```
/**
 * 用在this
 */
private void synchronizedThis() {
    synchronized (this) {
        System.out.println("synchronizedThis");
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```
&emsp; 用法和同步普通方法锁一样，都是锁住整个当前实例。  

##### 3.2.1.3.3. 同步对象实例  
&emsp; 这也是同步块的用法，和上面的锁住当前实例一样，这里表示锁住整个LOCK 对象实例，只有获取到这个LOCK实例的锁才能进入这个方法。  

```
/**
 * 用在对象
 */
private void synchronizedInstance() {
    synchronized (LOCK) {
        System.out.println("synchronizedInstance");
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

### 3.2.2. synchronized与ReentrantLock的比较  
&emsp; ***synchronized与ReentrantLock的比较：***  
1. 锁的实现：synchronized是JVM实现的，而ReentrantLock是JDK实现的。  
2. 性能：新版本Java对synchronized进行了很多优化，例如自旋锁等，synchronized 与 ReentrantLock大致相同。  
3. 等待可中断：当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。  
&emsp; ReentrantLock可中断，而synchronized不行。  
4. 公平锁：公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。  
&emsp; synchronized中的锁是非公平的，ReentrantLock默认情况下也是非公平的，但是也可以是公平的。  
5. 锁绑定多个条件。  
&emsp; 一个 ReentrantLock 可以同时绑定多个 Condition 对象。  

&emsp; ***synchronized与ReentrantLock的使用选择：***  
&emsp; 除非需要使用ReentrantLock的高级功能，否则优先使用synchronized。这是因为synchronized是JVM实现的一种锁机制，JVM原生地支持它，而 ReentrantLock 不是所有的JDK版本都支持。并且使用synchronized不用担心没有释放锁而导致死锁问题，因为JVM会确保锁的释放。  

### 3.2.3. synchronized原理  
#### 3.2.3.1. 反编译Synchronized代码块  

```
public class SyncDemo {

    public synchronized void play() {}

    public void learn() {
        synchronized(this) {
        }
    }
}
```
&emsp; 利用javap工具查看生成的class文件信息分析Synchronized，下面是部分信息:  

```
public com.zzw.juc.sync.SyncDemo();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: invokespecial #1        // Method java/lang/Object."<init>":()V
         4: return
      LineNumberTable:
        line 8: 0
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0       5     0  this   Lcom/zzw/juc/sync/SyncDemo;

  public synchronized void play();
    descriptor: ()V
    flags: ACC_PUBLIC, ACC_SYNCHRONIZED
    Code:
      stack=0, locals=1, args_size=1
         0: return
      LineNumberTable:
        line 10: 0
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0       1     0  this   Lcom/zzw/juc/sync/SyncDemo;

  public void learn();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=2, locals=3, args_size=1
         0: aload_0
         1: dup
         2: astore_1
         3: monitorenter
         4: aload_1
         5: monitorexit
         6: goto          14
         9: astore_2
        10: aload_1
        11: monitorexit
        12: aload_2
        13: athrow
        14: return
      Exception table:
         from    to  target type
             4     6     9   any
             9    12     9   any
```
&emsp; JVM基于进入和退出Monitor对象来实现方法同步和代码块同步，但两者实现细节不同。  

* ***方法同步：依靠的是方法修饰符上的ACC_SYNCHRONIZED实现。***  
* ***代码块同步：使用monitorenter和monitorexit指令实现。***  

##### 3.2.3.1.1. 同步代码块  
&emsp; 同步代码块：monitorenter指令插入到同步代码块的开始位置，monitorexit指令插入到同步代码块的结束位置，JVM需要保证每一个monitorenter都有一个monitorexit与之相对应。任何对象都有一个monitor与之相关联，当且一个monitor被持有之后，它将处于锁定状态。线程执行到monitorenter指令时，将会尝试获取对象所对应的monitor所有权，即尝试获取对象的锁。两条指令的作用：  

* monitorenter：  
&emsp; 每个对象有一个监视器锁（monitor），一个monitor只能被一个线程拥有。当monitor被占用时就会处于锁定状态，线程执行monitorenter指令时尝试获取monitor的所有权，过程如下：
    1. 如果monitor的进入数为0，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者。  
    2. 如果线程已经占有该monitor，只是重新进入，则进入monitor的进入数加1，所以synchronized关键字实现的锁是可重入的锁。  
    3. 如果其他线程已经占用了monitor，则该线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor的所有权。  

* monitorexit：  
&emsp; 执行monitorexit的线程必须是objectref所对应的monitor的所有者。
&emsp; 指令执行时，monitor的进入数减1，如果减1后进入数为0，当前线程释放monitor，不再是这个monitor的所有者。其他被这个monitor阻塞的线程可以尝试去获取这个monitor的所有权。  
&emsp; 总结：Synchronized的实现原理，Synchronized的语义底层是通过一个monitor的对象来完成，其实wait/notify等方法也依赖于monitor对象，这就是为什么只有在同步的块或者方法中才能调用wait/notify等方法，否则会抛出java.lang.IllegalMonitorStateException的异常的原因。  

&emsp; ***同步代码块中会出现两次的monitorexit。*** 这是因为一个线程对一个对象上锁了，后续就一定要解锁，第二个monitorexit是为了保证在线程异常时，也能正常解锁，避免造成死锁。  

##### 3.2.3.1.2. 同步方法  
&emsp; synchronized方法则会被翻译成普通的方法调用和返回指令如:invokevirtual、areturn指令，在JVM字节码层面并没有任何特别的指令来实现被synchronized修饰的方法，而是在Class文件的方法表中将该方法的access_flags字段中的synchronized标志位置1，表示该方法是同步方法并使用调用该方法的对象或该方法所属的Class在JVM的内部对象表示Klass做为锁对象。  

###### 3.2.3.1.2.1. Monitor和Java对象头详解  
&emsp; Synchronized用的锁标记是存放在Java对象头的Mark Word中。  

* ***Javad对象：***  
&emsp; java对象在内存中的存储结构如下：    
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/concurrent/multi-12.png)   
&emsp; 内存中的对象分为三部分：对象头、对象实例数据和对齐填充（数组对象多一个区域：记录数组长度）。  
&emsp; Java对象头：对象头里的数据主要是一些运行时的数据。  
&emsp; 在Hotspot虚拟机中，对象头包含2个部分：标记字段（Mark Word)和类型指针（Kass point)。其中Klass Point是是对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例，Mark Word用于存储对象自身的运行时数据，它是实现轻量级锁和偏向锁的关键。  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/concurrent/multi-13.png)   
&emsp; ***Java对象头中的Mark Word：***  
&emsp; Mark Word用于存储对象自身的运行时数据，如哈希码（Hash Code）、GC分代年龄、锁状态标志、线程持有锁、偏向线程ID、偏向时间戳等，这部分数据在32位和64位虚拟机中分别为32bit和64bit。一个对象头一般用2个机器码存储（在32位虚拟机中，一个机器码为4个字节即32bit）,但如果对象是数组类型，则虚拟机用3个机器码来存储对象头，因为JVM虚拟机可以通过Java对象的元数据信息确定Java对象的大小，但是无法从数组的元数据来确认数组的大小，所以用一块来记录数组长度。在32位虚拟机中，Java对象头的Makr Word的默认存储结构如下：  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/concurrent/multi-14.png)   
&emsp; 在程序运行期间，对象头中锁表标志位会发生改变。Mark Word可能发生的变化如下：  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/concurrent/multi-15.png)   

* ***Monitor：***  
&emsp; Monitor是操作系统提出来的一种高级原语，但其具体的实现模式，不同的编程语言都有可能不一样。Monitor有一个重要特点那就是，同一个时刻，只有一个线程能进入到Monitor定义的临界区中，这使得Monitor能够达到互斥的效果。但仅仅有互斥的作用是不够的，无法进入Monitor临界区的线程，它们应该被阻塞，并且在必要的时候会被唤醒。显然，monitor作为一个同步工具，也应该提供这样的机制。  

#### 3.2.3.2. synchronized与Object#wait()  
&emsp; 为什么线程通信的方法wait(), notify()和notifyAll()被定义在Object 类里？  
Java的每个对象中都有一个锁(monitor，也可以成为监视器) 并且wait()，notify()等方法用于等待对象的锁或者通知其他线程对象的监视器可用。在Java的线程中并没有可供任何对象使用的锁和同步器。这就是为什么这些方法是Object类的一部分，这样Java的每一个类都有用于线程间通信的基本方法。  

&emsp; ***为什么wait(), notify()和notifyAll ()必须在同步方法或者同步块中被调用？***  
当一个线程需要调用对象的wait()方法的时候，这个线程必须拥有该对象的锁，接着它就会释放这个对象锁并进入等待状态直到其他线程调用这个对象上的notify()方法。同样的，当一个线程需要调用对象的notify()方法时，它会释放这个对象的锁，以便其他在等待的线程就可以得到这个对象锁。由于所有的这些方法都需要线程持有对象的锁，这样就只能通过同步来实现，所以他们只能在同步方法或者同步块中被调用。  

### 3.2.4. synchronized的锁优化  
&emsp; JDK1.6对锁的实现引入了大量的优化，如偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化等技术来减少锁操作的开销。  
&emsp; 锁主要存在四中状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，它们会随着竞争的激烈而逐渐升级。***注意锁可以升级不可降级，但是偏向锁可以被重置为无锁状态，这种策略是为了提高获得锁和释放锁的效率。***

#### 3.2.4.1. synchronized锁升级  
&emsp; MarkWord结构和锁特征：  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/concurrent/multi-17.png)   
* 无锁：MarkWord标志位01，没有线程执行同步方法/代码块时的状态。  

* 偏向锁：MarkWord标志位01（和无锁标志位一样）。偏向锁是通过在bitfields中通过CAS设置当前正在执行的ThreadID来实现的。假设线程A获取偏向锁执行代码块（即对象头设置了ThreadA_ID），线程A同步块未执行结束时，线程B通过CAS尝试设置ThreadB_ID会失败，因为存在锁竞争情况，这时候就需要升级为轻量级锁。  
&emsp; 注：偏向锁是针对于不存在资源抢占情况时候使用的锁，如果被synchronized修饰的方法/代码块竞争线程多可以通过禁用偏向锁来减少一步锁升级过程。可以通过JVM参数-XX:-UseBiasedLocking = false来关闭偏向锁。  

    锁膨胀：
    当出现有两个线程来竞争锁的话，那么偏向锁就失效了，此时锁就会膨胀，升级为轻量级锁。这也是经常所说的锁膨胀。

    锁撤销：
    由于偏向锁失效了，那么接下来就得把该锁撤销，锁撤销的开销花费还是挺大的，其大概的过程如下：
    在一个安全点停止拥有锁的线程。
    遍历线程栈，如果存在锁记录的话，需要修复锁记录和Markword，使其变成无锁状态。
    唤醒当前线程，将当前锁升级成轻量级锁。

    所以，如果某些同步代码块大多数情况下都是有两个及以上的线程竞争的话，那么偏向锁就会是一种累赘，对于这种情况，我们可以一开始就把偏向锁这个默认功能给关闭

* 轻量级锁：MarkWord标志位00。轻量级锁是采用自旋锁的方式来实现的，自旋锁分为固定次数自旋锁和自适应自旋锁。轻量级锁是针对竞争锁对象线程不多且线程持有锁时间不长的场景, 因为阻塞线程需要CPU从用户态转到内核态，代价很大，如果一个刚刚阻塞不久就被释放代价有大。  
&emsp; 具体实现和升级为重量级锁过程：线程A获取轻量级锁时会把对象头中的MarkWord复制一份到线程A的栈帧中创建用于存储锁记录的空间DisplacedMarkWord，然后使用CAS将对象头中的内容替换成线程A存储DisplacedMarkWord的地址。如果这时候出现线程B来获取锁，线程B也跟线程A同样复制对象头的MarkWord到自己的DisplacedMarkWord中，如果线程A锁还没释放，这时候那么线程B的CAS操作会失败，会继续自旋，当然不可能让线程B一直自旋下去，自旋到一定次数（固定次数/自适应）就会升级为重量级锁。  

* 重量级锁：通过对象内部监视器（monitor）实现，monitor本质前面也提到了是基于操作系统互斥（mutex）实现的，操作系统实现线程之间切换需要从用户态到内核态切换，成本非常高。  

##### 3.2.4.1.1. synchronized锁对比 
|状态|	描述	|优点	|缺点	|应用场景|
|---|---|---|---|---|
|偏向锁	|无实际竞争，让一个线程一直持有锁，在其他线程需要竞争锁到时候，再释放锁|	加锁解锁不需要额外消耗	|如果线程间存在竞争，会有撤销锁到消耗	|只有一个线程进入临界区|
|轻量级|	无实际竞争，多个线程交替使用锁；允许短时间到锁竞争|	竞争的线程不会阻塞|	如果线程一直得不到锁，会一直自旋，消耗CPU	|多个线程交替进入临界区|
|重量级	|有实际竞争，且锁竞争时间长	|线程竞争不使用自旋，不消耗CPU	|线程阻塞，响应时间长	|多个线程同时进入临界区  | 

#### 3.2.4.2. 锁消除  
&emsp; 锁消除理解起来很简单，它指的就是虚拟机即使编译器在运行时，如果检测到那些共享数据不可能存在竞争，那么就执行锁消除。锁消除可以节省毫无意义的请求锁的时间。  

#### 3.2.4.3. 锁粗化  
&emsp; 原则上，在编写代码的时候，总是推荐将同步块的作用范围限制得尽量小，——直在共享数据的实际作用域才进行同步，这样是为了使得需要同步的操作数量尽可能变小，如果存在锁竞争，那等待线程也能尽快拿到锁。  
&emsp; 大部分情况下，上面的原则都是没有问题的，但是如果一系列的连续操作都对同一个对象反复加锁和解锁，那么会带来很多不必要的性能消耗。
&emsp; 如果虚拟机探测到有这样一串零碎到操作都对同一个对象加锁，将会把加锁同步的范围扩展（粗化）到整个操作序列到外部。  

## 3.3. Volatile  
&emsp; 一旦一个共享变量（类的成员变量、类的静态成员变量）被 volatile 修饰之后，那么就具备了两层语义：***保证内存的可见性和禁止指令重排序。***  

1. 不支持原子性。它只是对单个volatile变量的读/写具有原子性（只能保证对单次读/写的原子性）；但是对于类似i++这样的复合操作不能保证原子性。  
2. 禁止进行指令重排序，实现了有序性。也就是说，在volatile变量的赋值操作后⾯会有⼀个内存屏障（⽣成的汇编代码上），读操作不会被重排序到内存屏障之前。  
3. 实现了可见性，volatile提供happens-before的保证，使变量在多个线程间可见。即一个线程修改了某个变量的值，新值对其他线程来说是立即可见的。这个变量不会在多个线程中存在复本，直接从内存读取。  
&emsp; 总结：volatile保证了可见性和有序性，同时可以保证单次读/写的原子性。  

&emsp; ***synchronized和volatile比较：***  
&emsp; 关键字volatile是线程同步的轻量级实现，volatile比synchronized执行成本更低，因为它不会引起线程上下文的切换和调度。
&emsp; volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取；synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。  
&emsp; volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。  
&emsp; volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性。synchronized可以保证原子性，也可以间接保证可见性，因为它会将私有内存和公共内存中的数据做同步。  
&emsp; volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化。  
&emsp; volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的。  

&emsp; 再次重申一下，关键字volatile解决的是变量在多个线程之间的可见性；而synchronized解决的是多个线程之间访问资源的同步性，synchronized可以使多个线程访问同一个资源具有同步性，而且它还具有将线程工作内存中的私有变量与公共内存中的变量同步的功能。  

&emsp; ***volatile和atomic原子类区别：***  
* Volatile变量可以确保先行关系，即写操作会发生在后续的读操作之前, 但它并不能保证原子性。例如用volatile修饰i变量那么i++ 操作就不是原子性的。  
* atomic原子类提供的atomic方法可以让这种操作具有原子性如getAndIncrement()方法会原子性的进行增量操作把当前值加一，其它数据类型和引用变量也可以进行相似操作，但是atomic原子类一次只能操作一个共享变量，不能同时操作多个共享变量。  


### 3.3.1. Volatile原理  
&emsp; volatile可以保证线程可见性且提供了一定的有序性，但是无法保证原子性。在JVM底层volatile是采用“内存屏障”来实现的。  
&emsp; 观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令，lock前缀指令实际上相当于一个内存屏障（也称内存栅栏）。 
* 在每个volatile写操作前插⼊⼀个StoreStore屏障；  
* 在每个volatile写操作后插⼊⼀个StoreLoad屏障；  
* 在每个volatile读操作后插⼊⼀个LoadLoad屏障；  
* 在每个volatile读操作后再插⼊⼀个LoadStore屏障。  
&emsp; ⼤概示意图是这个样⼦：  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/concurrent/multi-18.png)   

### 3.3.2. Volatile使用  
#### 3.3.2.1. 如何正确使用volatile变量  

&emsp; ***volatile的使用限制：***  
&emsp; 只能在有限的一些情形下使用volatile变量替代锁。要使volatile变量提供理想的线程安全，必须同时满足下面两个条件：  
1. 对变量的写操作不依赖于当前值。即变量不能有自增自减等操作，volatile不保证原子性。  
2. 该变量没有包含在具有其他变量的不变式中。  
&emsp; 实际上，这些条件表明，可以被写入volatile变量的这些有效值独立于任何程序的状态，包括变量的当前状态。  
&emsp; 第一个条件的限制使volatile变量不能用作线程安全计数器。虽然增量操作（x++）看上去类似一个单独操作，实际上它是一个由（读取－修改－写入）操作序列组成的组合操作，必须以原子方式执行，而volatile不能提供必须的原子特性。实现正确的操作需要使x 的值在操作期间保持不变，而volatile变量无法实现这点。（然而，如果只从单个线程写入，那么可以忽略第一个条件。）  

&emsp; ***volatile的使用场景：***  
&emsp; 关键字volatile用于多线程环境下的单次操作(单次读或者单次写)。即volatile主要使用的场合是在多个线程中可以感知实例变量被更改了，并且可以获得最新的值使用，也就是用多线程读取共享变量时可以获得最新值使用。  

#### 3.3.2.2. 示例一：状态标志
&emsp; 也许实现volatile变量的规范使用仅仅是使用一个布尔状态标志，用于指示发生了一个重要的一次性事件，例如完成初始化或请求停机。  

```
volatile boolean shutdownRequested;  
...
public void shutdown() {
    shutdownRequested = true;
}

public void doWork() {
    while (!shutdownRequested) {
        // do stuff  
    }
}
```
&emsp; 线程1执行doWork()的过程中，可能有另外的线程2调用了shutdown，所以boolean变量必须是volatile。  
&emsp; 而如果使用synchronized块编写循环要比使用volatile状态标志编写麻烦很多。由于volatile简化了编码，并且状态标志并不依赖于程序内任何其他状态，因此此处非常适合使用volatile。  
&emsp; 这种类型的状态标记的一个公共特性是：通常只有一种状态转换；shutdownRequested标志从false 转换为true，然后程序停止。这种模式可以扩展到来回转换的状态标志，但是只有在转换周期不被察觉的情况下才能扩展(从false到true，再转换到false)。此外，还需要某些原子状态转换机制，例如原子变量。  

#### 3.3.2.3. 单例模式的实现  
&emsp; 单例模式的实现，典型的双重检查锁定（DCL）  

```
class Singleton{
    private volatile static Singleton instance = null;

    private Singleton() {

    }

    public static Singleton getInstance() {
        if(instance==null) {
            synchronized (Singleton.class) {
                if(instance==null)
                    instance = new Singleton();
            }
        }
        return instance;
    }
}
```
&emsp; 这是一种懒汉的单例模式，使用时才创建对象，而且为了避免初始化操作的指令重排序，给instance加上了volatile。




## 3.4. ThreadLocal  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/concurrent/multi-26.png)   

&emsp; 首先说明，ThreadLocal与线程同步无关。ThreadLocal虽然提供了一种解决多线程环境下成员变量的问题，但是它并不是解决多线程共享变量的问题。  
&emsp; ThreadLocal，很多地方叫做线程本地变量，也有些地方叫做线程本地存储。每一个线程都会保存一份变量副本，每个线程都可以独立地修改自己的变量副本，而不会影响到其他线程，是一种线程隔离的思想。  

&emsp; ***ThreadLocal和Synchonized关系：***  
&emsp; ThreadLocal，用于线程间的数据隔离，主要解决多线程中数据因并发产生不一致问题；Synchonized，多个线程间通信时能够获得数据共享。它们都用于解决多线程并发访问。  
&emsp; 但是ThreadLocal与synchronized有本质的区别：  
* 资源共享：
&emsp; lock的资源是多个线程共享的，所以访问的时候需要加锁。
&emsp; ThreadLocal为每一个线程都提供了变量的副本，是一个线程的本地变量，也就意味着这个变量是线程独有的，是不能与其他线程共享的。即隔离了多个线程对数据的数据共享，这样就可以避免资源竞争带来的多线程的问题。  
* 性能开销：lock是通过时间换空间的做法；ThreadLocal是典型的通过空间换时间的做法。  
* 当然它们的使用场景也是不同的，关键看资源是需要多线程之间共享的还是单线程内部共享的。  

&emsp; ***ThreadLocal和线程池一起使用？***  
&emsp; ThreadLocal对象的生命周期跟线程的生命周期一样长，那么如果将ThreadLocal对象和线程池一起使用，就可能会遇到这种情况：一个线程的ThreadLocal对象会和其他线程的ThreadLocal对象串掉，一般不建议将两者一起使用。  

### 3.4.1. ThreadLocal源码  
#### 3.4.1.1. ThreadLocal存储结构  
&emsp; 首先看下Thread.java类代码：  

```
//与此线程有关的ThreadLocal值。由ThreadLocal类维护
ThreadLocalMap threadLocals = null;
//与此线程有关的InheritableThreadLocal值。由InheritableThreadLocal类维护
ThreadLocalMap inheritableThreadLocals = null;
```
&emsp; 从上面Thread类 源代码可以看出Thread 类中有一个 threadLocals 和 一个  inheritableThreadLocals 变量，它们都是 ThreadLocalMap 类型的变量。默认情况下这两个变量都是null，只有当前线程调用 ThreadLocal 类的 set或get方法时才创建它们，实际上调用这两个方法的时候，调用的是ThreadLocalMap类对应的 get()、set()方法。  

&emsp; ThradLocal中内部类ThreadLocalMap：  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/concurrent/multi-23.png)   
&emsp; ThreadLocal.ThreadLocalMap，Map结构中Entry继承WeakReference，所以Entry对应key的引用（ThreadLocal实例）是一个弱引用，Entry对Value的引用是强引用。Key是一个ThreadLocal实例，Value是一个线程特有对象。Entry的作用即是：为其属主线程建立起一个ThreadLocal实例与一个线程特有对象之间的对应关系。  
&emsp; 具体的ThreadLocalMap实例并不是ThreadLocal保持，而是每个Thread持有，且不同的Thread持有不同的ThreadLocalMap实例, 因此它们是不存在线程竞争的(不是一个全局的map)， 另一个好处是每次线程死亡，所有map中引用到的对象都会随着这个Thread的死亡而被垃圾收集器一起收集。  

    如何解决 Hash 冲突？
    ThreadLocalMap 虽然是类似 Map 结构的数据结构，但它并没有实现 Map 接口。它不支持 Map 接口中的 next 方法，这意味着 ThreadLocalMap 中解决 Hash 冲突的方式并非 拉链表 方式。
    实际上，ThreadLocalMap 采用线性探测的方式来解决 Hash 冲突。所谓线性探测，就是根据初始 key 的 hashcode 值确定元素在 table 数组中的位置，如果发现这个位置上已经被其他的 key 值占用，则利用固定的算法寻找一定步长的下个位置，依次判断，直至找到能够存放的位置。
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/concurrent/multi-24.png)   

#### 3.4.1.2. ThreadLocal成员方法  
&emsp; ThreadLocal接口方法有4个。这些方法为每一个使用这个变量的线程都存有一份独立的副本，因此get总是返回由当前线程在调用set时设置的最新值。  

```
public T get() { }  //取数据
public void set(T value) { }  //存数据
public void remove() { }  //删除数据。将当前线程局部变量的值删除，目的是为了减少内存的占用，该方法是JDK5.0新增的方法。需要指出的是，当线程结束后，对应该线程的局部变量将自动被垃圾回收，所以显式调用该方法清除线程的局部变量并不是必须的操作，但它可以加快内存的回收速度。
protected T initialValue() { } // 初始化的数据，用于子类自定义初始化值。返回该线程局部变量的初始值，该方法是一个protected的方法，显然是为了让子类覆盖而设计的。这个方法是一个延迟调用方法，在线程第1次调用get()或set(Object)时才执行，并且仅执行1次。ThreadLocal中的缺省实现直接返回一个null。
```
&emsp; ***ThreadLocal.set()、get()、remove()方法都是对Thread对象的threadLocals属性进行操作。***
  
##### 3.4.1.2.1. set()  
&emsp; 当线程调用threadLocal对象的set(Object value)方法时，数据并不是存储在ThreadLocal对象中，而是存储在Thread对象的threadLocals属性中。  

```
public void set(T value) {
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null)
        map.set(this, value);
    else
        createMap(t, value);
}

set(ThreadLocal key, Object value)
/**
 * Set the value associated with key.
 *
 * @param key the thread local object
 * @param value the value to be set
 */
private void set(ThreadLocal<?> key, Object value) {
    Entry[] tab = table;
    int len = tab.length;
    //根据ThreadLocal的散列值，查找对应元素在数组中的位置
    int i = key.threadLocalHashCode & (len-1);
    //采用线性探测法寻找合适位置
    for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) {
        ThreadLocal<?> k = e.get();
        //key存在，直接覆盖
        if (k == key) {
            e.value = value;
            return;
        }
        // key == null，但是存在值（因为此处的e != null），说明之前的ThreadLocal对象已经被回收了
        if (k == null) {
            replaceStaleEntry(key, value, i);
            return;
        }
    }
    //ThreadLocal对应的key实例不存在，new一个
    tab[i] = new Entry(key, value);
    int sz = ++size;
    //清楚陈旧的Entry(key == null的)
    // 如果没有清理陈旧的 Entry 并且数组中的元素大于了阈值，则进行 rehash
    if (!cleanSomeSlots(i, sz) && sz >= threshold)
        rehash();
}
```



##### 3.4.1.2.2. get()  

```
public T get() {
    //获取当前线程。
    Thread t = Thread.currentThread();
    //获取线程的threadLocals属性。
    ThreadLocalMap map = getMap(t);
    if (map != null) {
        //如果线程对象的threadLocals属性不为空，则从该Map结构中，用threadLocal对象为键去查找值，如果能找到，则返回其value值，否则执行以下代码。
        ThreadLocalMap.Entry e = map.getEntry(this);
        if (e != null) {
            @SuppressWarnings("unchecked")
            T result = (T)e.value;
            return result;
        }
    }
    //如果线程对象的threadLocals属性为空，或未从threadLocals中找到对应的键值对，则调用该方法执行初始化。
    return setInitialValue();
}

private T setInitialValue() {
    //调用initialValue()获取默认初始化值，该方法默认返回null，子类可以重写，实现线程本地变量的初始化。
    T value = initialValue();
    //获取当前线程。
    Thread t = Thread.currentThread();
    //获取该线程对象的threadLocals属性。
    ThreadLocalMap map = getMap(t);
    //如果不为空，则将threadLocal:value存入线程对象的threadLocals属性中。
    if (map != null)
        map.set(this, value);
    else
        //否则初始化线程对象的threadLocals,然后将threadLocal:value键值对存入线程对象的threadLocals属性中。
        createMap(t, value);
    return value;
}
```


### 3.4.2. ThreadLocal使用  
&emsp; 常见的ThreadLocal用法主要有两种：
1. 在线程级别传递变量。  
&emsp; 在日常Web开发中会遇到需要把一个参数层层的传递到最内层，然后中间层根本不需要使用这个参数，或者是仅仅在特定的工具类中使用，这样完全没有必要在每一个方法里面都传递这样一个通用的参数。如果有一个办法能够在任何一个类里面想用的时候直接拿来使用就太好了。Java Web项目大部分都是基于Tomcat，每次访问都是一个新的线程，可以使用ThreadLocal，每一个线程都独享一个ThreadLocal，在接收请求的时候set特定内容，在需要的时候get这个值。  
&emsp; 最常见的ThreadLocal使用场景为用来解决数据库连接、Session管理等。  
2. 保证线程安全。  
&emsp; ThreadLocal为解决多线程程序的并发问题提供了一种新的思路。但是ThreadLocal也有局限性，阿里规范中  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/concurrent/multi-19.png)   
&emsp; 每个线程往ThreadLocal中读写数据是线程隔离，互相之间不会影响的，所以ThreadLocal无法解决共享对象的更新问题！  
&emsp; 由于不需要共享信息，自然就不存在竞争问题了，从而保证了某些情况下线程的安全，以及避免了某些情况需要考虑线程安全必须同步带来的性能损失！  

#### 3.4.2.1. 使用示例  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/concurrent/multi-20.png)   

1. 使用static定义threadLocal变量，是为了确保全局只有一个保存 Integer 对象的 ThreadLocal 实例。  
2. finally语句里调用threadLocal.remove()。

#### 3.4.2.2. SimpleDateFormat非线程安全问题  

```
public class Foo{
    // SimpleDateFormat is not thread-safe, so give one to each thread
    private static final ThreadLocal<SimpleDateFormat> formatter = newThreadLocal<SimpleDateFormat>(){
        @Override
        protected SimpleDateFormat initialValue(){
            return new SimpleDateFormat("yyyyMMdd HHmm");
        }
    };

    public String formatIt(Date date){
        return formatter.get().format(date);
    }
}
```
&emsp; final确保ThreadLocal 的实例不可更改，防止被意外改变，导致放入的值和取出来的不一致，另外还能防止ThreadLocal的内存泄漏。  

### 3.4.3. ThreadLocal的内存泄漏  
&emsp; ThreadLocalMap的key为ThreadLocal实例，是一个弱引用，弱引用有利于GC的回收，当key == null时，GC就会回收这部分空间，但value不一定能被回收，因为它和Current Thread之间还存在一个强引用的关系。  
&emsp; 由于这个强引用的关系，会导致value无法回收，如果线程对象不消除这个强引用的关系，就可能会出现OOM。调用ThreadLocalMap的remove()方法进行显式处理。  

### 3.4.4. ThreadLocal局限性（变量不具有传递性）  
&emsp; ThreadLocal无法在父子线程之间传递，示例代码如下：  

```
public class Service {
    private static ThreadLocal<Integer> requestIdThreadLocal = new ThreadLocal<>();
    public static void main(String[] args) {
        Integer reqId = new Integer(5);
        Service a = new Service();
        a.setRequestId(reqId);
    }

    public void setRequestId(Integer requestId) {
        requestIdThreadLocal.set(requestId);
        doBussiness();
    }

    public void doBussiness() {
        System.out.println("首先打印requestId:" + requestIdThreadLocal.get());
        (new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println("子线程启动");
                System.out.println("在子线程中访问requestId:" + requestIdThreadLocal.get());
            }
        })).start();
    }
}
```
&emsp; 运行结果如下：  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/concurrent/multi-25.png)   

#### 3.4.4.1. 类InheritableThreadLocal的使用  
&emsp; 使用类InheritableThreadLocal可以在子线程中取得父线程继承下来的值。  
&emsp; InheritableThreadLocal主要用于子线程创建时，需要自动继承父线程的ThreadLocal变量，实现子线程访问父线程的threadlocal变量。  
&emsp; InheritableThreadLocal继承了ThreadLocal，并重写了childValue、getMap、createMap三个方法。  

#### 3.4.4.2. 类TransmittableThreadLocal的使用  
&emsp; InheritableThreadLocal支持子线程访问在父线程中设置的线程上下文环境的实现原理是在创建子线程时将父线程中的本地变量值复制到子线程，即复制的时机为创建子线程时。  
&emsp; 但并发、多线程就离不开线程池的使用，因为线程池能够复用线程，减少线程的频繁创建与销毁，如果使用InheritableThreadLocal，那么线程池中的线程拷贝的数据来自于第一个提交任务的外部线程，即后面的外部线程向线程池中提交任务时，子线程访问的本地变量都来源于第一个外部线程，造成线程本地变量混乱。  
&emsp; TransmittableThreadLocal是阿里巴巴开源的专门解决InheritableThreadLocal的局限性，实现线程本地变量在线程池的执行过程中，能正常的访问父线程设置的线程变量。  

### 3.4.5. ThreadLocal的优化  
&emsp; Netty对ThreadLocal进行了优化，优化方式是继承了Thread类，实现了自己的FastThreadLocal。FastThreadLocal的吞吐量是jdk的ThreadLocal的3倍左右。  

# 4. 线程通信  
&emsp; 分布式系统中说的两种通信机制：共享内存机制和消息通信机制。单机中实现线程通信的方式：  
1. 等待、通知机制。wait/notify\notifyAll（synchronized同步方法或同步块中使用）实现内存可见性，及生产消费模式的相互唤醒机制；  
2. 等待、通知机制。同步锁（Lock）的Condition（await\signal\signalAll）；  
3. 管道，共享内存，实现数据的共享，满足读写模式。管道通信就是使用java.io.PipedInputStream和java.io.PipedOutputStream进行通信
4. 方法join。  

# 5. 进程通信  
&emsp; 进程间通信的主要方法有：  
1. 管道（Pipe）：管道是一种半双工的通信方式，数据只能单向流动。管道可用于具有亲缘关系进程间的通信，允许一个进程和另一个与它有共同祖先的进程之间进行通信。   
2. 命名管道（named pipe）：命名管道克服了管道没有名字的限制，因此，除具有管道所具有的功能外，它还允许无亲缘关系进程间的通信。命名管道在文件系统中有对应的文件名。命名管道通过命令mkfifo或系统调用mkfifo来创建。   
3. 信号（Signal）：信号是比较复杂的通信方式，用于通知接受进程有某种事件发生，除了用于进程间通信外，进程还可以发送信号给进程本身；linux除了支持Unix早期信号语义函数sigal外，还支持语义符合Posix.1标准的信号函数sigaction（实际上，该函数是基于BSD的，BSD为了实现可靠信号机制，又能够统一对外接口，用sigaction函数重新实现了signal函数）。Linux中可以使用kill -12 进程号，像当前进程发送信号，但前提是发送信号的进程要注册该信号。   
4. 消息（Message）队列：消息队列是消息的链接表，包括Posix消息队列system V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺限。 
5. 共享内存：使得多个进程可以访问同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。往往与其它通信机制，如信号量结合使用，来达到进程间的同步及互斥。   
6. 内存映射（mapped memory）：内存映射允许任何多个进程间通信，每一个使用该机制的进程通过把一个共享的文件映射到自己的进程地址空间来实现它。 Java中有类 MappedByteBuffer实现内存映射。  
7. 信号量（semaphore）：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。  
8. 套接口（Socket）：更为一般的进程间通信机制，可用于不同机器之间的进程间通信。起初是由Unix系统的BSD分支开发出来的，但现在一般可以移植到其它类Unix系统上：Linux和System V的变种都支持套接字。  



