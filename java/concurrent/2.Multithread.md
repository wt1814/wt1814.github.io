---
title: 多线程编程
date: 2020-01-07 00:00:00
tags:
    - 并发编程
---

<!-- TOC -->

- [1. 多线程基本概念](#1-多线程基本概念)
    - [1.1. 父子线程](#11-父子线程)
    - [1.2. 线程死锁、饥饿、活锁](#12-线程死锁饥饿活锁)
- [2. JMM](#2-jmm)
- [3. 线程同步](#3-线程同步)
    - [3.1. 线程安全-1](#31-线程安全-1)
    - [3.2. Synchronized](#32-synchronized)
    - [3.3. Volatile](#33-volatile)
    - [3.4. ThreadLocal](#34-threadlocal)
- [4. 线程通信(协程)](#4-线程通信协程)
- [5. 进程通信](#5-进程通信)

<!-- /TOC -->

![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/concurrent/multi-27.png)  



# 1. 多线程基本概念  

## 1.1. 父子线程  
&emsp; 某线程a中启动另外一个线程t，那么称线程t是线程a的一个子线程，而线程a是线程t的父线程。最典型的是在main方法中启动一个线程去执行。其中main方法隐含的main线程为父线程。  
&emsp; ***与进程相比，创建的子线程从主线程那继承了什么？***  
&emsp; 对于线程而言，并没有继承数据段和代码段，包括栈，而线程最大的优势是，多线程是共享地址空间的，从一个线程切换到同一个进程下的另一个线程运行，页表、数据区等很多都已经在内存或缓存里，而从一个进程切换到另一个进程，由于进程的空间都是独立的，所以切换就涉及到开销。这一点其实对于现在的硬件来讲，尤其是程序员来说，整体速度上影响不大，只是不方便同步。所以线程并不会继承那些看得见的东西（比如变量、代码等）。 

## 1.2. 线程死锁、饥饿、活锁  
&emsp; 死锁、饥饿和活锁都属于多线程的活跃性问题，如果发现这几种情况，那么相关线程可能就不再活跃，也就说它可能很难再继续往下执行了。  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/concurrent/multi-1.png)  

* 死锁：死锁应该是最糟糕的一种情况了。指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。  

* 饥饿：指某一个或者多个线程因为种种原因无法获得所需要的资源，导致一直无法执行。比如：  
    * 它的线程优先级可能太低，而高优先级的线程不断抢占它需要的资源，导致低优先级的线程无法工作。  
    * 另外一种可能是，某一个线程一直占着关键资源不放，导致其他需要这个资源的线程无法正常执行，这种情况也是饥饿的一种。   
&emsp; 与死锁相比，饥饿还是有可能在未来一段时间内解决的（比如高优先级的线程已经完成任务，不再疯狂的执行）  

* 活锁：指任务或者执行者没有被阻塞，由于某些条件没有满足，导致一直重复尝试，失败，尝试，失败。活锁可以认为是一种特殊的饥饿。线程都秉承着"谦让"的原则，主动将资源释放给他人使用，那么就会出现资源不断在两个线程之间跳动，而没有一个线程可以同时拿到所有资源而正常执行。  

# 2. JMM 

# 3. 线程同步  
&emsp; JMM中定义了线程的两种行为：线程通信、线程同步。线程通信是一种手段，而线程同步是一种目的，即线程通信的主要目的是用于线程同步。线程同步是为了解决线程安全问题。  

## 3.1. 线程安全-1
  
## 3.2. Synchronized  

## 3.3. Volatile  

## 3.4. ThreadLocal  


# 4. 线程通信(协程)  

# 5. 进程通信  