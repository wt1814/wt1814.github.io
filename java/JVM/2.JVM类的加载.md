## JVM类的加载  
### 1. 类加载的时机：  
&emsp; 什么情况下虚拟机需要开始加载一个类呢？虚拟机规范中并没有对此进行强制约束，这点可以交给虚拟机的具体实现来自由把握。  
### 2. 类加载的过程：  
&emsp; 类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载（Loading)、验证（Verification)、准备（Preparation)、解析（Resolution)、初始化(Initialization)、使用(Using)和卸载（Unloading) 7个阶段。类的加载包括前5个阶段，其屮验证、准备、解析3个部分统称为连接（Linking)，这7个阶段的发生顺序如图所示。  
![avatar](../../images/java/JVM/JVM-5.png)  
&emsp; 加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定（也称为动态绑定或晚期绑定）。  
#### 1. 加载：查找并加载类的二进制数据  
&emsp; 加载：查找并加载类的二进制数据。加载主要做三件事：  
* 找到类文件（首先通过类的全限定名来获取定义此类的二进制字节流）  
* 放入方法区（其次将这个字节流所代表的静态存储结构转化为方法区(1.8开始是堆)的运行时数据结构）  
* 开个入口（最后生成一个代表此类的java.lang.Class对象，作为访问方法区这些数据结构的入口）  

&emsp; 类的加载的最终产品是位于堆区中的Class对象，Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。  
&emsp; 其中加载的类有以下几种：  
1). 从本地系统直接加载
2).通过网络下载.class文件  
3).从zip，jar等归档文件中加载.class文件  
4).从专有数据库中提取.class文件  
5).将Java源文件动态编译为.class文件（服务器）  
6).命令行启动应用时候由JVM初始化加载  
7).通过Class.forName()方法动态加载  

#### 2. 链接：  
##### 验证：  
&emsp; 确保被加载的类的正确性。确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致会完成4个阶段的检验动作：  
&emsp; 1). 文件格式验证：验证字节流是否符合Class文件格式的规范；例如：是否以0xCAFEBABE开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。  
&emsp; 2). 元数据验证：对字节码描述的信息进行语义分析（注意：对比javac编译阶段的语义分析），以保证其描述的信息符合Java语言规范的要求，例如：这个类是否有父类（除了java.lang.Object之外所有类都是父类）、这个类是否被继承类不允许继承的类（被final修饰的类）等。  
&emsp; 3). 字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。  
&emsp; 4). 符号引用验证：确保解析动作能正确执行。  
&emsp; 验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用-Xverifynone参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。  

##### 准备：  
&emsp; 准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意：  
1. 这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在 Java 堆中。  
2. 这里所设置的初始值"通常情况"下是数据类型默认的零值（如0、0L、null、false等），比如我们定义了public static int value=111 ，那么 value 变量在准备阶段的初始值就是 0 而不是111（初始化阶段才会复制）。  
* 特殊情况：比如给 value 变量加上了 fianl 关键字public static final int value=111 ，那么准备阶段 value 的值就被赋值为 111。  

##### 解析：  

##### 3.初始化：  



##### 4.使用：  
&emsp; 类的使用包括主动引用和被动引用，主动引用在初始化的那里已经说过了，这里再贴一下。  
&emsp; ***主动引用：***  
    通过 new 关键字实例化对象、读取或设置类的静态变量、调用类的静态方法。  
    通过反射方法执行以上三种行为。  
    初始化子类的时候，会触发父类的初始化。  
    作为程序入口直接运行时（也就是直接调用 main 方法）  

&emsp; ***被动引用：***  
    引用父类的静态字段，只会引起父类的初始化，而不会引起子类的初始化。  
    定义类数组，不会引起类的初始化。  
    引用类的常量，不会引起类的初始化。  


