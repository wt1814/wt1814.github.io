---
title: GC垃圾回收
date: 2020-03-27 00:00:00
tags:
    - JVM
---
- [1. 哪些内存需要回收？](#1-%e5%93%aa%e4%ba%9b%e5%86%85%e5%ad%98%e9%9c%80%e8%a6%81%e5%9b%9e%e6%94%b6)
  - [1.1. JVM堆中对象存活判断:](#11-jvm%e5%a0%86%e4%b8%ad%e5%af%b9%e8%b1%a1%e5%ad%98%e6%b4%bb%e5%88%a4%e6%96%ad)
    - [1.1.1. 引用计数法：](#111-%e5%bc%95%e7%94%a8%e8%ae%a1%e6%95%b0%e6%b3%95)
    - [1.1.2. 可达性分析法：](#112-%e5%8f%af%e8%be%be%e6%80%a7%e5%88%86%e6%9e%90%e6%b3%95)
    - [1.1.3. 对象的四种引用状态](#113-%e5%af%b9%e8%b1%a1%e7%9a%84%e5%9b%9b%e7%a7%8d%e5%bc%95%e7%94%a8%e7%8a%b6%e6%80%81)
      - [1.1.3.1. 强引用：](#1131-%e5%bc%ba%e5%bc%95%e7%94%a8)
      - [1.1.3.2. 软引用：](#1132-%e8%bd%af%e5%bc%95%e7%94%a8)
      - [1.1.3.3. 弱引用：](#1133-%e5%bc%b1%e5%bc%95%e7%94%a8)
      - [1.1.3.4. 虚引用：](#1134-%e8%99%9a%e5%bc%95%e7%94%a8)
      - [1.1.3.5. 软引用和弱引用的使用：](#1135-%e8%bd%af%e5%bc%95%e7%94%a8%e5%92%8c%e5%bc%b1%e5%bc%95%e7%94%a8%e7%9a%84%e4%bd%bf%e7%94%a8)
- [2. 什么时候回收？](#2-%e4%bb%80%e4%b9%88%e6%97%b6%e5%80%99%e5%9b%9e%e6%94%b6)
- [3. 如何回收？（GC算法）](#3-%e5%a6%82%e4%bd%95%e5%9b%9e%e6%94%b6gc%e7%ae%97%e6%b3%95)
  - [3.1. 标记-清除（Mark-Sweep）算法](#31-%e6%a0%87%e8%ae%b0-%e6%b8%85%e9%99%a4mark-sweep%e7%ae%97%e6%b3%95)
  - [3.2. 复制（Copying）算法（新生代）](#32-%e5%a4%8d%e5%88%b6copying%e7%ae%97%e6%b3%95%e6%96%b0%e7%94%9f%e4%bb%a3)
  - [3.3. 标记-整理（Mark-Compact）算法（老年代）](#33-%e6%a0%87%e8%ae%b0-%e6%95%b4%e7%90%86mark-compact%e7%ae%97%e6%b3%95%e8%80%81%e5%b9%b4%e4%bb%a3)
  - [3.4. 分代收集算法](#34-%e5%88%86%e4%bb%a3%e6%94%b6%e9%9b%86%e7%ae%97%e6%b3%95)
- [4. 垃圾回收器](#4-%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6%e5%99%a8)
  - [4.1. --------新生代收集器](#41---------%e6%96%b0%e7%94%9f%e4%bb%a3%e6%94%b6%e9%9b%86%e5%99%a8)
  - [4.2. Serial收集器，单线程收集器](#42-serial%e6%94%b6%e9%9b%86%e5%99%a8%e5%8d%95%e7%ba%bf%e7%a8%8b%e6%94%b6%e9%9b%86%e5%99%a8)
  - [4.3. ParNew收集器，多线程收集器](#43-parnew%e6%94%b6%e9%9b%86%e5%99%a8%e5%a4%9a%e7%ba%bf%e7%a8%8b%e6%94%b6%e9%9b%86%e5%99%a8)
  - [4.4. Parallel Scavenge收集器，并行的多线程收集器](#44-parallel-scavenge%e6%94%b6%e9%9b%86%e5%99%a8%e5%b9%b6%e8%a1%8c%e7%9a%84%e5%a4%9a%e7%ba%bf%e7%a8%8b%e6%94%b6%e9%9b%86%e5%99%a8)
  - [4.5. --------老年代收集器](#45---------%e8%80%81%e5%b9%b4%e4%bb%a3%e6%94%b6%e9%9b%86%e5%99%a8)
  - [4.6. Serial Old收集器](#46-serial-old%e6%94%b6%e9%9b%86%e5%99%a8)
  - [4.7. Parallel Old收集器](#47-parallel-old%e6%94%b6%e9%9b%86%e5%99%a8)
    - [4.7.1. CMS收集器](#471-cms%e6%94%b6%e9%9b%86%e5%99%a8)
  - [4.8. G1收集器](#48-g1%e6%94%b6%e9%9b%86%e5%99%a8)
  - [4.9. --------](#49)
  - [4.10. 常用的收集器组合](#410-%e5%b8%b8%e7%94%a8%e7%9a%84%e6%94%b6%e9%9b%86%e5%99%a8%e7%bb%84%e5%90%88)
  - [4.11. 如何选择合适的垃圾收集器](#411-%e5%a6%82%e4%bd%95%e9%80%89%e6%8b%a9%e5%90%88%e9%80%82%e7%9a%84%e5%9e%83%e5%9c%be%e6%94%b6%e9%9b%86%e5%99%a8)
  - [4.12. 垃圾收集器常用参数：](#412-%e5%9e%83%e5%9c%be%e6%94%b6%e9%9b%86%e5%99%a8%e5%b8%b8%e7%94%a8%e5%8f%82%e6%95%b0)
- [5. GC类型：Minor GC和Full GC/Major GC](#5-gc%e7%b1%bb%e5%9e%8bminor-gc%e5%92%8cfull-gcmajor-gc)
  - [5.1. Minor GC：](#51-minor-gc)
  - [5.2. Major GC / Full GC](#52-major-gc--full-gc)
  - [5.3. Stop the world](#53-stop-the-world)

&emsp; 《Hotspot内存管理白皮书》是了解Java垃圾收集器最权威的文档。  
&emsp; GC主要是解决下面的三个问题：  
* 哪些内存需要回收？  
* 什么时候回收？  
* 如何回收？  

# 1. 哪些内存需要回收？  
&emsp; 虚拟机栈、本地栈和程序计数器在编译完毕后已经可以确定所需内存空间，程序执行完毕后也会自动释放所有内存空间，所以不需要进行动态回收优化。JVM GC回收堆区内的对象。  

## 1.1. JVM堆中对象存活判断:  
&emsp; 对于如何判断对象是否可以回收，有两种比较经典的判断策略：引用计数算法、可达性分析算法。  

### 1.1.1. 引用计数法：  
&emsp; 给每个对象添加一个计数器，当有地方引用该对象时计数器加1，当引用失效时计数器减1。用对象计数器是否为0来判断对象是否可被回收。  
&emsp; 缺点：无法解决循环引用的问题。如果出现A引用了B，B又引用了A，这时候就算它们都不再使用了，但因为相互引用，计算器=1，永远无法被回收。Java中没有使用这种算法。  
![](https://gitee.com/wt1814/pic-host/raw/master/images/java/JVM/JVM-16.png)  

### 1.1.2. 可达性分析法：  
&emsp; 从GC Roots开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的，那么虚拟机就判断是可回收对象。可达性分析可以解决循环引用的问题。  
![](https://gitee.com/wt1814/pic-host/raw/master/images/java/JVM/JVM-17.png)  
&emsp; 可作为GC ROOTs的对象：  
1). 虚拟机栈中引用的对象；  
2). 方法区中，类静态属性引用的对象；  
3). 方法区中，常量引用的对象；  
4). 本地方法栈中，JNI（即Native方法）引用的对象；  

### 1.1.3. 对象的四种引用状态  
&emsp; 在JDK中提供了四个级别的引用：强引用，软引用，弱引用和虚引用。在这四个引用类型中，只有强引用Final Reference类是包内可见，其他三种引用类型均为public，可以在应用程序中直接使用。引用类型的类结构如图所示。  
![](https://gitee.com/wt1814/pic-host/raw/master/images/java/JVM/JVM-22.png)  
![](https://gitee.com/wt1814/pic-host/raw/master/images/java/JVM/JVM-18.png)  

#### 1.1.3.1. 强引用：  
&emsp; 代码中普遍存在的类似"Object obj = new Object()"这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。  
&emsp; 强引用的特点：  
* 强引用可以直接访问目标对象。  
* 强引用所指向的对象在任何时候都不会被系统回收。JVM宁愿抛出OOM异常，也不会回收强引用所指向的对象。  
* 强引用可能导致内存泄漏。  

#### 1.1.3.2. 软引用：  
&emsp; 软引用是除了强引用外，最强的引用类型。可以通过java.lang.ref.SoftReference使用软引用。一个持有软引用的对象，不会被JVM很快回收，JVM会根据当前堆的使用情况来判断何时回收。当堆使用率临近阈值时，才会去回收软引用的对象。因此，软引用可以用于实现对内存敏感的高速缓存。  
&emsp; 软引用示例：
&emsp; 在IDE设置参数-Xmx2m -Xms2m规定堆内存大小为2m。  
![](https://gitee.com/wt1814/pic-host/raw/master/images/java/JVM/JVM-19.png)  
&emsp; 运行结果：  
![](https://gitee.com/wt1814/pic-host/raw/master/images/java/JVM/JVM-20.png)  
&emsp; 打开被注释掉的new byte[1024*100]语句，这条语句请求一块大的堆空间，使堆内存使用紧张。并显式的再调用一次GC，结果如下：  
![](https://gitee.com/wt1814/pic-host/raw/master/images/java/JVM/JVM-21.png)说明在系统内存紧张的情况下，软引用被回收。  

#### 1.1.3.3. 弱引用：  
&emsp; 弱引用是一种比软引用较弱的引用类型。在系统GC时，只要发现弱引用，不管系统堆空间是否足够，都会将对象进行回收。它可以作为简单的缓存表解决方案。  
&emsp; 在java中，可以用java.lang.ref.WeakReference实例来保存对一个Java对象的弱引用。  
![](https://gitee.com/wt1814/pic-host/raw/master/images/java/JVM/JVM-23.png)  
&emsp; 运行结果：  
![](https://gitee.com/wt1814/pic-host/raw/master/images/java/JVM/JVM-24.png)  

#### 1.1.3.4. 虚引用：  
&emsp; 虚引用是所有类型中最弱的一个。一个持有虚引用的对象，和没有引用几乎是一样的，随时可能被垃圾回收器回收。当试图通过虚引用的get()方法取得强引用时，总是会失败。并且，虚引用必须和引用队列一起使用，它的作用在于跟踪垃圾回收过程。  
&emsp; 当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在垃圾回收后，销毁这个对象，将这个虚引用加入引用队列。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。  
![](https://gitee.com/wt1814/pic-host/raw/master/images/java/JVM/JVM-25.png)  
&emsp; 运行结果：  
![](https://gitee.com/wt1814/pic-host/raw/master/images/java/JVM/JVM-26.png)  
&emsp; 对虚引用的get()操作，总是返回null，因为sf.get()方法的实现如下：  
![](https://gitee.com/wt1814/pic-host/raw/master/images/java/JVM/JVM-27.png)  

#### 1.1.3.5. 软引用和弱引用的使用：  
&emsp; 软引用，弱引用都非常适合来保存那些可有可无的缓存数据，如果这么做，当系统内存不足时，这些缓存数据会被回收，不会导致内存溢出。而当内存资源充足时，这些缓存数据又可以存在相当长的时间，从而起到加速系统的作用。  

-----
# 2. 什么时候回收？  
&emsp; 在可达性分析算法中不可达的对象，也不是一定会死亡的，它们暂时都处于“缓刑”阶段，要真正宣告一个对象“死亡”，至少要经历两次标记过程。  

&emsp; step1：判断有没有必要执行finalize()方法  
&emsp; 如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行`finalize()`方法。  

&emsp; 另外，有两种情况都视为“没有必要执行”：  
* 对象没有覆盖finaliza()方法。  
* finalize()方法已经被虚拟机调用过。  

&emsp; step2：如何执行  
&emsp; 如果这个对象被判定为有必要执行finalize()方法，那么此对象将会放置在一个叫做 F-Queue 的队列中，并在稍后由一个虚拟机自动建立的、低优先级的Finalizer线程去执行它。  

&emsp; step3：执行死亡还是逃脱死亡  
&emsp; 首先，需要知道，finalize()方法是对象逃脱死亡命运的最后一次机会，稍后GC将对F-Queue 队列中的对象进行第二次小规模的标记。  
&emsp; 逃脱死亡：对象想在finalize()方法中成功拯救自己，只要重新与引用链上的任何一个对象建立关联即可，例如把自己（this关键字）赋值给某个类变量或者对象的成员变量，这样在第二次标记时它将被移出“即将回收”的集合。  
&emsp; 执行死亡：对象没有执行逃脱死亡，那就是死亡了。  

-----
# 3. 如何回收？（GC算法）  
&emsp; GC常用的算法：复制（Copying）、标记-清除（Mark-Sweep）、标记-整理（Mark-Compact）、分代收集（新生用复制，老年用标记-压缩）。  

## 3.1. 标记-清除（Mark-Sweep）算法  
![](https://gitee.com/wt1814/pic-host/raw/master/images/java/JVM/JVM-14.png)  
&emsp; 这是最基础的算法，分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，标记完成后统一回收所有被标记的对象。  
&emsp; 适用场景：存活对象较多的情况下比较高效；适用于老年代。 

## 3.2. 复制（Copying）算法（新生代）  
![](https://gitee.com/wt1814/pic-host/raw/master/images/java/JVM/JVM-13.png)  

## 3.3. 标记-整理（Mark-Compact）算法（老年代）  
&emsp; 标记-整理算法是一种老年代的回收算法。  
&emsp; 标记-整理算法的工作过程如图：  
![](https://gitee.com/wt1814/pic-host/raw/master/images/java/JVM/JVM-15.png)  

## 3.4. 分代收集算法  
&emsp; 新生代采用复制算法、老年代采用标记-整理算法。  

# 4. 垃圾回收器  
&emsp; 垃圾收集算法是内存回收的理论基础，而垃圾收集器就是内存回收的具体实现。HotSpot虚拟机所包含的所有收集器如图：  
![](https://gitee.com/wt1814/pic-host/raw/master/images/java/JVM/JVM-28.png)  
&emsp; 上图展示了7种作用于不同分代的收集器。如果两个收集器之间存在连线，那说明它们可以搭配使用。虚拟机所处的区域说明它是属于新生代收集器还是老年代收集器。选择对具体应用最合适的收集器。  
&emsp; 收集器分类：  
* 串行收集器->Serial和Serial Old  
&emsp; 只能有一个垃圾回收线程执行，用户线程暂停。 适用于内存比较小的嵌入式设备 。  
* 并行收集器[吞吐量优先]->Parallel Scanvenge、Parallel Old  
&emsp; 多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。 适用于科学计算、后台处理等若交互场景 。  
* 并发收集器[停顿时间优先]->CMS、G1  
&emsp; 用户线程和垃圾收集线程同时执行(但并不一定是并行的，可能是交替执行的)，垃圾收集线程在执行的时候不会停顿用户线程的运行。 适用于相对时间有要求的场景，比如Web 。  

&emsp; ***理解吞吐量和停顿时间***  
&emsp; 停顿时间->垃圾收集器 进行 垃圾回收终端应用执行响应的时间  
&emsp; 吞吐量->运行用户代码时间/(运行用户代码时间+垃圾收集时间)  

&emsp; 停顿时间越短就越适合需要和用户交互的程序，良好的响应速度能提升用户体验；  
&emsp; 高吞吐量则可以高效地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。  
&emsp; 小结 :这两个指标也是评价垃圾回收器好处的标准，其实调优也就是在观察者两个变量。  

## 4.1. --------新生代收集器  
## 4.2. Serial收集器，单线程收集器  
&emsp; 最基本、发展历史最久的收集器，这个收集器是一个采用复制算法的单线程的收集器，单线程一方面意味着它只会使用一个CPU或一条线程去完成垃圾收集工作，另一方面也意味着它进行垃圾收集时必须暂停其他线程的所有工作，直到它收集结束为止。后者意味着，在用户不可见的情况下要把用户正常工作的线程全部停掉，这对很多应用是难以接受的。不过实际上到目前为止，Serial收集器依然是虚拟机运行在Client模式下的默认新生代收集器，因为它简单而高效。用户桌面应用场景中，分配给虚拟机管理的内存一般来说不会很大，收集几十兆甚至一两百兆的新生代停顿时间在几十毫秒最多一百毫秒，只要不是频繁发生，这点停顿是完全可以接受的。Serial收集器运行过程如下图所示：  
![](https://gitee.com/wt1814/pic-host/raw/master/images/java/JVM/JVM-29.png)  
&emsp; 说明：1.需要STW（Stop The World），停顿时间长。2.简单高效，对于单个CPU环境而言，Serial收集器由于没有线程交互开销，可以获取最高的单线程收集效率。  

## 4.3. ParNew收集器，多线程收集器  
&emsp; ParNew收集器其实就是Serial收集器的多线程版本，除了使用多条线程进行垃圾收集外，其余行为和Serial收集器完全一样，包括使用的也是复制算法。ParNew收集器除了多线程以外和Serial收集器并没有太多创新的地方，但是它却是Server模式下的虚拟机首选的新生代收集器，其中有一个很重要的和性能无关的原因是，除了Serial收集器外，目前只有它能与CMS收集器配合工作。CMS收集器是一款几乎可以认为有划时代意义的垃圾收集器，因为它第一次实现了让垃圾收集线程与用户线程基本上同时工作。ParNew收集器在单CPU的环境中绝对不会有比Serial收集器更好的效果，甚至由于线程交互的开销，该收集器在两个CPU的环境中都不能百分之百保证可以超越Serial收集器。当然，随着可用CPU数量的增加，它对于GC时系统资源的有效利用还是很有好处的。它默认开启的收集线程数与CPU数量相同，在CPU数量非常多的情况下，可以使用-XX:ParallelGCThreads参数来限制垃圾收集的线程数。ParNew收集器运行过程如下图所示：  
![](https://gitee.com/wt1814/pic-host/raw/master/images/java/JVM/JVM-30.png)  

## 4.4. Parallel Scavenge收集器，并行的多线程收集器  
&emsp; Parallel Scavenge收集器也是一个新生代收集器，也是用复制算法的收集器，也是并行的多线程收集器，但是它的特点是它的关注点和其他收集器不同。介绍这个收集器主要还是介绍吞吐量的概念。CMS等收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标则是打到一个可控制的吞吐量。所谓吞吐量的意思就是CPU用于运行用户代码时间与CPU总消耗时间的比值，即吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间），虚拟机总运行100分钟，垃圾收集1分钟，那吞吐量就是99%。另外，Parallel Scavenge收集器是虚拟机运行在Server模式下的默认垃圾收集器。  
&emsp; 停顿时间短适合需要与用户交互的程序，良好的响应速度能提升用户体验；高吞吐量则可以高效率利用CPU时间，尽快完成运算任务，主要适合在后台运算而不需要太多交互的任务。  
&emsp; 虚拟机提供了-XX:MaxGCPauseMillis和-XX:GCTimeRatio两个参数来精确控制最大垃圾收集停顿时间和吞吐量大小。不过不要以为前者越小越好，GC停顿时间的缩短是以牺牲吞吐量和新生代空间换取的。由于与吞吐量关系密切，Parallel Scavenge收集器也被称为“吞吐量优先收集器”。Parallel Scavenge收集器有一个-XX:+UseAdaptiveSizePolicy参数，这是一个开关参数，这个参数打开之后，就不需要手动指定新生代大小、Eden区和Survivor参数等细节参数了，虚拟机会根据当前系统的运行情况手机性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。如果对于垃圾收集器运作原理不太了解，以至于在优化比较困难的时候，使用Parallel Scavenge收集器配合自适应调节策略，把内存管理的调优任务交给虚拟机去完成将是一个不错的选择。  

## 4.5. --------老年代收集器  
## 4.6. Serial Old收集器  
&emsp; Serial收集器的老年代版本，同样是一个单线程收集器，使用“标记-整理算法”，这个收集器的主要意义也是在于给Client模式下的虚拟机使用。 

## 4.7. Parallel Old收集器  
&emsp; Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法。这个收集器在JDK 1.6之后的出现，“吞吐量优先收集器”终于有了比较名副其实的应用组合，在注重吞吐量以及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge收集器+Parallel Old收集器的组合。运行过程如下图所示：  
![](https://gitee.com/wt1814/pic-host/raw/master/images/java/JVM/JVM-31.png)  

### 4.7.1. CMS收集器  
&emsp; CMS（Conrrurent Mark Sweep）收集器是以获取最短回收停顿时间为目标的收集器。使用标记-清除算法，收集过程分为如下四步：  
1).初始标记，标记GCRoots能直接关联到的对象，时间很短。  
2).并发标记，进行GCRoots Tracing（可达性分析）过程，时间很长。  
3).重新标记，修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，时间较长。  
4).并发清除，回收内存空间，时间很长。  
&emsp; 其中，并发标记与并发清除两个阶段耗时最长，但是可以与用户线程并发执行。运行过程如下图所示:  
![](https://gitee.com/wt1814/pic-host/raw/master/images/java/JVM/JVM-32.png)  
&emsp; 说明：1.对CPU资源非常敏感，可能会导致应用程序变慢，吞吐率下降。2.无法处理浮动垃圾，因为在并发清理阶段用户线程还在运行，自然就会产生新的垃圾，而在此次收集中无法收集他们，只能留到下次收集，这部分垃圾为浮动垃圾，同时，由于用户线程并发执行，所以需要预留一部分老年代空间提供并发收集时程序运行使用。3.由于采用的标记 - 清除算法，会产生大量的内存碎片，不利于大对象的分配，可能会提前触发一次Full GC。虚拟机提供了-XX:+UseCMSCompactAtFullCollection参数来进行碎片的合并整理过程，这样会使得停顿时间变长，虚拟机还提供了一个参数配置，-XX:+CMSFullGCsBeforeCompaction，用于设置执行多少次不压缩的Full GC后，接着来一次带压缩的GC。  

## 4.8. G1收集器  
&emsp; G1收集器有以下特点：  
1).并行和并发。使用多个CPU来缩短Stop The World停顿时间，与用户线程并发执行。  
2).分代收集。独立管理整个堆，但是能够采用不同的方式去处理新创建对象和已经存活了一段时间、熬过多次GC的旧对象，以获取更好的收集效果。  
3).空间整合。基于标记 - 整理算法，无内存碎片产生。  
4).可预测的停顿。能简历可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。  
&emsp; G1之前的垃圾收集器，收集的范围都是整个新生代或者老年代，而G1不再是这样。使用G1收集器时，Java堆的内存布局与其他收集器有很大差别，它将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分（可以不连续）Region的集合。  

&emsp; ***开启G1：*** 在JDK9之前，JDK7和JDK8默认都是ParallelGC垃圾回收。到了JDK9，G1才是默认的垃圾回收器。所以如果JDK7或者JDK8需要使用G1的话，需要通过参数（-XX:+UseG1GC）显示执行垃圾回收器。而JDK9以后的版本，不需要任何JVM参数，默认就是G1垃圾回收模式，显示指定G1运行一个Demo程序如下：  

```java
java -Xmx1g -Xms1g -XX:+UseG1GC -XX:MaxGCPauseMillis=200 -jar demo.jar
```
## 4.9. --------  
## 4.10. 常用的收集器组合  

|	|新生代GC策略	|年老代GC策略	|说明|
|---|---|---|---|
|组合1	|Serial	|Serial Old	|Serial和Serial Old都是单线程进行GC，特点就是GC时暂停所有应用线程。|
|组合2	|Serial	|CMS+Serial Old	|CMS（Concurrent Mark Sweep）是并发GC，实现GC线程和应用线程并发工作，不需要暂停所有应用线程。另外，当CMS进行GC失败时，会自动使用Serial Old策略进行GC。|
|组合3	|ParNew	|CMS	|使用-XX:+UseParNewGC选项来开启。ParNew是Serial的并行版本，可以指定GC线程数，默认GC线程数为CPU的数量。可以使用-XX:ParallelGCThreads选项指定GC的线程数。如果指定了选项-XX:+UseConcMarkSweepGC选项，则新生代默认使用ParNew GC策略。|
|组合4	|ParNew	|Serial Old	|使用-XX:+UseParNewGC选项来开启。新生代使用ParNew GC策略，年老代默认使用Serial Old GC策略。|
|组合5	|Parallel Scavenge	|Serial Old	|Parallel Scavenge策略主要是关注一个可控的吞吐量：应用程序运行时间 / (应用程序运行时间 + GC时间)，可见这会使得CPU的利用率尽可能的高，适用于后台持久运行的应用程序，而不适用于交互较多的应用程序。|
|组合6	|Parallel Scavenge	|Parallel Old	|Parallel Old是Serial Old的并行版本|
|组合7	|G1GC	|G1GC	| -XX:+UnlockExperimentalVMOptions -XX:+UseG1GC  <br/>#开启  <br/>-XX:MaxGCPauseMillis =50  #暂停时间目标  <br/>-XX:GCPauseIntervalMillis =200  #暂停间隔目标  <br/>-XX:+G1YoungGenSize=512m  #年轻代大小  <br/>-XX:SurvivorRatio=6  #幸存区比例|

## 4.11. 如何选择合适的垃圾收集器  
&emsp; 官网：https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/collectors.html#sthref28
* 优先调整堆的大小让服务器自己来选择  
* 如果内存小于100M，使用串行收集器  
* 如果是单核，并且没有停顿时间要求，使用串行或JVM自己选  
* 如果允许停顿时间超过1秒，选择并行或JVM自己选  
* 如果响应时间最重要，并且不能超过1秒，使用并发收集器  
* 对于G1收集  

## 4.12. 垃圾收集器常用参数：  
&emsp; -XX:+UseSerialGC：在新生代和老年代使用串行收集器  
&emsp; -XX:+UseParNewGC：在新生代使用并行收集器  
&emsp; -XX:+UseParallelGC：新生代使用并行回收收集器，更加关注吞吐量  
&emsp; -XX:+UseParallelOldGC：老年代使用并行回收收集器  
&emsp; -XX:ParallelGCThreads：设置用于垃圾回收的线程数  
&emsp; -XX:+UseConcMarkSweepGC：新生代使用并行收集器，老年代使用CMS+串行收集器  
&emsp; -XX:ParallelCMSThreads：设定CMS的线程数量  
&emsp; -XX:+UseG1GC：启用G1垃圾回收器  

# 5. GC类型：Minor GC和Full GC/Major GC  
&emsp; JVM的内存被分为了三个主要部分：新生代，老年代和永久代。  
![](https://gitee.com/wt1814/pic-host/raw/master/images/java/JVM/JVM-33.png)  

## 5.1. Minor GC：  
1) 新生成的对象优先放在年轻代。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。
2) 新生代内存按照8:1:1的比例分为一个eden区和两个survivor区。大部分对象在Eden区中生成。当Eden占用完时，垃圾回收器进行回收。回收时先将eden区存活对象复制到一个survivor0区，然后清空eden区，当这个survivor0区也存放满了时，则将eden区和survivor0区（使用的survivor中的对象也可能失去引用）存活对象复制到另一个survivor1区，然后清空eden和这个survivor0区，此时survivor0区是空的，然后将survivor0区和survivor1区交换，即保持survivor1区为空， 如此往复。
4) 新生代发生的GC也叫做Minor GC，MinorGC发生频率比较高(不一定等Eden区满了才触发)。
对象每经历一次Minor GC，年龄加1，达到“晋升年龄阈值”后，被放到老年代，这个过程也称为“晋升”。显然，“晋升年龄阈值”的大小直接影响着对象在新生代中的停留时间，在Serial和ParNew GC两种回收器中，“晋升年龄阈值”通过参数MaxTenuringThreshold设定，默认值为15。
Minor GC触发条件：当Eden空间满时，就将触发一次Minor GC。  

## 5.2. Major GC / Full GC  
&emsp; Major GC：老年代（Old Generation）：在新生代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代，该区域中对象存活率高。老年代的垃圾回收，又称Major GC，通常使用“标记-清理”或“标记-整理”算法。  
&emsp; Full GC：整堆包括新生代和老年代的垃圾回收称为Full GC（HotSpot VM里，除了CMS之外，其它能收集老年代的GC都会同时收集整个GC堆，包括新生代）。  

&emsp; 老年代对象其存活时间长，因此Full GC很少执行。老年代内存比新生代也大很多(大概比例是2:1)。Full GC执行速度会比Minor GC慢很多，Full GC一般会比Minor GC慢10倍以上。Major GC也会触发STW（Stop the World）。所以，对于响应性的应用程序，应该尽量避免Major GC。还要注意，Major GC的STW的时长受年老代垃圾回收器类型的影响。STW会造成系统A内部的工作线程大量的卡顿，不再工作。要等JVM FullGC结束之后，工作线程才会恢复运作。  

&emsp; ***Full GC的触发条件：***  
1. 调用System.gc()  
只是建议虚拟机执行Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。  
2. 老年代空间不足  
老年代空间不足的常见场景为大对象直接进入老年代、长期存活的对象进入老年代等。  
为了避免以上原因引起的Full GC，应当尽量不要创建过大的对象以及数组。除此之外，可以通过-Xmn虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。还可以通过 -XX:MaxTenuringThreshold 调大对象进入老年代的年龄，让对象在新生代多存活一段时间。  
3. 空间分配担保失败  
使用复制算法的Minor GC需要老年代的内存空间作担保，如果担保失败会执行一次Full GC。  
4. JDK 1.7及以前的永久代空间不足  
为避免以上原因引起的Full GC，可采用的方法为增大永久代空间或转为使用 CMS GC。  
5. Concurrent Mode Failure  
执行CMS GC的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是GC过程中浮动垃圾过多导致暂时性的空间不足），便会报 Concurrent Mode Failure错误，并触发Full GC。  

## 5.3. Stop the world  
&emsp; Java中Stop-The-World机制简称STW，是在执行垃圾收集时，Java应用程序的其他所有线程都被挂起（除了垃圾收集帮助器之外）。Java中一种全局暂停现象，全局停顿，所有Java代码停止，native代码可以执行，但不能与JVM交互；这些现象多半是由于gc引起。  
&emsp; GC时的Stop the World(STW)是大家最大的敌人。但可能很多人还不清楚，除了GC，JVM下还会发生停顿现象。  
&emsp; JVM里有一条特殊的线程－－VM Threads，专门用来执行一些特殊的VM Operation，比如分派GC，thread dump等，这些任务，都需要整个Heap，以及所有线程的状态是静止的，一致的才能进行。所以JVM引入了安全点(Safe Point)的概念，想办法在需要进行VM Operation时，通知所有的线程进入一个静止的安全点。  

&emsp; 除了GC，其他触发安全点的VM Operation包括：  
1. JIT相关，比如Code deoptimization, Flushing code cache ；  
2. Class redefinition (e.g. javaagent，AOP代码植入的产生的instrumentation) ；  
3. Biased lock revocation 取消偏向锁 ；  
4. Various debug operation (e.g. thread dump or deadlock check)；  



