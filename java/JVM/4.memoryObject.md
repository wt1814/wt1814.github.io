---
title: 内存中对象
date: 2020-03-25 00:00:00
tags:
    - JVM
---

<!-- TOC -->

- [1. 内存中对象](#1-内存中对象)
    - [1.1. 对象的创建](#11-对象的创建)
    - [1.2. 对象的内存布局](#12-对象的内存布局)
    - [1.3. 对象的访问定位](#13-对象的访问定位)

<!-- /TOC -->


# 1. 内存中对象  
## 1.1. 对象的创建  
&emsp; 简述一下 Java 中创建一个对象的过程？  
&emsp; 解析：回答这个问题首先就要清楚类的生命周期  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/JVM/JVM-5.png)  
&emsp; Java中对象的创建就是在堆上分配内存空间的过程，此处说的对象创建仅限于new关键字创建的普通Java对象，不包括数组对象的创建。  
1. 检测类是否被加载  
&emsp; 当虚拟机执行到new时，会先去常量池中查找这个类的符号引用。如果能找到符号引用，说明此类已经被加载到方法区（方法区存储虚拟机已经加载的类的信息），可以继续执行；如果找不到符号引用，就会使用类加载器执行类的加载过程，类加载完成后继续执行。  
2. 为对象分配内存  
&emsp; 类加载完成以后，虚拟机就开始为对象分配内存，此时所需内存的大小就已经确定了。只需要在堆上分配所需要的内存即可。  
&emsp; 具体的分配内存有两种情况：第一种情况是内存空间绝对规整，第二种情况是内存空间是不连续的。  
    * 对于内存绝对规整的情况相对简单一些，虚拟机只需要在被占用的内存和可用空间之间移动指针即可，这种方式被称为指针碰撞。
    * 对于内存不规整的情况稍微复杂一点，这时候虚拟机需要维护一个列表，来记录哪些内存是可用的。分配内存的时候需要找到一个可用的内存空间，然后在列表上记录下已被分配，这种方式成为空闲列表。  
&emsp; 分配内存的时候也需要考虑线程安全问题，有两种解决方案：  
    * 第一种是采用同步的办法，使用CAS来保证操作的原子性。
    * 另一种是每个线程分配内存都在自己的空间内进行，即是每个线程都在堆中预先分配一小块内存，称为本地线程分配缓冲（TLAB），分配内存的时候再TLAB上分配，互不干扰。
3. 为分配的内存空间初始化零值  
&emsp; 对象的内存分配完成后，还需要将对象的内存空间都初始化为零值，这样能保证对象即使没有赋初值，也可以直接使用。  
4. 对对象进行其他设置  
&emsp; 分配完内存空间，初始化零值之后，虚拟机还需要对对象进行其他必要的设置，设置的地方都在对象头中，包括这个对象所属的类，类的元数据信息，对象的hashcode，GC分代年龄等信息。  
5. 执行init方法  
&emsp; 执行完上面的步骤之后，在虚拟机里这个对象就算创建成功了，但是对于Java程序来说还需要执行init方法才算真正的创建完成，因为这个时候对象只是被初始化零值了，还没有真正的去根据程序中的代码分配初始值，调用了init方法之后，这个对象才真正能使用。  

&emsp; 到此为止一个对象就产生了，这就是new关键字创建对象的过程。过程如下：  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/JVM/JVM-60.png)  

## 1.2. 对象的内存布局  
&emsp; 对象的内存布局包括三个部分：对象头，实例数据和对齐填充。

* 对象头：对象头包括两部分信息，第一部分是存储对象自身的运行时数据，如哈希码，GC分代年龄，锁状态标志，线程持有的锁等等。第二部分是类型指针，即对象指向类元数据的指针。  
* 实例数据：就是数据  
* 对齐填充：不是必然的存在，就是为了对齐  

## 1.3. 对象的访问定位  
&emsp; 对象的访问定位有两种：句柄定位和直接指针  

* 句柄定位：Java 堆会画出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/JVM/JVM-58.png)  
* 直接指针访问：java堆对象的不居中就必须考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象地址  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/JVM/JVM-59.png)  
