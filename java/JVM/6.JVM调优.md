---
title: JVM调优
date: 2020-03-28 00:00:00
tags:
    - JVM
---

* 获取堆内存日志，调整内存比例或者gc回收堆策略；  
* 获取堆heap快照，排查内存溢出的问题；  
* 获取线程stack快照，排查CPU飚高，Full GC频繁；  

### JVM参数  
&emsp; JDK1.6中JVM参数主要可以分为以下三类：  
* 标准参数（-），所有的JVM实现都必须实现这些参数的功能，而且向后兼容。  
* 非标准参数（-X），默认JVM实现这些参数的功能，但是并不保证所有JVM实现都满足，且不保证向后兼容。  
* 非Stable参数（-XX），此类参数各个JVM实现会有所不同，将来可能会随时取消，需要慎重使用。分Boolean类型和非Boolean类型：  
1). Boolean类型  
格式：-XX:[+-]<name> +或-表示启用或者禁用name属性  
比如：-XX:+UseConcMarkSweepGC 表示启用CMS类型的垃圾回收器  
&emsp; &emsp; &emsp;-XX:+UseG1GC 表示启用G1类型的垃圾回收器  
2). 非Boolean类型  
格式：-XX<name>=<value>表示name属性的值是value  
比如：-XX:MaxGCPauseMillis=500  


&emsp; ***设置参数的方式：***  
* 开发工具中设置比如IDEA，eclipse  
* 运行jar包的时候:java -XX:+UseG1GC xxx.jar  
* web容器比如tomcat，可以在脚本中的进行设置  
* 通过jinfo实时调整某个java进程的参数(参数只有被标记为manageable的flags可以被实时修改)  
### GC日志分析  

#### JVM GC相关的参数  

|参数	|描述|
|---|---|
|-verbose:gc	|开启输出JVM GC日志|
|-verbose:class 	|查看类加载信息明细|
|-Xloggc:./gc.log	|指定GC日志目录和文件名|
|-XX:+PrintGCDetails 	|GC日志打印详细信息|
|-XX:+PrintGCDateStamps	|GC日志打印时间戳信息|
|-XX:+PrintHeapAtGC	|在GC前后打印GC日志|
|-XX:+PrintGCApplicationStoppedTime	|打印应用暂停时间|
|-XX:+PrintGCApplicationConcurrentTime	|打印每次垃圾回收前，程序未中断的执行时间|
| | |
|-XX:+HeapDumpOnOutOfMemoryError	|当发生OOM(OutOfMemory)时，自动转储堆内存快照，缺省情况未指定目录时，JVM 会创建一个名称为 java_pidPID.hprof 的堆 dump 文件在 JVM 的工作目录下|
|-XX:HeapDumpPath=/data/log/gc/dump/	|指定OOM时堆内存转储快照位置|
|-XX:+PrintClassHistogramBeforeFullGC、-XX:+PrintClassHistogramAfterFullGC	|Full GC前后打印跟踪类视图|
|-XX:+PrintTenuringDistribution	|打印Young GC各个年龄段的对象分布|
|-XX:+PrintTLAB	|打印TLAB(线程本地分配缓存区)空间使用情况|
#### GC日志详解：  
&emsp; 在某个应用中，配置  

```java
-XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xloggc:D:/gc.log
```
&emsp; 启动后打印如下 GC 日志：  
&emsp; YongGC  

```java
2019-04-18T14:52:06.790+0800: 2.653: [GC (Allocation Failure) [PSYoungGen: 33280K->5113K(38400K)] 33280K->5848K(125952K), 0.0095764 secs] [Times: user=0.00 sys=0.00, real=0.01 secs]
```
&emsp; 含义：  

```java
2019-04-18T14:52:06.790+0800（当前时间戳）: 2.653（应用启动基准时间）: [GC (Allocation Failure) [PSYoungGen（表示 Young GC）: 33280K（年轻代回收前大小）->5113K（年轻代回收后大小）(38400K（年轻代总大小）)] 33280K（整个堆回收前大小）->5848K（整个堆回收后大小）(125952K（堆总大小）), 0.0095764（耗时） secs] [Times: user=0.00（用户耗时） sys=0.00（系统耗时）, real=0.01（实际耗时） secs]
```
&emsp; Full GC  

```java
2019-04-18T14:52:15.359+0800: 11.222: [Full GC (Metadata GC Threshold) [PSYoungGen: 6129K->0K(143360K)] [ParOldGen: 13088K->13236K(55808K)] 19218K->13236K(199168K), [Metaspace: 20856K->20856K(1069056K)], 0.1216713 secs] [Times: user=0.44 sys=0.02, real=0.12 secs]
```
&emsp; 含义：  

```java
2019-04-18T14:52:15.359+0800（当前时间戳）: 11.222（应用启动基准时间）: [Full GC (Metadata GC Threshold) [PSYoungGen: 6129K（年轻代回收前大小）->0K（年轻代回收后大小）(143360K（年轻代总大小）)] [ParOldGen: 13088K（老年代回收前大小）->13236K（老年代回收后大小）(55808K（老年代总大小）)] 19218K（整个堆回收前大小）->13236K（整个堆回收后大小）(199168K（堆总大小）), [Metaspace: 20856K（持久代回收前大小）->20856K（持久代回收后大小）(1069056K（持久代总大小）)], 0.1216713（耗时） secs] [Times: user=0.44（用户耗时） sys=0.02（系统耗时）, real=0.12（实际耗时） secs]
```
&emsp; ***GC日志格式详解：***  
&emsp; 每种收集器的日志形式都是由它们自身的实现所决定的，换言之，每种收集器的日志格式都可以不一样。不过虚拟机为了方便用户阅读，将各个收集器的日志都维持了一定的共性。例如上面一段GC日志：  
1. 日志的开头“GC”、“Full GC”表示这次垃圾收集的停顿类型，而不是用来区分新生代GC还是老年代GC的。如果有Full，则说明本次GC停止了其他所有工作线程(Stop-The-World)。Full GC，一般是因为出现了分配担保失败之类的问题，所以才导致STW。如果是调用System.gc()方法所触发的收集，将显示“Full GC(System)”。  
2. “GC”中接下来的“[DefNew”、“[Tenured”、“[Prem”表示GC发生的区域，这里显示的区域名称与使用的GC收集器是密切相关的，例如上面样例所使用的Serial收集器中的新生代名为“Default New Generation”，所以显示的是“[DefNew”。如果是ParNew收集器，新生代名称就会变为“[ParNew”，意为“Parallel New Generation”。如果采用Parallel Scavenge收集器，那它配套的新生代称为“PSYoungGen”，老年代和永久代同理，名称也是由收集器决定的。  
3. 后面方括号内部的“310K->194K(2368K)”、“2242K->0K(2368K)”，指的是该区域已使用的容量->GC后该内存区域已使用的容量(该内存区总容量)。方括号外面的“310K->194K(7680K)”、“2242K->2241K(7680K)”则指的是GC前Java堆已使用的容量->GC后Java堆已使用的容量(Java堆总容量)。  
4. 再往后“0.0269163 secs”表示该内存区域GC所占用的时间，单位是秒。有的收集器会给出更具体的时间数据，如“[Times: user=0.00 sys=0.00 real=0.03 secs]”，这里面的user、sys和real与Linux的time命令所输出的时间含义一致，分别表示用户态消耗的CPU时间、内核态消耗的CPU时间、操作从开始到结束经过的墙钟时间。CPU时间与墙钟时间的区别是，墙钟时间包括各种非运算的等待消耗，比如等待磁盘I/O、等待线程阻塞，而CPU时间不包括这些耗时，但当系统有多CPU或者多核的话，多线程操作会叠加这些CPU时间，所以如果看到user或sys时间超过real时间是完全正常的。  
5. “Heap”后面就列举出堆内存目前各个年代的区域的内存情况。  

#### GC日志分析工具：  
下文讲解



