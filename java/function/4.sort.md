---
title: 排序算法  
date: 2020-06-04 00:00:00
tags:
    - 算法
---


# 排序算法分类  
&emsp; 排序算法这么多，这里先将排序算法做个简单分类：  
* 根据待排序的数据量规模分类：  
    * 内部排序：在排序过程中，待排序的数据能够被全部加载进内存中。  
    &emsp; 常见的内部排序算法有：冒泡排序、快速排序；选择排序、堆排序；插入排序、希尔排序；归并排序；基数排序等。
    * 外部排序：待排序的数据太大，不能全部同时放入内存，排序过程中需要内存与外部存储交换数据。  

    &emsp; 内部排序是数据记录在内存中进行排序。而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。  

* 是否采用比较思想：
    * 比较类排序：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序。    
    * 非比较类排序：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。   

    ***比较和非比较的区别：***  


* 基于算法思想分类：
    * 基于交换：冒泡排序、快速排序  
    * 基于选择：选择排序、堆排序  
    * 基于插入：插入排序、希尔排序  
    * 基于分治：快速排序、归并排序  

* 根据排序时间复杂度分类：  
    * O(N)：桶排序、计数排序、基数排序  
    * O(NlogN)：快速排序、希尔排序、归并排序、堆排序  
    * O(N*N)：冒泡排序、插入排序、选择排序  

* 根据排序的稳定性进行分类：  

        稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。
        不稳定：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。
    * 稳定性排序：冒泡排序、插入排序、归并排序  
    * 不稳定排序：快速排序、选择排序、希尔排序、堆排序  

# 冒泡排序  
&emsp; 冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。   
&emsp; ***算法描述：***
1. 比较相邻的元素。如果第一个比第二个大，就交换它们两个；  
2. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素会是最大的数；  
3. 针对所有的元素重复以上的步骤，除了最后一个；  
4. 重复步骤1~3，直到排序完成。  

&emsp; ***优化一：***  
&emsp; 某一次排序后，整个排序都已经完成了，但是常规版还是会继续排序。可以设置一个标志位，用来表示当前第 i 趟是否有交换，如果有则要进行 i+1 趟，如果没有，则说明当前数组已经完成排序。  

&emsp; ***优化二：***  
&emsp; 第i趟排的第 i 小或者大的元素已经在第 i 位上了，甚至可能第 i-1 位也已经归位了，那么在内层循环的时候，有这种情况出现就会导致多余的比较出现。例如：6，4，7，5，1，3，2，当进行第一次排序的时候，结果为6，7，5，4，3，2，1，实际上后面有很多次交换比较都是多余的，因为没有产生交换操作。
利用一个标志位，记录一下当前第 i 趟所交换的最后一个位置的下标，在进行第 i+1 趟的时候，只需要内循环到这个下标的位置就可以了，因为后面位置上的元素在上一趟中没有换位，这一次也不可能会换位置了。  

&emsp; ***编码：***
```
/**
 * 冒泡排序优化版
 * @param array
 */
public static void sort(int array[])
{
    int tmp  = 0;
    //记录最后一次交换的位置
    int lastExchangeIndex = 0;
    //无序数列的边界，每次比较只需要比到这里为止
    int sortBorder = array.length - 1;
    for(int i = 0; i < array.length; i++)
    {
        //有序标记，每一轮的初始是true
        boolean isSorted = true;

        for(int j = 0; j < sortBorder; j++)
        {
            if(array[j] > array[j+1])
            {
                tmp = array[j];
                array[j] = array[j+1];
                array[j+1] = tmp;
                //有元素交换，所以不是有序，标记变为false
                isSorted = false;
                //把无序数列的边界更新为最后一次交换元素的位置
                lastExchangeIndex = j;
            }
        }
        sortBorder = lastExchangeIndex;
        if(isSorted){
            break;
        }
    }
}

public static void main(String[] args){
    int[] array = new int[]{3,4,2,1,5,6,7,8};
    sort(array);
    System.out.println(Arrays.toString(array));
}
```

&emsp; ***算法分析：***  
&emsp; 最佳情况：T(n) = O(n)   最差情况：T(n) = O(n2)   平均情况：T(n) = O(n2)  


# 快速排序  
&emsp; 快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。  
&emsp; ***算法描述：***  
1. 选择一个基准元素；  
2. 通过一趟排序将待排序的记录分割成独立的两部分，其中一部分记录的元素值均比基准元素值小。另一部分记录的元素值比基准值大；  
3. 此时基准元素在其排好序后的正确位置；  
4. 然后分别对这两部分记录用同样的方法继续进行排序，直到整个序列有序。  

&emsp; ***基准元素的选择，以及元素的移动是快速排序的核心问题。***  
* 基准元素的选择：  
&emsp; 最简单的方式是选择数列的第一个元素。但是当它为最大值或最小值时，快速排序的效率会严重降低。折中的方法是找到数组中的第一个、最后一个以及处于中间位置的元素，选出三者的中值作为枢纽，既避免了枢纽是最值的情况，也不会像在全部元素中寻找中值那样费时间。这种方法被称为“三项取中法”
(median-of-three)。  
* 元素的移动：  
&emsp; 选定了基准元素以后，把其他元素当中小于基准元素的都移动到基准元素一边，大于基准元素的都移动到基准元素另一边。
&emsp; 具体如何实现呢？有两种方法：双边循环法、单边循环法。  

&emsp; ***编码：***  
&emsp; ***递归实现（包含单边循环、双边循环）：***  

```
public static void quickSort(int[] arr, int startIndex, int endIndex) {
        // 递归结束条件：startIndex大等于endIndex的时候
        if (startIndex >= endIndex) {
            return;
        }
        // 得到基准元素位置
        int pivotIndex = partition(arr, startIndex, endIndex);
        // 根据基准元素，分成两部分递归排序
        quickSort(arr, startIndex, pivotIndex - 1);
        quickSort(arr, pivotIndex + 1, endIndex);
    }

    /**
     * 分治（双边循环法）
     * @param arr     待交换的数组
     * @param startIndex    起始下标
     * @param endIndex    结束下标
     */
    private static int partition(int[] arr, int startIndex, int endIndex) {
        // 取第一个位置的元素作为基准元素（也可以选择随机位置）
        int pivot = arr[startIndex];
        int left = startIndex;
        int right = endIndex;

        while( left != right) {
            //控制right指针比较并左移
            while(left<right && arr[right] > pivot){
                right--;
            }
            //控制left指针比较并右移
            while( left<right && arr[left] <= pivot) {
                left++;
            }
            //交换left和right指向的元素
            if(left<right) {
                int p = arr[left];
                arr[left] = arr[right];
                arr[right] = p;
            }
        }

        //pivot和指针重合点交换
        arr[startIndex] = arr[left];
        arr[left] = pivot;

        return left;
    }

    /**
     * 分治（单边循环法）
     * @param arr     待交换的数组
     * @param startIndex    起始下标
     * @param endIndex    结束下标
     */
    private static int partitionV2(int[] arr, int startIndex, int endIndex) {
        // 取第一个位置的元素作为基准元素（也可以选择随机位置）
        int pivot = arr[startIndex];
        int mark = startIndex;

        for(int i=startIndex+1; i<=endIndex; i++){
            if(arr[i]<pivot){
                mark ++;
                int p = arr[mark];
                arr[mark] = arr[i];
                arr[i] = p;
            }
        }

        arr[startIndex] = arr[mark];
        arr[mark] = pivot;
        return mark;
    }

    public static void main(String[] args) {
        int[] arr = new int[] {4,4,6,5,3,2,8,1};
        quickSort(arr, 0, arr.length-1);
        System.out.println(Arrays.toString(arr));
    }
```

&emsp; ***算法分析：***  
&emsp; 最佳情况：T(n) = O(nlogn)   最差情况：T(n) = O(n2)   平均情况：T(n) = O(nlogn)　  

# 直接选择排序  

&emsp; 从第一个元素开始，扫描整个待排数组，找到最小的元素放之后再与第一个元素交换位置，然后再从第二个元素开始，继续寻找最小的元素与第二个元素交换位置，依次类推。  

&emsp; 表现最稳定的排序算法之一，因为无论什么数据进去都是O(n2)的时间复杂度，所以用到它的时候，数据规模越小越好。好处就是不占用额外的内存空间。  
## 算法描述：  
1. 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置
2. 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。
3. 重复第二步，直到所有元素均排序完毕。  

&emsp; ***优化：***  
&emsp; 每趟排序确定两个最值——最大值与最小值，这样就可以将排序趟数缩减一半。  

## 编码：  

## 算法分析：  

