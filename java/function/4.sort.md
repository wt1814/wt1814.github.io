---
title: 排序算法  
date: 2020-06-04 00:00:00
tags:
    - 算法
---

<!-- TOC -->

- [1. 排序算法分类](#1-排序算法分类)
- [2. 冒泡排序](#2-冒泡排序)
    - [2.1. 算法描述](#21-算法描述)
    - [2.2. 编码](#22-编码)
- [3. 快速排序](#3-快速排序)
    - [3.1. 算法描述](#31-算法描述)
    - [3.2. 编码](#32-编码)
- [4. 直接选择排序](#4-直接选择排序)
    - [4.1. 算法描述](#41-算法描述)
    - [4.2. 编码](#42-编码)
- [5. 堆排序](#5-堆排序)
    - [5.1. 算法描述](#51-算法描述)
    - [5.2. 编码](#52-编码)
- [6. 直接插入排序](#6-直接插入排序)
    - [6.1. 算法描述](#61-算法描述)
    - [6.2. 编码](#62-编码)
    - [6.3. 二分插入排序](#63-二分插入排序)
    - [6.4. 二路插入排序](#64-二路插入排序)
- [7. 希尔排序](#7-希尔排序)
    - [7.1. 算法描述](#71-算法描述)
    - [7.2. 编码](#72-编码)
- [8. 归并排序](#8-归并排序)
    - [8.1. 算法描述](#81-算法描述)
    - [8.2. 编码：](#82-编码)
- [9. 计数排序](#9-计数排序)
    - [9.1. 算法描述](#91-算法描述)
    - [9.2. 编码](#92-编码)
- [10. 桶排序](#10-桶排序)
    - [10.1. 算法描述](#101-算法描述)
    - [10.2. 编码](#102-编码)
- [11. 基数排序](#11-基数排序)
    - [11.1. 算法描述](#111-算法描述)
    - [11.2. 编码](#112-编码)
- [12. 八大排序算法总结](#12-八大排序算法总结)

<!-- /TOC -->

# 1. 排序算法分类  
&emsp; 排序算法这么多，这里先将排序算法做个简单分类：  
* 根据待排序的数据量规模分类：  
    * 内部排序：在排序过程中，待排序的数据能够被全部加载进内存中。  
    &emsp; 常见的内部排序算法有：冒泡排序、快速排序；选择排序、堆排序；插入排序、希尔排序；归并排序；基数排序等。
    * 外部排序：待排序的数据太大，不能全部同时放入内存，排序过程中需要内存与外部存储交换数据。  

    &emsp; 内部排序是数据记录在内存中进行排序。而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。  

* 是否采用比较思想：
    * 比较类排序：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序。    
    * 非比较类排序：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。   

    ***比较和非比较的区别：***  


* 基于算法思想分类：
    * 基于交换：冒泡排序、快速排序  
    * 基于选择：选择排序、堆排序  
    * 基于插入：插入排序、希尔排序  
    * 基于分治：快速排序、归并排序  

* 根据排序时间复杂度分类：  
    * O(N)：桶排序、计数排序、基数排序  
    * O(NlogN)：快速排序、希尔排序、归并排序、堆排序  
    * O(N*N)：冒泡排序、插入排序、选择排序  

* 根据排序的稳定性进行分类：  

        稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。
        不稳定：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。
    * 稳定性排序：冒泡排序、插入排序、归并排序  
    * 不稳定排序：快速排序、选择排序、希尔排序、堆排序  

# 2. 冒泡排序  
&emsp; 冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。   

## 2.1. 算法描述
1. 比较相邻的元素。如果第一个比第二个大，就交换它们两个；  
2. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素会是最大的数；  
3. 针对所有的元素重复以上的步骤，除了最后一个；  
4. 重复步骤1~3，直到排序完成。  

&emsp; ***优化一：***  
&emsp; 某一次排序后，整个排序都已经完成了，但是常规版还是会继续排序。可以设置一个标志位，用来表示当前第 i 趟是否有交换，如果有则要进行 i+1 趟，如果没有，则说明当前数组已经完成排序。  

&emsp; ***优化二：***  
&emsp; 第i趟排的第 i 小或者大的元素已经在第 i 位上了，甚至可能第 i-1 位也已经归位了，那么在内层循环的时候，有这种情况出现就会导致多余的比较出现。例如：6，4，7，5，1，3，2，当进行第一次排序的时候，结果为6，7，5，4，3，2，1，实际上后面有很多次交换比较都是多余的，因为没有产生交换操作。
利用一个标志位，记录一下当前第 i 趟所交换的最后一个位置的下标，在进行第 i+1 趟的时候，只需要内循环到这个下标的位置就可以了，因为后面位置上的元素在上一趟中没有换位，这一次也不可能会换位置了。  

## 2.2. 编码  
```
/**
 * 冒泡排序优化版
 * @param array
 */
public static void sort(int array[])
{
    int tmp  = 0;
    //记录最后一次交换的位置
    int lastExchangeIndex = 0;
    //无序数列的边界，每次比较只需要比到这里为止
    int sortBorder = array.length - 1;
    for(int i = 0; i < array.length; i++)
    {
        //有序标记，每一轮的初始是true
        boolean isSorted = true;

        for(int j = 0; j < sortBorder; j++)
        {
            if(array[j] > array[j+1])
            {
                tmp = array[j];
                array[j] = array[j+1];
                array[j+1] = tmp;
                //有元素交换，所以不是有序，标记变为false
                isSorted = false;
                //把无序数列的边界更新为最后一次交换元素的位置
                lastExchangeIndex = j;
            }
        }
        sortBorder = lastExchangeIndex;
        if(isSorted){
            break;
        }
    }
}

public static void main(String[] args){
    int[] array = new int[]{3,4,2,1,5,6,7,8};
    sort(array);
    System.out.println(Arrays.toString(array));
}
```


# 3. 快速排序  
&emsp; 快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。  

## 3.1. 算法描述  
1. 选择一个基准元素；  
2. 通过一趟排序将待排序的记录分割成独立的两部分，其中一部分记录的元素值均比基准元素值小。另一部分记录的元素值比基准值大；  
3. 此时基准元素在其排好序后的正确位置；  
4. 然后分别对这两部分记录用同样的方法继续进行排序，直到整个序列有序。  

&emsp; ***基准元素的选择，以及元素的移动是快速排序的核心问题。***  
* 基准元素的选择：  
&emsp; 最简单的方式是选择数列的第一个元素。但是当它为最大值或最小值时，快速排序的效率会严重降低。折中的方法是找到数组中的第一个、最后一个以及处于中间位置的元素，选出三者的中值作为枢纽，既避免了枢纽是最值的情况，也不会像在全部元素中寻找中值那样费时间。这种方法被称为“三项取中法”
(median-of-three)。  
* 元素的移动：  
&emsp; 选定了基准元素以后，把其他元素当中小于基准元素的都移动到基准元素一边，大于基准元素的都移动到基准元素另一边。
&emsp; 具体如何实现呢？有两种方法：双边循环法、单边循环法。  

## 3.2. 编码  
&emsp; ***递归实现（包含单边循环、双边循环）：***  

```
public static void quickSort(int[] arr, int startIndex, int endIndex) {
        // 递归结束条件：startIndex大等于endIndex的时候
        if (startIndex >= endIndex) {
            return;
        }
        // 得到基准元素位置
        int pivotIndex = partition(arr, startIndex, endIndex);
        // 根据基准元素，分成两部分递归排序
        quickSort(arr, startIndex, pivotIndex - 1);
        quickSort(arr, pivotIndex + 1, endIndex);
    }

    /**
     * 分治（双边循环法）
     * @param arr     待交换的数组
     * @param startIndex    起始下标
     * @param endIndex    结束下标
     */
    private static int partition(int[] arr, int startIndex, int endIndex) {
        // 取第一个位置的元素作为基准元素（也可以选择随机位置）
        int pivot = arr[startIndex];
        int left = startIndex;
        int right = endIndex;

        while( left != right) {
            //控制right指针比较并左移
            while(left<right && arr[right] > pivot){
                right--;
            }
            //控制left指针比较并右移
            while( left<right && arr[left] <= pivot) {
                left++;
            }
            //交换left和right指向的元素
            if(left<right) {
                int p = arr[left];
                arr[left] = arr[right];
                arr[right] = p;
            }
        }

        //pivot和指针重合点交换
        arr[startIndex] = arr[left];
        arr[left] = pivot;

        return left;
    }

    /**
     * 分治（单边循环法）
     * @param arr     待交换的数组
     * @param startIndex    起始下标
     * @param endIndex    结束下标
     */
    private static int partitionV2(int[] arr, int startIndex, int endIndex) {
        // 取第一个位置的元素作为基准元素（也可以选择随机位置）
        int pivot = arr[startIndex];
        int mark = startIndex;

        for(int i=startIndex+1; i<=endIndex; i++){
            if(arr[i]<pivot){
                mark ++;
                int p = arr[mark];
                arr[mark] = arr[i];
                arr[i] = p;
            }
        }

        arr[startIndex] = arr[mark];
        arr[mark] = pivot;
        return mark;
    }

    public static void main(String[] args) {
        int[] arr = new int[] {4,4,6,5,3,2,8,1};
        quickSort(arr, 0, arr.length-1);
        System.out.println(Arrays.toString(arr));
    }
```

# 4. 直接选择排序  
&emsp; 从第一个元素开始，扫描整个待排数组，找到最小的元素放之后再与第一个元素交换位置，然后再从第二个元素开始，继续寻找最小的元素与第二个元素交换位置，依次类推。  
&emsp; 表现最稳定的排序算法之一，因为无论什么数据进去都是O(n2)的时间复杂度，所以用到它的时候，数据规模越小越好。好处就是不占用额外的内存空间。  

## 4.1. 算法描述  
1. 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置
2. 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。
3. 重复第二步，直到所有元素均排序完毕。  

&emsp; ***优化：***  
&emsp; 每趟排序确定两个最值——最大值与最小值，这样就可以将排序趟数缩减一半。  

## 4.2. 编码  

```
 /**
     * 选择排序
     * @param array
     * @return
     */
    public static int[] selectionSort(int[] array) {
        if (array.length == 0)
            return array;
        for (int i = 0; i < array.length; i++) {
            int minIndex = i;
            for (int j = i; j < array.length; j++) {
                if (array[j] < array[minIndex]) //找到最小的数
                    minIndex = j; //将最小数的索引保存
            }
            int temp = array[minIndex];
            array[minIndex] = array[i];
            array[i] = temp;
        }
        return array;
    }


    /**
     * 选择排序改进版
     * @param array
     */
    public static void selectionSort_improvement(int[] array){
        int minPoint;  //存储最小元素的小标
        int maxPoint;  //存储最大元素的小标
        int len = array.length;
        int temp;
        int counter = 1;

        for(int i=0;i<len/2;i++){
            minPoint= i;
            maxPoint= i;
            for(int j=i+1;j<=len-1-i;j++){  //每完成一轮排序，就确定了两个最值，下一轮排序时比较范围减少两个元素
                if(array[j]<array[minPoint]){  //如果待排数组中的某个元素比当前元素小，minPoint指向该元素的下标
                    minPoint= j;
                    continue;
                }else if(array[j]>array[maxPoint]){  //如果待排数组中的某个元素比当前元素大，maxPoint指向该元素的下标
                    maxPoint= j;
                }
            }

            if(minPoint!=i){  //如果发现了更小的元素，与第一个元素交换位置
                temp= array[i];
                array[i]= array[minPoint];
                array[minPoint]= temp;

                //原来的第一个元素已经与下标为minPoint的元素交换了位置
                //如果之前maxPoint指向的是第一个元素，那么需要将maxPoint重新指向array[minPoint]
                //因为现在array[minPoint]存放的才是之前第一个元素中的数据
                if(maxPoint== i){
                    maxPoint= minPoint;
                }

            }

            if(maxPoint!=len-1-i){  //如果发现了更大的元素，与最后一个元素交换位置
                temp= array[len-1-i];
                array[len-1-i]= array[maxPoint];
                array[maxPoint]= temp;
            }
            System.out.print("第"+counter+"轮排序结果：");
            System.out.println(Arrays.toString(array));
            counter++;
        }
    }


    public static void main(String[] args) {
        int[] arr = new int[] {4,7,6,5,3,2,8,1};
        selectionSort_improvement(arr);
    }
```


# 5. 堆排序  
&emsp; 首先了解二叉堆。二叉堆的特性：1.最大堆的堆定是整个堆中堆最大元素；2.最小堆的堆定是整个堆中堆最小元素。  
&emsp; 二叉堆的构建、删除、自我调整等基本操作是实现堆排序的基础。  

## 5.1. 算法描述  
1. 把无需数组构建成二叉堆。需要从小到大排序，则构建成最大堆；需要从大到小排序，则构建成最小堆。  
2. 循环删除堆顶元素，替换到二叉堆大末尾，调整堆产生新堆堆顶。  

## 5.2. 编码  
&emsp; 最大堆排序  

```
/**
     * 下沉调整
     * @param array     待调整的堆
     * @param parentIndex    要下沉的父节点
     * @param length    堆的有效大小
     */
    public static void downAdjust(int[] array, int parentIndex, int length) {
        // temp保存父节点值，用于最后的赋值
        int temp = array[parentIndex];
        int childIndex = 2 * parentIndex + 1;
        while (childIndex < length) {
            // 如果有右孩子，且右孩子大于左孩子的值，则定位到右孩子
            if (childIndex + 1 < length && array[childIndex + 1] > array[childIndex]) {
                childIndex++;
            }
            // 如果父节点大于等于任何一个孩子的值，直接跳出
            if (temp >= array[childIndex])
                break;
            //无需真正交换，单向赋值即可
            array[parentIndex] = array[childIndex];
            parentIndex = childIndex;
            childIndex = 2 * childIndex + 1;
        }
        array[parentIndex] = temp;
    }

    /**
     * 堆排序(升序)
     * @param array     待调整的堆
     */
    public static void heapSort(int[] array) {
        // 1.把无序数组构建成最大堆。
        for (int i = (array.length-2)/2; i >= 0; i--) {
            downAdjust(array, i, array.length);
        }
        System.out.println(Arrays.toString(array));
        // 2.循环交换集合尾部元素到堆顶，并调节堆产生新的堆顶。
        for (int i = array.length - 1; i > 0; i--) {
            // 最后一个元素和第一元素进行交换
            int temp = array[i];
            array[i] = array[0];
            array[0] = temp;
            // 下沉调整最大堆
            downAdjust(array, 0, i);
        }
    }

    public static void main(String[] args) {
        int[] arr = new int[] {1,3,2,6,5,7,8,9,10,0};
        heapSort(arr);
        System.out.println(Arrays.toString(arr));
    }
```

# 6. 直接插入排序  
&emsp; 每一趟将一个待排序的记录，按照其关键字的大小插入到有序队列的合适位置里，直到全部插入完成。  

## 6.1. 算法描述
1. 从第一个元素开始，该元素可以认为已经被排序；
2. 取出下一个元素，在已经排序的元素序列中从后向前扫描；
3. 如果该元素（已排序）大于新元素，将该元素移到下一位置；
4. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；
5. 将新元素插入到该位置后；
6. 重复步骤2~5。  

## 6.2. 编码  

```
    public static void insertSort(int[] array) {
        if (array.length == 0)
            return;

        for (int i = 1; i < array.length; ++i) {
            int value = array[i];
            int j = i - 1;
            // 查找插入的位置
            for (; j >= 0; --j) {
                if (array[j] > value) {
                    array[j + 1] = array[j];  // 数据移动
                } else {
                    break;
                }
            }
            array[j + 1] = value; // 插入数据
        }
    }
```


## 6.3. 二分插入排序   
&emsp; 二分插入排序：在插入某个元素之前需要先确定该元素在有序数组中的位置，上例的做法是对有序数组中的元素逐个扫描，当数据量比较大的时候，这是一个很耗时间的过程，可以采用二分查找法改进，这种排序也被称为二分插入排序。 

```
    /**
     * 二分插入排序
     * @param array
     */
    public static void binaryInsertionSort(int[] array){

        int counter = 1;

        for(int i=1;i<array.length;i++){
            int temp = array[i];  //存储待排序的元素值
            if(array[i-1]>temp){  //比有序数组的最后一个元素要小
                int intinsertIndex = binarySearch(array,0, i-1, temp); //获取应插入位置的下标
                for(int j=i;j>intinsertIndex;j--){  //将有序数组中，插入点之后的元素后移一位
                    array[j]= array[j-1];
                }
                array[intinsertIndex]= temp;  //插入待排序元素到正确的位置
            }
            System.out.print("第"+counter+"轮排序结果：");
            System.out.println(Arrays.toString(array));
            counter++;
        }
    }

    /**
     * 二分查找法
     * @param lowerBound 查找段的最小下标
     * @param upperBound 查找段的最大下标
     * @param target 目标元素
     * @return 目标元素应该插入位置的下标
     */
    public static int binarySearch(int[] array,int lowerBound,int upperBound,int target){
        int curIndex;
        while(lowerBound<upperBound){
            curIndex= (lowerBound+upperBound)/2;
            if(array[curIndex]>target){
                upperBound= curIndex - 1;
            }else{
                lowerBound= curIndex + 1;
            }
        }
        return lowerBound;
    }
```

## 6.4. 二路插入排序  


# 7. 希尔排序  
&emsp; 先将整个待排序的记录序列分割成为若干子序列，分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。  

## 7.1. 算法描述  
1. 选择一个增量序列t1，t2，…，tk，其中ti>tj，tk=1；
2. 按增量序列个数k，对序列进行k 趟排序；
3. 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m的子序列，分别对各子表进行直接插入排序。仅增量因子为1时，整个序列作为一个表来处理，表长度即为整个序列的长度。  

## 7.2. 编码  

```
    public static void sheelSort(int[] array){
        //增量每次都/2
        for (int step = array.length/2; step>0; step /=2){
            //从增量那组开始进行插入排序，直至完毕
            for (int i = step; i<array.length;i++){
                int j = i;
                int temp = array[i];

                //j-step 就是代表与它同组隔壁的元素
                while (j -step >=0 && array[j-step]>temp){

                    array[j] = array[j-step];
                    j = j-step;
                }
                array[j] = temp;
            }
        }
    }
```

# 8. 归并排序
&emsp; 归并排序是分治算法的典型应用。
&emsp; 归并排序先将一个无序的N长数组切成N个有序子序列（只有一个数据的序列认为是有序序列），然后两两合并，再将合并后的N/2（或者N/2 + 1）个子序列继续进行两两合并，以此类推得到一个完整的有序数组。过程如下图所示：
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/function/function-3.png)  

&emsp; 归并排序其实要做两件事：  
* “分解”——将序列每次折半划分。  
* “合并”——将划分后的序列段两两合并后排序。  

## 8.1. 算法描述

1. 将数组分成A，B 两个数组，如果这2个数组都是有序的，那么就可以很方便的将这2个数组进行排序。  	
2. 让这2个数组有序，可以将A，B组各自再分成2个数组。依次类推，当分出来的数组只有1个数据时，可以认为数组已经达到了有序。  
3. 然后再合并相邻的2个数组。这样通过先递归的分解数组，再合并数组就完成了归并排序。   

## 8.2. 编码：

```
public static void mergeSort(int[] array, int start, int end){
        if(start < end){
            //折半成两个小集合，分别进行递归
            int mid=(start+end)/2;
            mergeSort(array, start, mid);
            mergeSort(array, mid+1, end);
            //把两个有序小集合，归并成一个大集合
            merge(array, start, mid, end);
        }
    }

    private static void merge(int[] array, int start, int mid, int end){

        //开辟额外大集合，设置指针
        int[] tempArray = new int[end-start+1];
        int p1=start, p2=mid+1, p=0;
        //比较两个小集合的元素，依次放入大集合
        while(p1<=mid && p2<=end){
            if(array[p1]<=array[p2])
                tempArray[p++]=array[p1++];
            else
                tempArray[p++]=array[p2++];
        }
        //左侧小集合还有剩余，依次放入大集合尾部
        while(p1<=mid)
            tempArray[p++]=array[p1++];
        //右侧小集合还有剩余，依次放入大集合尾部
        while(p2<=end)
            tempArray[p++]=array[p2++];

        //把大集合的元素复制回原数组
        for (int i=0; i<tempArray.length; i++)
            array[i+start]=tempArray[i];
    }


    public static void main(String[] args) {
        int[] arr = new int[] {1,3,2,6,5,7,8,9,10,0};
        mergeSort(arr,0,arr.length-1);
        System.out.println(Arrays.toString(arr));
    }
```

---

# 9. 计数排序  
&emsp; 计数排序适用于一定范围的整数排序。

## 9.1. 算法描述  

## 9.2. 编码  


# 10. 桶排序  
&emsp; 当数列取值范围过大，或者不是整数时，不能适用计数排序。但是可以使用桶排序来解决问题。  
&emsp; 桶排序同样是一种线性时间的排序算法。类似于计数排序所创建的统计数组，桶排序需要创建若干个桶来协助排序。  
&emsp; 每一个桶（bucket）代表一个区间范围，里面可以承载一个或多个元素。桶排序的第一步，就是创建这些桶，确定每一个桶的区间范围。具体建立多少个桶，如何确定桶的区间范围，有很多不同的方式。  
&emsp; 示例：  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/function/function-7.png)  

## 10.1. 算法描述
1. 找出待排序数组中的最大值max和最小值min；
2. 使用动态数组ArrayList 作为桶，桶里放的元素也用 ArrayList 存储。桶的数量为 (max-min) / arr.length + 1；
3. 遍历数组 arr，计算每个元素 arr[i] 放的桶；
4. 每个桶各自排序；
5. 遍历桶数组，把排序好的元素放进输出数组。

## 10.2. 编码

```
public static double[] bucketSort(double[] array){
    //1.得到数列的最大值和最小值，并算出差值d
    double max = array[0];
    double min = array[0];
    for(int i=1; i<array.length; i++) {
        if(array[i] > max) {
            max = array[i];
        }
        if(array[i] < min) {
            min = array[i];
        }
    }

    double d = max - min;
    //2.初始化桶
    int bucketNum = array.length;
    ArrayList<LinkedList<Double>> bucketList = new ArrayList<LinkedList<Double>>(bucketNum);
    for(int i = 0; i < bucketNum; i++){
        bucketList.add(new LinkedList<Double>());
    }

    //3.遍历原始数组，将每个元素放入桶中
    for(int i = 0; i < array.length; i++){
        int num = (int)((array[i] - min)  * (bucketNum-1) / d);
        bucketList.get(num).add(array[i]);
    }

    //4.对每个通内部进行排序
    for(int i = 0; i < bucketList.size(); i++){
        //JDK底层采用了归并排序或归并的优化版本
        Collections.sort(bucketList.get(i));
    }

    //5.输出全部元素
    double[] sortedArray = new double[array.length];
    int index = 0;
    for(LinkedList<Double> list : bucketList){
        for(double element : list){
            sortedArray[index] = element;
            index++;
        }
    }
    return sortedArray;
}

public static void main(String[] args) {
    double[] array = new double[] {4.12,6.421,0.0023,3.0,2.123,8.122,4.12, 10.09};
    double[] sortedArray = bucketSort(array);
    System.out.println(Arrays.toString(sortedArray));
}
```  

# 11. 基数排序  
&emsp; 基数排序不但能处理整数排序，也能对字母、汉字进行排序。它把排序工作拆分成多个阶段，每一个阶段只根据一个字符进行计数排序，一共排序k轮（k是元素长度）。  
&emsp; 简单示例：  
&emsp; 数组中有若干个字符串元素，每个字符串元素都是由三个英文字母组成：  

    bda，cfd，qwe，yui，abc，rrr，uee  
&emsp; 由于每个字符串的长度是3个字符，可以把排序工作拆分成3轮：  
&emsp; 第一轮：按照最低位字符排序。排序过程使用计数排序，把字母的ascii码对应到数组下标，第一轮排序结果如下：  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/function/function-8.png)  
&emsp; 第二轮：在第一轮排序结果的基础上，按照第二位字符排序。  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/function/function-9.png)  
&emsp; 需要注意的是，这里使用的计数排序必须是稳定排序，这样才能保证第一轮排出的先后顺序在第二轮还能继续保持。  
比如在第一轮排序后，元素uue在元素yui之前。那么第二轮排序时，两者的第二位字符虽然同样是u，但先后顺序万万不能变，否则第一轮排序就白做了。  

&emsp; 第三轮：在第二轮排序结果的基础上，按照最高位字符排序。   
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/function/function-10.png)  
&emsp; 如此一来，这些字符串的顺序就排好了。  
&emsp; 像这样把字符串元素按位拆分，每一位进行一次计数排序的算法，就是基数排序（Radix Sort）。  

&emsp; 基数排序既可以从高位优先进行排序（Most Significant Digit first，简称MSD），也可以从低位优先进行排序（Least Significant Digit first，简称LSD）。  

&emsp; 如果排序对字符串长度不规则，则以最长的字符串为准，其他长度不足的字符串，在末尾补0即可。  

## 11.1. 算法描述  
1. 取得数组中的最大数，并取得位数；
2. arr为原始数组，从最低位开始取每个位组成radix数组；
3. 对radix进行计数排序（利用计数排序适用于小范围数的特点）。

## 11.2. 编码  

```
//ascii码的取值范围
public static final int ASCII_RANGE = 128;

public static String[]  radixSort(String[] array,int maxLength) {

    //排序结果数组，用于存储每一次按位排序的临时结果
    String[] sortedArray = new String[array.length];

    //从个位开始比较，一直比较到最高位
    for(int k=maxLength-1;k>=0;k--){
        //计数排序的过程，分成三步：
        //1.创建辅助排序的统计数组，并把待排序的字符对号入座，
        //这里为了代码简洁，直接使用ascii码范围作为数组长度
        int[] count = new int[ASCII_RANGE];

        for(int i=0;i<array.length;i++) {

            int index = getCharIndex(array[i],k);
            count[index]++;
        }

        //2.统计数组做变形，后面的元素等于前面的元素之和
        for(int i=1;i<count.length;i++) {
            count[i] = count[i] + count[i-1];
        }

        //3.倒序遍历原始数列，从统计数组找到正确位置，输出到结果数组
        for(int i=array.length-1;i>=0;i--) {
            int index = getCharIndex(array[i],k);
            int sortedIndex = count[index]-1;
            sortedArray[sortedIndex] = array[i];
            count[index]--;
        }
        //下一轮排序需要以上一轮的排序结果为基础，因此把结果复制给array
        array = sortedArray.clone();
    }
    return array;
}

//获取字符串第k位字符所对应的ascii码序号
private static int getCharIndex(String str, int k){

    //如果字符串长度小于k，直接返回0，相当于给不存在的位置补0
    if(str.length() < k+1){
        return 0;
    }
    return str.charAt(k);

}

public static void main(String[] args) {

    String[] array = {"qd","abc", "qwe","hhh","a","cws", "ope"};
    System.out.println(Arrays.toString(radixSort(array, 3)));

}
```

# 12. 八大排序算法总结  



