---
title: 栈
date: 2020-06-04 00:00:00
tags:
    - 算法
---


# 3. 栈Stack  
&emsp; ***栈的实现：***  
&emsp; 既可以用「数组」来实现一个栈，也可以用「链表」来实现一个栈。
&emsp; ***栈的基本操作：***  
&emsp; 栈有两种操作：Push和Pop。用Push（压入）来表示往栈中插入数据，也叫入栈，用Pop（弹出）来表示从栈中删除数据，也叫出栈。  
&emsp; ***栈的应用：***  
&emsp; 栈的输出顺序和输入顺序相反，所以***<font color = "red">栈通常用于“历史”的回溯，也就是逆流而上追溯“历史”</font>***。例如：***实现递归的逻辑，就可以用栈来代替。***因为栈可以回溯方法的调用链。  

## 3.1. 栈的实现  
### 3.1.1. 顺序栈  
&emsp; 用数组实现的栈，叫做顺序栈。顺序栈的实现非常简单。先初始化一个数组，然后再用一个变量给这个数组里的元素进行计数，当有新元素需要入栈的时候，将这个新元素写入到数组的最后一个元素的后面，然后计数器加一。当需要做出栈操作时，将数组中最后一个元素返回，计数器减一。  
&emsp; 在入栈前需要判断数组是否已经满了，如果数组大小等于计数器大小，则表明数组是满的。  
&emsp; 出栈的时候也需要判断数组是不是空数组，如果计数器是0，则表明数组是空的。  
&emsp; 从上面的实现流程可以看出，通过数组实现的栈，其入栈和出栈都是对单个元素进行操作，因此其入栈和出栈的时间复杂度都是O(1)，并且其入栈和出栈操作并没有额外开销更多空间，因此其空间复杂度也是O(1)的。  

### 3.1.2. 链式栈  
&emsp; 用链表实现的栈，叫做 链式栈。实现思路是先定义一个链表节点的类，基于这个类去定义一个头节点Head。当有新元素需要入栈的时候，将这个新元素的Next指针指向头结点Head的Next节点，然后再将Head的Next指向这个新节点。当需要做出栈操作时，直接将Head所指向的节点返回，同时让Head指向下一个节点。  
&emsp; 在入栈和出栈时都需要判断链表是否为空的情况。  
&emsp; 链式栈的入栈和出栈都是在处理头部节点，所以操作很简单，其时间和空间复杂度均为O(1)。  

## 3.2. 有关栈的算法题  

### 3.2.1. 利用栈实现字符串逆序  

### 3.2.2. 利用栈判断分隔符是否匹配  

### 3.2.3. 用两个栈实现队列  

### 3.2.4. 栈的压入、弹出序列  

### 3.2.5. 使用两个栈进行排序  


# 4. 队列  
&emsp; ***队列的实现：***  
&emsp; 与栈类似，队列即可以用数组实现，也可以用链表实现。  

&emsp; ***队列的基本操作：***  
&emsp; 队列有两种操作入队(enqueue)、出队(dequeue)。  

&emsp; 如果队列不断出队，队头左边的空间失去作用，那队列的容量越来越小。***<font color = "red">用数组实现的队列可以采用循环队列的方式来维持队列容量的恒定。</font>***  

&emsp; ***队列的应用：***  
&emsp; 队列的输出顺序和输入顺序相同，所以队列通常用于对“历史”的回放，也就是按照“历史”顺序，把“历史”重演一遍。  


&emsp; ***<font color = "red">双端队列</font>***，可以结合栈和队列的特点，即可以先入先出，也可以先入后出。  
&emsp; ***<font color = "red">优先级队列</font>***，遵循的不是先入先出，而是谁的优先级最高，谁先出队列。优先级队列是基于二叉堆来实现的。  


