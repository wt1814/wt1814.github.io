---
title: 基本概念
date: 2020-06-02 00:00:00
tags:
    - 算法
---


# 数组  
&emsp; 这里稍微讲解下二维数组。二维数组是一个元素为一维数组的数组。  

&emsp; 二维数组定义：

    数据类型[][] 变量名=new 数据类型[m][n];
        m表示这个二维数组有多少个数组
        n表示每一个一维数组的元素个数
    举例：
        int[][] arr=new int[3][2];定义了一个二维数组arr。这个二维数组有3个一维数组，名称是ar[0],arr[1],arr[2]；每个一维数组有2个元素，可以通过arr[m][n]来获取。

&emsp; 二维数组基本操作：遍历一个行列变化的二维数组。  

```
/*
 * 遍历一个行列变化的数组
 */
public class bianlishuzu2 {
    public static void main(String[] args) {
        int [][] arr={{1,2,3},{4,5},{6}};
        printArray(arr);
    }
    public static void printArray(int[][] arr){
        for(int x=0;x<arr.length;x++){
            for(int y=0;y<arr[x].length;y++){
                System.out.print(arr[x][y]);
            }
            System.out.println();
        }
    }
}
```

# 链表  
&emsp; 链表分类：单向链表、双端链表、有序链表、双向链表。  

## 单向链表  
&emsp; 链节点可以是一个单独的类，也可以是内部类。  

```
public class SingleLinkedList {
    private int size;//链表节点的个数
    private Node head;//头节点

    public SingleLinkedList(){
        size = 0;
        head = null;
    }

    //链表的每个节点类
    private class Node{
        private Object data;//每个节点的数据
        private Node next;//每个节点指向下一个节点的连接

        public Node(Object data){
            this.data = data;
        }
    }

    //在链表头添加元素
    public Object addHead(Object obj){
        Node newHead = new Node(obj);
        if(size == 0){
            head = newHead;
        }else{
            newHead.next = head;
            head = newHead;
        }
        size++;
        return obj;
    }

    //在链表头删除元素
    public Object deleteHead(){
        Object obj = head.data;
        head = head.next;
        size--;
        return obj;
    }

    //查找指定元素，找到了返回节点Node，找不到返回null
    public Node find(Object obj){
        Node current = head;
        int tempSize = size;
        while(tempSize > 0){
            if(obj.equals(current.data)){
                return current;
            }else{
                current = current.next;
            }
            tempSize--;
        }
        return null;
    }

    //删除指定的元素，删除成功返回true
    public boolean delete(Object value){
        if(size == 0){
            return false;
        }
        Node current = head;
        Node previous = head;
        while(current.data != value){
            if(current.next == null){
                return false;
            }else{
                previous = current;
                current = current.next;
            }
        }
        //如果删除的节点是第一个节点
        if(current == head){
            head = current.next;
            size--;
        }else{//删除的节点不是第一个节点
            previous.next = current.next;
            size--;
        }
        return true;
    }

    //判断链表是否为空
    public boolean isEmpty(){
        return (size == 0);
    }

    //显示节点信息
    public void display(){
        if(size >0){
            Node node = head;
            int tempSize = size;
            if(tempSize == 1){//当前链表只有一个节点
                System.out.println("["+node.data+"]");
                return;
            }
            while(tempSize>0){
                if(node.equals(head)){
                    System.out.print("["+node.data+"->");
                }else if(node.next == null){
                    System.out.print(node.data+"]");
                }else{
                    System.out.print(node.data+"->");
                }
                node = node.next;
                tempSize--;
            }
            System.out.println();
        }else{//如果链表一个节点都没有，直接打印[]
            System.out.println("[]");
        }
    }

}
```

## 链表解题思路：  
&emsp; 链表常见解题思路有翻转和快慢指针。  

### 链表翻转：  
&emsp; 翻转链表可以用非递归和递归这两种方式来解题。  

#### 非递归翻转链表（迭代解法）  


#### 递归翻转  

#### 变形题  


### 快慢指针：  
&emsp; 可以用快慢指针解决以下两大类问题：  
1. 寻找/删除第K个结点  
2. 有关链表环问题的相关解法    

#### 寻找/删除第 K 个结点  


#### 有关链表环问题的相关解法  
##### 判断是否有环？  


##### 找到入口结点  


----
# 栈Stack  

&emsp; ***栈的实现：***
&emsp; 既可以用「数组」来实现一个栈，也可以用「链表」来实现一个栈。

&emsp; ***栈的基本操作：***
&emsp; 栈有两种操作：Push和Pop。用Push（压入）来表示往栈中插入数据，也叫入栈，用Pop（弹出）来表示从栈中删除数据，也叫出栈。  

&emsp; ***栈的应用：***
&emsp; 栈的输出顺序和输入顺序相反，所以栈通常用于“历史”的回溯，也就是逆流而上追溯“历史”。  
&emsp; 例如：***实现递归的逻辑，就可以用栈来代替。***因为栈可以回溯方法的调用链。  

## 栈的实现：  
### 顺序栈：  
&emsp; 用数组实现的栈，叫做 顺序栈：  
&emsp; 顺序栈的实现非常简单。先初始化一个数组，然后再用一个变量给这个数组里的元素进行计数，当有新元素需要入栈的时候，将这个新元素写入到数组的最后一个元素的后面，然后计数器加一。当需要做出栈操作时，将数组中最后一个元素返回，计数器减一。  
&emsp; 当然在入栈前需要判断数组是否已经满了，如果数组大小等于计数器大小，则表明数组是满的。  
&emsp; 出栈的时候也需要判断数组是不是空数组，如果计数器是0，则表明数组是空的。  
&emsp; 从上面的实现流程可以看出，通过数组实现的栈，其入栈和出栈都是对单个元素进行操作，因此其入栈和出栈的时间复杂度都是O(1)，并且其入栈和出栈操作并没有额外开销更多空间，因此其空间复杂度也是O(1)的。  

### 链式栈：  
&emsp; 用链表实现的栈，叫做 链式栈：  
&emsp; 实现思路是先定义一个链表节点的类，基于这个类去定义一个头节点Head。当有新元素需要入栈的时候，将这个新元素的Next指针指向头结点Head的Next节点，然后再将Head的Next指向这个新节点。当需要做出栈操作时，直接将Head所指向的节点返回，同时让Head指向下一个节点。  
&emsp; 当然，在入栈和出栈时都需要判断链表是否为空的情况。  
&emsp; 链式栈的入栈和出栈都是在处理头部节点，所以操作很简单，其时间和空间复杂度均为O(1)。  

## 有关栈的算法题：  

### 利用栈实现字符串逆序：  

### 利用栈判断分隔符是否匹配：  

### 用两个栈实现队列：  

### 栈的压入、弹出序列：  

### 使用两个栈进行排序：  


# 队列：  

&emsp; ***队列的实现：***  
&emsp; 与栈类似，队列即可以用数组实现，也可以用链表实现。  

&emsp; ***队列的基本操作：***  
&emsp; 队列有两种操作入队(enqueue)、出队(dequeue)。  

&emsp; 如果队列不断出队，对头左边的空间失去作用，那队列的容量岂不是越来越小？  
用数组实现的队列可以采用循环队列的方式来维持队列容量的恒定。  

&emsp; ***队列的应用：***  
&emsp; 队列的输出顺序和输入顺序相同，所以队列通常用于对“历史”的回放，也就是按照“历史”顺序，把“历史”重演一遍。  


&emsp; 双端队列可以结合栈和队列的特点，即可以先入先出，也可以先入后出。  
&emsp; 还有一种队列，它遵循的不是先入先出，而是谁的优先级最高，谁先出队列，这种队列叫做优先队列。优先队列是基于二叉堆来实现的。  


----
# 哈希表  
## 哈希表基本概念：  
&emsp; 哈希表也称散列表，Hash表是一种根据关键字值（key - value）而直接进行访问的数据结构。  
&emsp; 哈希表基于数组，通过把关键字映射到数组的某个下标来加快查找速度，但是又和数组、链表、树等数据结构不同，在这些数据结构中查找某个关键字，通常要遍历整个数据结构，也就是O(N)的时间级，但是对于哈希表来说，只是O(1)的时间级。  
&emsp; 哈希数据结构的性能取决于三个因素：哈希函数、哈希因子、处理冲突方法。  

### 哈希函数：  
&emsp; 散列函数能使对一个数据序列的访问过程更加迅速有效，通过散列函数，数据元素将被更快地定位。常用Hash函数有：  
1. 直接寻址法。取关键字或关键字的某个线性函数值为散列地址。即H(key)=key或H(key) = a·key + b，其中a和b为常数（这种散列函数叫做自身函数）  
2. 数字分析法。分析一组数据，比如一组员工的出生年月日，这时我们发现出生年月日的前几位数字大体相同，这样的话，出现冲突的几率就会很大，但是我们发现年月日的后几位表示月份和具体日期的数字差别很大，如果用后面的数字来构成散列地址，则冲突的几率会明显降低。因此数字分析法就是找出数字的规律，尽可能利用这些数据来构造冲突几率较低的散列地址。  
3. 平方取中法。取关键字平方后的中间几位作为散列地址。  
4. 折叠法。将关键字分割成位数相同的几部分，最后一部分位数可以不同，然后取这几部分的叠加和（去除进位）作为散列地址。  
5. 随机数法。选择一随机函数，取关键字作为随机函数的种子生成随机值作为散列地址，通常用于关键字长度不同的场合。  
6. 除留余数法。取关键字被某个不大于散列表表长m的数p除后所得的余数为散列地址。即 H(key) = key MOD p,p<=m。不仅可以对关键字直接取模，也可在折叠、平方取中等运算之后取模。对p的选择很重要，一般取素数或m，若p选的不好，容易产生碰撞。  

&emsp; 注：HashMap并没有直接采用取模法（index = HashCode(Key)%Array.length），而是利用了位运算来优化性能。  

### 哈希因子  
&emsp; 哈希因子是表示Hsah表中元素的填满的程度，若哈希因子越大，则填满的元素越多，这样的好处是：空间利用率高了,但冲突的机会加大了。反之,加载因子越小，填满的元素越少,好处是冲突的机会减小了，但空间浪费多了。  

### 处理冲突
&emsp; 理想情况下，两个不同的关键字映射到不同的单元，然而由于数组单元有限，关键字范围可能远超数组单元，因此就会出现两个关键字散列到同一个值得时候，这就是散列冲突。  
&emsp; 常用的哈希冲突解决方法有两类，开放寻址法和拉链法。  
&emsp; 处理冲突的方法决定了哈希表的数据结构。采用开放地址法，哈希表的数据结构是一维数组；采用链地址法，哈希表的数据结构是数组加链表。  
&emsp; 在Java中ThreaLocal所使用的是开放寻址法；HashMap使用拉链法。  

## 题型：  



---
# 树  
## 二叉树  
&emsp; 二叉树有两种特殊形式，一个叫满二叉树，一个叫完全二叉树。  

&emsp; ***二叉树的实现：***  
&emsp; 二叉树即可以用数组实现，也可以用链表实现。  
&emsp; 二叉树一般使用链表实现；二叉堆，一种特殊的完全二叉树，使用数组来操作。  

&emsp; ***二叉树的遍历：***  
&emsp; 二叉树的遍历方式有深度优先遍历、广度优先遍历。  

&emsp; ***二叉树的应用：***  
&emsp; 二叉树包含许多特殊的形式，每一种形式都有自己的应用。但是其最主要的应用还在于进行查找操作和维持相对顺序这两个方面。有一种特殊的二叉树叫做***二叉查找树或二叉排序树***。  

&emsp; 二叉查找树有可能退化成一个链表，可以采用自平衡方式优化结构。二叉树自平衡的方式有多种，如红黑树、平衡二叉树（AVL）。  


## 红黑树  


# B-树、B+树   






