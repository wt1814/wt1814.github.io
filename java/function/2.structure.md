---
title: 数据结构
date: 2020-06-02 00:00:00
tags:
    - 算法
---
<!-- TOC -->

- [1. 数组](#1-数组)
- [2. 链表](#2-链表)
    - [2.1. 单向链表](#21-单向链表)
    - [2.2. 链表解题思路](#22-链表解题思路)
        - [2.2.1. 链表翻转](#221-链表翻转)
            - [2.2.1.1. 非递归翻转链表（迭代解法）](#2211-非递归翻转链表迭代解法)
            - [2.2.1.2. 递归翻转](#2212-递归翻转)
            - [2.2.1.3. 变形题](#2213-变形题)
        - [2.2.2. 快慢指针](#222-快慢指针)
            - [2.2.2.1. 寻找/删除第 K 个结点](#2221-寻找删除第-k-个结点)
            - [2.2.2.2. 有关链表环问题的相关解法](#2222-有关链表环问题的相关解法)
                - [2.2.2.2.1. 判断是否有环？](#22221-判断是否有环)
                - [2.2.2.2.2. 找到入口结点](#22222-找到入口结点)
- [3. 栈Stack](#3-栈stack)
    - [3.1. 栈的实现](#31-栈的实现)
        - [3.1.1. 顺序栈](#311-顺序栈)
        - [3.1.2. 链式栈](#312-链式栈)
    - [3.2. 有关栈的算法题](#32-有关栈的算法题)
        - [3.2.1. 利用栈实现字符串逆序](#321-利用栈实现字符串逆序)
        - [3.2.2. 利用栈判断分隔符是否匹配](#322-利用栈判断分隔符是否匹配)
        - [3.2.3. 用两个栈实现队列](#323-用两个栈实现队列)
        - [3.2.4. 栈的压入、弹出序列](#324-栈的压入弹出序列)
        - [3.2.5. 使用两个栈进行排序](#325-使用两个栈进行排序)
- [4. 队列](#4-队列)
- [5. 哈希表](#5-哈希表)
    - [5.1. 哈希表基本概念](#51-哈希表基本概念)
        - [5.1.1. 哈希函数](#511-哈希函数)
        - [5.1.2. 哈希因子](#512-哈希因子)
        - [5.1.3. 处理冲突](#513-处理冲突)
    - [5.2. 题型](#52-题型)
- [6. 树](#6-树)
    - [6.1. 二叉树](#61-二叉树)
    - [6.2. 红黑树](#62-红黑树)
- [7. B-树、B+树](#7-b-树b树)

<!-- /TOC -->

# 1. 数组  
&emsp; 这里稍微讲解下二维数组。二维数组是一个元素为一维数组的数组。  

&emsp; 二维数组定义：

    数据类型[][] 变量名=new 数据类型[m][n];
        m表示这个二维数组有多少个数组
        n表示每一个一维数组的元素个数
    举例：
        int[][] arr=new int[3][2];定义了一个二维数组arr。这个二维数组有3个一维数组，名称是ar[0],arr[1],arr[2]；每个一维数组有2个元素，可以通过arr[m][n]来获取。

&emsp; 二维数组基本操作：遍历一个行列变化的二维数组。  

    /*
    * 遍历一个行列变化的数组
    */
    public class bianlishuzu2 {
        public static void main(String[] args) {
            int [][] arr = { {1,2,3},{4,5},{6} };
            printArray(arr);
        }
        public static void printArray(int[][] arr){
            for(int x=0;x<arr.length;x++){
                for(int y=0;y<arr[x].length;y++){
                    System.out.print(arr[x][y]);
                }
                System.out.println();
            }
        }
    }


# 2. 链表  
&emsp; 链表分类：单向链表、双端链表、有序链表、双向链表。  

## 2.1. 单向链表  
&emsp; 链节点可以是一个单独的类，也可以是内部类。  

```
public class SingleLinkedList {
    private int size;//链表节点的个数
    private Node head;//头节点

    public SingleLinkedList(){
        size = 0;
        head = null;
    }

    //链表的每个节点类
    private class Node{
        private Object data;//每个节点的数据
        private Node next;//每个节点指向下一个节点的连接

        public Node(Object data){
            this.data = data;
        }
    }

    //在链表头添加元素
    public Object addHead(Object obj){
        Node newHead = new Node(obj);
        if(size == 0){
            head = newHead;
        }else{
            newHead.next = head;
            head = newHead;
        }
        size++;
        return obj;
    }

    //在链表头删除元素
    public Object deleteHead(){
        Object obj = head.data;
        head = head.next;
        size--;
        return obj;
    }

    //查找指定元素，找到了返回节点Node，找不到返回null
    public Node find(Object obj){
        Node current = head;
        int tempSize = size;
        while(tempSize > 0){
            if(obj.equals(current.data)){
                return current;
            }else{
                current = current.next;
            }
            tempSize--;
        }
        return null;
    }

    //删除指定的元素，删除成功返回true
    public boolean delete(Object value){
        if(size == 0){
            return false;
        }
        Node current = head;
        Node previous = head;
        while(current.data != value){
            if(current.next == null){
                return false;
            }else{
                previous = current;
                current = current.next;
            }
        }
        //如果删除的节点是第一个节点
        if(current == head){
            head = current.next;
            size--;
        }else{//删除的节点不是第一个节点
            previous.next = current.next;
            size--;
        }
        return true;
    }

    //判断链表是否为空
    public boolean isEmpty(){
        return (size == 0);
    }

    //显示节点信息
    public void display(){
        if(size >0){
            Node node = head;
            int tempSize = size;
            if(tempSize == 1){//当前链表只有一个节点
                System.out.println("["+node.data+"]");
                return;
            }
            while(tempSize>0){
                if(node.equals(head)){
                    System.out.print("["+node.data+"->");
                }else if(node.next == null){
                    System.out.print(node.data+"]");
                }else{
                    System.out.print(node.data+"->");
                }
                node = node.next;
                tempSize--;
            }
            System.out.println();
        }else{//如果链表一个节点都没有，直接打印[]
            System.out.println("[]");
        }
    }

}
```

## 2.2. 链表解题思路  
&emsp; ***<font color = "red">链表常见解题思路有翻转和快慢指针。</font>***  

### 2.2.1. 链表翻转  
&emsp; 翻转链表可以用非递归和递归这两种方式来解题。  

#### 2.2.1.1. 非递归翻转链表（迭代解法）  


#### 2.2.1.2. 递归翻转  

#### 2.2.1.3. 变形题  


### 2.2.2. 快慢指针  
&emsp; ***<font color = "red">可以用快慢指针解决以下两大类问题：</font>***  
1. 寻找/删除第K个结点  
2. 有关链表环问题的相关解法    

#### 2.2.2.1. 寻找/删除第 K 个结点  


#### 2.2.2.2. 有关链表环问题的相关解法  
##### 2.2.2.2.1. 判断是否有环？  


##### 2.2.2.2.2. 找到入口结点  


----
# 3. 栈Stack  
&emsp; ***栈的实现：***  
&emsp; 既可以用「数组」来实现一个栈，也可以用「链表」来实现一个栈。
&emsp; ***栈的基本操作：***  
&emsp; 栈有两种操作：Push和Pop。用Push（压入）来表示往栈中插入数据，也叫入栈，用Pop（弹出）来表示从栈中删除数据，也叫出栈。  
&emsp; ***栈的应用：***  
&emsp; 栈的输出顺序和输入顺序相反，所以***<font color = "red">栈通常用于“历史”的回溯，也就是逆流而上追溯“历史”</font>***。例如：***实现递归的逻辑，就可以用栈来代替。***因为栈可以回溯方法的调用链。  

## 3.1. 栈的实现  
### 3.1.1. 顺序栈  
&emsp; 用数组实现的栈，叫做顺序栈。顺序栈的实现非常简单。先初始化一个数组，然后再用一个变量给这个数组里的元素进行计数，当有新元素需要入栈的时候，将这个新元素写入到数组的最后一个元素的后面，然后计数器加一。当需要做出栈操作时，将数组中最后一个元素返回，计数器减一。  
&emsp; 在入栈前需要判断数组是否已经满了，如果数组大小等于计数器大小，则表明数组是满的。  
&emsp; 出栈的时候也需要判断数组是不是空数组，如果计数器是0，则表明数组是空的。  
&emsp; 从上面的实现流程可以看出，通过数组实现的栈，其入栈和出栈都是对单个元素进行操作，因此其入栈和出栈的时间复杂度都是O(1)，并且其入栈和出栈操作并没有额外开销更多空间，因此其空间复杂度也是O(1)的。  

### 3.1.2. 链式栈  
&emsp; 用链表实现的栈，叫做 链式栈。实现思路是先定义一个链表节点的类，基于这个类去定义一个头节点Head。当有新元素需要入栈的时候，将这个新元素的Next指针指向头结点Head的Next节点，然后再将Head的Next指向这个新节点。当需要做出栈操作时，直接将Head所指向的节点返回，同时让Head指向下一个节点。  
&emsp; 在入栈和出栈时都需要判断链表是否为空的情况。  
&emsp; 链式栈的入栈和出栈都是在处理头部节点，所以操作很简单，其时间和空间复杂度均为O(1)。  

## 3.2. 有关栈的算法题  

### 3.2.1. 利用栈实现字符串逆序  

### 3.2.2. 利用栈判断分隔符是否匹配  

### 3.2.3. 用两个栈实现队列  

### 3.2.4. 栈的压入、弹出序列  

### 3.2.5. 使用两个栈进行排序  


# 4. 队列  
&emsp; ***队列的实现：***  
&emsp; 与栈类似，队列即可以用数组实现，也可以用链表实现。  

&emsp; ***队列的基本操作：***  
&emsp; 队列有两种操作入队(enqueue)、出队(dequeue)。  

&emsp; 如果队列不断出队，队头左边的空间失去作用，那队列的容量越来越小。***<font color = "red">用数组实现的队列可以采用循环队列的方式来维持队列容量的恒定。</font>***  

&emsp; ***队列的应用：***  
&emsp; 队列的输出顺序和输入顺序相同，所以队列通常用于对“历史”的回放，也就是按照“历史”顺序，把“历史”重演一遍。  


&emsp; ***<font color = "red">双端队列</font>***，可以结合栈和队列的特点，即可以先入先出，也可以先入后出。  
&emsp; ***<font color = "red">优先级队列</font>***，遵循的不是先入先出，而是谁的优先级最高，谁先出队列。优先级队列是基于二叉堆来实现的。  


----
# 5. 哈希表  
## 5.1. 哈希表基本概念  
&emsp; 哈希表也称散列表，Hash表是一种根据关键字值（key - value）而直接进行访问的数据结构。  
&emsp; 哈希表基于数组，通过把关键字映射到数组的某个下标来加快查找速度，但是又和数组、链表、树等数据结构不同，在这些数据结构中查找某个关键字，通常要遍历整个数据结构，也就是O(N)的时间级，但是对于哈希表来说，只是O(1)的时间级。  
&emsp; 哈希数据结构的性能取决于三个因素：哈希函数、哈希因子、处理冲突方法。  

### 5.1.1. 哈希函数  
&emsp; 散列函数能使对一个数据序列的访问过程更加迅速有效，通过散列函数，数据元素将被更快地定位。常用Hash函数有：  
1. 直接寻址法。取关键字或关键字的某个线性函数值为散列地址。即H(key)=key或H(key) = a·key + b，其中a和b为常数（这种散列函数叫做自身函数）  
2. 数字分析法。分析一组数据，比如一组员工的出生年月日，这时我们发现出生年月日的前几位数字大体相同，这样的话，出现冲突的几率就会很大，但是我们发现年月日的后几位表示月份和具体日期的数字差别很大，如果用后面的数字来构成散列地址，则冲突的几率会明显降低。因此数字分析法就是找出数字的规律，尽可能利用这些数据来构造冲突几率较低的散列地址。  
3. 平方取中法。取关键字平方后的中间几位作为散列地址。  
4. 折叠法。将关键字分割成位数相同的几部分，最后一部分位数可以不同，然后取这几部分的叠加和（去除进位）作为散列地址。  
5. 随机数法。选择一随机函数，取关键字作为随机函数的种子生成随机值作为散列地址，通常用于关键字长度不同的场合。  
6. 除留余数法。取关键字被某个不大于散列表表长m的数p除后所得的余数为散列地址。即 H(key) = key MOD p,p<=m。不仅可以对关键字直接取模，也可在折叠、平方取中等运算之后取模。对p的选择很重要，一般取素数或m，若p选的不好，容易产生碰撞。  

&emsp; 注：HashMap并没有直接采用取模法（index = HashCode(Key)%Array.length），而是利用了位运算来优化性能。  

### 5.1.2. 哈希因子  
&emsp; 哈希因子是表示Hsah表中元素的填满的程度，若哈希因子越大，则填满的元素越多，这样的好处是：空间利用率高了,但冲突的机会加大了。反之,加载因子越小，填满的元素越少,好处是冲突的机会减小了，但空间浪费多了。  

### 5.1.3. 处理冲突
&emsp; 理想情况下，两个不同的关键字映射到不同的单元，然而由于数组单元有限，关键字范围可能远超数组单元，因此就会出现两个关键字散列到同一个值得时候，这就是散列冲突。  
&emsp; 常用的哈希冲突解决方法有两类，开放寻址法和拉链法。  
&emsp; 处理冲突的方法决定了哈希表的数据结构。采用开放地址法，哈希表的数据结构是一维数组；采用链地址法，哈希表的数据结构是数组加链表。  
&emsp; 在Java中ThreaLocal所使用的是开放寻址法；HashMap使用拉链法。  

## 5.2. 题型  



---
# 6. 树  
## 6.1. 二叉树  
&emsp; 二叉树有两种特殊形式，一个叫满二叉树，一个叫完全二叉树。  

&emsp; ***二叉树的实现：***  
&emsp; 二叉树即可以用数组实现，也可以用链表实现。  
&emsp; 二叉树一般使用链表实现；二叉堆，一种特殊的完全二叉树，使用数组来操作。  

&emsp; ***二叉树的遍历：***  
&emsp; 二叉树的遍历方式有深度优先遍历、广度优先遍历。  

&emsp; ***二叉树的应用：***  
&emsp; 二叉树包含许多特殊的形式，每一种形式都有自己的应用。但是其最主要的应用还在于进行查找操作和维持相对顺序这两个方面。有一种特殊的二叉树叫做***二叉查找树或二叉排序树***。  

&emsp; 二叉查找树有可能退化成一个链表，可以采用自平衡方式优化结构。二叉树自平衡的方式有多种，如红黑树、平衡二叉树（AVL）。  


## 6.2. 红黑树  
&emsp; 红黑树是一种近似平衡的二叉查找树。在每个节点增加一个存储位表示节点的颜色，可以是红或黑（非红即黑）。其主要的优点就是“平衡“，即左右子树高度几乎一致，以此来防止树退化为链表，通过这种方式来保障查找的时间复杂度为 log(n)。  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/java/function/function-6.png)  

&emsp; ***红黑树主要有以下几个特性：***  
1. 每个节点要么是红色，要么是黑色，但根节点永远是黑色的；  
2. 每个红色节点的两个子节点一定都是黑色；  
3. 红色节点不能连续（也即是，红色节点的孩子和父亲都不能是红色）；  
4. 从任一节点到其子树中每个叶子节点的路径都包含相同数量的黑色节点；  
5. 所有的叶节点都是是黑色的（注意这里说叶子节点其实是上图中的 NIL 节点）；  

&emsp; 在树的结构发生改变时（插入或者删除操作），往往会破坏上述条件3或条件 4，需要通过调整使得查找树重新满足红黑树的条件。  

&emsp; ***红黑树与平衡二叉树的区别：***
1. 红黑树放弃了追求完全平衡，追求大致平衡，在与平衡二叉树的时间复杂度相差不大的情况下，保证每次插入最多只需要三次旋转就能达到平衡，实现起来也更为简单。  
2. 平衡二叉树追求绝对平衡，条件比较苛刻，实现起来比较麻烦，每次插入新节点之后需要旋转的次数不能预知。  
3. 红黑树和AVL树的区别在于它使用颜色来标识结点的高度，它所追求的是局部平衡而不是AVL树中的非常严格的平衡。  
4. 红黑树是牺牲了严格的高度平衡的优越条件为代价红黑树能够以O(log2 n)的时间复杂度进行搜索、插入、删除操作。  
5. 红黑树的算法时间复杂度和AVL相同，但统计性能比AVL树更高。  

# 7. B-树、B+树   






