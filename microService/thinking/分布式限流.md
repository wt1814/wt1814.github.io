---
title: 分布式限流
date: 2020-05-16 00:00:00
tags:
    - 分布式
---

<!-- TOC -->

- [1. 限流介绍](#1-限流介绍)
- [2. 限流算法详解](#2-限流算法详解)
    - [2.1. 固定窗口计数器，控制并发数量](#21-固定窗口计数器控制并发数量)
    - [2.2. 滑动窗口](#22-滑动窗口)
    - [2.3. 漏桶算法，控制访问速率](#23-漏桶算法控制访问速率)
    - [2.4. 令牌桶算法](#24-令牌桶算法)
- [3. 分布式限流实现](#3-分布式限流实现)

<!-- /TOC -->

![image](https://gitee.com/wt1814/pic-host/raw/master/images/microService/problems/problem-28.png)  

&emsp; ***<font color = "lime">在开发高并发系统时有三把利器用来保护系统：缓存、降级和限流。</font>***   

# 1. 限流介绍  
&emsp; 由于API接口无法控制调用方的行为，因此当遇到瞬时请求量激增时，会导致接口占用过多服务器资源，使得其他请求响应速度降低或是超时，更有甚者可能导致服务器宕机。接口限流可以解决此问题。  
&emsp; 限流(Rate limiting)指对应用服务的请求进行限制，例如某一接口的请求限制为100个每秒,对超过限制的请求则进行快速失败或丢弃。  

&emsp; <font color="red">限流可以应对：热点业务带来的突发请求、调用方bug导致的突发请求、恶意攻击请求。</font>因此，对于公开的接口最好采取限流措施。  

&emsp; 常见的限流算法有：固定窗口计数器、滑动窗口计数器、漏桶法和令牌桶算法。  

&emsp; <font color = "red">限流方式：服务降级、服务拒绝。</font>  

&emsp; <font color = "red">设计要点：</font>   

* 手动开关，主动运维和应急使用；  
* 监控通知，限流发生时有关人员要清楚；  
* 用户感知，如返回特定错误信息；  
* 链路标识，RPC链路加入限流标识方便上下游业务识别限流场景做不同处理；  

# 2. 限流算法详解  
## 2.1. 固定窗口计数器，控制并发数量  
&emsp; 单位时间内，所接受的QPS的请求数目，如果超过阈值，则直接拒绝服务。  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/microService/problems/problem-23.png)  

&emsp; 固定窗口计数器算法概念如下：  

* 将时间划分为多个窗口；  
* 在每个窗口内每有一次请求就将计数器加一；  
* 如果计数器超过了限制数量，则本窗口内所有的请求都被丢弃当时间到达下一个窗口时，计数器重置。  

&emsp; 固定窗口计数器是最为简单的算法，但<font color="red">固定窗口算法有时会让通过请求量允许为限制的两倍</font>。考虑如下情况：限制1秒内最多通过5个请求，在第一个窗口的最后半秒内通过了5个请求，第二个窗口的前半秒内又通过了5个请求。这样看来就是在1秒内通过了10个请求。  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/microService/problems/problem-24.png)  
&emsp; Java内部可以通过原子类计数器AtomicInteger、信号量Semaphore来做简单的限流。  

```
// 限流的个数
private int maxCount = 5;
// 指定的时间内
private long interval = 60;
// 原子类计数器
private AtomicInteger atomicInteger = new AtomicInteger(0);
// 起始时间
private long startTime = System.currentTimeMillis();

public boolean limit(int maxCount, int interval) {
    atomicInteger.addAndGet(1);
    if (atomicInteger.get() == 1) {
        startTime = System.currentTimeMillis();
        atomicInteger.addAndGet(1);
        return true;
    }
    // 超过了间隔时间，直接重新开始计数
    if (System.currentTimeMillis() - startTime > interval * 1000) {
        startTime = System.currentTimeMillis();
        atomicInteger.set(1);
        return true;
    }
    // 还在间隔时间内,check有没有超过限流的个数
    if (atomicInteger.get() > maxCount) {
        return false;
    }
    return true;
}
```

## 2.2. 滑动窗口  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/microService/problems/problem-25.png)  
&emsp; 滑动窗口计数器算法概念如下：  

* 将时间划分为多个区间；  
* 维持一个时间窗口，占据多个区间。在每个区间内每有一次请求就将计数器加一；  
* 每经过一个区间的时间，则抛弃最老的一个区间，并纳入最新的一个区间；  
* 如果当前窗口内区间的请求计数总和超过了限制数量，则本窗口内所有的请求都被丢弃。  

&emsp; 服务最多只能每秒钟处理5个请求。可以设置一个1秒钟的滑动窗口，窗口中有5个格子，每个格子200毫秒，每200毫秒移动一次，每次移动都需要记录当前服务请求的次数。  
&emsp; 内存中需要保存5次的次数。可以用数据结构LinkedList来实现。格子每次移动的时候判断一次，当前访问次数和LinkedList中最后一个相差是否超过200，如果超过就需要限流了。  
&emsp; 示例代码如下：  

```
//服务访问次数，可以放在Redis中，实现分布式系统的访问计数
Long counter = 0L;
//使用LinkedList来记录滑动窗口的5个格子。
LinkedList<Long> ll = new LinkedList<Long>();

public static void main(String[] args){
    Counter counter = new Counter();

    counter.doCheck();
}

private void doCheck(){
    while (true){
        ll.addLast(counter);

        if (ll.size() > 5){
            ll.removeFirst();
        }

        //比较最后一个和第一个，两者相差一秒
        if ((ll.peekLast() - ll.peekFirst()) > 200){
            //To limit rate
        }

        Thread.sleep(200);
    }
}
```
&emsp; ***计数器算法与滑动窗口算法比较：***  
&emsp; 计数器算法可以看成是滑动窗口的低精度实现。滑动窗口计数器是通过将窗口再细分，并且按照时间"滑动"，这种算法避免了固定窗口计数器带来的双倍突发请求。但时间区间的精度越高，算法所需的空间容量就越大。  

## 2.3. 漏桶算法，控制访问速率  
&emsp; 漏桶算法即是一种非常常用的限流算法，可以用来<font color = "red">实现流量整形（Traffic Shaping）和流量控制（Traffic Policing）。</font>  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/microService/problems/problem-26.png)  

&emsp; 漏桶算法概念如下：  

* 将每个请求视作"水滴"放入"漏桶"进行存储；  
* "漏桶"以固定速率向外"漏"出请求来执行；  
* 如果"漏桶"空了则停止"漏水"；如果"漏桶"满了则多余的"水滴"会被直接丢弃。  

&emsp; <font color = "red">漏桶算法的缺陷也很明显，当短时间内有大量的突发请求时，即便此时服务器没有任何负载，每个请求也都得在队列中等待一段时间才能被响应。</font>  
&emsp; 漏桶算法多使用队列实现，服务的请求会存到队列中，服务的提供方则按照固定的速率从队列中取出请求并执行，过多的请求则放在队列中排队或直接拒绝。   

## 2.4. 令牌桶算法  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/microService/problems/problem-27.png)  

&emsp; 令牌桶算法概念如下：  

* 令牌以固定速率生成，生成的令牌放入令牌桶中存放；  
* 当请求到达时，会尝试从令牌桶中取令牌，取到了令牌的请求可以执行；  
* 如果桶空了，那么尝试取令牌的请求会被直接丢弃；如果令牌桶满了则多余的令牌会直接丢弃。  

&emsp; ***漏桶和令牌桶的比较：***  
&emsp; ***<font color="lime">令牌桶可以在运行时控制和调整数据处理的速率，处理某时的突发流量。</font>***<font color="red">放令牌的频率增加可以提升整体数据处理的速度，而通过每次获取令牌的个数增加或者放慢令牌的发放速度和降低整体数据处理速度。</font>而漏桶不行，因为它的流出速率是固定的，程序处理速度也是固定的。  

&emsp; ***<font color="red">令牌桶算法既能够将所有的请求平均分布到时间区间内，又能使服务器能够承受范围内的突发请求</font>***，因此是目前使用较为广泛的一种限流算法。  

&emsp; ~~实现思路：可以准备一个队列，用来保存令牌，另外通过一个线程池定期生成令牌放到队列中，每来一个请求，就从队列中获取一个令牌，并继续执行。~~  
&emsp; 可以使用Guava的RateLimiter来实现。  

# 3. 分布式限流实现  
&emsp; Java单机限流可以使用AtomicInteger、Semaphore或Guava的RateLimiter来实现，但是上述方案都不支持集群限流。集群限流的应用场景有两个，一个是网关，常用的方案有Nginx限流和Spring Cloud Gateway，另一个场景是与外部或者下游服务接口的交互，可以使用redis+lua实现。阿里巴巴的开源限流系统Sentinel也可以针对接口限流。





