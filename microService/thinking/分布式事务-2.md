---
title: 分布式事务
date: 2020-05-11 00:00:00
tags:
    - 分布式
---
<!-- TOC -->

- [1. 消息驱动模式（Message Driven）](#1-消息驱动模式message-driven)
    - [1.1. 本地消息表（异步确保）-强一致性](#11-本地消息表异步确保-强一致性)
        - [1.1.1. 实现流程](#111-实现流程)
        - [1.1.2. 特点](#112-特点)
    - [1.2. 事务消息-最终一致性](#12-事务消息-最终一致性)
        - [1.2.1. 实现流程](#121-实现流程)
        - [1.2.2. 特点](#122-特点)
    - [1.3. 最大努力通知-最终一致性](#13-最大努力通知-最终一致性)
        - [1.3.1. 实现流程](#131-实现流程)
        - [1.3.2. 特点](#132-特点)
- [2. 事件溯源模式(Event Sourcing)，Saga事务模型-最终一致性](#2-事件溯源模式event-sourcingsaga事务模型-最终一致性)
    - [2.1. 事件/编排Choreography](#21-事件编排choreography)
        - [2.1.1. 实现流程](#211-实现流程)
        - [2.1.2. 特点](#212-特点)
    - [2.2. 命令/协调orchestrator](#22-命令协调orchestrator)
        - [2.2.1. 实现流程](#221-实现流程)
        - [2.2.2. 特点](#222-特点)

<!-- /TOC -->


# 1. 消息驱动模式（Message Driven） 
## 1.1. 本地消息表（异步确保）-强一致性  
&emsp; 本地消息表核心思想是将分布式事务拆分成本地事务进行处理。  

### 1.1.1. 实现流程  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/microService/problems/problem-6.png)  
&emsp; ***基本思路：***  
&emsp; 消息生产方，需要额外建一个消息表，并记录消息发送状态。消息表和业务数据要在一个事务里提交，也就是说要在一个数据库里面。然后消息会经过MQ发送到消息的消费方。如果消息发送失败，会进行重试发送。  
&emsp; 消息消费方，需要处理这个消息，并完成自己的业务逻辑。此时如果本地事务处理成功，表明已经处理成功了，如果处理失败，那么就会重试执行。如果是业务上面的失败，可以给生产方发送一个业务补偿消息，通知生产方进行回滚等操作。  
&emsp; 生产方和消费方定时扫描本地消息表，把还没处理完成的消息或者失败的消息再发送一遍。  

&emsp; ***具体流程：***  

        A 系统在自己本地一个事务里操作同时，插入一条数据到消息表；  
        接着A系统将这个消息发送到MQ中去；  
        B系统接收到消息之后，在一个事务里，往自己本地消息表里插入一条数据，同时执行其他的业务操作，如果这个消息已经被处理过了，那么此时这个事务会回滚，这样保证不会重复处理消息；  
        B系统执行成功之后，就会更新自己本地消息表的状态以及A系统消息表的状态；  
        如果B系统处理失败了，那么就不会更新消息表状态，那么此时A系统会定时扫描自己的消息表，如果有未处理的消息，会再次发送到MQ中去，让B再次处理；  
        这个方案保证了最终一致性，哪怕B事务失败了，但是A会不断重发消息，直到B那边成功为止。  

### 1.1.2. 特点  
* 优点：从应用设计开发的角度实现了消息数据的可靠性，消息数据的可靠性不依赖于消息中间件，弱化了对 MQ 中间件特性的依赖。  
* 缺点：与具体的业务场景绑定，耦合性强，不可公用。消息数据与业务数据同库，占用业务系统资源。业务系统在使用关系型数据库的情况下，消息服务性能会受到关系型数据库并发性能的局限。  

## 1.2. 事务消息-最终一致性  
&emsp; 该方案基于本地消息表进行优化，不使用本地消息表，而是基于MQ（RocketMQ支持事务消息，RabbitMQ和Kafka都不支持事务消息。）RocketMQ中间件能够支持一种事务消息机制，确保本地操作和发送消息的异步处理达到本地事务的结果一致。  

### 1.2.1. 实现流程  
&emsp; 事务消息作为一种异步确保型事务，将两个事务分支通过MQ进行异步解耦，事务消息的设计流程同样借鉴了两阶段提交理论，整体交互流程如下图所示：  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/microService/problems/problem-7.png)  
&emsp; 事务发起方发送 Prepare 消息到消息中间件。  
&emsp; 发送成功后，执行本地事务。如果事务执行成功，则 Commit，消息中间件将消息下发至消费端。如果事务执行失败，则回滚，消息中间件将这条 Prepare 消息删除。如果执行本地事务过程中，执行端挂掉，或者超时，MQ将会不停的询问其同组的其它producer来获取状态。  
&emsp; 消费端接收到消息进行消费，如果消费失败，则不断重试。  

### 1.2.2. 特点  

* 优点：  
    * 消息数据独立存储，降低业务系统与消息系统之间的耦合。
    * 吞吐量优于本地消息表方案。
* 缺点：
    * 一次消息发送需要两次网络请求(half消息 + commit/rollback)。
    * 需要实现消息回查接口。

## 1.3. 最大努力通知-最终一致性  
&emsp; 最大努力通知型( Best-effort delivery)是最简单的一种柔性事务，适用于一些最终一致性时间敏感度低的业务，且被动方处理结果不影响主动方的处理结果。典型的使用场景：如银行通知、商户通知、短信、邮件等。最大努力通知其实就是消息中间件的使用。  

### 1.3.1. 实现流程  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/microService/problems/problem-8.png)  
&emsp; 在该系统中，A系统执行完本地事务，向MQ发送消息，最大努力通知服务消费消息，比如消息服务，然后调用B系统的接口，执行B系统的本地事务，如果B系统执行成功则OK，否则不断重试，重复多次之后还是失败的话就放弃执行。 
 
### 1.3.2. 特点  
&emsp; ***最大努力通知方案和可靠消息最终一致性方案的区别：***  
&emsp; 可靠消息最终一致性方案可以保证的是只要系统A的事务完成，通过不停（无限次）重试来保证系统B的事务总会完成。但是最大努力方案就不同，如果系统B本地事务执行失败了，那么它会重试N次后就不再重试，系统B的本地事务可能就不会完成了。  

# 2. 事件溯源模式(Event Sourcing)，Saga事务模型-最终一致性  
&emsp; Saga模式是一种分布式异步事务，一种最终一致性事务，是一种柔性事务，有两种不同的方式来实现saga事务，最流行的两种方式是以下两种。  

## 2.1. 事件/编排Choreography  
&emsp; 没有中央协调器（没有单点风险）时，每个服务产生并聆听其他服务的事件，并决定是否应采取行动。  
&emsp; 该实现第一个服务执行一个事务，然后发布一个事件。该事件被一个或多个服务进行监听，这些服务再执行本地事务并发布（或不发布）新的事件，当最后一个服务执行本地事务并且不发布任何事件时，意味着分布式事务结束，或者它发布的事件没有被任何Saga参与者听到都意味着事务结束。 
![image](https://gitee.com/wt1814/pic-host/raw/master/images/microService/problems/problem-30.png)  

### 2.1.1. 实现流程  
1. 订单服务保存新订单，将状态设置为pengding挂起状态，并发布名为ORDER_CREATED_EVENT的事件。
2. 支付服务监听ORDER_CREATED_EVENT，并公布事件BILLED_ORDER_EVENT。
3. 库存服务监听BILLED_ORDER_EVENT，更新库存，并发布ORDER_PREPARED_EVENT。
4. 货运服务监听ORDER_PREPARED_EVENT，然后交付产品。最后，它发布ORDER_DELIVERED_EVENT。
5. 最后，订单服务侦听ORDER_DELIVERED_EVENT并设置订单的状态为concluded完成。

&emsp; 假设库存服务在事务过程中失败了。进行回滚：
1. 库存服务产生PRODUCT_OUT_OF_STOCK_EVENT
2. 订购服务和支付服务会监听到上面库存服务的这一事件：
    1. 支付服务会退款给客户。
    2. 订单服务将订单状态设置为失败。  

### 2.1.2. 特点  
* 优点：事件/编排是实现Saga模式的自然方式; 它很简单，容易理解，不需要太多的努力来构建，所有参与者都是松散耦合的，因为它们彼此之间没有直接的耦合。如果事务涉及2至4个步骤，则可能是非常合适的。  

## 2.2. 命令/协调orchestrator  
&emsp; 中央协调器负责集中处理事件的决策和业务逻辑排序。  
&emsp; saga协调器orchestrator以命令/回复的方式与每项服务进行通信，告诉服务应该执行哪些操作。  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/microService/problems/problem-31.png)  

### 2.2.1. 实现流程  
1. 订单服务保存pending状态，并要求订单Saga协调器（简称OSO）开始启动订单事务。
2. OSO向收款服务发送执行收款命令，收款服务回复Payment Executed消息。
3. OSO向库存服务发送准备订单命令，库存服务将回复OrderPrepared消息。
4. OSO向货运服务发送订单发货命令，货运服务将回复Order Delivered消息。

&emsp; OSO订单Saga协调器必须事先知道执行“创建订单”事务所需的流程(通过读取BPM业务流程XML配置获得)。如果有任何失败，它还负责通过向每个参与者发送命令来撤销之前的操作来协调分布式的回滚。当有一个中央协调器协调一切时，回滚要容易得多，因为协调器默认是执行正向流程，回滚时只要执行反向流程即可。  

### 2.2.2. 特点  
* 优点：
    * 避免服务之间的循环依赖关系，因为saga协调器会调用saga参与者，但参与者不会调用协调器。
    * 集中分布式事务的编排。
    * 只需要执行命令/回复(其实回复消息也是一种事件消息)，降低参与者的复杂性。
    * 在添加新步骤时，事务复杂性保持线性，回滚更容易管理。
    * 如果在第一笔交易还没有执行完，想改变有第二笔事务的目标对象，则可以轻松地将其暂停在协调器上，直到第一笔交易结束。
* 缺点：协调器中集中太多逻辑的风险。  
