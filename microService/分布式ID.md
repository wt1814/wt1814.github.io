---
title: 分布式ID
date: 2020-05-10 00:00:00
tags:
    - 分布式
---
## 分布式ID  
&emsp; 在业务开发中需要使用一些id。分布式系统的全局唯一ID称为分布式ID。  

&emsp; 分布式ID需要满足那些条件？  
* 全局唯一：必须保证ID是全局性唯一的，基本要求。  
* 高性能：高可用低延时，ID生成响应要块，否则反倒会成为业务瓶颈。  
* 高可用：100%的可用性是骗人的，但是也要无限接近于100%的可用性。  
* 好接入：要秉着拿来即用的设计原则，在系统设计和实现上要尽可能的简单。  
* 趋势递增：最好趋势递增，这个要求就得看具体业务场景了，一般不严格要求。  
* 可反解：一个ID生成之后，就会伴随着信息终身，排错分析的时候，需要查验。这时候一个可反解的ID可以帮上很多忙，从哪里来的，什么时候出生的。  

## 分布式ID常见生成方案  

&emsp; 分布式ID常见生成方案有以下几种：  
* UUID
* 数据库自增ID
* 数据库多主模式
* 号段模式
* Redis
* 雪花算法(SnowFlake)
* 滴滴出品(TinyID)
* 百度(Uidgenerator)
* 美团(Leaf)  

### UUID  
&emsp; ***生产随机数的方式：***  
1). Math.random()0到1之间随机数；  
2). java.util.Random伪随机数（线性同余法生成）；  
3). java.security.SecureRandom真随机数；  
4). java.util.concurrent.ThreadLocalRandom每一个线程有一个独立的随机数生成器。  

&emsp; ***优点：***  
* 不需要第三方组件（也就没有单点的风险），代码实现简单；  
* 本机生成，没有网络消耗；  
* 因为是全球唯一的ID，所以迁移数据容易。  

&emsp; ***缺点：***  
* 每次生成的ID是无序的，相对来说还会影响性能（比如 MySQL 的 InnoDB 引擎，如果UUID作为数据库主键，其无序性会导致数据位置频繁变动）；  
* UUID的字符串存储，查询效率慢；  
* 长度长，存储空间大；  
* ID本事无业务含义，不可读。  

&emsp; ***应用场景：***  
* 适用于类似生成token令牌的场景；  
* 不适用一些要求有趋势递增的ID场景。  

### 2. 利用数据库生成  
#### MySql主键自增：  
&emsp; 这个方案利用了MySQL的主键自增auto_increment，默认每次ID加1。  
&emsp; ***优点：***  
* 数字化，id递增；  
* 查询效率高；  
* 具有一定的业务可读。  
&emsp; ***缺点：***  
* 存在单点问题，如果mysql挂了，就没法生成ID；  
* 数据库压力大，高并发抗不住。  

