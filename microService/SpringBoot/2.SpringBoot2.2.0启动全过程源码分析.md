---
title: Spring Boot 2.2.0启动全过程源码分析
date: 2020-04-14 00:00:00
tags:
    - SpringBoot
---
<!-- TOC -->

- [1. Spring Boot 2.2.0启动全过程源码分析](#1-spring-boot-220启动全过程源码分析)
    - [1.1. SpringApplication初始化](#11-springapplication初始化)
        - [1.1.1. 流程解析](#111-流程解析)
            - [1.1.1.1. 推断当前 WEB 应用类型](#1111-推断当前-web-应用类型)
            - [1.1.1.2. 设置应用上下文初始化器](#1112-设置应用上下文初始化器)
            - [1.1.1.3. 设置监听器](#1113-设置监听器)
    - [1.2. SpringApplication 实例 run()方法运行过程](#12-springapplication-实例-run方法运行过程)
        - [1.2.1. 流程解析：](#121-流程解析)
            - [1.2.1.1. 步骤3：设置系统属性 `java.awt.headless` 的值](#1211-步骤3设置系统属性-javaawtheadless-的值)
            - [1.2.1.2. 步骤6：根据运行监听器和应用参数来准备 Spring 环境](#1212-步骤6根据运行监听器和应用参数来准备-spring-环境)
            - [1.2.1.3. 步骤8：准备应用上下文](#1213-步骤8准备应用上下文)
        - [1.2.2. 总结：](#122-总结)

<!-- /TOC -->

# 1. Spring Boot 2.2.0启动全过程源码分析
&emsp; SpringBoot启动类代码如下：  

```java
public static void main(String[] args) {
    SpringApplication.run(DemoApplication.class, args);
}
```
&emsp; 进入SpringApplication#run方法中，一路点击#run方法。  

```java
public static ConfigurableApplicationContext run(Class<?>[] primarySources, String[] args) {
    return (new SpringApplication(primarySources)).run(args);
}
```
&emsp; SpringApplication.run()中首先new SpringApplication对象，然后调用该对象的run方法。即run()方法主要包括两大步骤：  
1. 创建SpringApplication 对象；  
2. 运行run()方法。  

## 1.1. SpringApplication初始化  
<!-- https://mp.weixin.qq.com/s/JcMRo6xuDEimKk-KZDKJ1g-->
![image](https://gitee.com/wt1814/pic-host/raw/master/images/sourceCode/springBoot/springBoot-4.png)  

&emsp; 构造过程一般是对构造函数一些成员属性赋值。  
&emsp; 构造SpringApplication对象时需要用到的一些成员属性：  

```
// SpringApplication.java

/**
 * SpringBoot的启动类即包含main函数的主类
 */
private Set<Class<?>> primarySources;
/**
 * 包含main函数的主类
 */
private Class<?> mainApplicationClass;
/**
 * 资源加载器
 */
private ResourceLoader resourceLoader;
/**
 * 应用类型
 */
private WebApplicationType webApplicationType;
/**
 * 初始化器
 */
private List<ApplicationContextInitializer<?>> initializers;
/**
 * 监听器
 */
private List<ApplicationListener<?>> listeners;
```
&emsp; 构建SpringApplication对象时主要是给上面代码中的六个成员属性赋值。  


&emsp; SpringApplication的一个构造函数：  

```java
public SpringApplication(ResourceLoader resourceLoader, Class... primarySources) {

    this.sources = new LinkedHashSet();
    this.bannerMode = Mode.CONSOLE;
    this.logStartupInfo = true;
    this.addCommandLineProperties = true;
    this.addConversionService = true;
    this.headless = true;
    this.registerShutdownHook = true;
    this.additionalProfiles = new HashSet();
    this.isCustomEnvironment = false;
    //1. 给resourceLoader属性赋值，注意传入的resourceLoader参数为null
    this.resourceLoader = resourceLoader;
    //断言主要加载资源类不能为 null，否则报错
    Assert.notNull(primarySources, "PrimarySources must not be null");
    //2. 初始化主要加载资源类集合并去重
    this.primarySources = new LinkedHashSet(Arrays.asList(primarySources));
    //3. 判断当前是否是一个 Web 应用
    this.webApplicationType = WebApplicationType.deduceFromClasspath();
    //4. 设置应用上下文初始化器
    // 从类路径下找到 META/INF/Spring.factories 配置的所有 ApplicationContextInitializer，然后保存起来
    this.setInitializers(this.getSpringFactoriesInstances(ApplicationContextInitializer.class));
    //5. 设置监听器
    // 从类路径下找到 META/INF/Spring.factories 配置的所有 ApplicationListener，然后保存起来
    this.setListeners(this.getSpringFactoriesInstances(ApplicationListener.class));
    //6. 推断主入口应用类。从多个配置类中找到有 main 方法的主配置类（只有一个）
    this.mainApplicationClass = this.deduceMainApplicationClass();
}
```
&emsp; 可以看到构建SpringApplication对象时其实就是给前面讲的6个SpringApplication类的成员属性赋值而已，做一些初始化工作：  
1. 给resourceLoader属性赋值，resourceLoader属性，资源加载器，此时传入的resourceLoader参数为null；  
2. 给primarySources属性赋值，primarySources属性即SpringApplication.run(MainApplication.class,args);中传入的MainApplication.class，该类为SpringBoot项目的启动类，主要通过该类来扫描Configuration类加载bean；
3. 给webApplicationType属性赋值，webApplicationType属性，代表应用类型，根据classpath存在的相应Application类来判断。因为后面要根据webApplicationType来确定创建哪种Environment对象和创建哪种ApplicationContext；
4. 给initializers属性赋值，initializers属性为List<ApplicationContextInitializer<?\>>集合，利用SpringBoot的SPI机制从spring.factories配置文件中加载，后面在初始化容器的时候会应用这些初始化器来执行一些初始化工作。因为SpringBoot自己实现的SPI机制比较重要；  
5. 给listeners属性赋值，listeners属性为List<ApplicationListener<?\>>集合，同样利用利用SpringBoot的SPI机制从spring.factories配置文件中加载。因为SpringBoot启动过程中会在不同的阶段发射一些事件，所以这些加载的监听器们就是来监听SpringBoot启动过程中的一些生命周期事件的；
6. 给mainApplicationClass属性赋值，mainApplicationClass属性表示包含main函数的类，即这里要推断哪个类调用了main函数，然后把这个类的全限定名赋值给mainApplicationClass属性，用于后面启动流程中打印一些日志，详细分析见后面的第3.2小节。

### 1.1.1. 流程解析  
&emsp; 从上述流程中，挑以下几个进行分析。  

#### 1.1.1.1. 推断当前 WEB 应用类型  

```java
this.webApplicationType = deduceWebApplicationType();
```
&emsp; deduceWebApplicationType方法和相关的源码：  

```java
private WebApplicationType deduceWebApplicationType() {

    if (ClassUtils.isPresent(REACTIVE_WEB_ENVIRONMENT_CLASS, null) && !ClassUtils.isPresent(MVC_WEB_ENVIRONMENT_CLASS, null)) {
        return WebApplicationType.REACTIVE;
    }

    for (String className : WEB_ENVIRONMENT_CLASSES) {
        if (!ClassUtils.isPresent(className, null)) {
            return WebApplicationType.NONE;
        }
    }
    return WebApplicationType.SERVLET;
}

private static final String REACTIVE_WEB_ENVIRONMENT_CLASS = "org.springframework." 
        + "web.reactive.DispatcherHandler";
private static final String MVC_WEB_ENVIRONMENT_CLASS = "org.springframework."
        + "web.servlet.DispatcherServlet";
private static final String[] WEB_ENVIRONMENT_CLASSES = { "javax.servlet.Servlet",
        "org.springframework.web.context.ConfigurableWebApplicationContext" };

public enum WebApplicationType {
    /**
     * 非 WEB 项目
     */
    NONE,
    /**
     * SERVLET WEB 项目
     */
    SERVLET,
    /**
     * 响应式 WEB 项目
     */
    REACTIVE
}
```
&emsp; 这个就是根据类路径下是否有对应项目类型的类推断出不同的应用类型。  

#### 1.1.1.2. 设置应用上下文初始化器  

```java
this.setInitializers(this.getSpringFactoriesInstances(ApplicationContextInitializer.class));
```
1. 参数ApplicationContextInitializer.class用来初始化指定的 Spring 应用上下文，如注册属性资源、激活 Profiles 等。  
2. this.getSpringFactoriesInstances()方法和相关的源码：  

```java
private <T> Collection<T> getSpringFactoriesInstances(Class<T> type) {
    return this.getSpringFactoriesInstances(type, new Class[0]);
}

private <T> Collection<T> getSpringFactoriesInstances(Class<T> type, Class<?>[] parameterTypes, Object... args) {
    //获取当前线程上下文类加载器
    ClassLoader classLoader = this.getClassLoader();
    //获取 ApplicationContextInitializer 的实例名称集合并去重
      //根据类路径下的 META-INF/spring.factories 文件解析并获取 ApplicationContextInitializer 接口的所有配置的类路径名称
    Set<String> names = new LinkedHashSet(SpringFactoriesLoader.loadFactoryNames(type, classLoader));
    //根据以上类路径创建初始化器实例列表
    List<T> instances = this.createSpringFactoriesInstances(type, parameterTypes, classLoader, args, names);
    //初始化器实例列表排序
    AnnotationAwareOrderComparator.sort(instances);
    //返回初始化器实例列表
    return instances;
}
```  

#### 1.1.1.3. 设置监听器  

```java
this.setListeners(this.getSpringFactoriesInstances(ApplicationListener.class));
```
&emsp; 参数ApplicationListener.class继承了JDK 的 java.util.EventListener 接口，实现了观察者模式，它一般用来定义感兴趣的事件类型，事件类型限定于 ApplicationEvent的子类。  

----------------
## 1.2. SpringApplication 实例 run()方法运行过程
&emsp; 进入SpringApplication#run方法中，一路点击#run方法。  

```java
public ConfigurableApplicationContext run(String... args) {

    // 1、创建并启动计时监控类
    StopWatch stopWatch = new StopWatch();
    stopWatch.start();//首先记录了当前任务的名称，默认为空字符串，然后记录当前 Spring Boot 应用启动的开始时间
    // 2、初始化应用上下文和异常报告集合
    ConfigurableApplicationContext context = null;
    Collection<SpringBootExceptionReporter> exceptionReporters = new ArrayList();
    // 3、设置系统属性 `java.awt.headless` 的值，默认值为：true
    this.configureHeadlessProperty();
    // 4、创建所有 Spring 运行监听器并发布应用启动事件
    // 从类路径下找到 META/INF/Spring.factories 获取 SpringApplicationRunListeners
    SpringApplicationRunListeners listeners = this.getRunListeners(args);
    // 回调所有 SpringApplicationRunListeners 的 starting() 方法
    listeners.starting();
    Collection exceptionReporters;
    try {
        // 5、初始化默认应用参数类，封装命令行参数
        ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);
        // 6、根据运行监听器和应用参数来准备 Spring 环境
        //包括创建环境，创建环境完成后回调 SpringApplicationRunListeners#environmentPrepared()方法，表示环境准备完成
        ConfigurableEnvironment environment = this.prepareEnvironment(listeners, applicationArguments);
        this.configureIgnoreBeanInfo(environment);
        // 7、打印 Banner
        Banner printedBanner = this.printBanner(environment);
        // 8、创建应用上下文（决定创建 web 的 IOC 容器还是普通的 IOC 容器）
            //根据不同的应用类型初始化不同的上下文应用类
        context = this.createApplicationContext();
        // 9、准备异常报告器
        exceptionReporters = this.getSpringFactoriesInstances(SpringBootExceptionReporter.class, new Class[]{ConfigurableApplicationContext.class}, context);
        // 10、准备应用上下文
        /*
         * 将 environment 保存到 IOC 容器中，并且调用 applyInitializers() 方法
         * applyInitializers() 方法回调之前保存的所有的 ApplicationContextInitializer 的 initialize() 方法
         * 然后回调所有的 SpringApplicationRunListener#contextPrepared() 方法
         * 最后回调所有的 SpringApplicationRunListener#contextLoaded() 方法
         */
        this.prepareContext(context, environment, listeners, applicationArguments, printedBanner);
        // 11、刷新应用上下文，IOC 容器初始化（如果是 Web 应用还会创建嵌入式的 Tomcat），扫描、创建、加载所有组件
        this.refreshContext(context);
        // 12、应用上下文刷新后置处理，从 IOC 容器中获取所有的 ApplicationRunner 和 CommandLineRunner 进行回调
        this.afterRefresh(context, applicationArguments);
        // 13、停止计时监控类
        stopWatch.stop();
        // 14、输出日志记录执行主类名、时间信息
        if (this.logStartupInfo) {
            (new StartupInfoLogger(this.mainApplicationClass)).logStarted(this.getApplicationLog(), stopWatch);
        }
        // 15、发布应用上下文启动完成事件，调用所有SpringApplicationRunListeners#started()方法
        listeners.started(context);
        // 16、执行ApplicationRunner和CommandLineRunner两种运行器
        this.callRunners(context, applicationArguments);
    } catch (Throwable var10) {
        this.handleRunFailure(context, var10, exceptionReporters, listeners);
        throw new IllegalStateException(var10);
    }
    try {
        // 17、发布应用上下文就绪事件，触发所有SpringApplicationRunListener 监听器的running事件方法。
        listeners.running(context);
        // 18、返回应用上下文
        return context;
    } catch (Throwable var9) {
        this.handleRunFailure(context, var9, exceptionReporters, (SpringApplicationRunListeners)null);
        throw new IllegalStateException(var9);
    }
}
```

### 1.2.1. 流程解析：  
&emsp; 从上述流程中，挑以下几个进行分析。

#### 1.2.1.1. 步骤3：设置系统属性 `java.awt.headless` 的值  

```java
this.configureHeadlessProperty();
```
&emsp; 设置该默认值为：true，Java.awt.headless = true 有什么作用？  
&emsp; 对于一个Java服务器来说经常要处理一些图形元素，例如地图的创建或者图形和图表等。这些API基本上总是需要运行一个X-server以便能使用AWT（Abstract Window Toolkit，抽象窗口工具集）。然而运行一个不必要的 X-server 并不是一种好的管理方式。有时你甚至不能运行 X-server,因此最好的方案是运行 headless 服务器，来进行简单的图像处理。  
&emsp; 参考：www.cnblogs.com/princessd8251/p/4000016.html  

#### 1.2.1.2. 步骤6：根据运行监听器和应用参数来准备 Spring 环境  

```java
ConfigurableEnvironment environment = this.prepareEnvironment(listeners, applicationArguments);
this.configureIgnoreBeanInfo(environment);
```
&emsp; this.prepareEnvironment()源码：  

```java
private ConfigurableEnvironment prepareEnvironment(SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments) {
    // 6.1) 获取（或者创建）应用环境
        //分为标准 Servlet 环境和标准环境
    ConfigurableEnvironment environment = this.getOrCreateEnvironment();
    // 6.2) 配置应用环境
        // 配置 property sources
        //配置 Profiles
    this.configureEnvironment((ConfigurableEnvironment)environment, applicationArguments.getSourceArgs());
    ConfigurationPropertySources.attach((Environment)environment);
    listeners.environmentPrepared((ConfigurableEnvironment)environment);
    this.bindToSpringApplication((ConfigurableEnvironment)environment);
    if (!this.isCustomEnvironment) {
        environment = (new EnvironmentConverter(this.getClassLoader())).convertEnvironmentIfNecessary((ConfigurableEnvironment)environment, this.deduceEnvironmentClass());
    }

    ConfigurationPropertySources.attach((Environment)environment);
    return (ConfigurableEnvironment)environment;
}
```

#### 1.2.1.3. 步骤8：准备应用上下文  

```java
this.prepareContext(context, environment, listeners, applicationArguments, printedBanner);
```
&emsp; this.prepareContext()源码：  

```java
private void prepareContext(ConfigurableApplicationContext context, ConfigurableEnvironment environment, SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments, Banner printedBanner) {
    //绑定环境到上下文
    context.setEnvironment(environment);
    //配置上下文的 bean 生成器及资源加载器
    this.postProcessApplicationContext(context);
    //为上下文应用所有初始化器
    this.applyInitializers(context);
    //触发所有 SpringApplicationRunListener 监听器的 contextPrepared 事件方法
    listeners.contextPrepared(context);
    //记录启动日志
    if (this.logStartupInfo) {
        this.logStartupInfo(context.getParent() == null);
        this.logStartupProfileInfo(context);
    }
    //注册两个特殊的单例bean
    ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();
    beanFactory.registerSingleton("springApplicationArguments", applicationArguments);
    if (printedBanner != null) {
        beanFactory.registerSingleton("springBootBanner", printedBanner);
    }

    if (beanFactory instanceof DefaultListableBeanFactory) {
        ((DefaultListableBeanFactory)beanFactory).setAllowBeanDefinitionOverriding(this.allowBeanDefinitionOverriding);
    }

    if (this.lazyInitialization) {
        context.addBeanFactoryPostProcessor(new LazyInitializationBeanFactoryPostProcessor());
    }
    //加载所有资源
    Set<Object> sources = this.getAllSources();
    Assert.notEmpty(sources, "Sources must not be empty");
    this.load(context, sources.toArray(new Object[0]));
    //触发所有 SpringApplicationRunListener 监听器的 contextLoaded 事件方法
    listeners.contextLoaded(context);
}
```

### 1.2.2. 总结：  
&emsp; run() 阶段主要是回调4个监听器(ApplicationContextInitializer、ApplicationRunner、CommandLineRunner、SpringApplicationRunListener)中的方法与加载项目中组件到 IOC 容器中，而所有需要回调的监听器都是从类路径下的 META/INF/Spring.factories 中获取，从而达到启动前后的各种定制操作。  



