---
   title: 分布式锁
   date: 2020-05-13 00:00:00
   tags:
       - 分布式
---
## 1. 分布式锁简介  
### 为什么需要分布式锁？  
![](https://gitee.com/wt1814/pic-host/raw/master/images/microService/problems/problem-11.png)  
&emsp; 如上图，在分布式系统中，订单模块为了迎战高并发，订单服务被横向拆分，拆分成了不同的进程，就像上图，两个人同时访问订单服务,然后订单系统1和订单系统2共用一个Mysql当成数据库，经过查询发现仅有一件商品，所以两个系统都认为可以下单。如果不加锁限制,可能会出现库存减为负数的情况。解决方案：  
![](https://gitee.com/wt1814/pic-host/raw/master/images/microService/problems/problem-12.png)  
&emsp; 如上图。mysql自带行级锁，可以考虑使用它的行级锁，可以保证数据的安全。不足之处：使用MySql的行级锁，系统的中压力全部集中在mysql，那mysql就是系统吞吐量的瓶颈了，系统的吞吐量也会收到mysql的限制。  
&emsp; 可以使用分布式锁。如下图,分布式锁将系统的压力从mysql上面转移到自己身上来。  
![](https://gitee.com/wt1814/pic-host/raw/master/images/microService/problems/problem-13.png)  

&emsp; ***分布式锁的使用场景：***  
&emsp; 在分布式环境下解决多实例对数据的访问一致性。只要涉及到多个实例进程对同一份数据进行修改等操作都会需要分布式锁，例如全局计数器，再比如在下单，更新缓存，减少库存等场景下会用到分布式锁。  

### CAP理论在分布式锁的应用  
&emsp; 分布式锁一般有三种实现方式：1.数据库悲观锁、乐观锁；2.基于缓存（redis，memcached，tair）的分布式锁；3.基于ZooKeeper临时顺序节点的分布式锁。  
&emsp; 基于Redis的分布式锁是AP模型，基于Zookeeper的分布式锁是CP模型的。  

## 2. 分布式锁实现  
&emsp; 分布式锁实现的三个核心要素：1.加锁；2.解锁；3.锁超时。  

### 1. 基于Redis的分布式锁  

#### 1. 使用Redis分布式锁的中的问题：  

1. 超时问题：  
2. 部署问题：除了要考虑客户端要怎么实现分布式锁之外，还需要考虑Redis的部署问题。Redis有3种部署方式：单机模式；Master-Slave+Sentinel选举模式；Redis Cluster模式。  
&emsp; 如果采用单机部署模式，会存在单点问题，只要 Redis 故障了。加锁就不行了。  
&emsp; 采用Master-Slave 模式，加锁的时候只对一个节点加锁，即便通过 Sentinel做了高可用，但是如果Master节点故障了，发生主从切换，此时就会有可能出现锁丢失的问题。  
3. 加锁涉及获取锁、加锁操作；解锁涉及获取锁、解锁操作。Redis如何保证原子操作？

#### Redis 分布式锁实现：  
##### Redis Client原生API  
###### 单实例redis实现分布式锁  

&emsp; ***加锁代码：***  

```java
public class RedisTool {
    private static final String LOCK_SUCCESS = "OK";
    private static final String SET_IF_NOT_EXIST = "NX";
    private static final String SET_WITH_EXPIRE_TIME = "PX";
    /**
     * 尝试获取分布式锁
     * @param jedis Redis客户端
     * @param lockKey 锁
     * @param requestId 请求标识
     * @param expireTime 超期时间
     * @return 是否获取成功
     */
    public static boolean tryGetDistributedLock(Jedis jedis, String lockKey, String requestId, int expireTime) {
        String result = jedis.set(lockKey, requestId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime);
        if (LOCK_SUCCESS.equals(result)) {
            return true;
        }
        return false;
    }
}
```
&emsp; 加锁就一行代码：jedis.set(String key, String value, String nxxx, String expx, int time)，这个set()方法一共有五个形参：  
1).key，使用key来当锁，因为key是唯一的。  
2).value，传参requestId，代表执行的具体线程。  
3).nxxx，传参NX，意思是SET IF NOT EXIST，即当key不存在时，进行set操作；若key已经存在，则不做任何操作；  
4).expx，传参PX，即给这个key加一个过期的设置，具体时间由第五个参数决定。  
5).time，与第四个参数相呼应，代表key的过期时间。  

&emsp; 执行上面的set()方法就只会导致两种结果：1).锁不存在，那么就进行加锁操作，并对锁设置个有效期，同时value表示加锁的客户端；2).锁存在，不做任何操作。  

&emsp; 加锁中使用了redis的set命令。最初分布式锁借助于setnx和expire命令，但是这两个命令不是原子操作，如果执行setnx之后获取锁但是此时客户端挂掉，这样无法执行expire设置过期时间就导致锁一直无法被释放，因此在2.8版本中Antirez为setnx增加了参数扩展，使得setnx和expire具备原子操作性。  
    
    SET KEY value [EX seconds] [PX milliseconds] [NX|XX]  
* EX second:设置键的过期时间为second秒。  
* PX millisecond:设置键的过期时间为millisecond毫秒。  
* NX：只在键不存在时，才对键进行设置操作。  
* XX:只在键已经存在时，才对键进行设置操作。  

&emsp; ***解锁代码：***  

```java
public class RedisTool {
    private static final Long RELEASE_SUCCESS = 1L;
    /**
     * 释放分布式锁
     * @param jedis Redis客户端
     * @param lockKey 锁
     * @param requestId 请求标识
     * @return 是否释放成功
     */
    public static boolean releaseDistributedLock(Jedis jedis, String lockKey, String requestId) {
        //Lua脚本代码
        String script = "if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end";
        Object result = jedis.eval(script, Collections.singletonList(lockKey), Collections.singletonList(requestId));
        if (RELEASE_SUCCESS.equals(result)) {
            return true;
        }
        return false;
    }
}
```
###### 集群redlock算法实现分布式锁  
&emsp; RedLock算法的：假设Redis的部署模式是Redis Cluster，总共有5个Master节点。客户端通过以下步骤获取一把锁：  
*1. 获取当前时间戳，单位是毫秒。  
*2. 轮流尝试在每个Master节点上创建锁，过期时间设置较短，一般就几十毫秒。  
*3. 尝试在大多数节点上建立一个锁，比如 5 个节点就要求是3个节点（n / 2 +1）。  
*4. 客户端计算建立好锁的时间，如果建立锁的时间小于超时时间，就算建立成功了。  
*5. 要是锁建立失败了，那么就依次删除这个锁。  
*6. 只要别人建立了一把分布式锁，你就得不断轮询去尝试获取锁。  

&emsp; ***RedisLock工具类：***  

```java
package com.caiya.cms.web.component;

import com.caiya.cache.CacheException;
import com.caiya.cache.redis.JedisCache;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.Objects;
import java.util.concurrent.TimeUnit;

/**
 * redis实现分布式锁
 * 可实现特性:
 * 1、使多线程无序排队获取和释放锁;
 * 2、丢弃未成功获得锁的线程处理;
 * 3、只释放线程本身加持的锁;
 * 4、避免死锁
 *
 * @author wangnan
 * @since 1.0
 */
public final class RedisLock {

    private static final Logger logger = LoggerFactory.getLogger(RedisLock.class);

    /**
     * 尝试加锁(仅一次)
     *
     * @param lockKey       锁key
     * @param lockValue     锁value
     * @param expireSeconds 锁超时时间(秒)
     * @return 是否加锁成功
     * @throws CacheException
     */
    public static boolean tryLock(String lockKey, String lockValue, long expireSeconds) throws CacheException {
        JedisCache jedisCache = JedisCacheFactory.getInstance().getJedisCache();
        try {
            String response = jedisCache.set(lockKey, lockValue, "nx", "ex", expireSeconds);
            return Objects.equals(response, "OK");
        } finally {
            jedisCache.close();
        }
    }

    /**
     * 加锁(指定最大尝试次数范围内)
     *
     * @param lockKey       锁key
     * @param lockValue     锁value
     * @param expireSeconds 锁超时时间(秒)
     * @param tryTimes      最大尝试次数
     * @param sleepMillis   每两次尝试之间休眠时间(毫秒)
     * @return 是否加锁成功
     * @throws CacheException
     */
    public static boolean lock(String lockKey, String lockValue, long expireSeconds, int tryTimes, long sleepMillis) throws CacheException {
        boolean result;
        int count = 0;
        do {
            count++;
            result = tryLock(lockKey, lockValue, expireSeconds);
            try {
                TimeUnit.MILLISECONDS.sleep(sleepMillis);
            } catch (InterruptedException e) {
                logger.error(e.getMessage(), e);
            }
        } while (!result && count <= tryTimes);
        return result;
    }

    /**
     * 释放锁
     *
     * @param lockKey   锁key
     * @param lockValue 锁value
     */
    public static void unlock(String lockKey, String lockValue) {
        JedisCache jedisCache = JedisCacheFactory.getInstance().getJedisCache();
        try {
            String luaScript = "if redis.call('get',KEYS[1]) == ARGV[1] then return redis.call('del',KEYS[1]) else return 0 end";
            Object result = jedisCache.eval(luaScript, 1, lockKey, lockValue);
//            Objects.equals(result, 1L);
        } catch (Exception e) {
            logger.error(e.getMessage(), e);
        } finally {
            jedisCache.close();
        }
//        return false;
    }


    private RedisLock() {
    }

}
```
&emsp; 使用工具类的代码片段1：  

```java
        ...
        String lockKey = Constant.DEFAULT_CACHE_NAME + ":addItemApply:" + applyPriceDTO.getItemId() + "_" + applyPriceDTO.getSupplierId();// 跟业务相关的唯一拼接键
        String lockValue = Constant.DEFAULT_CACHE_NAME + ":" + System.getProperty("JvmId") + ":" + Thread.currentThread().getName() + ":" + System.currentTimeMillis();// 生成集群环境中的唯一值
        boolean locked = RedisLock.tryLock(lockKey, lockValue, 100);// 只尝试一次，在本次处理过程中直接拒绝其他线程的请求
        if (!locked) {
            throw new IllegalAccessException("您的操作太频繁了,休息一下再来吧~");
        }
        try {
            // 开始处理核心业务逻辑
            Item item = itemService.queryItemByItemId(applyPriceDTO.getItemId());
            ...
            ...
        } finally {
            RedisLock.unlock(lockKey, lockValue);// 在finally块中释放锁
        }
```
&emsp; 使用工具类的代码片段2：  

```java
        ...
        String lockKey = Constant.DEFAULT_CACHE_NAME + ":addItemApply:" + applyPriceDTO.getItemId() + "_" + applyPriceDTO.getSupplierId();
        String lockValue = Constant.DEFAULT_CACHE_NAME + ":机器编号:" + Thread.currentThread().getName() + ":" + System.currentTimeMillis();
        boolean locked = RedisLock.lock(lockKey, lockValue, 100, 20, 100);// 非公平锁，无序竞争（这里需要合理根据业务处理情况设置最大尝试次数和每次休眠时间）
        if (!locked) {
            throw new IllegalAccessException("系统太忙,本次操作失败");// 一般来说，不会走到这一步；如果真的有这种情况，并且在合理设置锁尝试次数和等待响应时间之后仍然处理不过来，可能需要考虑优化程序响应时间或者用消息队列排队执行了
        }

        try {
            // 开始处理核心业务逻辑
            Item item = itemService.queryItemByItemId(applyPriceDTO.getItemId());
            ...
            ...
        } finally {
            RedisLock.unlock(lockKey, lockValue);
        }
        ...
```
##### Redisson实现redis分布式锁  
&emsp; 基于redis的分布式锁实现客户端Redisson，官方网址：https://redisson.org/。  

### 2. 基于ZooKeeper的分布式锁  
&emsp; 对于ZK来说，实现分布式锁的核心是临时顺序节点和监听机制。  
&emsp; ***使用ZK实现分布式锁的落地方案：***  
&emsp; 1).使用ZK的临时节点和有序节点，每个线程获取锁就是在ZK创建一个临时有序的节点，比如在/lock/目录下。  
&emsp; 2).创建节点成功后，获取/lock目录下的所有临时节点，再判断当前线程创建的节点是否是所有的节点的序号最小的节点。  
&emsp; 3).如果当前线程创建的节点是所有节点序号最小的节点，则认为获取锁成功。  
&emsp; 4).如果当前线程创建的节点不是所有节点序号最小的节点，则对节点序号的前一个节点添加一个事件监听。  
&emsp; 比如当前线程获取到的节点序号为 /lock/003，然后所有的节点列表为[/lock/001，/lock/002，/lock/003]，则对 /lock/002 这个节点添加一个事件监听器。  
&emsp; 如果锁释放了，会唤醒下一个序号的节点，然后重新执行第 3 步，判断是否自己的节点序号是最小。  
&emsp; 比如 /lock/001 释放了，/lock/002 监听到时间，此时节点集合为[/lock/002，/lock/003]，则 /lock/002 为最小序号节点，获取到锁。  
&emsp; 整个过程如下：  
![](https://gitee.com/wt1814/pic-host/raw/master/images/microService/problems/problem-14.png)  
&emsp; 获取锁：  
![](https://gitee.com/wt1814/pic-host/raw/master/images/microService/problems/problem-15.png)  
&emsp; 1).多个客户端去创建节点时，ZooKeeper会自动根据请求到达的时间顺序对节点进行编号；  
&emsp; 2).每个客户端需要判断自己所创建的节点是否是所有子节点中最小的一个，如果是则说明获取到锁，可以直接执行方法，否则监听上一个节点等待锁。  
&emsp; 释放锁：  
![](https://gitee.com/wt1814/pic-host/raw/master/images/microService/problems/problem-16.png)  
&emsp; 获取到锁的客户端执行结束后删除该节点，此时会触发下一个客户端的监听器去获取锁。  
&emsp; 持有/lock/000的客户端在执行结束后删除该节点，持有/lock/001的客户端会收到通知。所有争夺分布式锁的客户端会按照节点的创建顺序执行任务，形成一个等待队列。  
![](https://gitee.com/wt1814/pic-host/raw/master/images/microService/problems/problem-17.png)  
&emsp; 如果客户端在创建节点后由于某些原因断开了与ZooKeeper的连接，则该客户端的Session失效时会删除其创建的节点，并进行通知。  
&emsp; 若持有/lock/000的客户端还在执行方法，持有/lock/001的客户端突然断开连接，为了不让后面的节点收到错误的通知顺序，要尽可能保证在该客户端之前获取锁的所有客户端都能执行完成，需适当加大SessionTimeOut的值来延长节点的存活时间。  

&emsp; ***zookeeper分布式锁的缺点：***  
1). 加锁会频繁地“写”zookeeper，增加zookeeper的压力；  
2). 写zookeeper的时候会在集群进行同步，节点数越多，同步越慢，获取锁的过程越慢；  
3). 需要另外依赖zookeeper，而大部分服务是不会使用zookeeper的，增加了系统的复杂性；  
4). 相对于redis分布式锁，性能要稍微略差一些；  

#### Zookeeper API实现分布式锁  
......

#### Curator框架：  
......

### 3. 数据库锁  
......

### 4. 其他框架实现  
#### Spring Integration  
&emsp; Spring Integration提供的全局锁目前为如下存储提供了实现：Gemfire、JDBC、Redis、Zookeeper。它们使用相同的API抽象。即不论使用哪种存储，编码体验是一样的，若想更换实现，只需要修改依赖和配置，无需修改代码。  
