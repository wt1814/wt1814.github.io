---
   title: 分布式锁
   date: 2020-05-13 00:00:00
   tags:
       - 分布式
---
<!-- TOC -->

- [1. 分布式锁使用场景](#1-分布式锁使用场景)
- [2. 分布式锁实现](#2-分布式锁实现)
    - [2.1. 基于Redis的分布式锁](#21-基于redis的分布式锁)
        - [2.1.1. 使用Redis分布式锁的中的问题](#211-使用redis分布式锁的中的问题)
        - [2.1.2. Redis 分布式锁实现](#212-redis-分布式锁实现)
            - [2.1.2.1. Redis Client原生API](#2121-redis-client原生api)
                - [2.1.2.1.1. 单实例redis实现分布式锁](#21211-单实例redis实现分布式锁)
                    - [2.1.2.1.1.1. 加锁](#212111-加锁)
                    - [2.1.2.1.1.2. 解锁](#212112-解锁)
                - [2.1.2.1.2. ※※※集群redlock算法实现分布式锁](#21212-※※※集群redlock算法实现分布式锁)
            - [2.1.2.2. Redisson实现redis分布式锁](#2122-redisson实现redis分布式锁)
    - [2.2. 基于ZooKeeper的分布式锁](#22-基于zookeeper的分布式锁)
        - [2.2.1. Zookeeper API实现分布式锁](#221-zookeeper-api实现分布式锁)
        - [2.2.2. Curator框架](#222-curator框架)
    - [2.3. 数据库锁](#23-数据库锁)
    - [2.4. 其他框架实现](#24-其他框架实现)
        - [2.4.1. Spring Integration](#241-spring-integration)

<!-- /TOC -->


![image](https://gitee.com/wt1814/pic-host/raw/master/images/microService/problems/problem-29.png)  

# 1. 分布式锁使用场景  
&emsp; ***分布式锁的使用场景：***  
1. 避免不同节点重复相同的工作。  

        比如用户执行了某个操作有可能不同节点会发送多封邮件。  
        比如多台机器都可以定时执行某个任务，如果限制任务每次只能被一台机器执行，不能重复执行，就可以用分布式锁来做标记。
2. 避免破坏数据的正确性：在分布式环境下解决多实例对数据的访问一致性。如果多个节点在同一条数据上同时进行操作，可能会造成数据错误或不一致的情况出现。  

        比较敏感的数据比如金额修改，同一时间只能有一个人操作，如果2个人同时修改金额，一个加金额一个减金额，为了防止同时操作造成数据不一致，需要锁，如果是数据库需要的就是行锁或表锁，如果是在集群里，多个客户端同时修改一个共享的数据就需要分布式锁。  
        比如秒杀场景，要求并发量很高，那么同一件商品只能被一个用户抢到，那么就可以使用分布式锁实现。 

&emsp; ***为什么使用分布式锁？***  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/microService/problems/problem-11.png)  
&emsp; 如上图，在分布式系统中，订单模块为了迎战高并发，订单服务被横向拆分，拆分成了不同的进程，就像上图，两个人同时访问订单服务,然后订单系统1和订单系统2共用一个Mysql当成数据库，经过查询发现仅有一件商品，所以两个系统都认为可以下单。如果不加锁限制,可能会出现库存减为负数的情况。  
&emsp; 解决方案：  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/microService/problems/problem-12.png)  
&emsp; 如上图。mysql自带行级锁，可以考虑使用它的行级锁，可以保证数据的安全。不足之处：使用MySql的行级锁，系统的压力全部集中在mysql，那么mysql就是系统吞吐量的瓶颈了，系统的吞吐量也会受到mysql的限制。  
&emsp; 可以使用分布式锁。如下图,分布式锁将系统的压力从mysql上面转移到自身上来。  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/microService/problems/problem-13.png)  

# 2. 分布式锁实现  
&emsp; 分布式锁一般有三种实现方式：1.数据库悲观锁、乐观锁；2.基于缓存（redis，memcached，tair）的分布式锁；3.基于ZooKeeper临时顺序节点的分布式锁。  
&emsp; <font color="red">基于Redis的分布式锁是AP模型，基于Zookeeper的分布式锁是CP模型的。</font> 

&emsp; 分布式锁实现的三个核心要素：1.加锁；2.解锁；3.锁超时。  

## 2.1. 基于Redis的分布式锁  
### 2.1.1. 使用Redis分布式锁的中的问题  
1. 超时问题。  
2. 部署问题：除了要考虑客户端要怎么实现分布式锁之外，还需要考虑Redis的部署问题。Redis有多种部署方式：单机模式；Master-Slave+Sentinel选举模式；Redis Cluster模式。  
&emsp; 如果采用单机部署模式，会存在单点问题。只要 Redis 故障了，加锁就不行了。  
&emsp; 采用Master-Slave 模式，加锁的时候只对一个节点加锁，即使通过 Sentinel做了高可用，但是<font color="red">如果Master节点故障了，发生主从切换，此时就会有可能出现锁丢失的问题</font>。  

### 2.1.2. Redis 分布式锁实现  
#### 2.1.2.1. Redis Client原生API  
##### 2.1.2.1.1. 单实例redis实现分布式锁  

###### 2.1.2.1.1.1. 加锁  
&emsp; ***加锁代码：***  

```java
public class RedisTool {
    private static final String LOCK_SUCCESS = "OK";
    private static final String SET_IF_NOT_EXIST = "NX";
    private static final String SET_WITH_EXPIRE_TIME = "PX";
    /**
     * 尝试获取分布式锁
     * @param jedis Redis客户端
     * @param lockKey 锁
     * @param requestId 请求标识
     * @param expireTime 超期时间
     * @return 是否获取成功
     */
    public static boolean tryGetDistributedLock(Jedis jedis, String lockKey, String requestId, int expireTime) {
        String result = jedis.set(lockKey, requestId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime);
        if (LOCK_SUCCESS.equals(result)) {
            return true;
        }
        return false;
    }
}
```
&emsp; 加锁就一行代码：jedis.set(String key, String value, String nxxx, String expx, int time)，这个set()方法一共有五个形参：  

* key，使用key来当锁，因为key是唯一的。  
* value，传参requestId，代表执行的具体线程。  
* ***nxxx，传参NX，意思是SET IF NOT EXIST，即当key不存在时，进行set操作；若key已经存在，则不做任何操作。***  
* ***expx，传参PX，即给这个key加一个过期的设置，具体时间由第五个参数决定。***  
* ***time，与第四个参数相呼应，代表key的过期时间。***  

&emsp; 执行上面的set()方法就只会导致两种结果：1).锁不存在，进行加锁操作，并对锁设置个有效期，同时value表示加锁的客户端；2).锁存在，不做任何操作。  

&emsp; 加锁中使用了redis的set命令。加锁涉及获取锁、加锁两步操作***最初分布式锁借助于setnx和expire命令***，但是这两个命令不是原子操作，如果执行setnx之后获取锁但是此时客户端挂掉，这样无法执行expire设置过期时间就导致锁一直无法被释放，因此***在2.8版本中Antirez为setnx增加了参数扩展，使得setnx和expire具备原子操作性***。  

```
SET KEY value [EX seconds] [PX milliseconds] [NX|XX]
``` 
* EX second:设置键的过期时间为second秒。  
* PX millisecond:设置键的过期时间为millisecond毫秒。  
* NX：只在键不存在时，才对键进行设置操作。  
* XX：只在键已经存在时，才对键进行设置操作。  

###### 2.1.2.1.1.2. 解锁  
&emsp; 解锁也涉及获取锁、删除锁两步操作，采用redis和lua脚本实现。lua脚本执行命令具有原子性。  
&emsp; ***解锁代码：***  

```java
public class RedisTool {
    private static final Long RELEASE_SUCCESS = 1L;
    /**
     * 释放分布式锁
     * @param jedis Redis客户端
     * @param lockKey 锁
     * @param requestId 请求标识
     * @return 是否释放成功
     */
    public static boolean releaseDistributedLock(Jedis jedis, String lockKey, String requestId) {
        //Lua脚本代码
        String script = "if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end";
        Object result = jedis.eval(script, Collections.singletonList(lockKey), Collections.singletonList(requestId));
        if (RELEASE_SUCCESS.equals(result)) {
            return true;
        }
        return false;
    }
}
```

##### 2.1.2.1.2. ※※※集群redlock算法实现分布式锁  
&emsp; Redis分布式锁官网中文地址：http://redis.cn/topics/distlock.html。 

&emsp; RedLock算法描述：假设Redis的部署模式是Redis Cluster，总共有5个Master节点。客户端通过以下步骤获取一把锁。
1. 获取当前时间戳，单位是毫秒。  
2. 轮流尝试在每个Master节点上创建锁，过期时间设置较短，一般就几十毫秒。  
3. 尝试在大多数节点上建立一个锁，比如 5 个节点就要求是3个节点（n / 2 +1）。  
4. 客户端计算建立好锁的时间，如果建立锁的时间小于超时时间，就算建立成功了。  
5. 要是锁建立失败了，那么就依次删除这个锁。  
6. 只要别的线程建立了一把分布式锁，当前线程就得不断轮询去尝试获取锁。  

&emsp; <font color="red">一句话概述：当前线程尝试给每个Master节点加锁。要在多数节点上加锁，并且加锁时间小于超时时间，则加锁成功；加锁失败时，依次删除节点上的锁。</font>  

#### 2.1.2.2. Redisson实现redis分布式锁  
&emsp; 基于redis的分布式锁实现客户端Redisson，官方网址：https://redisson.org/。  

## 2.2. 基于ZooKeeper的分布式锁  
&emsp; 对于ZK来说，实现分布式锁的核心是临时顺序节点和监听机制。  
&emsp; ***使用ZK实现分布式锁的落地方案：***  
1. 使用ZK的临时节点和有序节点，每个线程获取锁就是在ZK创建一个临时有序的节点，比如在/lock/目录下。  
2. 创建节点成功后，获取/lock目录下的所有临时节点，再判断当前线程创建的节点是否是所有的节点的序号最小的节点。  
3. 如果当前线程创建的节点是所有节点序号最小的节点，则认为获取锁成功。  
4. 如果当前线程创建的节点不是所有节点序号最小的节点，则对节点序号的前一个节点添加一个事件监听。  
&emsp; 比如当前线程获取到的节点序号为 /lock/003，然后所有的节点列表为[/lock/001，/lock/002，/lock/003]，则对 /lock/002 这个节点添加一个事件监听器。  
5. 如果锁释放了，会唤醒下一个序号的节点，然后重新执行第 3 步，判断是否自己的节点序号是最小。比如 /lock/001 释放了，/lock/002 监听到时间，此时节点集合为[/lock/002，/lock/003]，则 /lock/002 为最小序号节点，获取到锁。  

&emsp; <font color="red">一句话概述：在某一节点下，建立临时顺序节点。最小节点获取到锁。非最小节点监听上一节点，上一节点释放锁，唤醒当前节点。</font>

&emsp; 整个过程如下：  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/microService/problems/problem-14.png)  

----
* 获取锁：  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/microService/problems/problem-15.png)  
    1. 多个客户端去创建节点时，ZooKeeper会自动根据请求到达的时间顺序对节点进行编号；  
    2. 每个客户端需要判断自己所创建的节点是否是所有子节点中最小的一个，如果是则说明获取到锁，可以直接执行方法，否则监听上一个节点等待锁。  


* 释放锁：  

    1. 获取到锁的客户端执行结束后删除该节点，此时会触发下一个客户端的监听器去获取锁。  
    ![image](https://gitee.com/wt1814/pic-host/raw/master/images/microService/problems/problem-16.png)  
    &emsp; 例如：持有/lock/000的客户端在执行结束后删除该节点，持有/lock/001的客户端会收到通知。所有争夺分布式锁的客户端会按照节点的创建顺序执行任务，形成一个等待队列。  
    2. 如果客户端在创建节点后由于某些原因断开了与ZooKeeper的连接，则该客户端的Session失效时会删除其创建的节点，并进行通知。  
    ![image](https://gitee.com/wt1814/pic-host/raw/master/images/microService/problems/problem-17.png)  
    &emsp; 例如：持有/lock/000的客户端还在执行方法，持有/lock/001的客户端突然断开连接，为了不让后面的节点收到错误的通知顺序，要尽可能保证在该客户端之前获取锁的所有客户端都能执行完成，需适当加大SessionTimeOut的值来延长节点的存活时间。  

&emsp; ***zookeeper分布式锁的缺点：***  

* 加锁会频繁地“写”zookeeper，增加zookeeper的压力；  
* 写zookeeper的时候会在集群进行同步，节点数越多，同步越慢，获取锁的过程越慢；  
* 需要另外依赖zookeeper，而大部分服务是不会使用zookeeper的，增加了系统的复杂性；  
* 相对于redis分布式锁，性能要稍微略差一些；  

### 2.2.1. Zookeeper API实现分布式锁  
......

### 2.2.2. Curator框架  
......

## 2.3. 数据库锁  
......

## 2.4. 其他框架实现  
### 2.4.1. Spring Integration  
&emsp; Spring Integration提供的全局锁目前为如下存储提供了实现：Gemfire、JDBC、Redis、Zookeeper。它们使用相同的API抽象。即不论使用哪种存储，编码体验是一样的，若想更换实现，只需要修改依赖和配置，无需修改代码。  
