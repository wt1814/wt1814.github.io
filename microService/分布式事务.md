---
title: 分布式事务
date: 2020-05-11 00:00:00
tags:
    - 分布式
---
<!-- TOC -->

- [1. 分布式事务产生的原因](#1-分布式事务产生的原因)
- [2. 分布式理论](#2-分布式理论)
    - [2.1. CAP理论](#21-cap理论)
    - [2.2. BASE理论](#22-base理论)
    - [2.3. 酸碱平衡](#23-酸碱平衡)
- [3. 分布式事务解决方案](#3-分布式事务解决方案)
    - [3.1. 分布式事务模型DTP](#31-分布式事务模型dtp)
    - [3.2. 基于DTP的XA实现](#32-基于dtp的xa实现)
    - [3.3. 一致性协议-XA两阶段提交](#33-一致性协议-xa两阶段提交)
        - [3.3.1. 实现流程](#331-实现流程)
        - [3.3.2. 特点](#332-特点)
        - [3.3.3. XA二阶段问题](#333-xa二阶段问题)
    - [3.4. 一致性协议-XA三阶段提交](#34-一致性协议-xa三阶段提交)
        - [3.4.1. 实现流程](#341-实现流程)
        - [3.4.2. 特点](#342-特点)
    - [3.5. 消息驱动模式（Message Driven）](#35-消息驱动模式message-driven)
        - [3.5.1. 本地消息表（异步确保）-强一致性](#351-本地消息表异步确保-强一致性)
            - [3.5.1.1. 实现流程](#3511-实现流程)
            - [3.5.1.2. 特点](#3512-特点)
        - [3.5.2. 事务消息-最终一致性](#352-事务消息-最终一致性)
            - [3.5.2.1. 实现流程](#3521-实现流程)
            - [3.5.2.2. 特点](#3522-特点)
        - [3.5.3. 最大努力通知-最终一致性](#353-最大努力通知-最终一致性)
            - [3.5.3.1. 实现流程](#3531-实现流程)
            - [3.5.3.2. 特点](#3532-特点)
    - [3.6. 事件溯源模式(Event Sourcing)，Saga事务模型-最终一致性](#36-事件溯源模式event-sourcingsaga事务模型-最终一致性)
        - [3.6.1. 事件/编排Choreography方式](#361-事件编排choreography方式)
            - [3.6.1.1. 实现流程](#3611-实现流程)
            - [3.6.1.2. 特点](#3612-特点)
        - [3.6.2. 命令/协调orchestrator](#362-命令协调orchestrator)
            - [3.6.2.1. 实现流程](#3621-实现流程)
            - [3.6.2.2. 特点](#3622-特点)
    - [3.7. TCC模式-强一致性](#37-tcc模式-强一致性)
        - [3.7.1. 实现流程](#371-实现流程)
        - [3.7.2. 特点](#372-特点)
- [4. 分布式事务具体实现](#4-分布式事务具体实现)
    - [4.1. JTA](#41-jta)
    - [4.2. TCC框架](#42-tcc框架)
    - [4.3. LCN分布式事务框架](#43-lcn分布式事务框架)
    - [4.4. Seata](#44-seata)

<!-- /TOC -->


<!-- https://mp.weixin.qq.com/s?__biz=MzI5ODQ2MzI3NQ==&mid=2247487531&idx=1&sn=b3fbc4dee7cea4a78db062a4a656afdf&chksm=eca4296fdbd3a079a8e328ec7946ced7d1f94c0f105463743a8bee569bae6da00bf2133c3e1a&mpshare=1&scene=1&srcid=&sharer_sharetime=1564202929646&sharer_shareid=b256218ead787d58e0b58614a973d00d&key=ecc4386bb884a7b134f7967009b30d8850e84095233bdb465a9d85c893c9d20f24ac5d5c020310846ccee37aa2e8173504c6cfc1df58512d821d0e4576cf5551069f7159d6583c1ffafa2c3922d85c13&ascene=1&uin=MTE1MTYxNzY2MQ%3D%3D&devicetype=Windows+10&version=62060834&lang=zh_CN&pass_ticket=FpawTdCfFbNulIqKIET55TinFCVk8qXp4EKE58T1l6zm9idpTXvh4%2BicV3hbPZAB -->

# 1. 分布式事务产生的原因  
* 数据库分库分表：如果一个操作既访问01库，又访问02库，而且要保证数据的一致性，那么就要用到分布式事务。  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/microService/problems/problem-1.png)  
* 应用SOA化：所谓的SOA化，就是业务的服务化。将一个整体的系统拆分为多个子系统，每个子系统都有自己的数据库，为了保证数据一致性，就需要用到分布式事务。  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/microService/problems/problem-2.png)  

# 2. 分布式理论  
## 2.1. CAP理论  
* Consistency一致性  
&emsp; 一致性指“all nodes see the same data at the same time”，即更新操作成功并返回客户端完成后，所有节点在同一时间的数据完全一致。分布式的一致性。  
&emsp; 对于一致性，可以分为从客户端和服务端两个不同的视角。从客户端来看，一致性主要指的是多并发访问时更新过的数据如何获取的问题。从服务端来看，则是更新如何复制分布到整个系统，以保证数据最终一致。一致性是因为有并发读写才有的问题，因此在理解一致性的问题时，一定要注意结合考虑并发读写的场景。  
&emsp; ***强一致性、弱一致性、最终一致性：***  
&emsp; 从客户端角度，多进程并发访问时，更新过的数据在不同进程如何获取的不同策略，决定了不同的一致性。对于关系型数据库，要求更新过的数据能被后续的访问都能看到，这是强一致性。如果能容忍后续的部分或者全部访问不到，则是弱一致性。如果经过一段时间后要求能访问到更新后的数据，则是最终一致性。  
&emsp; 从服务端角度，如何尽快将更新后的数据分布到整个系统，降低达到最终一致性的时间窗口，是提高系统的可用度和用户体验非常重要的方面。对于分布式数据系统：  
&emsp; N — 数据复制的份数  
&emsp; W — 更新数据时需要保证写完成的节点数  
&emsp; R — 读取数据的时候需要读取的节点数  
&emsp; 如果W+R>N，写的节点和读的节点重叠，则是强一致性。例如对于典型的一主一备同步复制的关系型数据库，N=2,W=2,R=1，则不管读的是主库还是备库的数据，都是一致的。  
&emsp; 如果W+R<=N，则是弱一致性。例如对于一主一备异步复制的关系型数据库，N=2,W=1,R=1，则如果读的是备库，就可能无法读取主库已经更新过的数据，所以是弱一致性。  

* Availability可用性  
&emsp; 可用性指“Reads and writes always succeed”，即服务一直可用，而且是正常响应时间。对于一个可用性的分布式系统，每一个非故障的节点必须对每一个请求作出响应。也就是，该系统使用的任何算法必须最终终止。当同时要求分区容忍性时，这是一个很强的定义：即使是严重的网络错误，每个请求必须终止。好的可用性主要是指系统能够很好的为用户服务，不出现用户操作失败或者访问超时等用户体验不好的情况。可用性通常情况下可用性和分布式数据冗余，负载均衡等有着很大的关联。  

* Partition Tolerance分区容错性  
&emsp; 分区容错性指“the system continues to operate despite arbitrary message loss or failure of part of the system”，即分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务。分区容错性和扩展性紧密相关。在分布式应用中，可能因为一些分布式的原因导致系统无法正常运转。好的分区容错性要求能够使应用虽然是一个分布式系统，而看上去却好像是在一个可以运转正常的整体。比如现在的分布式系统中有某一个或者几个机器宕掉了，其他剩下的机器还能够正常运转满足系统需求，或者是机器之间有网络异常，将分布式系统分隔未独立的几个部分，各个部分还能维持分布式系统的运作，这样就具有好的分区容错性。  

&emsp; 在分布式系统中，最多只能满足C、A、P中的两个需求。  
&emsp; CA without P：如果不要求P（不允许分区），则C（强一致性）和A（可用性）是可以保证的。但其实分区不是你想不想的问题，而是始终会存在，因此CA的系统更多的是允许分区后各子系统依然保持CA。注意：CA模型就是单机环境。  
&emsp; CP without A：如果不要求A（可用），相当于每个请求都需要在Server之间强一致，而P（分区）会导致同步时间无限延长，如此CP也是可以保证的。很多传统的数据库分布式事务都属于这种模式。  
&emsp; AP wihtout C：要高可用并允许分区，则需放弃一致性。一旦分区发生，节点之间可能会失去联系，为了高可用，每个节点只能用本地数据提供服务，而这样会导致全局数据的不一致性。现在众多的NoSQL都属于此类。  

&emsp; ~~对于多数大型互联网应用的场景，主机众多、部署分散，而且现在的集群规模越来越大，所以节点故障、网络故障是常态，而且要保证服务可用性达到N个9，即保证P和A，舍弃C（退而求其次保证最终一致性）。虽然某些地方会影响客户体验，但没达到造成用户流程的严重程度。~~  

&emsp; 选择哪两个条件较为合适呢？分区容错性是一个最基本的要求，再根据业务 特点在C（一致性）和A（可用性）之间寻求平衡。  
&emsp; 对于一个业务系统来说，可用性和分区容错性是必须要满足的两个条件，并且这两者是相辅相成的。业务系统之所以使用分布式系统，主要原因有两个：  
1. 提升整体性能。当业务量猛增，单个服务器已经无法满足业务需求时，就需要使用分布式系统，使用多个节点提供相同的功能，从而整体上提升系统的性能，这就是使用分布式系统的第一个原因。  
2. 实现分区容错性。单一节点或多个节点处于相同的网络环境下，那么会存在一定的风险，万一该机房断电、该地区发生自然灾害，那么业务系统就全面瘫痪了。为了防止这一问题，采用分布式系统，将多个子系统分布在不同的地域、不同的机房中，从而保证系统高可用性。  
&emsp; 这说明分区容错性是分布式系统的根本，如果分区容错性不能满足，那使用分布式系统将失去意义。  
&emsp; 此外，可用性对业务系统也尤为重要。在大谈用户体验的今天，如果业务系统时常出现“系统异常”、响应时间过长等情况，这使得用户对系统的好感度大打折扣，在互联网行业竞争激烈的今天，相同领域的竞争者不甚枚举，系统的间歇性不可用会立马导致用户流向竞争对手。因此，只能通过牺牲一致性来换取系统的可用性和分区容错性。所谓的“牺牲一致性”并不是完全放弃数据一致性，而是牺牲强一致性换取弱一致性。  


## 2.2. BASE理论  
&emsp; BASE理论是对CAP的延伸和补充，是对CAP中的AP方案的一个补充，即在选择AP方案的情况下，如何更好的最终达到C。  

&emsp; BASE是Basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性）三个短语的缩写。BASE理论是对CAP中一致性和可用性权衡的结果，其来源于对大规模互联网系统分布式实践的总结，是基于CAP定理逐步演化而来的。BASE和ACID是相反的，它完全不同于ACID的强一致性模型，而是通过牺牲强一致性来获得可用性，并允许数据在一段时间内是不一致的，但最终达到一致状态。  
* BA：Basic Available基本可用。整个系统在某些不可抗力的情况下，仍然能够保证“可用性”，即一定时间内仍然能够返回一个明确的结果。只不过“基本可用”和“高可用”的区别是：  
  1. “一定时间”可以适当延长；    
  2. 当举行大促时，响应时间可以适当延长；  
  3. 给部分用户返回一个降级页面；  
  4. 给部分用户直接返回一个降级页面，从而缓解服务器压力。但要注意，返回降级页面仍然是返回明确结果。  
* S：Soft State，柔性状态。同一数据的不同副本的状态，可以不需要实时一致。柔性事务：不同于ACID的刚性事务，在分布式场景下基于BASE理论，就出现了柔性事务的概念。通过柔性事务来达到最终的一致性。  
* E：Eventual Consisstency，最终一致性。同一数据的不同副本的状态，可以不需要实时一致，但一定要保证经过一定时间后仍然是一致的。  

## 2.3. 酸碱平衡  
&emsp; 化学理论中 ACID 是酸、Base 恰好是碱。分布式理论中，ACID能够保证事务的强一致性，即数据是实时一致的。这在本地事务中是没有问题的，在分布式事务中，强一致性会极大影响分布式系统的性能。分布式系统的不同业务场景对一致性的要求不同。如交易场景下，就要求强一致性，此时就需要遵循ACID理论，而在注册成功后发送短信验证码等场景下，并不需要实时一致，因此遵循BASE理论即可。因此在具体的分布式系统架构设计过程中，ACID特性和BASE理论往往又会结合在一起。  

----
# 3. 分布式事务解决方案  
## 3.1. 分布式事务模型DTP  
&emsp; DTP是由X/Open组织提出的一种分布式事务模型——X/Open Distributed Transaction Processing Reference Model。  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/microService/problems/problem-3.png)  
&emsp; ***X/Open DTP中的角色：***  
1). AP(Application Program)：应用程序。  
&emsp; 主要是定义事务边界以及那些组成事务的特定于应用程序的操作。在开发的过程中，可以使用资源管理器提供的事务接口来实现分布式事务。  
2). RM(Resouces Manager)：资源管理器。  
&emsp; 资源管理器能够提供单数据源的事务能力，它们通过XA接口，将本数据库的提交、回滚等能力提供给事务管理器调用，以帮助事务管理器实现分布式的事务管理。能够提供数据服务的对象都可以是资源管理器，比如：数据库、消息中间件、缓存等。大部分场景下，数据库即为分布式事务中的资源管理器。  

    XA是DTP模型定义的接口，指的是模型中TM（事务管理器）和RM（资源管理器）之间进行通信的接口，用于向事务管理器提供该资源管理器(该数据库)的提交、回滚等能力。目前大多数实现XA的都是数据库或者MQ，所以提起XA往往多指基于资源层的底层分布式事务解决方案。其实现在也有些数据分片框架或者中间件也支持XA协议，毕竟它的兼容性、普遍性更好。  
3). TM(Transaction Manager)：事务管理器。  
&emsp; 管理全局事务，协调事务的提交或者回滚，并协调故障恢复。常见的事务管理器（TM）是交易中间件。  
&emsp; 分布式事务的实现由事务管理器来完成，它会提供分布式事务的操作接口供业务系统调用，这些接口称为TX接口；事务管理器还管理着所有的资源管理器，通过它们提供的XA接口来同一调度这些资源管理器，以实现分布式事务。  
&emsp; DTP只是一套实现分布式事务的规范，并没有定义具体如何实现分布式事务，TM可以采用2PC、3PC、Paxos等协议实现分布式事务。  

&emsp; ***DTP中的几个概念：***  
* 全局事务：对于一次性操作多个资源管理器的事务，就是全局事务。  
* 分支事务：在全局事务中，某一个资源管理器有自己独立的任务，这些任务的集合作为这个资源管理器的分支任务。  
* 控制线程：用来表示一个工作线程，主要是关联AP,TM,RM三者的一个线程，也就是事务上下文环境。简单的说，就是需要标识一个全局事务以及分支事务的关系。  

&emsp; ***DTP模型执行流程：***  
1. AP使用一组来自RM的资源；  
2. AP通过TM接口定义事务的边界；  
3. TM和RM交换事务信息；  

## 3.2. 基于DTP的XA实现
## 3.3. 一致性协议-XA两阶段提交  
### 3.3.1. 实现流程  
&emsp; 在分布式系统中，每个节点虽然可以知晓自己的操作是成功或者失败，却无法知道其他节点的操作是成功或失败。当一个事务跨越多个节点时，为了保持事务的ACID特性，需要引入一个作为协调者的组件来统一掌控所有节点（称作参与者）的操作结果并最终指示这些节点是否要把操作结果进行真正的提交（比如将更新后的数据写入磁盘等等）。  
&emsp; 二阶段提交的算法思路可以概括为：参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈情报决定各参与者是否要提交操作还是中止操作。  

![image](https://gitee.com/wt1814/pic-host/raw/master/images/microService/problems/problem-4.png)  
&emsp; 二阶段提交将分布式事务的提交拆分为2个阶段：`准备阶段prepare和提交阶段commit/rollback`。  
1. 第一阶段：准备阶段  
&emsp; 协调者向所有参与者发送事务执行请求，并等待参与者反馈事务执行结果。  
&emsp; 事务参与者收到请求之后，本地执行事务，但不提交。  
&emsp; 参与者将自己事务执行情况反馈给协调者，同时等待协调者的下一步通知。  

2. 第二阶段：提交阶段（执行阶段）  
&emsp; 在第一阶段协调者的询盘之后，各个参与者会回复自己事务的执行情况，这时候存在三种可能：  
    * 所有的参与者回复能够正常执行事务。  
    &emsp; 协调者向各个参与者发送commit通知，请求提交事务。  
    &emsp; 参与者收到事务提交通知之后，执行commit操作。  
    &emsp; 参与者向协调者返回事务commit结果信息。  
    * 一个或多个参与者回复事务执行失败。  
    * 协调者等待超时。  
    &emsp; 协调者向各个参与者发送事务rollback通知，请求回滚事务。  
    &emsp; 参与者收到事务回滚通知之后，执行rollback操作。  
    &emsp; 参与者向协调者返回事务rollback结果信息。  

### 3.3.2. 特点  

* 优点：尽量保证了数据的强一致，适合对数据强一致要求很高的关键领域。（其实也不能100%保证强一致）。
* 缺点：实现复杂，牺牲了可用性，对性能影响较大，不适合高并发高性能场景。
* ***使用场景：***2PC牺牲了一部分可用性来换取的一致性。`XA事务适合单块应用里，跨多个库的分布式事务`，而且因为严重依赖于数据库层面来搞定复杂的事务，效率很低，绝对不适合高并发的场景。可以基于spring + JTA实现。

### 3.3.3. XA二阶段问题     
1. 单点故障问题：  
&emsp; 参与者发生故障。协调者需要给每个参与者额外指定超时机制，超时后整个事务失败。  
&emsp; 协调者发生故障。参与者会一直阻塞下去。需要额外的备机进行容错。  
2. 同步阻塞问题：  
&emsp; 执行过程中，所有参与节点都是事务阻塞型的。当参与者占有公共资源时，其他第三方节点访问公共资源不得不处于阻塞状态。  
3. 丢失消息导致的数据不一致问题：  
&emsp; 在二阶段提交的阶段二中，当协调者向参与者发送commit请求之后，发生了局部网络异常或者在发送commit请求过程中协调者发生了故障，这会导致只有一部分参与者接受到了commit请求。而在这部分参与者接到commit请求之后就会执行commit操作。但是其他部分未接到commit请求的机器则无法执行事务提交。于是整个分布式系统便出现了数据部一致性的现象。  
4. 二阶段无法解决的问题：  
&emsp; 协调者在发出commit消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了。那么即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没人知道事务是否被已经提交。  

## 3.4. 一致性协议-XA三阶段提交  
&emsp; 三阶段提交是在二阶段提交上的改进版本，3PC最关键要解决的就是协调者和参与者同时挂掉的问题，所以3PC把2PC的准备阶段再次一分为二，这样三阶段提交。   

### 3.4.1. 实现流程  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/microService/problems/problem-5.png)  
&emsp; `XA三阶段提交包含CanCommit、PreCommit、DoCommit三个阶段`：  
1. 询问阶段：CanCommit阶段。  
 &emsp; 协调者向参与者发送commit请求，参与者如果可以提交就返回Yes响应，否则返回No响应。  
2. 准备阶段：PreCommit阶段。  
 &emsp; 协调者根据参与者的反应情况来决定是否可以进行事务的PreCommit操作。根据响应情况，有以下两种可能：  
   * 假如协调者从所有的参与者获得的反馈都是Yes响应，那么就会执行事务的预执行。  

            发送预提交请求：协调者向参与者发送PreCommit请求，并进入Prepared阶段。  
            事务预提交：参与者接收到PreCommit请求后，会执行事务操作，并将undo和redo信息记录到事务日志中。  
            响应反馈：如果参与者成功的执行了事务操作，则返回ACK响应，同时开始等待最终指令。  
   * 假如有任何一个参与者向协调者发送了No响应，或者等待超时之后，协调者都没有接到参与者的响应，那么就执行事务的中断。  

            发送中断请求：协调者向所有参与者发送abort请求。  
            中断事务：参与者收到来自协调者的abort请求之后（或超时之后，仍未收到协调者的请求），执行事务的中断。 
3. 提交阶段：doCommit阶段。  
 该阶段进行真正的事务提交，也可以分为以下两种情况。  
    * 执行提交：  

            发送提交请求：协调接收到参与者发送的ACK响应，那么它将从预提交状态进入到提交状态。并向所有参与者发送doCommit请求。    
            事务提交：参与者接收到doCommit请求之后，执行正式的事务提交。并在完成事务提交之后释放所有事务资源。  
            响应反馈：事务提交完之后，向协调者发送Ack响应。  
            完成事务：协调者接收到所有参与者的ack响应之后，完成事务。  
    * 中断事务：  

            协调者没有接收到参与者发送的ACK响应（可能是接受者发送的不是ACK响应，也可能响应超时），那么就会执行中断事务。  
            发送中断请求：协调者向所有参与者发送abort请求。  
            事务回滚：参与者接收到abort请求之后，利用其在阶段二记录的undo信息来执行事务的回滚操作，并在完成回滚之后释放所有的事务资源。  
            反馈结果：参与者完成事务回滚之后，向协调者发送ACK消息。  
            中断事务：协调者接收到参与者反馈的ACK消息之后，执行事务的中断。  

### 3.4.2. 特点  
* 优点：相比二阶段提交，三阶段提交降低了阻塞范围，在等待超时后协调者或参与者会中断事务。避免了协调者单点问题。阶段 3 中协调者出现问题时，参与者会继续提交事务。  
* 缺点：数据不一致问题依然存在，当在参与者收到 preCommit 请求后等待 do commite 指令时，此时如果协调者请求中断事务，而协调者无法与参与者正常通信，会导致参与者继续提交事务，造成数据不一致。  

        &emsp; 与两阶段提交不同的是，三阶段提交有两个改动点。  
        1. 引入超时机制。同时在协调者和参与者中都引入超时机制。一旦事物参与者迟迟没有接到协调者的commit请求，会自动进行本地commit。这样有效解决了协调者单点故障的问题。但是性能问题和不一致的问题仍然没有根本解决。  
        2. 3PC把2PC的准备阶段再次一分为二，保证了在最后提交阶段之前各参与节点的状态是一致的。   
        ~~&emsp; 三阶段提交在两阶段提交的第一阶段与第二阶段之间插入了一个准备阶段，使得原先在两阶段提交中，参与者在投票之后，由于协调者发生崩溃或错误，而导致参与者处于无法知晓是否提交或者中止的“不确定状态”所产生的可能相当长的延时的问题得以解决。（3PC最关键要解决的就是协调者和参与者同时挂掉的问题）~~   

        &emsp; 解决二阶段提交时的问题：在三阶段提交中，如果在第三阶段协调者发送提交请求之后挂掉，并且唯一的接受的参与者执行提交操作之后也挂掉了，这时协调者通过选举协议产生了新的协调者。  
        &emsp; 在二阶段提交时存在的问题就是新的协调者不确定已经执行过事务的参与者是执行的提交事务还是中断事务。  
        &emsp; 但是在三阶段提交时，肯定得到了第二阶段的再次确认，那么第二阶段必然是已经正确的执行了事务操作，只等待提交事务了。  
        &emsp; 所以新的协调者可以从第二阶段中分析出应该执行的操作，进行提交或者中断事务操作，这样即使挂掉的参与者恢复过来，数据也是一致的。  

        &emsp; 所以，三阶段提交解决了二阶段提交中存在的由于协调者和参与者同时挂掉可能导致的数据一致性问题和单点故障问题，并减少阻塞。  
        &emsp; 因为一旦参与者无法及时收到来自协调者的信息之后，它会默认执行提交事务，而不会一直持有事务资源并处于阻塞状态。  
        &emsp; 三阶段提交的问题：在提交阶段如果发送的是中断事务请求，但是由于网络问题，导致部分参与者没有接到请求。  
        &emsp; 那么参与者会在等待超时之后执行提交事务操作，这样这些由于网络问题导致提交事务的参与者的数据就与接受到中断事务请求的参与者存在数据不一致的问题。  
        &emsp; 所以无论是2PC还是3PC都不能保证分布式系统中的数据100%一致。  

## 3.5. 消息驱动模式（Message Driven）  
### 3.5.1. 本地消息表（异步确保）-强一致性  
&emsp; 本地消息表核心思想是将分布式事务拆分成本地事务进行处理。  

#### 3.5.1.1. 实现流程  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/microService/problems/problem-6.png)  
&emsp; ***基本思路：***  
&emsp; 消息生产方，需要额外建一个消息表，并记录消息发送状态。消息表和业务数据要在一个事务里提交，也就是说要在一个数据库里面。然后消息会经过MQ发送到消息的消费方。如果消息发送失败，会进行重试发送。  
&emsp; 消息消费方，需要处理这个消息，并完成自己的业务逻辑。此时如果本地事务处理成功，表明已经处理成功了，如果处理失败，那么就会重试执行。如果是业务上面的失败，可以给生产方发送一个业务补偿消息，通知生产方进行回滚等操作。  
&emsp; 生产方和消费方定时扫描本地消息表，把还没处理完成的消息或者失败的消息再发送一遍。  

&emsp; ***具体流程：***  

    A 系统在自己本地一个事务里操作同时，插入一条数据到消息表；  
    接着A系统将这个消息发送到MQ中去；  
    B系统接收到消息之后，在一个事务里，往自己本地消息表里插入一条数据，同时执行其他的业务操作，如果这个消息已经被处理过了，那么此时这个事务会回滚，这样保证不会重复处理消息；  
    B系统执行成功之后，就会更新自己本地消息表的状态以及A系统消息表的状态；  
    如果B系统处理失败了，那么就不会更新消息表状态，那么此时A系统会定时扫描自己的消息表，如果有未处理的消息，会再次发送到MQ中去，让B再次处理；  
    这个方案保证了最终一致性，哪怕B事务失败了，但是A会不断重发消息，直到B那边成功为止。  

#### 3.5.1.2. 特点  
* 优点：从应用设计开发的角度实现了消息数据的可靠性，消息数据的可靠性不依赖于消息中间件，弱化了对 MQ 中间件特性的依赖。  
* 缺点：与具体的业务场景绑定，耦合性强，不可公用。消息数据与业务数据同库，占用业务系统资源。业务系统在使用关系型数据库的情况下，消息服务性能会受到关系型数据库并发性能的局限。  

### 3.5.2. 事务消息-最终一致性  
&emsp; 该方案基于本地消息表进行优化，不使用本地消息表，而是基于MQ。注：RocketMQ支持事务消息，RabbitMQ和Kafka都不支持事务消息。RocketMQ中间件能够支持一种事务消息机制，确保本地操作和发送消息的异步处理达到本地事务的结果一致。  

#### 3.5.2.1. 实现流程  
&emsp; 事务消息作为一种异步确保型事务，将两个事务分支通过MQ进行异步解耦，事务消息的设计流程同样借鉴了两阶段提交理论，整体交互流程如下图所示：  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/microService/problems/problem-7.png)  
&emsp; 事务发起方发送 Prepare 消息到消息中间件。  
&emsp; 发送成功后，执行本地事务。如果事务执行成功，则 Commit，消息中间件将消息下发至消费端。如果事务执行失败，则回滚，消息中间件将这条 Prepare 消息删除。如果执行本地事务过程中，执行端挂掉，或者超时，MQ将会不停的询问其同组的其它producer来获取状态。  
&emsp; 消费端接收到消息进行消费，如果消费失败，则不断重试。  

#### 3.5.2.2. 特点  
* 优点：  
    * 消息数据独立存储，降低业务系统与消息系统之间的耦合。
    * 吞吐量优于本地消息表方案。
* 缺点：
    * 一次消息发送需要两次网络请求(half消息 + commit/rollback)。
    * 需要实现消息回查接口。


### 3.5.3. 最大努力通知-最终一致性  
&emsp; 最大努力通知型( Best-effort delivery)是最简单的一种柔性事务，适用于一些最终一致性时间敏感度低的业务，且被动方处理结果不影响主动方的处理结果。典型的使用场景：如银行通知、商户通知、短信、邮件等。最大努力通知其实就是消息中间件的使用。  

#### 3.5.3.1. 实现流程  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/microService/problems/problem-8.png)  
&emsp; 在该系统中，A系统执行完本地事务，向MQ发送消息，最大努力通知服务消费消息，比如消息服务，然后调用B系统的接口，执行B系统的本地事务，如果B系统执行成功则OK，否则不断重试，重复多次之后还是失败的话就放弃执行。 
 
#### 3.5.3.2. 特点  
&emsp; ***最大努力通知方案和可靠消息最终一致性方案的区别：***  
&emsp; 可靠消息最终一致性方案可以保证的是只要系统A的事务完成，通过不停（无限次）重试来保证系统B的事务总会完成。但是最大努力方案就不同，如果系统B本地事务执行失败了，那么它会重试N次后就不再重试，系统B的本地事务可能就不会完成了。  

## 3.6. 事件溯源模式(Event Sourcing)，Saga事务模型-最终一致性  
&emsp; Saga模式是一种分布式异步事务，一种最终一致性事务，是一种柔性事务，有两种不同的方式来实现saga事务，最流行的两种方式是以下两种。  

### 3.6.1. 事件/编排Choreography方式  
&emsp; 没有中央协调器（没有单点风险）时，每个服务产生并聆听其他服务的事件，并决定是否应采取行动。  
&emsp; 该实现第一个服务执行一个事务，然后发布一个事件。该事件被一个或多个服务进行监听，这些服务再执行本地事务并发布（或不发布）新的事件，当最后一个服务执行本地事务并且不发布任何事件时，意味着分布式事务结束，或者它发布的事件没有被任何Saga参与者听到都意味着事务结束。 
![image](https://gitee.com/wt1814/pic-host/raw/master/images/microService/problems/problem-30.png)  

#### 3.6.1.1. 实现流程  
1. 订单服务保存新订单，将状态设置为pengding挂起状态，并发布名为ORDER_CREATED_EVENT的事件。
2. 支付服务监听ORDER_CREATED_EVENT，并公布事件BILLED_ORDER_EVENT。
3. 库存服务监听BILLED_ORDER_EVENT，更新库存，并发布ORDER_PREPARED_EVENT。
4. 货运服务监听ORDER_PREPARED_EVENT，然后交付产品。最后，它发布ORDER_DELIVERED_EVENT。
5. 最后，订单服务侦听ORDER_DELIVERED_EVENT并设置订单的状态为concluded完成。

&emsp; 假设库存服务在事务过程中失败了。进行回滚：
1. 库存服务产生PRODUCT_OUT_OF_STOCK_EVENT
2. 订购服务和支付服务会监听到上面库存服务的这一事件：
    1. 支付服务会退款给客户。
    2. 订单服务将订单状态设置为失败。  

#### 3.6.1.2. 特点  
* 优点：事件/编排是实现Saga模式的自然方式; 它很简单，容易理解，不需要太多的努力来构建，所有参与者都是松散耦合的，因为他们彼此之间没有直接的耦合。如果您的事务涉及2至4个步骤，则可能是非常合适的。  

### 3.6.2. 命令/协调orchestrator  
&emsp; 中央协调器负责集中处理事件的决策和业务逻辑排序。  
&emsp; saga协调器orchestrator以命令/回复的方式与每项服务进行通信，告诉他们应该执行哪些操作。  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/microService/problems/problem-31.png)  

#### 3.6.2.1. 实现流程  
1. 订单服务保存pending状态，并要求订单Saga协调器（简称OSO）开始启动订单事务。
2. OSO向收款服务发送执行收款命令，收款服务回复Payment Executed消息。
3. OSO向库存服务发送准备订单命令，库存服务将回复OrderPrepared消息。
4. OSO向货运服务发送订单发货命令，货运服务将回复Order Delivered消息。

&emsp; OSO订单Saga协调器必须事先知道执行“创建订单”事务所需的流程(通过读取BPM业务流程XML配置获得)。如果有任何失败，它还负责通过向每个参与者发送命令来撤销之前的操作来协调分布式的回滚。当你有一个中央协调器协调一切时，回滚要容易得多，因为协调器默认是执行正向流程，回滚时只要执行反向流程即可。  

#### 3.6.2.2. 特点 
* 优点：
    * 避免服务之间的循环依赖关系，因为saga协调器会调用saga参与者，但参与者不会调用协调器。
    * 集中分布式事务的编排。
    * 只需要执行命令/回复(其实回复消息也是一种事件消息)，降低参与者的复杂性。
    * 在添加新步骤时，事务复杂性保持线性，回滚更容易管理。
    * 如果在第一笔交易还没有执行完，想改变有第二笔事务的目标对象，则可以轻松地将其暂停在协调器上，直到第一笔交易结束。
* 缺点：协调器中集中太多逻辑的风险。  

## 3.7. TCC模式-强一致性  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/microService/problems/problem-9.png)  
&emsp; TCC是Try、Commit、Cancel的缩写。TCC是两阶段型、补偿型的事务。TCC采用的补偿机制，其逻辑模式类似于XA两阶段提交。其核心思想是：针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作。TCC模型是把锁的粒度完全交给业务处理。业务实现TCC服务之后，该TCC服务将作为分布式事务的其中一个资源，参与到整个分布式事务中；事务管理器分两阶段协调的TCC服务，第一阶段调用所有TCC服务的Try方法，在第二阶段执行所有TCC服务的Confirm或者Cancel方法。  

### 3.7.1. 实现流程  
* 条件：  

        需要实现确认和补偿逻辑
        需要支持幂等

1. Try阶段主要是对业务系统做检测及资源锁定或者预留。这个阶段主要完成：  
    1. 完成所有业务检查( 一致性 ) 。  
    2. 预留必须业务资源( 准隔离性 ) 。  
    3. Try尝试执行业务。
2. Confirm(确认)阶段主要是对业务系统做确认提交，不做业务检查。Try阶段执行成功并开始执行Confirm阶段时，默认 Confirm阶段是不会出错的。即：只要Try成功，Confirm一定成功。  
3. Cancel(取消)阶段主要是在业务执行错误，需要回滚的状态下，执行的业务取消，预留资源释放。  

&emsp; 示例：TCC模式下，A账户往B账户汇款100元为例子。汇款服务和收款服务分别需要实现，Try-Confirm-Cancel接口，并在业务初始化阶段将其注入到TCC事务管理器中。  
![image](https://gitee.com/wt1814/pic-host/raw/master/images/microService/problems/problem-9.png)  

### 3.7.2. 特点  
* 优点：  
    * 性能提升：具体业务来实现控制资源锁的粒度变小，不会锁定整个资源。  
    * `数据最终一致性：基于Confirm和Cancel的幂等性，保证事务最终完成确认或者取消，保证数据的一致性。`  
    * 可靠性：解决了XA协议的协调者单点故障问题，由主业务方发起并控制整个业务活动，业务活动管理器也变成多点，引入集群。  
* 缺点：  
    * TCC的Try、Confirm和Cancel操作功能要按具体业务来实现。  

---
# 4. 分布式事务具体实现  
## 4.1. JTA  

## 4.2. TCC框架  
ByteTCC、TCC-transaction、EasyTransaction  

## 4.3. LCN分布式事务框架  

## 4.4. Seata  



